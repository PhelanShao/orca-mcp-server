### **SEVEN** **DETAILED DOCUMENTATION** **7.1 The SHARK Integral Package and Task Driver**

**7.1.1 Preface**

Starting with ORCA 5.0 very large changes have taken place in the way that the program handles integrals and
integral related tasks like building Fock matrices. SHARK is a powerful and efficient infrastructure that greatly
facilitates the handling of these tasks. This allows developers to write highly streamlined code with optimal performance and a high degree of reliability. Compared to the way ORCA handled integrals before ORCA 5.0, tens of
thousands of lines of codes, often duplicated or nearly duplicated from closely related parts of the program could be
eliminated. From the perspective of the user, the visible changes to the input and output of the program compared
to ORCA 4.2.1 and earlier are relatively limited. However, under the hood, the changes are vast and massive and
will ensure that ORCA’s infrastructure is modern and very well suited for the future of scientific computing.

The benefits of SHARK for the users of ORCA are:

1. Improved code efficiency that is consistent through all program tasks. In particular, complicated two-electron
integrals, for example in the context of GIAOs, two-electron spin-orbit coupling and two-electron spin-spin
coupling integrals are handled with vastly improved efficiency. Also, integral digestion has been vastly
improved with very large benefits for calculations that build many Fock matrices at a time, for example in
CIS/TD-DFT, analytic Hessians or response property calculations.

2. Improved code reliability, since all integrals now run through a well debugged, common interface

3. Shorter development times. The new infrastructure is so user friendly to programmers that writing new code
that makes use of SHARK is much faster than in the past.

4. SHARK handles basis sets much better than the old infrastructure. Whether the basis sets used follow a

segmented contraction, general contraction or partial general contraction is immaterial since the algorithms
have been optimized carefully for each kind of basis throughout.

**7.1.2 The SHARK integral algorithm**

One cornerstone of SHARK is a new integral algorithm that allows for highly efficient evaluation of molecular
integrals. The algorithm is based on the beautiful McMurchie-Davidson algorithm which leads to the following
equation for a given two-electron integral:


( *𝜇* *𝐴* *𝜈* *𝐵* *|𝜅* *𝐶* *𝜏* *𝐷* ) = *𝐶* ∑︁


∑︁ *𝐸* *𝑡* *[𝜇𝜈]* [;] *[𝑥]* *𝐸* *𝑢* *[𝜇𝜈]* [;] *[𝑦]* *𝐸* *𝑣* *[𝜇𝜈]* [;] *[𝑧]* ∑︁

*𝑡𝑢𝑣* *𝑡* *[′]* *𝑢* *[′]* *𝑣*


∑︁ *𝐸* *𝑡* *[𝜅𝜏]* *[′]* [;] *[𝑥]* *𝐸* *𝑢* *[𝜅𝜏]* *[′]* [;] *[𝑦]* *𝐸* *𝑣* *[𝜅𝜏]* *[′]* [;] *[𝑧]* ( *−* 1) *[𝑡]* *[′]* [+] *[𝑢]* *[′]* [+] *[𝑣]* *[′]* *𝑅* *𝑡* + *𝑡* *′* *,𝑢* + *𝑢* *′* *,𝑣* + *𝑣* *′*

*𝑡* *[′]* *𝑢* *[′]* *𝑣* *[′]*


Here

5
*𝐶* = 8 *𝜋* */* 2 = 139 *.* 947346620998902770103

and the primitive Cartesian Gaussian basis functions *{𝜇* *𝐴* *}* where *𝐴* is the atomic center, where basis function *𝜇* is
centered at position **R** *𝐴* . In order to catch a glimpse of what the McMurchie-Davidson algorithm is about, consider

**443**

**ORCA Manual** **,** **Release 6.0.1**

two unnormalized, primitive Gaussians centered at atoms *𝐴* and *𝐵*, respectively:

*𝐺* *𝐴* = *𝑥* *[𝑖]* *𝐴* *[𝑦]* *𝐴* *[𝑗]* *[𝑧]* *𝐴* *[𝑘]* [exp(] *[−][𝛼𝑅]* *𝐴* [2] [)]

*𝐺* *𝐵* = *𝑥* *[𝑖]* *𝐵* *[′]* *[𝑦]* *𝐵* *[𝑗]* *[′]* *[𝑧]* *𝐵* *[𝑘]* *[′]* [exp(] *[−][𝛽𝑅]* *𝐵* [2] [)]

By means of the Gaussian product theorem, the two exponentials are straightforwardly rewritten as:

exp( *−𝛼𝑅* *𝐴* [2] [) exp(] *[−][𝛽𝑅]* *𝐵* [2] [) =] *[ 𝐾]* *[𝐴𝐵]* [exp] *−* ( *𝛼* + *𝛽* ) *𝑟* *𝑃* [2]
(︁ )︁

With

*𝐾* *𝐴𝐵* = exp (︁ *−* *𝛼* *[𝛼]* + *[𝛽]* *𝛽* *[|]* **[R]** *[𝐴]* *[−]* **[R]** *[𝐵]* *[|]* [2] [)︁]

*𝑟* *𝑃* [2] [=] *[ |]* **[r]** *[ −]* **[R]** *[𝑃]* *[|]* [2] [ is the electronic position relative to the point]

**R** *𝑃* = *𝛼* + *𝛼* *𝛽* **[R]** *[𝐴]* [+] *𝛼* + *𝛽* *𝛽* **[R]** *[𝐵]*

at which the new Gaussian is centered. The ingenious invention of McMurchie and Davidson was to realize that the
complicated polynomial that arises from multiplying the two primitive Cartesian Gaussians can be nicely written
in terms of Hermite polynomials *{* Λ *}* . In one dimension:


*𝑥* *[𝑖]* *𝐴* *[𝑥]* *𝐵* *[𝑖]* *[′]* [=]


*𝑖* + *𝑖* *[′]*
∑︁ *𝐸* *𝑡*

*𝑡* =0


And hence:

With


*𝑗* + *𝑗* *[′]*
∑︁ *𝐸* *𝑢* *[𝐴𝐵]*

*𝑢* =0


*𝑘* + *𝑘* *[′]*
∑︁ *𝐸* *𝑣* *[𝐴𝐵]* Λ *[𝐴𝐵]* *𝑡𝑢𝑣*

*𝑣* =0


*𝐺* *𝐴* *𝐺* *𝐵* = *𝐾* *𝐴𝐵*


*𝑖* + *𝑖* *[′]*
∑︁ *𝐸* *𝑡* *[𝐴𝐵]*

*𝑡* =0


*𝑢* *𝜕*
)︂ (︂ *𝜕𝑍* *𝑃*


*𝑣*
exp *−* ( *𝛼* + *𝛽* ) *𝑅* *𝑃* [2]
)︂ (︁ )︁


*𝜕*
Λ *[𝐴𝐵]* *𝑡𝑢𝑣* [=]
(︂ *𝜕𝑋* *𝑃*


*𝑡* *𝜕*
)︂(︂ *𝜕𝑌* *𝑃*


This means that the original four center integral is reduced to a sum of two-center integrals over Hermite Gaussian
functions. These integrals are denoted as

*𝑅* *𝑡* + *𝑡* *′* *,𝑢* + *𝑢* *′* *,𝑣* + *𝑣* *′* = Λ *[𝐴𝐵]* *𝑡𝑢𝑣* [(] **[r]** [1] [;] **[ R]** *[𝑃]* [)Λ] *[𝐶𝐷]* *𝑡* *[′]* *𝑢* *[′]* *𝑣* *[′]* [(] **[r]** [2] [;] **[ R]** *[𝑄]* [)] *[𝑟]* 12 *[−]* [1] *[𝑑]* **[r]** [1] *[𝑑]* **[r]** [2]
∫︁∫︁

With these definitions one understands the McMurchie Davidson algorithm as consisting of three steps:

1. Transformation of the Bra function product into the Hermite Gaussian Basis

2. Transformation of the Ket function product into the Hermite Gaussian Basis

3. Calculation of the Hermite Gaussian electron repulsion integral

SHARK is the realization that these three steps can be efficiently executed by a triple matrix product:


( *𝜇* *𝐴* *𝜈* *𝐵* *|𝜅* *𝐶* *𝜏* *𝐷* ) = (︀ **E** [bra] **RE** [ket] [)︀]


*𝜇𝜈,𝜅𝜏*


Here **E** [bra] and **E** [ket] collect the *𝐸* coefficients for all members of the shell product on the bra and ket side ( *𝐸* *𝜇𝜈,𝑡𝑢𝑣* [bra]
and *𝐸* [ket]
*𝜅𝜏,𝑡𝑢𝑣* [), respectively, and] **[ R]** [ collects the integrals over Hermite Gaussian functions (] *[𝑅]* *[𝑡𝑢𝑣,𝑡]* *[′]* *[𝑢]* *[′]* *[𝑣]* *[′]* [).]

There are many benefits to this formulation:

1. The integral is factorized allowing steps to be performed independent of each other. For example, the E
matrices can be calculated at the beginning of the calculation and reused whenever needed. Their storage is
unproblematic

2. Matrix multiplications lead to extremely efficient formation of the target integrals and drive the hardware at
peak performance

**444** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

3. Steps like contraction of primitive integrals and transformation from the Cartesian to the spherical Harmonics
basis can be folded into the definition of the E matrices thus leading to extremely efficient code with next to
no overhead creates by short loops.

4. Programming integrals becomes very easy and efficient. Other types of integrals as well as derivative integrals are readily approached in the same way. Also, two- and three-index repulsion integrals, as needed for
the RI approximation are also readily formulated in this way.

5. One-electron integrals are equally readily done with this approach.

There is a very large number of technicalities that we will not describe in this manual which is only intended to
provide the gist of the algorithm.

**7.1.3 SHARK and libint**

Up to ORCA 4.2.1, ORCA has almost entirely relied on the libint2 integral library which is known to be very
efficient and powerful. Starting from ORCA 5.0, both SHARK and libint are used for integral evaluations and
libint is fully integrated into the SHARK programming environment. Integrals that are only available in one of
the packages are done with this package (e. g. GIAO, SOC and Spin-Spin integrals in SHARK; F12 or second
derivative integrals in libint). For the integrals available in both packages, the program makes a judicious choice
about the most efficient route. The reason for this hybrid approach is the following:

The SHARK integral algorithm is at its best for higher angular momentum functions ( *𝑙>* 2; *𝑑* -functions) which
is where the efficiency of the matrix multiplications leads to very large computational benefits. Integrals over,
say, four *𝑓* - or *𝑔* -functions perform much faster (up to a factor of five) than with traditional integral algorithms.
However, for low angular momenta, there is overhead created by the matrix multiplications and also by the fact that
the McMurchie Davidson algorithm is known to not be the most FLOP count efficient algorithm. To some extent,
this is take care of by using highly streamlined routines for low angular momenta that perform extremely well.
However, there are penalties for intermediate angular momenta, where the efficiency of the matrix multiplications
has not set in and the integrals are too complicated for hand coding. These integrals perform best with libint and
consequently, the program will, by default, select libint to perform such integral batches.

**7.1.4 Basis set types**


One significant aspect of molecular integral evaluation is the type of contraction that is present in a Gaussian basis
set. The most general type of basis set is met in the “general contraction” scheme. Here all primitive Gaussian basis
functions of a given angular momentum are collected in a vector *{𝜑}* . In general, all primitives will contribute to
all basis functions *{𝜙}* of this same angular momentum. Hence, we can write:

*𝜙* 1 *𝑑* 11 *𝑑* 11 *· · ·* *𝑑* 1 *𝑀* *𝑙* *𝜑* 1

⎛ ⎞ ⎛ ⎞ ⎛ ⎞


⎛

⎜
⎜
⎜
⎝


⎞

⎟
⎟
⎟
⎠


⎞

⎟
⎟
⎟
⎠


*𝜑* 1
*𝜑* 2

...

*𝜑* *𝑀* *𝑙*


⎞


⎟
⎟
⎟
⎠ [=]


⎛

⎜
⎜
⎜
⎝


*𝑑* 11 *𝑑* 11 *· · ·* *𝑑* 1 *𝑀* *𝑙*
*𝑑* 21 *𝑑* 21 *· · ·* *𝑑* 2 *𝑀* *𝑙*

... ... ... ...

*𝑑* *𝑁* *𝑙* 1 *𝑑* *𝑁* *𝑙* 2 *· · ·* *𝑑* *𝑁* *𝑙* *𝑀* *𝑙*


⎜
⎜
⎜
⎝


*𝜙* 1

*𝜙* 2

...

*𝜙* *𝑁* *𝑙*


Where *𝑁* *𝑙* and *𝑀* *𝑙* are the number of actual basis functions and primitives respectively. Typically, the number of
primitives is much larger than the number of basis functions. The matrix **d** collects the contraction coefficients for
each angular momentum. Typical basis sets that follow this contraction pattern are atomic natural orbital (ANO)
basis sets. They are typically based on large primitive sets of Gaussians. Such basis sets put very demands on the
integral package since there are many integrals over primitive Gaussian basis functions that need to be generated. If
the integral package does not take advantage of the general contraction, then this integral evaluation will be highly
redundant since identical integrals will be calculated *𝑁* *𝑙* times (and hence, integrals over four generally contracted
shells will be redundantly generated *𝑁* *𝑙* [4] [times). SHARK takes full advantage of general contraction for all one-]
and two-electron integrals that it can generate. Here, the unique advantages of the integral factorization come to
full benefit since all integral quadruples of a given atom quadruple/angular momentum quadruple can be efficiently
generated by just two large matrix multiplications.

The opposite of general contraction is met with segmented contraction. Here each basis function involves a number

**7.1. The SHARK Integral Package and Task Driver** **445**

**ORCA Manual** **,** **Release 6.0.1**

of primitives:


*𝜙* *𝜇* = ∑︁ *𝑑* *𝑘𝜇* *𝜑* *𝑘*

*𝑘*


Quite typically, none of the *𝜑* *𝑘* that occur in the contraction of one basis functions occurs in any other basis function.
Typical basis sets of this form are the “def2” basis sets of the Karlsruhe group. They are readily handled by most
integral packages and both SHARK and libint are efficient in this case.

The third class of basis sets is met, when general contraction is combined with segmented contraction. Basis sets
of this type are, for example, the correlation consistent (cc) basis sets. We call such basis sets “partially generally
contracted”. In such basis sets, part of the basis functions are generally contracted (for example, the s- and pfunctions in main group elements), while other basis functions (e. g. polarization functions, diffuse functions, core
correlation functions) are not generally contracted. It is difficult to take full advantage of such basis sets given their
complicated structure. In ORCA 5, special code has been provided that transforms the basis set into an intermediate
basis set that does not contain any redundancies and hence drives SHARK or libint at peak performance.

In assessing the efficiency vs the accuracy of different integral algorithms, it is clear that segmented basis sets lead
to the highest possible efficiency if they are well constructed. For such basis set the pre-screening that is an essential
step of any integral direct algorithm performs best. The highest possible accuracy (per basis functions) is met with
generally contracted basis sets. However, here the pre-screening becomes rather inefficient since it can only be
performed at the level of atom/angular momentum combinations rather than individual shell quadruples. Thus, as
soon as a given atom/angular momentum combination leads to any non-negligible integral, all integrals for this
combination need to be calculated. This created a sizeable overhead. Consequently, SCF calculations can never be
as efficient as with segmented basis sets. If this is immaterial, for example, because a subsequent coupled cluster
or MRCI calculation is dominating the calculation time, general contraction is very worthwhile to be explored.
For partial general contraction, our algorithm performs very nearly as efficiently as for segmented contraction in
SCF calculations. However, since the intermediate basis set is larger than the original orbital basis, certain limited
performance penalties can arise in some job types.

**7.1.5 Task drivers**

In traditional algorithms, quantum chemical programs frequently contain many instances of nested loops over basis
function shells, the integral package is called and the integrals are “digested” for a given task. While these steps
are inevitable, programming them repeatedly is laborious and error prone. In addition, improvements, say in the
handling of contractions or symmetry, need to implemented in many different places. In the SHARK infrastructure
all of this is unnecessary since it is programmed in an object-oriented fashion, where the programmer does not need
to take care of any detail. Hence, developers only need to write short code sections that distribute the generated
integrals into whatever data structure they need, while the SHARK interface takes care of all technical aspects and
triggers the sophisticated and efficient machinery that underlies it.

Given this situation, the future of ORCA will involve SHARK taking care of nearly of the compute intensive,
laborious tasks, while ORCA will organize and trigger all of these tasks. ORCA and SHARK communicate via a
lean and well-defined interface to exchange the necessary data. In this way, a modern, efficient, easy to use and
readily maintainable development environment is created.

**7.1.6 SHARK User Interface**

While SHARK is a large and complicated machinery, we have deliberately kept the interface as straightforward
and simple as possible. There are only a few flags that can be set that are explained below:

In the simple input line there is:



This turns SHARK on (default) or off. Note that the option to turn SHARK off, will be unique to ORCA 5.0. Future
versions of ORCA will always make use of SHARK and the legacy code will disappear from the program for good.

**446** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


### **7.2 More on Coordinate Input**

We will now enter the detailed discussion of the features of ORCA. Note that some examples are still written in
the “old syntax” but there is no need for the user to adopt that old syntax. The new syntax works as well.

**7.2.1 Fragment Specification**

The atoms in the molecule can be assigned to certain *fragments* . This helps to organize the output in the population
analysis section, is used for the fragment optimization feature, for the local energy decomposition and for multilevel calculations. There are two options to assign atoms to fragments. The first option is to assign a given atom to
a given fragment by putting a `(n)` directly after the atomic symbol. Fragment enumeration starts with fragment
1!



In this example the fragment feature is used to divide the molecule into a “metal” and a “ligand” fragment and
consequently the program will print the metal and ligand characters contained in each MO in the population analysis

section.

Alternatively you can assign atoms to fragments in the geom block:



(continues on next page)

**7.2. More on Coordinate Input** **447**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**Note:**

  - With the second option (geom-fragments) the %geom block has to be written after the coordinate section.

  - geom-fragments also works with coordinates that are defined via an external file.

  - For the geom-fragments option the atoms are assigned to fragment 1 if no assignment is given.

**7.2.2 Defining Geometry Parameters and Scanning Potential Energy Surfaces**

ORCA lets you define the coordinates of all atoms as functions of user defined geometry parameters. By giving not
only a value but a range of values (or a list of values) to this parameters potential energy surfaces can be scanned.
In this case the variable `RunTyp` is automatically changed to `Scan` . The format for the parameter specification is
straightforward:



In the example above the geometry of formaldehyde is defined in internal coordinates (the geometry functions work
exactly the same way with Cartesian coordinates). Each geometric parameter can be assigned as a function of by enclosing an expression within function braces, “ `{}` “. For example, a function may look like `*cos(Theta)*rML+R` .
Note that all trigonometric functions expect their arguments to be in degrees and not radians. The geometry parameters are expected to be defined such that the lengths come out in Ångströms and the angles in degrees. *After*
evaluating the functions, the coordinates will be converted to atomic units. In the example above, the variable `rCO`
was defined as a “Scan parameter”. Its value will be changed in 26 steps from 1.3 Å down to 1.1 Å and at each
point a single point calculation will be done. At the end of the run the program will summarize the total energy
at each point. This information can then be copied into the spreadsheet of a graphics program and the potential
energy surface can be plotted. Up to three parameters can be scan parameters. In this way grids or cubes of energy
(or property) values as a function of geometry can be constructed.

If you want to define a parameter at a series of values rather than evenly spaced intervals, the following syntax is
to be used:

**448** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**



In this example the C-O distance is changed in seven non-equidistant steps. This can be used in order to provide
more points close to a minimum or maximum and fewer points at less interesting parts of the surface.

A special feature has also been implemented into ORCA - the parameters themselves can be made functions of the
other parameters as in the following (nonsense) example:



In this example the parameter `rCO` is computed from the parameter `rCOHalf` . In general the geometry is computed
(assuming a `Scan` calculation) by: (a) incrementing the value of the parameter to be scanned (b) evaluating the
functions that assign values to parameters, and (c) evaluating functions that assign values to geometrical variables.

Although it is not mandatory, it is good practice to *first* define the static or scan-parameters and then define the
parameters that are functions of these parameters.

Finally, ORCA has some special features that may help to reduce the computational effort for surface scans:

(continues on next page)

**7.2. More on Coordinate Input** **449**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**Note:**

  - You can scan along normal modes of a Hessian using the `NMScan` feature as described in section *Normal*
*Mode Scan Calculations Between Different Structures* .

  - The surface scan options are also supported in conjunction with TD-DFT/CIS or MR-CI calculations (see
section *Potential Energy Surface Scans* ).

**7.2.3 Mixing internal and Cartesian coordinates**

In some cases it may be practical to define some atomic positions in Cartesian and some in internal coordinates.
This can be achieved by specifying all coordinates in the `*int` block: using “0 0 0” as reference atoms indicates
Cartesian coordinates. Note that for the first atom the flags are “1 1 1”, as “0 0 0” would be the normal values for
internal coordinates. Consider, for example, the relaxed surface scan from section *Relaxed Surface Scans*, where
the methyl group is given first in an arbitrary Cartesian reference frame and then the water molecule is specified in
internal coordinates:



Internal and Cartesian coordinates can thus be mixed in any order but it is recommended that the first 3 atoms are
specified in Cartesian coordinates in order to define a unique reference frame.

**7.2.4 Inclusion of Point Charges**

In some situations it is desirable to add point charges to the system. In ORCA there are two mechanisms to add
point-charges. If you only want to add a few point charges you can “mask” them as atoms as in the following
(nonsense) input:



(continues on next page)

**450** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Here the “Q“‘s define the atoms as point charges. The next four numbers are the magnitude of the point charge and
its position. The program will then treat the point charges as atoms with no basis functions and nuclear charges
equal to the “Q” values.

If you have thousands of point charges to treat, as in a QM/MM calculation, it is more convenient, and actually
necessary, to read the point charges from an external file as in the following example:



The program will now read the file “ `pointcharges.pc` ” that contains the point-charge information and then call
the module `orca_pc` which adds the point charge contribution to the one-electron matrix and the nuclear repulsion.
The file “ `pointcharges.pc` ” is a simple ASCII file in the following format:



The first line gives the number of point charges. Each consecutive line gives the magnitude of the point charge (in
atomic units) and its position (in Ångström units!). However, it should be noted that ORCA treats point charges from
an external file differently than “Q” atoms. When using an external point charge file, the interaction between the
point charges is not included in the nuclear energy. This behavior originates from QM/MM, where the interactions
among the point charges is done by the MM program. These programs typically use an external point charge file
when generating the ORCA input. To add the interaction of the point charges to the nuclear energy, the `DoEQ`
keyword is used either in the simple input or the `%method` block as shown below.




**7.2. More on Coordinate Input** **451**

**ORCA Manual** **,** **Release 6.0.1**
### **7.3 Details on the numerical integration grids**

As in all other popular grid schemes, our grids are constructed from assembling a set of atomic grids into a molecular one, using Becke’s approach. Each individual atomic grid is build based on optimized parameters for that
atom, and are composed of an angular and a radial part, that are defined separately.

The whole scheme was updated from ORCA 5.0, but we tried to keep things as close as possible to the previous
one. First, the overall construction of these grids needs to be explained.

**7.3.1 The angular grid scheme**

Instead of using a single angular grid throughout the whole atom, most schemes apply a so-called grid pruning in
order to reduce the number of grid points outside of the most important regions, as we do in ORCA. In the current
scheme, we split the atomic grids into five regions, using Lebedev grids with the following number of points on
each of those:

Table 7.1: Different angular grid schemes used in ORCA. The numbers indicate the Lebedev grids used.

The ideal cutoffs between those regions were subjected to optimization, and are defined for all atoms. Whenever
we refer to a AngularGrid flag in ORCA, one of these schemes is chosen.

**7.3.2 The radial grid scheme**

The number of radial points ( *𝑛* *𝑟* ) for a given atom is simply defined using the equation first defined by Krack and
Köster:

*𝑛* *𝑟* = (15 *× 𝜀* *−* 40) + *𝑏* *× 𝑅𝑂𝑊*

where *𝜀* is called the IntAcc of that grid in ORCA, b is any number and ROW refers to the row of the periodic table
for that atom. In its original formulation, *𝑏* was set to 5, but here it as now optimized and varies slightly depending
on the AngularGrid schemes shown above.

One important thing to note is that each increase of IntAcc by 1, adds 15 radial points to the atomic grids, as in the
previous grid scheme. These IntAcc values were optimized for each angular grid:

Table 7.2: Optmimized IntAcc parameters for the exchange-correlation and COSX grids.

**452** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

After defining the number of radial points *𝑛* *𝑟*, the actual radial grid is then defined from a Gauss-Chebyschev
quadrature using the so-called M3 mapping from Treutler and Ahlrich:

*𝜉* 2
*𝑟* =
*𝑙𝑛* 2 *[𝑙𝑛]* 1 *−* *𝑥*

where *−* 1 *≤* *𝑥* *≤* 1, and the center of the grid ( *𝑥* = 0) coincides with the value of *𝜉* . These *𝜉* parameters were also
optimized for each atom type.

**7.3.3 The DEFGRIDs**

With all that in mind, we can now present how the DEFGRIDs are built in terms of their AngularGrid scheme and
IntAccs, which define the angular and radial parts of the atomic grids. More details can be found in Ref. [383].

Table 7.3: Angular grid schemes used in different part of ORCA. The XC and COSX grids are separated by a slash,
and multiple COSX grid schemes are separated by a comma.

OBS.: The IntAccs for TD-DFT and the CP-SCF are 3.467 for the XC and 3.067 for the COSX instead of the

default. These numbers can be smaller here and we exploit this to increase the overall speed.

From the Table 7.3 one can see, for instance, that the default SCF XC grid now is defined from AngularGrid 4
(with no extra final integration in the end). The default COSX uses a 1,2,3 grid scheme, with the COSX third grid
being used to update the energy after the SCF converges and for the gradients.

**7.3.4 Other details and options**

**The new adaptive pruning.** The current pruning scheme uses lower grids close to the nucleus, and far away from
the bonding region. However, if the basis set has polarized functions close to the nuclei, or diffuse Gaussians, this
might not be sufficient.

To improve the grids for these problems, we now use by default an adaptive pruning scheme, that detects corepolarization, diffuse functions and steep basis set orbitals by analyzing the expectation value of the position operator, *⟨𝑟* ˆ *⟩*, and fixes the grid accordingly. This can increase the grids in these cases by 10-20%, but gives significantly
better results. To use the non-adaptive scheme, just set %METHOD GRIDPRUNING OLDPRUNING END. For
a completely unpruned grid, set GRIDPRUNING to UNPRUNED.

**A simpler Gauss-Legendre angular grid.** By setting AngularGrid to 0, instead of using the Lebedev grids, a
Gauss-Legendre angular grid will be built, as suggested by Treutler and Ahlrich [851]. The number of *𝜃* points is
defined as 0 *.* 4 *𝑛* *𝑟* by default and the number of *𝜑* points is chosen as to avoid crowding close to the poles.

These grids are in general less efficient than the Lebedev’s, but are useful if one needs to construct extremely large
grids for specific applications.

**The SpecialGrid Option.** Sometimes, you might want to increase the integration accuracy for some atoms that
need special care, while it is not necessary to enlarge the grid generally. ORCA provides you with a basic mechanism to increase the radial integration accuracy for a few atoms while maintaining the chosen grid for all others.



(continues on next page)

**7.3. Details on the numerical integration grids** **453**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

OBS.: Starting from ORCA 5.0 it is not necessary to use this option anymore unless you have very specific reasons.
The basis set is considered during the grid construction and that is automatically extended if needed.

**7.3.5 SCF grid keyword list**

A complete description of the SCF grid options is given below. There are keywords specific to the XC integration,
COSX integration and a general part that applies to all:



**7.3.6 Changing TD-DFT, CP-SCF and Hessian grids**

**TD-DFT.** The grids used in CIS or TD-DFT can be changed in their respective block:



**CP-SCF.** The CP-SCF grids are changed in the %METHOD block:

**454** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

OBS.: The Z_Grid_RHS is only used in MP2 and the number here has a different meaning. It refers to which of
the COSX grids used in the SCF will be chosen, rather than an AngularGrid scheme. The default is to use the
second COSX grid.

**Hessian.** The XC grids used to compute the DFT terms in the Hessian are automatically chosen to be one unit
higher than the SCF grids. Because of the second derivative terms, we found that it is better to have a slightly
higher XC grid here. The COSX grid can be changed freely:



These four numbers refer to the possible usages of COSX in the Hessian, as explained in Sec. *Frequency calcula-*
*tions - numerical and analytical*

**Non-local functionals (VV10 and alike).** The default non-local grid is defined by AngularGrid 2, and is not
recommended to be changed. In any case, these can be altered by using:



**7.3.7 When should I change from the default grids?**

In general, the errors from the default grids are rather small and reasonable for most applications. After benchmarking against the GMTNK55 test set with the default !DEFGRID2, we found an error of about 0 *.* 01 *±* 0 *.* 03
kcal/mol from DFT (compared to a reference grid), and 0 *.* 05 *±* 0 *.* 10 kcal/mol for the COSX (compared to the
analytical integration). We also benchmarked geometries, excitation energies and frequencies, and all errors are
systematically low.

However, there might still be cases where an improved grid is needed:

  - If you need to be confident that your energy error is below 0.2 kcal/mol;

  - When dealing with anions with large negative charges ( *< −* 3);

  - For very subtle intermolecular interactions;

  - When dealing with weird electronic structures;

  - With large conjugated systems - graphene-like structures and large polyaromatics.

When needed, the !DEFGRID3 is very large and conservative - it was built to cover almost all these cases. In
contrast, !DEFGRID1 will yield grids of the size close to previous ORCA versions defaults, but still with increased

accuracy.

**7.3. Details on the numerical integration grids** **455**

**ORCA Manual** **,** **Release 6.0.1**
### **7.4 Choice of Computational Model**

**7.4.1 Features Common to All Calculations**

The computational model is specified in the block `%method` . The following choices exist:



In the case of Hartree-Fock calculations [840], nothing else is required in this block. Density functional calculations

[451, 647] need slightly more attention, as will be seen in the next section.

The type of calculation to be performed can be chosen by the `RunTyp` flag as follows:



**7.4.2 Density Functional Calculations**

**Choice of Functional**

**Basic Choice of Density Functional.** If you are doing a DFT calculation [451, 647], the following choices for
local, gradient-corrected, and hybrid density functionals are available. See also the simple input keywords in
section *Density Functional Methods* for a more complete list of density functionals (including double-hybrids,
which cannot be called from the `%method` block for technical reasons).

(continues on next page)

**456** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**7.4. Choice of Computational Model** **457**

**ORCA Manual** **,** **Release 6.0.1**

Note that `Functional` is a *compound keyword* . It chooses specific values for the variables `Exchange`,
`Correlation`, and `ACM` described below. If given as a simple input keyword, in some cases, it will also activate a
dispersion correction. You can explicitly give these variables instead or in addition to `Functional` . However, make
sure that you specify these variables *after* you have assigned a value to `Functional` or the values of `Exchange`,
`Correlation` and `ACM` will be reset to the values chosen by `Functional` .

**Empirical Parameters in Density Functionals.** Some functionals incorporate empirical parameters that can be
changed to improve agreement with experiment. Currently, there are a few parameters that can be changed (other
than the parameters used in the hybrid functionals, which are described later).

The first of these parameters is *𝛼* of Slater’s X *𝛼* method. Theoretically, it has a value of 2/3 and this is used
in the HFS and LSD functionals. However, the exchange contribution is underestimated by about 10% by this
approximation (quite significant!) and a value around 0.70-0.75 is recommended for molecules.

The second parameter is the *𝛽* for Becke’s gradient-corrected exchange functional. Becke determined the value
0.0042 by fitting the exchange energies for rare gas atoms. There is some evidence that with smaller basis sets, a
slightly smaller value such as 0.0039 gives improved results for molecules.

The next parameter is the value *𝜅*, which occurs in the PBE exchange functional. It has been given the value 0.804
by Perdew et al. in order to satisfy the Lieb-Oxford bound. Since then, other workers have argued that a larger
value for this parameter (around 1.2) gives better energetics, which is explored in the revPBE functional. Note,
however, that while revPBE gives slightly better energetics, it also gives slightly poorer geometries.

The last two parameters are also related to PBE. Within the PBE correlation functional, there is *𝛽* *𝐶* (not to be
confused with the *𝛽* exchange parameter in Becke’s exchange functional), whose original value is *𝛽* *𝐶* = 0 *.* 066725.
Modified variants exist with different *𝛽* *𝐶* values, e.g., the PBEsol functional and the PBEh-3c compound method.
Furthermore, the *𝜇* parameter in the PBE exchange functional may be modified. In the original formulation, it is
related to *𝛽* *𝐶* via *𝜇* = *𝛽* *𝐶* *[𝜋]* 3 [2] [, but has been modified in later variants as well.]



**Specifying Exchange and Correlation approximations individually.** The following keywords are available for
specifying the exchange and correlation approximations individually. In addition, scaling parameters can be defined
to construct user-defined hybrid or “extended” hybrid functionals:



(continues on next page)

**458** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



**Hybrid Density Functionals.** The hybrid DFs [87, 88] are invoked by choosing a nonzero value for the variable
`ACM` . (ACM stands for “adiabatic connection model”). Specifically, these functionals have the following form:

*𝐸* XC = *𝑎𝐸* HF [X] [+ (1] *[ −]* *[𝑎]* [)] *[ 𝐸]* LSD [X] [+] *[ 𝑏𝐸]* GGA [X] [+] *[ 𝐸]* LSD [C] [+] *[ 𝑐𝐸]* GGA [C] (7.1)

Here, *𝐸* XC is the total exchange/correlation energy, *𝐸* HF [X] [is the Hartree-Fock exchange,] *[ 𝐸]* LSD [X] [is the local (Slater) ex-]
change, *𝐸* GGA [X] [is the gradient correction to the exchange,] *[ 𝐸]* LSD [C] [is the local, spin-density based part of the correlation]
energy, and *𝐸* GGA [C] [is the gradient correction to the correlation energy.]

This brings us to a slightly awkward subject: several hybrid functionals with the same name give different values
in different programs. The reason for this is that they choose slightly different default values for the parameters *𝑎*,
*𝑏*, and *𝑐* and/or differ in the way they treat the local part of the correlation energy.

Different parametrizations exist. The most popular example of this is due to Vosko, Wilk, and Nusair (VWN,

[874]). VWN in their classic paper give two sets of parameters — one in the main body (parametrization of RPA
results; known as VWN-III) and one in their table 5 of correlation energies (parametrization of the Ceperley/Alder
Monte Carlo results; known as VWN-V). Some programs use VWN-III, while others use VWN-V. Additionally, a
slightly better fit to the uniform electron gas has been produced by Perdew and Wang [668]. The results from this
fit are very similar to those using `VWN5`, whereas `VWN3` yields quite different values.

In ORCA, almost all functionals choose `PWLDA` as the underlying LDA functional. A special situation arises if
LYP is the correlation functional [502] since LYP is *not* a correction to the correlation, but rather includes the full

correlation. It is therefore used in the B3LYP functional as:

*𝐸* B3LYP [C] [=] *[ 𝐸]* LSD [C] [+] *[ 𝑐]* (︀ *𝐸* LYP [C] *[−]* *[𝐸]* LSD [C] )︀ (7.2)

In ORCA, `VWN5` is chosen for the local correlation part of B3LYP. This choice is consistent with the TurboMole
program [12, 13, 14], but not with the Gaussian program [278]. However, the user has full control over this setting.
The underlying local part of any correlation functional can be set in the input with the variable `LDAOpt` :



**7.4. Choice of Computational Model** **459**

**ORCA Manual** **,** **Release 6.0.1**

Specifying `C_VWN3` for `LDAOpt` together with `Functional=B3LYP` should give results very close to the B3LYP
functional as implemented in the Gaussian series of programs [1] . Due to the popularity of the B3LYP functional,
the following aliases are defined in order to facilitate comparisons with other major electronic structure packages:



**One-Parameter Hybrid Density Functionals.** The underlying LDA-dependence of the three-parameter (i.e.
ACM) hybrids causes slightly different results from programs which use a different choice of LDA. It has been
argued from a theoretical viewpoint that the optimal mixing of HF exchange is 25% [248]. It has been further
shown that use of this fixed ratio and *not* scaling the GGA correlation or exchange contributions gives results that
are as good as the original three-parameter hybrids [9]. The one-parameter hybrid PBE0 has been advertised as a
hybrid functional of overall well-balanced accuracy [8].

As such, the one-parameter hybrids are based more in theory and remove some arbitrariness from the hybrid
procedures. The slightly higher HF-exchange (0.25 in favor of 0.20 used in the original three-parameter hybrids)
is also reasonable for many systems. The one-parameter hybrids have the simple form:

*𝐸* XC = *𝐸* DFT [X] [+] *[ 𝑎]* *[′]* [ (︀] *𝐸* HF [X] *[−]* *[𝐸]* DFT [X] )︀ + *𝐸* DFT [C] (7.3)

with *𝑎* *[′]* = [1]

4 [. This is the same as the three-parameter hybrids (equation (][7.1][)) with] *[ 𝑎]* [=] *[ 𝑎]* *[′]* [,] *[ 𝑏]* [= 1] *[ −]* *[𝑎]* *[′]* [, and] *[ 𝑐]* [= 1]
and is how it is implemented.

**Extended “double-hybrid” functionals.** In addition to mixing the HF-exchange into a given DF, Grimme has
proposed to mix in a fraction of the MP2 correlation energy as calculated with hybrid DFT orbitals [320]. Such
functionals may be referred to as “extended” or “double” hybrid functionals. Grimme’s expression is:

*𝐸* XC = *𝑎𝐸* X [HF] [+ (1] *[ −]* *[𝑎]* [)] *[ 𝐸]* X [DFT] + (1 *−* *𝑐* ) *𝐸* C [DFT] + *𝑐𝐸* C [MP2] (7.4)

Such functionals can be defined by the user in ORCA as follows:



Grimme recommends the B88 exchange functional, the LYP correlation functional and the parameters *𝑎* = 0 *.* 53
and *𝑐* = 0 *.* 27. This gives the B2PLYP functional which appears to be a fair bit better than B3LYP based on
Grimme’s detailed evaluation study.

Presently, this methodology covers single point calculations, analytic gradients (and thus also geometry optimizations, relaxed scans, and transition state searches), and frequencies and other second-derivative properties (without
the frozen core approximation in the MP2 part). Note that `%mp2 density relaxed end` should be specified in
order to get the response density that is consistent with first-order properties from analytic first-derivatives. By
default, this response density is not calculated since its construction adds significant overhead to the calculation.
Therefore, you have to specifically request it to look at the consistent density. The considerably less costly unrelaxed (expectation value-like) density may instead requested by `%mp2 density unrelaxed end` . However, this
is not recommended since the changes to the relaxed density are considerable in our experience and the unrelaxed
density has a much weaker theoretical status than its relaxed counterpart.

1 There is some evidence that the version used in the Gaussian program gives slightly better results in molecular applications than the
TurboMole variant, but the differences are very small [387].

**460** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**Range-separated hybrid functionals.** ORCA supports functionals based on the error function splitting of the
two-electron operator used for exchange as first realized by Hirao and coworkers [410]:


*𝑟* 12 *[−]* [1] [=][ erfc][(] *[𝜇]* *[·][ 𝑟]* [12] [)] *[ ·][ 𝑟]* 12 *[−]* [1]
~~⏟~~ ~~⏞~~

SR


+ erf( *𝜇* *· 𝑟* 12 ) *· 𝑟* 12 *[−]* [1]
~~⏟~~ ~~⏞~~ (7.5)

LR


2 *𝑥*
where erf( *𝑥* ) = ~~*√*~~ *𝜋* ∫︀ 0 [exp(] *[−][𝑡]* [2] [)] *[𝑑𝑡]* [and erfc][(] *[𝑥]* [) = 1] *[−]* [erf][(] *[𝑥]* [)][. Note that the splitting is only applied to the exchange]
contribution; all other contributions (one-electron parts of the Hamiltonian, the electron-electron Coulomb interaction and the approximation for the DFT correlation) are not affected. Later, Handy and coworkers generalized
the ansatz to [900]:



*[𝛽]* *[·]* [ erf] [(] *[𝜇]* *[·][ 𝑟]* [12] [)]]
*𝑟* 12 *[−]* [1] [= 1] *[ −]* [[] *[𝛼]* [+]

*𝑟* 12
~~⏟~~ ⏞

SR



*[𝛽]* *[·]* [ erf] [(] *[𝜇]* *[·][ 𝑟]* [12] [)]
+ *[𝛼]* [+]

*𝑟* 12
⏟ ~~⏞~~

LR


(7.6)


This form of the splitting used in ORCA is shown visually (according to Handy and coworkers) in Fig. 7.1.

Fig. 7.1: Graphical description of the Range-Separation ansatz. The gray area corresponds to Hartree-Fock exchange. *𝛼* and *𝛽* follow Handy’s terminology [900].

The splitting has been used to define the *𝜔* B97 family of functionals, wherein the short-range part (SR) is described
by DFT exchange and the long-range part by exact exchange, i.e. Hartree-Fock exchange. The same is true for
CAM-B3LYP, LC-BLYP, and LC-PBE. It is possible to use a fixed amount of Hartree-Fock exchange (EXX) and/or
a fixed amount of DFT exchange in this ansatz. Here are some examples of range-separated hybrid functionals
available in ORCA and their parameters:

**7.4. Choice of Computational Model** **461**

**ORCA Manual** **,** **Release 6.0.1**

The currently available speed-up options are RIJONX and RIJCOSX. Integral-direct single-point calculations,
calculations involving the first nuclear gradient (i.e. geometry optimizations), frequency calculations, TDDFT,
TDDFT nuclear gradient, and EPR/NMR calculations are the supported job types with range-separated hybrid
functionals thus far.

In principle, it is possible to change the amount of fixed Hartree-Fock exchange (ACM-A), the amount of variable
exchange (RangeSepScal), and *𝜇*, though this is not recommended. The amount of fixed DFT Exchange (ACM-B)
can only be changed for CAM-B3LYP and LC-BLYP. In other words, ACM-B is ignored by the *𝜔* B97 approaches
as no corresponding *𝜇* -independent exchange functional has been defined.



**Note:** For information on the ACM formalism, see preceding section called “Specifying Exchange and Correlation
approximations individually”. While it is technically possible to choose an exchange functional that has no *𝜇* dependence, this makes no sense conceptually.

**LibXC Functionals**

Since ORCA 4.2, it is possible to use the functionals provided by LibXC [2] within the ORCA framework. The LibXC
version used by ORCA is printed at the beginning of the output. The LibXC reference should be cited when LibXC
is used as part of your calculations. For reference, see [506].

The complete list of functionals available via the LibXC interface can always be inspected by typing at the command
line
```
orca -libxcfunctionals

```
The list of functionals has the following form:



(continues on next page)

2 [https://libxc.gitlab.io](https://libxc.gitlab.io)

**462** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



The list is grouped by “level” of functional (LDA, GGA, meta-GGA, etc.) and then by part of the energy it models
(correlation, exchange, exchange-correlation). Correlation functionals carry a `’_c_’` in their names, exchange
functionals an `’_x_’`, and combined exchange-correlation functionals an `’_xc_’` . Additional information for a
specific functional can be requested using
```
orca -libxcinfo [functional name]

```
where the functional name is the keyword in the above list.

Specification of LibXC functionals in the ORCA input follows the standard format:



or in the case of separate exchange and correlation specifications:



CAM-type range-separated functionals are supported through the LibXC interface since ORCA 5.0. So are functionals that include non-local (VV10) correlation (see *DFT Calculations with the Non-Local, Density Dependent*
*Dispersion Correction (VV10): DFT-NL* ). The VV10 part is computed internally by ORCA. Other non-local functionals, such as BEEF-vdW, are not supported. Meta-GGA functionals that depend on the kinetic energy density
*𝜏* are supported, but not those that depend on the Laplacian of the density *∇* [2] *𝜌* .

Double-hybrid functionals can be constructed with LibXC components as described in section *DFT Calcu-*
*lations with Second Order Perturbative Correction (Double-Hybrid Functionals)*, but only with separate exchange and correlation components. So `exchange=gga_x_pbe` and `correlation=gga_c_pbe` can be used, but
`functional=hyb_gga_xc_pbeh` **cannot** be used in a double-hybrid formulation. Beware that the exchange and
correlation contributions calculated by LibXC are simply scaled by `ScalDFX` and `ScalGGAC`, respectively, and no
care is taken to separately scale LDA components or alter other internal parameters!

**Screening Thresholds**

When the density is smaller than a certain threshold, LibXC skips the evaluation of the functional and instead
sets all the output quantities to zero in order to avoid under- and/or overflows. The default thresholds for different
functionals are set by the LibXC developers, but may sometimes be too low. We have not performed extensive
testing, but allow the user to set the threshold. Similarly, there are thresholds for minimum values of *𝜁* and *𝜏*
in order to avoid division by zero. The default values are functional-independent and can be changed using the
following keywords.



**7.4. Choice of Computational Model** **463**

**ORCA Manual** **,** **Release 6.0.1**

**Modifying LibXC Functional Parameters**

Starting with ORCA 5.1 it is possible to modify the “external parameters” of a functional that the LibXC interface provides. The available parameters and their default values can be seen in the output or with the `orca`
`-libxcinfo` command above. Please exercise caution when using this interface and if using a published functional reparametrization, make sure you can reproduce results from the original publication. The syntax requires
one of the `ExtParamX`, `ExtParamC`, or `ExtParamXC` keywords (depending on which functional is modified), followed by the parameter name in quotation marks, and finally the new value. For example, here is an input for the
PWPB95 double-hybrid functional, where the simple input keyword is used to set most parameters (such as the
MP2 scaling factors) and only the exchange and correlation parameters of the mPW91 and B95 LibXC functionals,
respectively, are modified.



Note that the variable definitions in LibXC may be different from the ones used internally in ORCA or in the
original publication, due to various constant factors, etc. When in doubt, please consult the LibXC documentation
or source code repository — we simply provide access to the interface.

**Simple Input of LibXC Functionals**

Some LibXC functionals are accessible via the simple input keyword `!LibXC(Keyword)`, e.g. `!LibXC(TPSS)` .
The keywords match those in section *Density Functional Methods* for functionals that are also implemented natively in ORCA. Using this syntax, parameters for the DFT-D dispersion corrections are also set automatically (if
implemented). Table Table 7.4 lists the available functionals and their LibXC names.

Table 7.4: LibXC functionals available via the simple input `!LibXC(Keyword)`

continues on next page

**464** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.4 – continued from p revious p a g e

**Using the RI-J Approximation to the Coulomb Part**

**Note:** This is the default for non-hybrid DFT! Can be turned off by using `!NORI` .

A very useful approximation that greatly speeds up DFT calculations unless the molecule gets very large is the so
called “RI-approximation” [65, 225, 245, 246, 440, 862, 888]. RI stands for “Resolution of the identity”. In short,
charge distributions arising from *products of basis functions* are approximated by a linear combination of *auxiliary*
*basis functions* .

*𝜑* *𝑖* ( *⃗𝑟* ) *𝜑* *𝑗* ( *⃗𝑟* ) *≈* ∑︁ *𝑐* *[𝑖𝑗]* *𝑘* *[𝜂]* *[𝑘]* [(] **[r]** [)] (7.7)

*𝑘*

There are a variety of different possibilities to determine the expansion coefficients *𝑐* *[𝑖𝑗]* *𝑘* [. A while ago, Almlöf]
and coworkers [860] have shown that for the approximation of electron repulsion integrals, the best choice is to
minimize the *residual repulsion* [3] .

3 The basic theory behind the RI method has been known for a long time and since at least the late sixties, methods similar to the RI
approximation have been used — mainly in the context of “approximate *ab initio* methods” such as LEDO, PDDO, and MADO, but also in
density functional theory in the mid and late seventies by Baerends, Dunlap, and others [65, 225, 862, 888].

**7.4. Choice of Computational Model** **465**

**ORCA Manual** **,** **Release 6.0.1**

Define:

and


*𝑅* *𝑖𝑗* *≡* *𝜑* *𝑖* ( *⃗𝑟* ) *𝜑* *𝑗* ( *⃗𝑟* ) *−* ∑︁ *𝑐* *[𝑖𝑗]* *𝑘* *[𝜂]* *[𝑘]* [(] *[⃗𝑟]* [)] (7.8)

*𝑘*


1
*𝑇* *𝑖𝑗* = ∫︁∫︁ *𝑅* *𝑖𝑗* ( *⃗𝑟* ) *|⃗𝑟* *−* *⃗𝑟* *[′]* *|* *[𝑅]* *[𝑖𝑗]* [(] *[⃗𝑟]* [)] *[ 𝑑]* [3] *[𝑟𝑑]* [3] *[𝑟]* *[′]* (7.9)

Determining the coefficients that minimize *𝑇* *𝑖𝑗* leads to

**c** *[𝑖𝑗]* = **V** *[−]* [1] **t** *[𝑖𝑗]* (7.10)

where:

*𝑡* *[𝑖𝑗]* *𝑘* [=] ⟨︀ *𝜑* *𝑖* *𝜑* *𝑗* ⃒⃒ *𝑟* 12 *−* 1 ⃒⃒ *𝜂* *𝑘* ⟩︀ (7.11)

*𝑉* *𝑖𝑗* = ⟨︀ *𝜂* *𝑖* ⃒⃒ *𝑟* 12 *−* 1 ⃒⃒ *𝜂* *𝑗* ⟩︀ (7.12)

Thus, an ordinary two-electron integral becomes

*−* 1
⟨︀ *𝜑* *𝑖* *𝜑* *𝑗* ⃒⃒ *𝑟* 12 ⃒⃒ *𝜑* *𝑘* *𝜑* *𝑙* ⟩︀ *≈* ∑︁ *𝑐* *[𝑖𝑗]* *𝑝* *[𝑐]* *[𝑘𝑙]* *𝑞* *[𝑉]* *[𝑝𝑞]*

*𝑝,𝑞*


=
∑︁


∑︁ *𝑉* *𝑝𝑞* ∑︁

*𝑝,𝑞* *𝑟*


(︀ **V** *[−]* [1] [)︀] *𝑝𝑟* *[𝑡]* *𝑟* *[𝑖𝑗]* ∑︁

*𝑠*


(7.13)

(7.14)


(︀ **V** *[−]* [1] [)︀]


*𝑞𝑠* *[𝑡]* *𝑠* *[𝑘𝑙]*


*𝑟*


=
∑︁

*𝑟,𝑠*


(︀ **V** *[−]* [1] [)︀] *𝑟𝑠* *[𝑡]* *𝑟* *[𝑖𝑗]* *[𝑡]* *𝑠* *[𝑘𝑙]*


and the total Coulomb energy becomes

*𝐸* *𝐽* = ∑︁

*𝑖,𝑗*

*≈*
∑︁

*𝑖,𝑗*

=
∑︁

*𝑟,𝑠*

where **P** is the total density matrix.


∑︁ *𝑃* *𝑖𝑗* *𝑃* *𝑘𝑙* ⟨︀ *𝜑* *𝑖* *𝜑* *𝑗* ⃒⃒ *𝑟* 12 *−* 1 ⃒⃒ *𝜑* *𝑘* *𝜑* *𝑙* ⟩︀

*𝑘,𝑙*


∑︁ *𝑃* *𝑖𝑗* *𝑃* *𝑘𝑙* ∑︁

*𝑘,𝑙* *𝑟,𝑠*


∑︁


(︀ **V** *[−]* [1] [)︀]


*𝑟𝑠* *[𝑡]* *𝑟* *[𝑖𝑗]* *[𝑡]* *𝑠* *[𝑘𝑙]*


*𝑟,𝑠*


∑ *𝑃* *𝑘𝑙* *𝑡* *[𝑘𝑙]* *𝑠*

*𝑘,𝑙*


∑


(︀ **V** *[−]* [1] [)︀]


*𝑟𝑠* ∑ *𝑃* *𝑖𝑗* *𝑡* *[𝑖𝑗]* *𝑟*

*𝑖,𝑗*


*𝑟𝑠* ∑


~~⏟~~ ~~⏞~~
**X** *𝑟*


~~⏟~~ ~~⏞~~
**X** *𝑠*


In a similar way, the Coulomb contribution to the Kohn-Sham matrix is calculated. There are substantial advantages
from this approximation: the quantities to be stored are the matrix **V** *[−]* [1] — which depends only on two indices —
and the three-index auxiliary integrals *𝑡* *[𝑖𝑗]* *𝑟* [. This leads to a tremendous reduction of storage requirements compared]
to a four-index list of repulsion integrals. In addition, the two- and three-index electron repulsion integrals are
easier to compute than the four-index integrals, leading to further reductions in processing time. Furthermore,
the Coulomb energy and the Kohn-Sham matrix contributions can be quickly assembled by simple vector/matrix
operations, leading to large time savings. This arises because each auxiliary basis function *𝜂* *𝑘* ( *⃗𝑟* ) appears in the
expansion of many charge distributions *𝜑* *𝑖* ( *⃗𝑟* ) *𝜑* *𝑗* ( *⃗𝑟* ). Unfortunately, a similar strategy is less easily applied (or, at
least, with less benefit) to the Hartree-Fock exchange term.

If the auxiliary basis set *{𝜂}* is large enough, the approximation is also highly accurate. Since any DFT procedure
already has a certain, sometimes sizable, error from the noise in the numerical integration of the XC part, it might be
argued that a similarly large error in the Coulomb part is perfectly acceptable without affecting the overall accuracy
of the calculation much. Furthermore, the errors introduced by the RI method are usually much smaller than the
errors in the calculation due to basis set incompleteness. It is therefore recommended to use the RI procedure for
pure DFs. However, one should probably not directly mix absolute total energies obtained from RI and non-RI
calculations as the error in the total energy accumulates and will rise with increased molecular size, while the
errors in the relative energies will tend to cancel.

**466** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

There are several choices for auxiliary basis sets described in the next section, which depend on the choice of the
primary GTO basis set used to expand the molecular orbitals [4] .

In ORCA, the RI approximation is toggled by the input



**Note:** If you use RI, you *must* specify an auxiliary basis set (in the `%basis` section or using the appropriate simple
keyword) or use the `!AutoAux` simple keyword.

**The Split-RI-J Coulomb Approximation**

There is an improved version of the RI-algorithm that has been implemented since ORCA 2.2.09. This SplitRI-J algorithm yields the same Coulomb energy as the standard RI-algorithm, but is significantly faster if the
basis set contains many high angular momentum functions (d-, f-, g-functions). For small basis sets, there is
virtually no difference between the two algorithms, except that Split-RI-J uses more memory than standard RI.
However, calculations with ca. 2000 basis functions only need about an extra 13 MB for Split-RI-J, which is a
trivial requirement on present-day hardware.

The Split-RI-J algorithm is invoked with the `!Split-RI-J` simple keyword. Split-RI-J is presently only available
for SCF and gradient calculations.

**Note:**

  - The Split-RI-J algorithm is the default if RI is turned on via `!RI` . If you do not want to use Split-RI-J, please
also use the keyword `!NoSplit-RI-J`

**Using the RI Approximation for Hartree-Fock and Hybrid DFT (RIJONX)**

The RI approximation can be used, although with less benefit, for hybrid DFT and Hartree-Fock (RHF and UHF)
calculations. In this case, a different algorithm [5] is used that allows a fair approximation to the Hartree-Fock exchange matrix (RI-JK). It can be difficult to make this approximation highly accurate. It is, however, usefully fast
compared to direct SCF if the molecule is “dense” enough. There are special auxiliary basis sets for this purpose
(see section *Basis Sets* ).

**Note:** There has been little experimentation with this feature. It is provided on an experimental basis here.

4 It probably should be noted that a slightly awkward step in the procedure is the inversion of the auxiliary integral matrix **V**, which can
easily become very large. Matrix inversion is an O(N [3] ) process such that for large molecules, this step takes some real time. However, in
ORCA, this is only done *once* during the calculation, whereas other programs that constrain the fit to also exactly reproduce the number of
electrons perform a similar process *each iteration* . Starting from ORCA 2.2.09, the Cholesky decomposition is used in favor of matrix inversion,
removing any bottleneck concerning the solution of the linear equation system.
5 This algorithm was described by Kendall and Früchtl [440].

**7.4. Choice of Computational Model** **467**

**ORCA Manual** **,** **Release 6.0.1**

Alternatively, the RI method can be used for the Coulomb term and the standard treatment for the exchange term.
This method is called RIJONX since the exchange term should tend towards linear scaling for large molecules.
This feature can be used for Hartree-Fock and hybrid DFT calculations by using:



The requirements for the auxiliary basis are the same as for the normal RI-J method.

**Using the RI Approximation for Hartree-Fock and Hybrid DFT (RIJCOSX)**

**Note:** This is the default for hybrid DFT! Can be turned off by using `!NOCOSX` .

The aim of this approximation is to efficiently compute the elements of exchange-type matrices [6] :

*𝐾* *𝜇𝜈* = ∑︁ *𝑃* *𝜅𝜏* ( *𝜇𝜅|𝜈𝜏* ) (7.15)

*𝜅𝜏*

where **P** is some kind of density-type matrix (not necessarily symmetric) and the two-electron integrals are defined
over the basis set *{𝜙}* by:

( *𝜇𝜅|𝜈𝜏* ) = *𝜇* ( **r** 1 ) *𝜅* ( **r** 1 ) *𝜈* ( **r** 2 ) *𝜏* ( **r** 2 ) *𝑟* 12 *[−]* [1] *[𝑑]* **[r]** [1] *[𝑑]* **[r]** [2] (7.16)
∫︁

The approximation pursued here can be written as follows:


*𝑋* *𝜇𝑔* ∑︁

*𝑔* *𝜏*


*𝐾* *𝜇𝜈* *≈* ∑︁


*𝐴* *𝜐𝜏* ( **r** *𝑔* ) ∑︁

*𝜏* *𝜅*


*𝑃* *𝜅𝜏* *𝑋* *𝜅𝑔* (7.17)

*𝜅*


Here, the index *𝑔* refers to grid points **r** *𝑔* and:


*𝑋* *𝜅𝑔* = *𝑤* *𝑔* [1] *[/]* [2] *𝜅* ( **r** *𝑔* ) (7.18)


*𝜈* ( **r** ) *𝜏* ( **r** )
*𝐴* *𝜐𝜏* ( **r** *𝑔* ) = (7.19)
∫︁ *|* **r** *−* **r** *𝑔* *|* *[𝑑]* **[r]**

where *𝑤* *𝑔* denotes the grid weights. Thus, the first integration is carried out numerically and the second one
analytically. Note that this destroys the Hermitian character of the two-electron integrals.

Equation (7.17) is perhaps best evaluated in three steps:

*𝐹* *𝜏𝑔* = ( **PX** ) *𝜏𝑔* (7.20)

*𝐺* *𝜈𝑔* = ∑︁ *𝐴* *𝜈𝜏* ( **r** *𝑔* ) *𝐹* *𝜏𝑔* (7.21)

*𝜏*

*𝐾* *𝜇𝜈* = ( **XG** [+] ) *𝜇𝜈* (7.22)

As such, the equations are very similar to the pseudo-spectral method extensively developed and discussed by
Friesner and co-workers since the mid 1980s and commercially available in the Jaguar quantum chemistry package.
The main difference at this point is that instead of *𝑋* *𝜅𝑔* there appears a least-square fitting operator *𝑄* *𝜅𝑔* in Friesner’s
formulation. Note that an analogue of the fitting procedure has also been implemented in ORCA and — in contrast
to Friesner’s pseudo-spectral method — does not need specially optimized grids. The basic idea is to remove the
grid errors within the basis set by “fitting” the numerical overlap to the analytical one. Due to its nature, overlap
fitting is supposed to work better with larger basis sets.

6 The theory of this approach together with all evaluations and implementation details is described in [383, 624]. References to earlier work
can also be found there.

**468** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**The RIJCOSX gradient**

Given the exchange matrix, the exchange energy is given by (a sum over spin cases is left out here for simplicity):


*𝐸* X = [1]

2


∑︁ *𝑃* *𝜇𝜈* *𝐾* *𝜇𝜈* ( **P** ) (7.23)

*𝜇𝜈*


Previous to ORCA6, the gradient of the COSX contribution to the energy was taken as an approximation:


*𝜕𝐸* *𝑋*

*≈* 2
*𝜕𝜆* ∑︁

*𝑔*


∑︁

*𝜇𝜈*


*𝜕𝐹* *𝜇𝑔*

*𝜕𝜆* *[𝐺]* *[𝜈𝑔]* (7.24)


with


*𝜕𝐹* *𝜇𝑔*


*𝑃* *𝜅𝜇* *𝜕𝑋𝜕𝜆* *𝜇𝑔*
*𝜅*


*𝜇𝑔* = *𝑤* [1] *[/]* [2]

*𝜕𝜆* *𝑔* ∑︁


(7.25)
*𝜕𝜆*


as published in the original implementation paper [624].

Starting from ORCA6, this was updated to the full derivative of the energy component, including the derivative of
all terms: grid weight derivatives, derivative of the SFitting matrices and all derivatives of *𝐹* and *𝐺* [7] . The gradient
is thus now more accurate and less noisy. In case one wants to revert to the previous approximated version (not
recommended), just set:



**Working with the COSX Numerical Grids**

For expert users, the grid parameters for the exchange grids can be even more finely controlled:



There are three grids involved: the smallest grid (Acc1, Ang1) that is used for the initial SCF iterations, the medium
grid (Acc2, Ang2) that is used until the end of the SCF and the largest grid (Acc3, Ang3) that is used for the final
energy and the gradient evaluations. `UseFinalGridX` can be used to turn this last grid on or off, though changing
this is not generally recommended. More details about the grid constructions can be found in *Details on the*
*numerical integration grids* .

**Some SFitting Parameters**

To modify the overlap fitting parameters, the following input can be specified:



Note that overlap fitting also works for HF and MP2 gradients without specifying any additional keyword. The
`UseQGradFit` parameter uses the same fitting matrix for the gradients as for the energy calculation and is the
default behavior since ORCA6.

7 The theory is not yet published, but will be soon.

**7.4. Choice of Computational Model** **469**

**ORCA Manual** **,** **Release 6.0.1**

**Use of Partial Contraction Scheme**

Since ORCA 5.0, generally-contracted basis sets can be handled efficiently by using an intermediate partially contracted (pc) atomic-orbital basis for the exchange-matrix computation without affecting the results [383]. Depending on the basis set and element type, computational speedups by many orders of magnitude are possible. For
testing or benchmark purposes, the K matrix computation can be done in the original basis by using the flag



**Restoring Full Symmetry**

The semi-numerical integration scheme in the default COSX algorithm breaks the permutational symmetry of the
two-electron integrals. We have observed that this flaw is often the cause of convergence problems for iterative
algorithms, in particular for multi-reference theories [382]. An input option is available since ORCA 6.0 to preserve
the full eight-fold permutational symmetry of the two-electron integrals:



The full-symmetrization algorithm often improves the numerical stability and is enabled by default for TRAHCASSCF and CASSCF linear-response calculations. However, the full-symmetrization algorithm may come with
additional costs that depend on the number of **F** intermediates. The number of **F** intermediates depends on the
symmetry of the density matrix (symmetric (S), anti-symmetric (A), and non-symmetric (N)) and whether overlap
fitting is employed, as summarized in the table below.

Table 7.5: Number of COSX **F** intermediates per density matrix

Note that for symmetric (S) and anti-symmetric (A) densities, we symmetrize and anti-symmetrize, respectively,
exchange matrices at the end, which reduces the number of **F** intermediates by a factor of 2. The actual computational costs usually do not increase linearly with the number of **F** intermediates since we compute the costly
analytic integrals ( *𝐴* *𝜈𝜏* ( **r** *𝑔* )) only once and then contract them with the additional **F** intermediates. From our experience the overhead of the full-symmetrization algorithm is roughly between 1.2 and 1.5 times that of the original
algorithm.

**COSX Grid and Convergence Issues**

**Symptoms of convergence issues:** Erratic convergence behavior, often starting from the first SCF step or possibly
setting in at a later stage, which produce crazy energy values with “megahartree” jumps. If overlap fitting is on,
the following error message may also be encountered: “Error in Cholesky inversion of numerical overlap”.

Convergence issues may arise when the chosen grid has difficulties in representing the basis set. This is the “grid
equivalent” of a linear dependence problem, as discussed in *Linear Dependence* . It should also be mentioned that
the grid-related problem discussed here often goes hand in hand with basis set linear dependence, although not
necessarily. The most straightforward way of dealing with this is to increase the size of the integration grid. This,
however, is not always desirable or possible.

**470** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

One way to avoid the Cholesky inversion issue is to turn overlap fitting off ( `!NoSFitting` ). However, this means
that the numerical problems are still present, but are ignored. Due to the fact that overlap fitting operates with
the numerical overlap and its inverse, it is more sensitive to linear dependence issues, so turning off the fitting
procedure may lead to convergence. This may be a pragmatic — but by no means clean — solution, since it relies
on the assumption that the numerical errors are small.

On the other hand, overlap fitting also gives a similar tool to deal with linear dependence issues as the one discussed
for basis sets. The eigenvalues of the numerical overlap can be similarly inspected and small values screened out.
There is unfortunately no universal way to determine this screening parameter, but see *Linear Dependence* for
typical values.

The parameters influencing the method used for inversion and obtaining the fitting matrix are:



By default, the inversion procedure proceeds through Cholesky decomposition as it is the fastest option. Ideally,
the overlap matrix is non-singular if the basis set is not linearly dependent. For singular matrices, the Cholesky
procedure will fail. It should be noted at this point that the numerical overlap can become linearly dependent even if
the overlap of basis functions is not, and so a separate parameter will be needed to take care of grid-related issues. To
achieve this, a diagonalization procedure ( `Diag` ) can be used instead of Cholesky with the corresponding parameter
to screen out eigenvectors belonging to eigenvalues below a threshold ( `SInvThresh` ). For both Cholesky and
diagonalization procedures, a “full Q” approach is also available ( `Cholesky_Q` and `Diag_Q` ), which corresponds
to the use of a more accurate (untruncated) fitting matrix.

**Treatment of Dispersion Interactions with DFT-D3**

**Introduction**

DFT-D3 is an atom-pairwise (atom-triplewise) dispersion correction which can be added to the KS-DFT energies
and gradient [324]:

*𝐸* DFT-D3 = *𝐸* KS-DFT + *𝐸* disp (7.26)

*𝐸* disp is then the sum of the two- and three-body contributions to the dispersion energy, *𝐸* disp = *𝐸* [(2)] + *𝐸* [(3)] . Most
important is the two-body term, which is given at long range by:


*𝐸* disp = *−* ∑︁

*𝐴<𝐵*


*𝑛* ∑︁ =6 *,* 8 *𝑠* *𝑛* *𝐶𝑟* *𝐴𝐵* *[𝑛]* *𝑛* *[𝐴𝐵]* (7.27)


where *𝐶* *𝑛* *[𝐴𝐵]* denotes the averaged (isotropic) *𝑛* [th] -order dispersion coefficient for atom pair *AB* and *𝑟* *𝐴𝐵* is their
internuclear distance. *𝑠* *𝑛* is a functional-dependent scaling factor (see below). In the general case, an adequate
damping function must be employed.

**Damping Functions**

In order to avoid near-singularities for small *𝑟* *𝐴𝐵*, the dispersion contribution needs to be damped at short distances.
One possible way is to use rational damping as proposed by Becke and Johnson [90, 424, 425]:


*𝐸* [(2)] = *−*
∑︁

*𝐴<𝐵*


*𝑛* ∑︁ =6 *,* 8 *𝑠* *𝑛* *𝑟* *𝐴𝐵* *[𝑛]* [+] *𝐶* *[ 𝑓]* *𝑛* *[𝐴𝐵]* [(] *[𝑅]* 0 *[𝐴𝐵]* ) *[𝑛]* (7.28)


**7.4. Choice of Computational Model** **471**

**ORCA Manual** **,** **Release 6.0.1**

with [425]

and


*𝑅* 0 *[𝐴𝐵]* =


√︃


*𝐶* 8 *[𝐴𝐵]* (7.29)
*𝐶* 6 *[𝐴𝐵]*


*𝑓* ( *𝑅* 0 *[𝐴𝐵]* ) = *𝑎* 1 *𝑅* 0 *[𝐴𝐵]* + *𝑎* 2 *.* (7.30)

Damping the dispersion contribution to zero for short ranges (as in Ref. [324]) is also possible:


*𝐸* [(2)] = *−*
∑︁

*𝐴<𝐵*


*𝑛* ∑︁ =6 *,* 8 *𝑠* *𝑛* *𝐶𝑟* *𝐴𝐵* *[𝑛]* *𝑛* *[𝐴𝐵]* *𝑓* *𝑑,𝑛* ( *𝑟* *𝐴𝐵* ) (7.31)


with

1

=
*𝑓* *𝑑,𝑛* *𝑟* *𝐴𝐵* (7.32)
1 + 6( *𝑠* *𝑟,𝑛* *𝑅* 0 *[𝐴𝐵]* ) *[−][𝛼]* *[𝑛]*

Note that the *𝑅* 0 *[𝐴𝐵]* used with this damping are from Ref. [324]. For more information on the supported damping
functions, see Ref [326]. The recommended variant is that with Becke-Johnson damping and is invoked by the
keyword `!D3BJ` or simply `!D3` . The dispersion correction with zero damping is invoked by the keyword `!D3ZERO` .

**Three-body term**

It is possible to calculate the three-body dispersion contributions with DFT-D3, according to


*𝐸* [(3)] = *−*
∑︁

*𝐴<𝐵<𝐶*


*𝐶* 9 *[𝐴𝐵𝐶]* ( 3 cos *𝜃* *𝑎* cos *𝜃* *𝑏* cos *𝜃* *𝑐* + 1 )

*𝑓* *𝑑,* (3) ~~(~~ *𝑟* *𝐴𝐵𝐶* ) (7.33)
( *𝑟* *𝐴𝐵* *𝑟* *𝐵𝐶* *𝑟* *𝐶𝐴* ) [3]


where *𝜃* *𝑎*, *𝜃* *𝑏* and *𝜃* *𝑐* are the internal angles of the triangle formed by *𝑟* *𝐴𝐵*, *𝑟* *𝐵𝐶* and *𝑟* *𝐶𝐴* . The *𝐶* 9 coefficient is
approximated by

*𝐶* 9 *[𝐴𝐵𝐶]* *≈−* ~~√~~ *𝐶* 6 *[𝐴𝐵]* *𝐶* 6 *[𝐴𝐶]* *𝐶* 6 *[𝐵𝐶]* (7.34)

The three-body contribution has a small effect on medium-sized molecules and is damped according to equation
(7.33). The damping function *𝑓* *𝑑,* (3) ~~(~~ *𝑟* *𝐴𝐵𝐶* ) is similar to the one shown in equation (7.32) with *𝑟* *𝐴𝐵𝐶* being the
geometric mean of *𝑟* *𝐴𝐵*, *𝑟* *𝐵𝐶* and *𝑟* *𝐶𝐴* . It can be used with both variants of the *𝐸* [(2)] term, although the three-body
term itself will always be calculated using the zero damping scheme. Adding the three-body correction has proven
to give quite accurate results for the thermochemistry of supramolecular systems[322]. The three-body term is
invoked by the keyword `!ABC`, along with either the `!D3ZERO` keyword for zero damping of *𝐸* [(2)] or `!D3BJ` for
Becke-Johnson damping of *𝐸* [(2)] .

**Options**

Note that correcting Hartree-Fock (HF) is only parametrized with BJ-damping. For a constantly updated list of
supported functionals, check the website of the Grimme group [329]. If there is a functional on this website that
is parametrized, but the parameters are not yet implemented into ORCA, you can specify the parameters manually
as shown below (using the respective parameters from [329]). In the same fashion, one could also use one’s own
parameters, but this is not recommended.

**Important** : GGA and hybrid functionals should only be used with *𝑠* 6 = 1 *.* 0 to ensure asymptotically correct
behavior. Double-hybrid functionals already account for parts of the dispersion interaction and should therefore
be used with *𝑠* 6 *<* 1 *.* 0. In the `%method` block, it is possible to change the *𝑠* 6, *𝑎* 1, *𝑠* 8, and *𝑎* 2 parameters for the
variant with Becke-Johnson damping:

**472** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


The variant with zero damping offers the parameters *𝑠* 6, *𝑟𝑠* 6, *𝑠* 8, and *𝛼* 6 .



If a geometry optimization is performed ( `!OPT` ), then the program automatically calls the DFT-D3 gradient. There
are also special functional parameters, which were optimized for triple-zeta basis sets. This option is only available
with zero damping and can be invoked by the keywords `!D3ZERO D3TZ` . Preliminary results in the SI of Ref. [324]
indicate that results are only slightly worse than with quadruple-zeta basis sets using the default parameters. This
option should be carefully tested for future use in large computations.

**Example input files**

Following are some example input files. In this first example, a computation using the DFT-D3 dispersion correction with BJ-damping is run. The use of `!D3BJ` is identical to `!D3` as the BJ-damping is on by default.



The output for the dispersion correction in the ORCA output will look like this:




(continues on next page)

**7.4. Choice of Computational Model** **473**

**ORCA Manual** **,** **Release 6.0.1**


(continued from previous page)



*𝐸* disp is given as the “ `Dispersion correction` ” and is automatically included in the final single point energy.
As discussed above, the parameters *𝑠* 6, *𝑎* 1, *𝑠* 8, and *𝑎* 2 may be manually defined by:




This results in the same output as above, but with additional messages that user inputs were found for the parameters:



The calculation of the same system using zero damping is run by the input:



As stated above, the parameters *𝑠* 6, *𝑟𝑠* 6, *𝑠* 8 and *𝛼* 6 can be defined by the user. The next example shows this along
with the call for the three-body correction ( `!ABC` ):



(continues on next page)

**474** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



**DFT Calculations with the Non-Local, Density Dependent Dispersion Correction (VV10): DFT-NL**

Accounting for the missing van der Waals (vdW, dispersion) forces in standard Kohn-Sham Density Functional
Theory (DFT) has become essential in many studies of chemical and physical electronic structure problems. Common approaches use atom pair-wise additive schemes such as the popular DFT-D3 [324, 326] method, which is also
available in ORCA by invoking the keyword `!D3` (see section *Treatment of Dispersion Interactions with DFT-D3* ),
but these are not self-consistent, and thus do not correct the MOs or any computed property besides the energies.

A different route is followed by the van der Waals Density Functional (vdW-DF) as pioneered by Langreth and
Lundquist [503]. These methods use only the electron density to include such dispersion/correlation effects. The
vdW correlation functional VV10 of Vydrov and Van Voorhis [876] currently seems to be the most promising
candidate for a general and accurate electronic structure method.

We use the term DFT-NL for any density functional in combination with the non-local part of the VV10 functional
with an optimized parameter *𝑏*, which will be defined below. The performance of these methods has been evaluated
in Ref. [400] using the GMTKN30 [307, 308, 309] database and the S66 set [6]. The performance of weak hydrogen
bonds were evaluated in Ref. [401].

DFT-NL and DFT-D3 perform very similarly, but NL is to be preferred for metallic systems or when the basic
electronic structure changes significantly (e.g. oxidations or ionizations). As a recent example, Janes and Iron
showed that for functionals such as wB97X-V, including VV10 correlation results in very high quality reaction
barriers when metals are involved [411].

The total exchange-correlation (XC) energy of VV10-type functionals is defined in eq. (7.35). It is composed of
standard exchange (X) and correlation (C) parts and the non-local (NL) term, which covers (mainly) long-range
dispersive energy:

*𝐸* XC [DFT-NL] = *𝐸* X [(hybrid)GGA] + *𝐸* C [GGA] + *𝐸* C-NL [VV10] (7.35)

The NL term is given by the following double integral:


*𝐸* C-NL [VV10] [=] ∫︁ *𝑑𝑟𝜌* ( *𝑟* ) [︂ *𝛽* + [1] 2


*𝑑𝑟* *[′]* *𝜌* ( *𝑟* *[′]* ) *𝜙* ( *𝑟, 𝑟* *[′]* ) (7.36)
∫︁ ]︂


where *𝜌* is the total electron density, and the definitions of the kernel *𝜙* ( *𝑟, 𝑟* *[′]* ) and *𝛽* are as follows (in a.u.):

3
*𝜙* ( *𝑟, 𝑟* *[′]* ) = *−* (7.37)
2 *𝑔𝑔* *[′]* ( *𝑔* + *𝑔* *[′]* )


3 */* 4
(7.38)
]︂


*𝛽* = [1]

32


3

[︂ *𝑏* [2]


with


*𝑔* ( *𝑟* ) = *𝜔* 0 ( *𝑟* ) *𝑅* [2] + *𝜅* ( *𝑟* )

*𝑅* = *|𝑟* *−* *𝑟* *[′]* *|*


⃒⃒⃒⃒


4
+ [4] *[𝜋]*

3 *[𝜌]* [(] *[𝑟]* [)]


*𝜔* 0 ( *𝑟* ) =


√


*∇* *𝜌* ( *𝑟* )
*𝐶*
⃒⃒⃒⃒ *𝜌* ( *𝑟* )


*𝜅* ( *𝑟* ) = *𝑏* [3] *[𝜋]*

2


1 */* 6

*𝜌* ( *𝑟* )

[︂ 9 *𝜋* ]︂


In the original definition, the short-range attenuation parameter *𝑏* appearing in *𝜅* and *𝛽* was fitted to the S22 set [429]
of non-covalent interactions ( *𝑏* = 5 *.* 9 for the rPW86PBE GGA). The other parameter *𝐶* = 0 *.* 0093, appearing in *𝜔* 0,

**7.4. Choice of Computational Model** **475**

**ORCA Manual** **,** **Release 6.0.1**

determines the long-range behavior, and was set to its original value. Other DFT-NL functionals are constructed
analogously. For a detailed discussion of the derivation of the formulas and their physical meaning and basis, see
the references given above.

The defined energy of the non-local DFT-NL exchange-correlation functional can be computed in two ways: as
a post-SCF addition based on a converged SCF density or in a self-consistent treatment. We take B3LYP as an
example.

In our implementation of the non-self-consistent B3LYP-NL functional, a self-consistent B3LYP computation is
performed as the first step. In the second step, the optimized electron density from the B3LYP computation is
taken as input for the energy calculation of the non-local part. This procedure is invoked by the combination
of the keywords `!B3LYP NL` . The use of the keywords `!B3LYP SCNL` would request a self-consistent treatment in
which orbitals and density are optimized in the presence of the full B3LYP + VV10 exchange-correlation potential.
According to many test calculations, an SCNL treatment is rarely necessary for normal energy evaluations.

The computation of the double integral given in eq. (7.36) requires using an integration grid, just like for normal
exchange-correlation functionals. This grid is built similarly to the regular grids available in the ORCA, see Sec.
*Details on the numerical integration grids* .

In the following, we compute the energy of the argon dimer at a distance of 3.76 Å with the def2-TZVP basis
set and using the B3LYP hybrid functional as an example. Here, we choose the non-self-consistent variant of the
DFT-NL dispersion correction.

The DFT-NL output for this example is shown below:




Here, we find the B3LYP total energy (” `SCF Energy` ”), the non-local contribution (” `NL Energy` ”), and their sum
(” `SC+NL Energy` ”), which is the final total energy. In the “ `DFT components` ” section, the non-local contribution
is listed separately (” `NL Energy, E(C,NL)` ”) in order to be consistent with the `!SCNL` output.

In the current version of ORCA, there are several functionals with pre-fitted *𝑏* parameters (the parameter *𝐶* is not
changed), available for use by the keyword `!DF NL` or `!DF SCNL`, where DF stands for one of the following density

**476** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


functional keywords:



Additionally, one can include the non-local term in Hartree-Fock (HF) with a parameter of *𝑏* = 3 *.* 9 using the
keywords “ `!HF NL` ”.

**The B97-V Family**

Head-Gordon’s *𝜔* B97X-V functional [555] is a reparametrized version of the range-separated *𝜔* B97X, which makes
use of the non-local VV10 kernel to capture London-dispersion effects ( *𝑏* = 6 *.* 0 and *𝐶* = 0 *.* 01; note that *𝐶* is,
unlike for the other functionals, changed for *𝜔* B97X-V). The keyword `!wB97X-V` evaluates the VV10 kernel in a
post-SCF way by default (i.e. only the semi-local exchange-correlation part is converged self-consistently and the
resulting density is then used to assess the VV10-type energy contribution). A recent study showed that this saves
computer time and does not have a significant effect on the resulting relative energies [603]. The keyword “ `!NL` ”
does not have to be specified in this case as the VV10 kernel is invoked automatically. If a user wishes to carry out
fully self-consistent calculations with *𝜔* B97X-V, the “ `!SCNL` ” keyword must be specified.

The range-separated meta-GGA hybrid *𝜔* B97M-V [557] and the meta-GGA B97M-V [556] are also available (via
keywords `!wB97M-V` and `!B97M-V`, respectively). In the spirit of *𝜔* B97X-V, the VV10 (NL) correction is called

**7.4. Choice of Computational Model** **477**

**ORCA Manual** **,** **Release 6.0.1**

automatically in the post-SCF way by default.

**Changing the** *𝑏* **,** *𝐶* **and Scaling Parameters**

All density functionals that are available in ORCA, but for which no *𝑏* parameter is available, can be used with the
DFT-NL method by providing a value for the parameter *𝑏* as shown here:



The other parameter *𝐶*, appearing in *𝜔* 0, may also be changed, as shown in the following example.



Of course, both parameters may be changed by using the `NLb` and `NLC` keywords in the `%method` block at the same

time.

**Note:** In order to improve the scaling for larger systems, a distance cutoff was also introduced, controlled by the
`vdWdistTCUT` flag in the `%method` block. The default value is 10 Å, so two grid points more than 10 Å away from
each other do not correlate via the VV10 potential. This is already very conservative and has practically zero effect
on the final energy, but can be altered if needed.

For methods where the long-range correlation is already partly covered, e.g. in double-hybrids, the NL energy can
be scaled down using the `NLScal` parameter as shown below. By default, the scaling factor is 1 *.* 0 if not otherwise
specified by the employed functional.



**Self-consistent Computations with the DFT-NL Dispersion Correction**

Self-consistent calculations with the DFT-NL dispersion correction are possible by using the keyword `!SCNL` in
combination with one of the available density functionals. Note that due to technical reasons, self-consistent calculations are not possible with the Hartree-Fock method.

For example, we can use the B3LYP hybrid functional with the self-consistent DFT-NL variant by the following
input:



**478** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

The output is the same as a normal SCF calculation, but after convergence, a line with `NL Energy, E(C,NL)` is
printed under “ `DFT components` ”, as it was for the post-SCF DFT-NL variant.

  - Analytic gradients are already available, thus geometry optimizations with numerical frequencies can be
computed using these functionals.

  - TD-DFT calculations are not yet available.

  - Any calculation that requires second derivatives of the NL functional is not yet possible. These are needed
for real type perturbations in the CP-SCF solutions, e.g. for analytic Hessians, dipole polarizabilities, and
double-hybrid gradients.

  - Strictly imaginary perturbations such as NMR shielding and EPR g-tensors (both also with GIAOs), and
hyperfine couplings are available.

**DFT and HF Calculations with the Geometrical Counterpoise Correction: gCP**

The central idea of the gCP correction [476] is to add a semi-empirical correction ∆ *𝐸* gCP to the energies of molecular systems that removes artificial overbinding effects from BSSE (see section *Counterpoise Correction* ). gCP
uses atomic corrections and therefore also has the ability to correct for intramolecular BSSE. The parametrization is constructed such that it approximates the Boys and Bernadi counterpoise (CP) correction ∆ *𝐸* *𝐶𝑃* in the
intermolecular case. That is,

∆ *𝐸* *𝐶𝑃* *≈* ∆ *𝐸* gCP (7.39)

where e.g. for a complexation reaction *𝐴* + *𝐵* *→* *𝐶*, our correction is given by

∆ *𝐸* gCP = *𝐸* gCP ( *𝐶* ) *−* *𝐸* gCP ( *𝐴* ) *−* *𝐸* gCP ( *𝐵* ) (7.40)

In practice, *𝐸* gCP can be simply added to the HF/DFT energy

*𝐸* total = *𝐸* HF/DFT + *𝐸* gCP (7.41)

which is done automatically in ORCA (the `FINAL SINGLE POINT ENERGY` includes the gCP correction).

The central equation of the gCP correction over all atoms *𝑁* reads:

*̸*


*𝑁*
∑︁ *𝑒* [miss] *𝑎* *· 𝑓* dec ( *𝑅* *𝑎𝑏* ) (7.42)

*𝑏* = *̸* *𝑎*


*𝐸* gCP = *𝜎* *·*

*̸*


*𝑁*
∑︁

*𝑎* *̸*


*̸*

where the energy *𝑒* [miss] *𝑎* is a measure of the incompleteness of the chosen target basis set (which is typically small)
and *𝑓* dec ( *𝑅* *𝑎𝑏* ) is a decay function that depends on the interatomic distance *𝑅* *𝑎𝑏* . The scaling factor *𝜎* is one of 4
parameters needed for every `method/basis set` combination. More details on this can be found in the original
gCP paper [476].

Analytical gradients with gCP are available for geometry optimization. Due to its semi-empirical nature, the
correction is calculated within seconds, even for very large systems.

The gCP correction can be invoked by using the `!GCP(level)` keyword, where `level` is a compound of the
method ( `HF` or `DFT` ) and the `basis set` keyword. See Table 7.7 for the available basis sets and the corresponding
keywords. For example, gCP can be invoked in a B3LYP calculation with the def2-SV(P) basis set using the input:


*̸*


*̸*


*̸*

Table 7.7: Overview of parametrized basis sets. The `level` keyword in `!GCP(level)` is a compound of `HF` or `DFT`
and the `basis set` keyword. Valid inputs are, for example: `!GCP(HF/MINIS)`, `!GCP(DFT/LANL)`, `!GCP(HF/TZ)`,
`!GCP(DFT/631GD)`, *. . .*

**7.4. Choice of Computational Model** **479**

**ORCA Manual** **,** **Release 6.0.1**

At all print levels, warnings from the gCP program are printed. Using the default print level, the only additional output is the final gCP correction before `FINAL SINGLE POINT ENERGY` . Using `!LargePrint` or `%output`
`Print[P_gCP] 2 end` states the gCP `level`, the 4 parameters mentioned above, and the computed correction. A
larger print level can be specified to get more details (more information on this below).

Several warnings and notices may be issued. Elements of the 5th and higher periods are treated as their 4th period
analogs — e.g. Sn is treated with the same parameters as Ge. If this is the case, a note is printed. Another note
is printed if there is a mismatch between the basis used for the SCF calculation and that of the requested gCP
calculation. For example, the following input with tetramethyltin



should use the parameters of Ge in place of Sn and there should be a mismatch between the basis set in ORCA
(def2-SVP) and gCP (MINIS). Sure enough, the output is as follows:



A mismatch between the basis sets used is allowed since a minor mismatch may only result in a small error. One
should still be careful with such results; use your own judgment! This also allows gCP in calculations that use
an unparametrized basis set. However, in this case, the number of basis functions and exponents should be very
similar!

It should be noted that some elements are not parametrized, depending on the gCP `level` used. If only a few
atoms in a large molecule are treated inaccurately or not at all, the error is expected to be small. To check all
parameters used and the individual atomic contributions, specify the print level `%output Print[P_gCP] 3 end` .
For example, the above tetramethyltin input with this print level has the following output:



(continues on next page)

**480** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



From this, it can be seen that the Sn atom (atom 2 in the list of atomic contributions) gives no contribution because
its `Emiss` is zero (unparametrized for the given gCP `level` ). This is confirmed by looking at the `gCP element`
`parameters` section, which lists the `emiss` of Sn as zero for `!GCP(HF/MINIS)` . Rerunning this example with
`!GCP(HF/SVP)` now gives a contribution for Sn, as seen by the following output. Note that this calculation also
has a much smaller basis set mismatch, and so should be the more accurate gCP correction of the two.



(continues on next page)

**7.4. Choice of Computational Model** **481**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



The gCP input can also be defined in the `%method` block of the input:



**General advice:**

  - Small basis sets show not only a large BSSE, but general shortcomings. These effects are not always clearly
distinguishable.

  - If computationally affordable, large basis sets (triple- *𝜁* and higher) are always preferable for a given system.

  - gCP only makes sense for somewhat large molecules

  - gCP should always be applied together with a dispersion correction for DFT: gCP-D3 is well tested, but gCPNL also works well (see sections *Treatment of Dispersion Interactions with DFT-D3* and *DFT Calculations*
*with the Non-Local, Density Dependent Dispersion Correction (VV10): DFT-NL* )

**Note:**

   - `!GCP(HF/MINIS)` automatically sets the refitted D3 parameter, as proposed in the original gCP paper.

  - The gCP method is implemented via an external tool called **otool_gcp**, which is based on the original Fortran

**482** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

program used in the publication. Thus, the otool_gcp binary can also be called directly via the command
line ( `otool_gcp -h` gives an overview of the options).

  - It is also possible to read an external parameter file ( `$HOME/.gcppar` ) using the `!GCP(FILE)` keyword. For
further information, please look at the manual for the gcp program as provided by Prof. S. Grimme [8] .

  - During the calculation, some temporary output files are written by ORCA: `BASENAME.gcp.in.tmp` and
`BASENAME.gcp.out.tmp` will contain the input for otool_gcp and its output, respectively.

  - It has been demonstrated that the popular combination of B3LYP with 6-31G(d) can be strongly improved
using DFT-D3 and gCP [475]. For convenience, the keyword `!B3LYP-gCP-D3/6-31G*` has been defined.
This is equivalent to `!B3LYP 6-31G* D3BJ GCP(DFT/631GD)` .

**HF-3c: Hartree-Fock with three corrections**

HF-3c is a fast Hartree-Fock based method developed for computation of structures, vibrational frequencies and
non-covalent interaction energies in huge molecular systems [834]. The starting point for evaluating the electronic
energy is a standard HF calculation with a small Gaussian AO basis set. The used so-called MINIX basis set
consists of different sets of basis functions for different groups of atoms as shown in table Table 7.8.

Table 7.8: Composition of the MINIX basis set.

*̸*


Three terms are added to correct the HF energy *𝐸* tot [HF/MINIX] in order to include London dispersion interactions, to
account for the BSSE and to correct for basis set deficiencies, i.e. overestimated bond lengths. The corrected total
energy is therefore calculated as

*𝐸* tot [HF-3c] = *𝐸* tot [HF/MINIX] + *𝐸* disp [D3(BJ)] + *𝐸* BSSE [gCP] [+] *[ 𝐸]* [SRB] *[.]* (7.43)

The first correction term *𝐸* disp [D3(BJ)] is the atom-pair wise London dispersion energy from the D3 dispersion correction
scheme[324] applying Becke-Johnson (BJ) damping [90, 424, 425] (see section *Treatment of Dispersion Interac-*
*tions with DFT-D3* ). The second term *𝐸* BSSE [gCP] [denotes the geometrical counterpoise (gCP) correction [][476][] to treat]
the BSSE (see section *DFT and HF Calculations with the Geometrical Counterpoise Correction: gCP* ). For the
HF-3c method, the three usual D3 parameters *𝑠* 8, *𝑎* 1 and *𝑎* 2 were re-fitted using reference interaction energies of
the complexes of the S66 test set [6]. This results in *𝑠* 8 = 0 *.* 8777, *𝑎* 1 = 0 *.* 4171 and *𝑎* 2 = 2 *.* 9149. The parameter
*𝑠* 6 was set to unity as usual to enforce the correct asymptotic limit and the gCP correction was already applied in
this fitting step.

The last term *𝐸* SRB is a short-ranged correction to deal with basis set deficiencies which occur when using small or
minimal basis sets. It corrects for systematically overestimated covalent bond lengths for electronegative elements
and is calculated as a sum over all atom pairs:

*̸*


Atoms
∑︁ ( *𝑍* *𝐴* *𝑍* *𝐵* ) [3] *[/]* [2] exp( *−𝛾* ( *𝑅* *𝐴𝐵* [0] *[,]* [D3] [)] [3] *[/]* [4] *[𝑅]* *[𝐴𝐵]* [)]

*𝐵* = *̸* *𝐴*


*𝐸* SRB = *−𝑠*

*̸*


Atoms
∑︁

*𝐴* *̸*


*̸*

Here, *𝑅* *𝐴𝐵* [0] *[,]* [D3] [are the default cut-off radii as determined] *[ ab initio]* [ for the D3 scheme [][324][] and] *[ 𝑍]* *[𝐴]* [,] *[ 𝑍]* *[𝐵]* [are the]
nuclear charges. This correction is applied for all elements up to argon. The empirical fitting parameters *𝑠* = 0 *.* 03

8 http://www.thch.uni-bonn.de/tc/

**7.4. Choice of Computational Model** **483**

**ORCA Manual** **,** **Release 6.0.1**

and *𝛾* = 0 *.* 7 were determined to produce vanishing HF-3c total atomic forces for B3LYP-D3(BJ)/def2-TZVPP
equilibrium structures of 107 small organic molecules. More details can be found in the original publication [834].

The HF-3c method can only be invoked with a simple keyword:
```
! HF-3c

```
`! HF-3c` is a compound keyword and equals `! HF MINIX D3BJ GCP(HF/MINIX) PATOM`, hence no basis set etc.
has to be specified. The `PATOM` guess is selected since the grid construction for the default guess can take more
time than an actual SCF step. The guess can only be overwritten manually in the %method section.

The default mode for the integral handling is set to `Conventional` . The storing of the two-electron integrals on
disk or in memory if possible leads to large computational savings. In case one want to use the `Direct` mode, this
has to be specified in the %scf input section:



The output gives the used parameters and the correction itself for D3 and gCP separately. As the SRB correction is
also calculated with the otool_gcp, the results are given in the gCP output section. The `Total correction to`
`HF/MINIX` is the sum of all three corrections (D3, gCP and SRB) and `FINAL SINGLE POINT ENERGY` is the total
HF-3c energy as given in equation (7.43).


(continues on next page)

**484** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



For the elements up to Xe, the default initial guess is a Hückel guess. Beyond Xe, the guess mode is changed to
`HCORE` since no Hückel parameters for the respective ECP bases are available and other models are not implemented
at the moment. For calculations with only lighter elements and therefore no ECPs, the ECP printouts in the output
file can be ignored.

**PBEh-3c: A PBE hybrid density functional with small AO basis set and two corrections**

PBEh-3c is a highly efficient electronic structure approach performing particularly well in the optimization of geometries and for interaction energies of non-covalent complexes.[325] Here, a global hybrid variant of the PerdewBurke-Ernzerhof (PBE) functional with a relatively large amount of non-local Fock-exchange (42%) is employed
with a valence-double-zeta Gaussian AO basis set (def2-mSVP). Basis set superposition errors (BSSE) and London dispersion effects are accounted for by the gCP and D3 schemes, respectively (see above). The basis set is
constructed such that:

Table 7.9: Composition of the def2-mSVP basis set.

For inter- and intramolecular BSSE the gCP expression from Eq. (7.42) is used but with a damping function (similar to the zero-damping in Eq. (7.32)). This damping improves the thermochemistry of the method significantly
compared with the non-damped version. London dispersion effects are accounted for by the DFT-D3 (BJ-damping)
scheme including the three-body term. Compared to the related HF-3c approach, the PBEh-3c is somewhat more
costly, however, it yields much better geometries. These are roughly of MP2-quality (or even better for non-covalent
structures) but may be computed at much lower cost. Due to the moderate amount of non-local Fock exchange, the
method is less prone to self-interaction errors (as in GGAs) but still applicable in cases when Hartree-Fock fails
(strongly correlated systems).

The PBEh-3c method may be invoked with the simple keyword:
```
! PBEh-3c

```
Identical to HF-3c, the default initial guess for all elements up to Xe is a Hückel guess. Beyond Xe, the guess mode
is changed to `HCORE` . For calculations with only lighter elements and therefore no ECPs, the ECP printouts in the
output file can be ignored.

Recently, a new composite ‘low-cost’ method for accurate thermochemistry, structures, and noncovalent interactions specifically also for transition metal chemistry and other stronger correlated systems was implemented. As

**7.4. Choice of Computational Model** **485**

**ORCA Manual** **,** **Release 6.0.1**

it is based on the B97 GGA including D3 with three-body contribution, a short range bond length correction, and
a modified, stripped-down triple- *𝜁* basis, def2-mTZVP, the computational cost of this method termed B97-3c are
between that of HF-3c and PBEh-3c (for large systems roughly two times more expensive than HF-3c). It is invoked
with a simple keyword analogously to the latter methods. Some more detailed information can be found in Ref.

[121] .

*𝑟* [2] **SCAN-3c: A robust “Swiss army knife” composite electronic-structure method**

The *𝑟* [2] SCAN-3c composite method[333] is available as robust “Swiss army knife” electronic structure method for
thermochemistry, geometries and non-covalent interactions and has shown in preliminary tests consistent performance for both open and closed shell transition metal complexes. It is based on the *𝑟* [2] SCAN[282] meta-GGA
combined with the D4 dispersion correction[244] and the geometrical counter poise-correction[476]. The modified triple- *𝜁* basis set, def2-mTZVPP, is larger and more consistent for the light main-group elements and almost
as computationally efficient as the def2-mTZVP basis set of B97-3c. The computational cost of *𝑟* [2] SCAN-3c is
slightly larger than B97-3c. It is invoked with the simple keyword
```
! r2SCAN-3c

```
*𝜔* **B97X-3c: A composite range-separated hybrid DFT method with a molecule-optimized polarized**
**valence double-** *𝜁* **basis set**

The *𝜔* B97X-3c composite method[540] is based on the *𝜔* B97X-V functional and combines a tailored and moleculeoptimized polarized valence double- *𝜁* (vDZP) basis set and a specifically adapted D4 dispersion correction. The
vDZP basis set employs large-core ECPs and shows only very small basis set superposition and incompleteness
errors compared to conventional double- *𝜁* basis sets. In thorough tests on standard benchmarks sets, the *𝜔* B97X-3c
method was shown to be on par with well-performing hybrid DFT methods in a quadruple- *𝜁* basis set at a fraction
of their computational cost. *𝜔* B97X-3c is consistently available for all elements up to Rn (Z = 1–86).

It is invoked with the simple keyword:
```
! wB97X-3c

```
The vDZP basis set alone is utilized as follows (note that the corresponding large-core ECPs are called automatically):
```
! vDZP

```
**7.4.3 Semiempirical Methods**

The present version of ORCA has inherited the capability of doing semiempirical calculations from the earlier
versions. A number of methods based on the “neglect of differential overlap” [692, 779] are currently implemented
for energies and analytic gradients (for geometry optimization).



(continues on next page)

**486** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

The methods MNDO [206, 207, 848], AM1 [208] and PM3 [822] are available for main group elements only
and arise from the work of the Dewar group. They have been optimized to reproduce molecular structure and
energetics. The older CNDO/1,2 and INDO/1,2 were developed by the Pople group [61, 175, 176, 177, 693,
696, 697, 749, 750] and were designed to roughly mimic minimal basis *ab initio* calculations. The methods of the
Zerner group (ZINDO/1,2 and ZINDO/S) are closely related to the older methods but have been well parameterized
for transition metals too [36, 37, 38, 63, 183, 466, 720, 908, 909, 910, 912]. ZINDO/1 (and less so ZINDO/2)
are suitable for geometry optimization. ZINDO/S gives good results for electronically excited states at moderate
configuration interaction levels and is also successful for the calculation of electron and spin distributions in large
transition metal complexes [37, 183, 466, 908, 909, 910]. The ZNDDO/1,2 methods have been implemented
into ORCA as straightforward extensions of the corresponding INDO methods without changing any parameter.
However, the methods benefit from the somewhat more accurate representation of the Coulomb interaction within
the NDDO approximation [431, 634]. The preliminary experience with these methods is that they are better than
the corresponding INDO methods for calculation of transition metal complex structures but on the whole have also
similar deficiencies.

The analytic gradients are available for all of these methods and can be used to produce reasonable molecular
structures at low computational cost or to get preliminary insight in the behavior of the system under investigation [9] .

There is also a mechanism for simplified input. Instead of giving values for `Method` and `Version` separately you
can also assign the value that would normally belong to `Method` to `Version` . The program will recognize that and
assign the correct values to both `Method` and `Version` .




  - If you want you can also combine semiempirical methods with MP2 (energies only). For example use `Method`
= `AM1;` and `DoMP2` = `true;` It is questionable if this makes the results of semiempirical calculations any better
but at least it is possible in ORCA.

You can change the built-in semiempirical parameters in a straightforward fashion. For example:



The `%ndoparas` block is there in order to let you input your favorite personal parameters. The “molecular” parameters are set using “ `INTFA` ” (“interaction factors”);



(continues on next page)

9 However, do not try to use ZINDO/S (or CNDO/S) for structure optimizations - it does not make sense and will lead to disastrous results
because there is no accurate representation of nuclear repulsion in these methods.

**7.4. Choice of Computational Model** **487**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

All atomic parameters are collected in an array “P”. The first index is the atomic number of the element whose
parameters you want to change. The second index identifies which parameter. The list of parameters follows
below. Most of them will only be interesting for expert users. The most commonly modified parameters are the
Beta’s (number 25 through 28). Note that most programs require a negative number here. In ORCA the resonance
integrals are defined in a way that makes the Beta’s positive.



(continues on next page)

**488** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**Semi-empirical tight-binding methods: Grimme’s GFN0-xTB, GFN-xTB and GFN2-xTB**

ORCA is interfaced to the XTB tool by Grimme and coworkers, allowing the user to request all kinds of calculations
using the popular GFN0-xTB, GFN-xTB and GFN2-xTB Hamiltonians.[70, 332, 699] From the technical side, the
user has to provide the executable provided by the Grimme group. The xtb program package can be obtained
[free of charge from https://github.com/grimme-lab/xtb/releases and detailed information on the usage of the](https://github.com/grimme-lab/xtb/releases) `xtb`
[standalone program and its utilities can be found at https://xtb-docs.readthedocs.io/en/latest/contents.html. Only](https://xtb-docs.readthedocs.io/en/latest/contents.html)
the file `bin/xtb` is used by ORCA . The user should copy this file into the directory where the other ORCA
executables are located, and rename it as `otool_xtb` .

**Please use the 6.7.1 version (or any later version) of xtb; older versions are not fully compatible with ORCA**
**anymore or are missing features, for example it may not be possible to invoke the solvation model! Addi-**
**tionally, Windows users should copy** `libiomp5md.dll` **from the XTB directory to the ORCA directory.**

XTB is invoked by the following keywords:



(continues on next page)

**7.4. Choice of Computational Model** **489**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

The following methods can be used in conjunction with XTB:

  - Single Point Energy

  - Energy and Gradient

  - Optimization, using all kinds of constraints, relaxed surface scans, etc.

  - Nudged-Elastic Band calculations

  - Numerical Frequency Calculations

  - Intrinsic Reaction Coordinate

  - Molecular Dynamics Calculations

  - QM/MM calculations

**Note:**

  - XTB0 is a non-self-consistent tight-binding method, and as such, its accuracy is generally inferior to XTB1
and XTB2 (and sometimes even XTBFF), despite that it is a few times faster than XTB1 and XTB2. From
our experience, we only recommend XTB0 when both XTB1 and XTB2 exhibit qualitative failures for the
system of interest.

  - Please note that XTB0, XTB1 and XTB2 can also be used for the initial path generation or for the calculation
of an initial TS structure on XTB level, both as input for the subsequent NEB calculation on a higher level
of theory. For more details, please consult section *Nudged Elastic Band Method* .

**Solvation**

Three implicit solvation models can be requested in XTB calculations: (1) the analytical linearized PoissonBoltzmann (ALPB) solvation model, (2) the domain decomposition COSMO (ddCOSMO)[136], and (3) the extended conductor-like polarizable continuum model (CPCM-X).[815] These three models can be requested via the
following tags in the simple input



where `solvent` is any of the solvents in Table 7.29.

**490** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


**Keywords for XTB**

A list of additional keywords for XTB is detailed here:



**Note:**

  - If jobs are run over several nodes, the number of cores used by the XTB tool might be lower than requested
via the pal keyword.
### **7.5 Choice of Basis Set**

A fair number of reasonable basis sets is hardwired in the program as will be described in the next section. In
addition, whole basis sets can be read from a file, basis sets can be assigned for all atoms of a given type or, at
the highest resolution, basis sets can be assigned to individual atoms which is convenient if different parts of the
molecule are to be treated at different levels of accuracy. Most hard wired basis sets were obtained from the EMSL
library [251] and the input format in ORCA is closely related to the “GAMESS-US” format.

**Note:** As of ORCA version 4.0, the basis set handling has been significantly modified!
Please check your basis sets very carefully!

**7.5.1 Built-in Basis Sets**

The basis set is specified in the block `%BASIS` . Note that there are three distinguished slots for auxiliary basis
sets (AuxJ, AuxC and AuxJK) to be used with RI approximation. Which auxiliary basis slot is used in the actual
program depends on the context. The AuxJ and AuxJK slots are used in the context of Fock matrix construction,
whereas the AuxC slot is used for all other integral generation steps e.g. in post-Hartree Fock methods. Assigning
the auxiliary basis with the simple input, takes care of the individual slots. However, in specific cases they must
be set explicitly in the block input. For example, a “/JK” basis may be assigned to AuxJ in this way.

**7.5. Choice of Basis Set** **491**

**ORCA Manual** **,** **Release 6.0.1**

**Note:** As of ORCA 4.0, the basis set name has to be put in quotation marks, and the basis set name identifiers are
the same as in the simple input!



**Warning:**

   - ORCA uses pure d and f functions (5D and 7F instead of Cartesian 6D and 10F) for all basis sets. This
needs to be taken into account when results are compared with other programs, especially for Pople-style
basis sets that were optimized with Cartesian (6D) functions.

   - If you use `Decontract` : if your basis set arises from general contraction it will contain duplicate primitives in several contractions and these will be removed such that only unique primitives remain and there
is no problem with redundancy.

A complete list of predefined basis sets and their availability is given in Table 7.10.

Table 7.10: Basis sets availability

continues on next page

**492** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.10 – continued from p revious p a g e

continues on next page

**7.5. Choice of Basis Set** **493**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.10 – continued from p revious p a g e

continues on next page

**494** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.10 – continued from p revious p a g e

continues on next page

**7.5. Choice of Basis Set** **495**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.10 – continued from p revious p a g e

continues on next page

**496** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.10 – continued from p revious p a g e

continues on next page

**7.5. Choice of Basis Set** **497**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.10 – continued from p revious p a g e

continues on next page

**498** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.10 – continued from p revious p a g e

continues on next page

**7.5. Choice of Basis Set** **499**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.10 – continued from p revious p a g e

continues on next page

**500** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.10 – continued from p revious p a g e

**7.5. Choice of Basis Set** **501**

**ORCA Manual** **,** **Release 6.0.1**

**Note:** Check these pointers for more information on the basis sets: (indicated in ecah element of the table as well)

   - [1] Used with the Def-ECP pseudopotentials (Rb–Lr).

   - [2] Used with the Def2-ECP pseudopotentials (Rb–Rn).

   - [3] Used with the dhf-ECP or dhf-ECP-2c pseudopotentials (Rb–Rn). For elements H–Kr equivalent to the
respective def2-XVP basis set.

   - [4] Used with the HayWadt pseudopotentials (Na–La, Hf–Bi, U–Pu).

   - [5] Valence double-ζ with large-core pseudopotentials. For the respective ECP types per element, see Ref. [15]
and table 6.5.

   - [6] The respective basis sets without core correlation functions, i.e. (aug-)cc-pVXZ(-DK)(/C), are used for H
and He.

   - [7] Used with the SK-MCDHF-RSC pseudopotentials (Ca, Cu–Kr, Sr–Xe, Ba, Hf–Ra, U).

A note on RI and auxiliary basis sets: one thing that is certainly feasible and reasonable if you do not want to
depend on the RI approximation is to converge a RI-J calculation and then take the resulting orbitals as initial
guess for a calculation with exact Coulomb term. This should converge within a few cycles and the total execution
time should still be lower than just converging the calculation directly with exact Coulomb treatment.

**7.5.2 Automatic generation of auxiliary basis sets**

If no auxiliary basis set is available for your chosen orbital basis set, one can be generated automatically by ORCA
using the keyword `AutoAux` . This is specified as any other fitting basis set: as a value to the `AuxJ/AuxJK/AuxC`
variables in the `%basis` block or as a separate keyword in the simple input line (in which case all three Aux slots
are populated with identical fitting basis sets). `AutoAux` can also be assigned to individual elements or atoms

- see sections *Assigning or Adding Basis Functions to an Element* and *Assigning or Adding Basis Functions to*
*Individual Atoms* . The generated basis sets can be used for Coulomb, exchange and correlation fitting and are
as accurate as the optimized auxiliary basis sets at the cost of being up to twice as large. The exact generation
procedure is described elsewhere [828] but notably **it has been significantly altered since ORCA 3.1 and will**
**not produce the same results!** For compatibility, the old version is still accessible via the setting `OldAutoAux`
`true` in the `%basis` block. Some additional settings for `AutoAux` are given below with their default values.



(continues on next page)

1 Used with the Def-ECP pseudopotentials (Rb–Lr).
2 Used with the Def2-ECP pseudopotentials (Rb–Rn).
3 Used with the dhf-ECP or dhf-ECP-2c pseudopotentials (Rb–Rn).
4 Used with the HayWadt pseudopotentials (Na–La, Hf–Bi, U–Pu).
5 Valence double-ζ with large-core pseudopotentials. For the respective ECP types per element, see Ref. [540] and Table 4.3.
6 The respective basis sets without core correlation functions, i.e. (aug-)cc-pVXZ(-DK)(/C), are used for H and He.
7 Used with the SK-MCDHF-RSC pseudopotentials (Ca, Cu–Kr, Sr–Xe, Ba, Hf–Ra, U).

**502** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



Note that if the orbital basis set contains diffuse functions, as is the case for the aug-cc-pVXZ sets, the AutoAux
fitting basis may contain (near-)linear dependencies. In this case, the Cholesky decomposition of the Coulomb
metric will fail and the program will likely crash. One may print the offending auxiliary basis using `!PrintBasis`
and manually remove the most diffuse s- and/or p-functions, which will usually resolve the problem. An alternative,
automatic solution is implemented in ORCA 5.0 – see section *Removal of Redundant Basis Functions* .

**7.5.3 Assigning or Adding Basis Functions to an Element**

In order to assign a new basis set to a given element, use:



Note that for simplicity and consistency the input format is the same as that used in the basis set files. In this format
the first line carries first the angular momentum of the shell to be added (s, p, d, f, g, h, i, j) and the number of
primitives. Then for each primitive one line follows which has (a) the index of the primitive (1, 2, 3, ...) (b) the
exponent of the primitive and (c) the contraction coefficient (unnormalized). Note that ORCA always uses spherical
harmonic Gaussian functions. L-shells (not to be confused with angular momentum equal to 9) can only be dealt
with as separate s- and p-shells. There also is the possibility to include a `SCALE X` statement after the number of
primitives in the first line to indicate that the basis function exponents should be scaled.

In order to add basis functions to the basis of a given element (for example because you do not like the standard
polarization functions) use `AddGTO` instead of `NewGTO` . In `NewGTO` or `AddGTO` you can also use the nicknames of
internally stored basis sets. An example is:

**7.5. Choice of Basis Set** **503**

**ORCA Manual** **,** **Release 6.0.1**



In this example the 6-31G basis is assigned to oxygen and in addition a polarization function with exponent 0.4 is
added to the oxygen basis.

Note that the `NewGTO` keyword does not change the ECP for the given element - you must use `NewECP` or `DelECP`
(see section *Advanced Specification of Effective Core Potentials* ).

A similar mechanism was established for the auxiliary basis sets in RI calculations:



New basis functions can be specifically assigned to any auxiliary basis sets. The keywords `NewAuxCGTO`,
`AddAuxCGTO`, `NewAuxJKGTO`, `AddAuxJKGTO`, `NewCABSGTO`, `AddCABSGTO` are used in the same way. The keywords `NewAuxGTO` and `AddAuxGTO` are the same as `NewAuxJGTO` and `AddAuxJGTO`, that is, they only influence
the Coulomb auxiliary basis (/J basis)!

**7.5.4 Assigning or Adding Basis Functions to Individual Atoms**

Sometimes you may want to not treat all carbon atoms with the same basis set but to assign a specific basis set to a
specific atom in the molecules. This is also possible in ORCA and takes place in the coordinate section ( `%coords`,
`*xyz`, etc.). The format is the same as described above. An example may help to make things clear:



In this example an extra d-shell with exponent 1.0 is added to the first carbon atom and the basis for the oxygen
atom is changed to `6-311G` with an extra d-function of exponent 1.2 added.

Analogously, `AUX` basis functions can be assigned or added to individual atoms using the keywords `NewAuxJGTO`,
`AddAuxJGTO`, `NewAuxCGTO`, `AddAuxCGTO`, `NewAuxJKGTO`, `AddAuxJKGTO`, `NewCABSGTO`, `AddCABSGTO` .

A note on the use of `AutoAux` : if you change the basis set on a given atom and want to generate a fitting basis, you
have to specify it again in the `COORDS` section, even if `AutoAux` is already present in the simple input line or in the

**504** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


`%basis` block. For example:



Here the oxygen atom is assigned the Def2-SVP basis and the Def2/JK fitting basis, the first hydrogen atom is
assigned the Def2-SVP basis and an automatically generated fitting basis and the second hydrogen atom is assigned
the Def2-SVP basis with two additional polarization functions and a larger automatically generated fitting basis
that accounts for these functions.

**Tip:** When assigning custom basis sets it is always a good idea to print the basis set information ( `%output`
`print[p_basis] 2 end` or simply `!PrintBasis` ) and check that everything is correct.

**7.5.5 Assigning Basis Sets and ECPs to Fragments**

In multi-level or QM/QM calculations it may be convenient to assign different basis sets to different fragments.
This can be done with the keywords `FragBasis`, `FragAuxJ`, `FragAuxJK`, `FragAuxC`, `FragCABS`, and `FragECP` in
the `%basis` block, followed by the number of the fragment (numbering starts at 1!) and a standard basis set or ECP
from the ORCA library (see Tables Table 7.10 and Table 4.3). Note that unlike the `NewGTO` keyword, `FragBasis`
also changes the ECP, if applicable. Fragment basis sets will overload the global or element-specific ( *Assigning or*
*Adding Basis Functions to an Element* ) choice but can be overloaded for individual atoms ( *Assigning or Adding*
*Basis Functions to Individual Atoms* ). If AutoAux is requested for a fragment, it will be generated for the actual
orbital basis set chosen for each atom, even if it is changed in the coordinates section. However, if AutoAux was
requested for an element or in the simple input, the auxiliary basis will be generated before the fragment basis is
assigned (which is not desired), therefore AutoAux must be requested again for the fragment. An example is given
below:



(continues on next page)

**7.5. Choice of Basis Set** **505**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

It is also possible to read fragment-specific basis sets from a file. The syntax is analogous, using the keywords
`ReadFragBasis`, `ReadFragAuxJ`, `ReadFragAuxJK`, `ReadFragAuxC`, `ReadFragCABS`, and `ReadFragECP` . In this
case, the input string is expected to be an existing basis set file in GAMESS-US format (see section *Reading Orbital*
*and Auxiliary Basis Sets from a File* ). All other details above (e.g., regarding ECPs and AutoAux) also apply here.

**7.5.6 Reading Orbital and Auxiliary Basis Sets from a File**

By using the variables `GTOName`, `GTOAuxJName`, `GTOAuxJKName`, `GTOAuxCName`, and `GTOCABSName` ( `GTOAuxName`
is a synonym for `GTOAuxJName` ) a basis set can be read from an ASCII file. In this way you can construct or modify
your favorite standard basis set and load it easily into the program.



A word of caution: in C/C++ the backslashes in directory assignments must be given twice to be correctly understood! The format is that used for “GAMESS-US” in the EMSL library [251]. To give an example of what this
format looks like here is a part of the `3-21GSP` basis of Buenker and coworkers [588, 589]:



(continues on next page)

**506** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

The file format for the auxiliary basis sets is exactly the same. Basis sets can be also exported in GAMESS-US
format by the `orca_exportbasis` utility (section *orca_exportbasis* ). Note that in order to read basis sets printed
by ORCA (using `!PrintBasis` ), the `NewGTO` and `end` keywords must be removed.

**7.5.7 Advanced Specification of Effective Core Potentials**

**Library ECPs and Basis Sets**

Besides the simple input line (section *Effective Core Potentials* ), assignment of ECPs can be done within the `%basis`
block using the `ECP` and `NewECP` keywords as in the following example:



A variant of the `NewECP` keyword can be used for individual atoms inside the geometry definition:



Note that these keywords only affect the ECP and not the valence basis set!

In case the basis set for an element/atom has been changed using the `NewGTO` keyword (see sections *Assigning*
*or Adding Basis Functions to an Element* and *Assigning or Adding Basis Functions to Individual Atoms* above) it
may be necessary to remove the ECP from that element/atom. This can be done with the `DelECP` keyword in the
`%basis` block or coordinates input, respectively:



To remove all ECPs loaded by default (e.g. in case no global basis set is chosen) you can use the `!NoECP` simple
keyword.

**7.5. Choice of Basis Set** **507**

**ORCA Manual** **,** **Release 6.0.1**

**Manual Input of ECP Parameters**

To manually specify ECP parameters, the `NewECP` keyword is followed by the element for which an ECP is to be
entered, the number of core electrons to be replaced (N_core) and the maximum angular momentum (lmax). The
ECP specification is finished by giving the definitions of the individual shells that constitute the angular dependent
potentials U *𝑙* .



For each ECP shell, first the angular momentum *𝑙* has to be given, followed by the number of primitives. The primitives themselves are then specified by giving a running index and the respective tuple of exponent *𝑎* *𝑘𝑙*, expansion
coefficient *𝑑* *𝑘𝑙* and radial power *𝑛* *𝑘𝑙* .



As an example, consider the SD(10,MDF) for Vanadium. The name indicates a Stuttgart–Dresden type ECP that
replaces 10 core electrons and is derived from a relativistic calculation for the neutral atom. It consists of 4 shells
with angular momentum s, p, d, and f. Note that the f shell has an expansion coefficient of 0.0 and thus will
not contribute at all to this effective core potential. This is typical for all SD potentials (but may be different for
program packages like TURBOMOLE that do not support arbitrary angular momentum with respect to the ECP
and therefore use recontractions of the original parameter sets).




**508** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**ECPs and ghost atoms**

When ghost atoms are defined on the input (see section *Special definitions* ), ECPs are **not** added to these atoms by
default. If that is somehow needed, please add `GhostECP true` under the `%basis` block.



**7.5.8 Embedding Potentials**

Computations on cluster models sometimes require the presence of embedding potentials in order to account for
otherwise neglected repulsive terms at the border [304]. In order to simplify these kind of calculations with ORCA
the ECP embedding can be accomplished quite easily:



The declaration of such a coreless ECP center takes place in the coordinates section by appending a bracket “>”
to the element symbol. Note that embedding ECPs are treated as point charges in ORCA, so the charge has to
be given next. The coordinates of the coreless ECP center have to be specified as usual and may be followed by
an optional ECP assignment. In general, calculations that employ an ECP embedding procedure should be single
point calculations. However if the need arises to perform a geometry optimization, make sure to set up explicit
Cartesian constraints for the coreless ECP centers.

**7.5.9 Linear Dependence**

The previous sections describe the assessment of a desired molecular basis set from appropriately parametrized
functions at various locations within the molecule (normally centered on atoms). The parametrization of these
functions is such that the chance for redundancy is minimal. Since however, one is limited to work with finite numerical precision, and furthermore these parameters also depend on the molecular geometry, redundancies cannot
be completely eliminated in advance. Redundancy means that the subspace spanned by the given basis functions
at given values of parameters (including geometry), can be identically spanned by a smaller number of *linear in-*
*dependent* basis functions. Linear dependent (redundant) function sets however may cause numerical instabilities.
Linear dependence is normally identified by searching for zero eigenvalues of the overlap matrix. Note that the
inverse of the overlap (or related matrices) are used for orthogonalization purposes, and it follows that if near zero
eigenvalues are not treated properly, the inverse becomes ill-defined, and the SCF procedure numerically unstable.

From the previous discussion, it is evident that the crucial parameter for curing linear dependence is the threshold
below which an overlap eigenvalue is considered zero. This parameter may be changed using the following keyword



Although there is no strict limit for the value of the above parameter, it should reasonably be somewhere between
1e-5 and 1e-8 (the default is 1e-7). One may get away with 1e-9 or perhaps even lower without convergence
problem, but there is a risk that the result is contaminated with noise caused by the near zero vectors. In difficult
cases, an 1e-6 threshold was often found to work smoothly, and above that one risks throwing away more and more
functions, which also influence comparability of results with other calculations. To monitor the behavior of the
small eigenvalues, one should look for the following block in the output

**7.5. Choice of Basis Set** **509**

**ORCA Manual** **,** **Release 6.0.1**



Here, the smallest eigenvalue is printed, along with the currently used overlap threshold, and the number of functions below this (which will be dropped). It is a recommended consistency check to look for an equal number of
zero entries among orbital energies once the SCF procedure converged. Note that for functions belonging to zero
eigenvalues *no level shifts* are applied!

In case that redundant vectors were removed from the basis, `! MORead NoIter` should only be used in conjunction
with the same `SThresh` as in the original calculation, otherwise the results will be inconsistent. `!` `MORead` may
still be used together with a change in `SThresh`, but a few SCF iterations will be required.

**Automatic Adjustments for Near Linear-Dependent Cases**

Starting from ORCA6, there is now a keyword called DiffSThresh, which controls an automatic tightening of the
integral cutoff parameters Thresh and TCut in case small eigenvalues of the overlap matrix are found. We found
this to be important in some calculations using diffuse basis, and these parameters are set to a minimum value
of Thresh=1e-12 and TCut=1e-13 in case the “Smallest eigenvalue” shown above gets below that number. If the
cutoffs are already tighter than that, for instance when using `!VeryTightSCF`, than nothing will happen.

We found empirically that these are safe numbers to mitigate noise and increase the robustness of the SCF procedure, thus they are enforced by default. The default is 1e-6 and this can be turned off by setting `%SCF DiffSThresh`
`-1 END` on the input in case you don’t want this automatic adjustment to happen.

**Removal of Redundant Basis Functions**

While the approach described above is usually successful in removing linear dependencies from the orbital basis set,
the auxiliary basis used in RI is not orthogonalized the same way. Instead, the RI linear equation system is solved
using a Cholesky decomposition (CD) of the auxiliary basis Coulomb metric. If the auxiliary basis is redundant,
the CD fails and the program usually aborts. One simple solution implemented in ORCA is to perform a pivoted
Cholesky decomposition (PCD) of the metric, terminating at a given threshold. Then, the shells contributing to the
nullspace are removed from the basis at the beginning of the calculation. This can be requested for any of the basis
sets using either the overlap or the Coulomb metric. It is most appropriate for the AuxJ/AuxJK/AuxC basis using
the Coulomb metric. The truncated basis can be examined using the `!PrintBasis` keyword. Often, functions
may be removed for some atoms of a given element, but kept for others. As long as the threshold is low enough,
i.e. only truly redundant functions are removed, this should not affect the molecular symmetry of the results.



**510** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**
### **7.6 Choice of Initial Guess and Restart of SCF Calculations**

The initial guess is an important issue in each SCF calculation. If this guess is reasonable, the convergence of the
procedure will be much better. ORCA makes some effort to provide a good initial guess and gives the user enough
flexibility to tailor the initial guess to his or her needs.

The initial guess is also controlled via the `%scf` block and the variables `Guess`, `MOInp` and `GuessMode` .



**7.6.1 AutoStart feature**

Older versions of ORCA always created a new GBW file at the beginning of the run no matter whether a file of
the same name existed or perhaps contained orbitals. Now, in the case of single-point calculations the program
automatically checks if a `.gbw` file of the same name exists. If yes, the program checks if it contains orbitals
and all other necessary information for a restart. If yes, the variable `Guess` is set to `MORead` . The existing `.gbw`
file is renamed to `BaseName.ges` and `MOInp` is set to this filename. If the `AutoStart` feature is not desired, set
`AutoStart false` in the `%scf` block or give the keyword `!NoAutoStart` in the simple input line. Note that
`AutoStart` is ignored for geometry optimizations: in this case, using previously converged orbitals contained in
a `.gbw` file (of a different name) can be achieved via `MORead` and `MOInp` .

**7.6.2 One Electron Matrix Guess**

The simplest guess is to diagonalize the one electron matrix to obtain starting orbitals. This guess is very simple
but usually also a disaster because it produces orbitals that are far too compact.

**7.6.3 Basis Set Projection**

The remaining guesses (may) need the projection of initial guess orbitals onto the actual basis set. In ORCA
there are two ways this can be done. `GuessMode FMatrix` and `GuessMode CMatrix` . The results from the
two methods are usually rather similar. In certain cases `GuessMode CMatrix` may be preferable. `GuessMode`
`FMatrix` is simpler and faster. In short the `FMatrix` projection defines an effective one electron operator:

ˆ
*𝑓* = ∑︁ *𝜀* *𝑝* *𝑎* *[†]* *𝑝* *[𝑎]* *[𝑝]* (7.44)

*𝑝*

where the sum is over all orbitals of the initial guess orbital set, *𝑎* *[†]* *𝑝* [is the creation operator for an electron in guess]
MO *𝑝*, *𝑎* *𝑝* is the corresponding annihilation operator and *𝜀* *𝑖* is the orbital energy. This effective one electron operator
is diagonalized in the actual basis and the eigenvectors are the initial guess orbitals in the target basis. For most
wavefunctions this produces a fairly reasonable guess.

`CMatrix` is more involved. It uses the theory of corresponding orbitals to fit each MO subspace (occupied, partially
occupied or spin-up and spin-down occupied) separately [34, 444]. After fitting the occupied orbitals, the virtual
starting orbitals are chosen in the orthogonal complement of the occupied orbitals. In some cases, especially when

**7.6. Choice of Initial Guess and Restart of SCF Calculations** **511**

**ORCA Manual** **,** **Release 6.0.1**

restarting ROHF calculations, this may be an advantage. Otherwise, it is not expected that `CMatrix` will be grossly
superior to `FMatrix` for most cases.

**7.6.4 PModel Guess**

The PModel guess (chosen by `Guess PModel` in the `%scf` block or simply a keyword line with `!PModel` ) is one
that is usually considerably successful. It consists of building and diagonalizing a Kohn–Sham matrix with an
electron density which consists of the superposition of spherical neutral atoms densities which are predetermined
for both relativistic and nonrelativistic methods. This guess is valid for both Hartree–Fock and DFT methods,
but not for semiempirical models. However, due to the complexity of the guess it will also take a little computer
time (usually less than one SCF iteration). The model densities are available for most atoms of the periodic table
and consequently the PModel guess is usually the method of choice (particularly for molecules containing heavy
elements) unless you have more accurate starting orbitals available.

**7.6.5 Hückel and PAtom Guesses**

The extended Hückel guess proceeds by performing a minimal basis extended Hückel calculation and projecting
the MOs from this calculation onto the actual basis set using one of the two methods described above. The minimal
basis is the STO-3G basis set. The Hückel guess may not be very good because the STO-3G basis set is so poor.
There is also accumulating evidence that the superposition of atomic densities produces a fairly good initial guess.
The critique of the atomic density method is that the actual shape of the molecule is not taken into account and it
is more difficult to reliably define singly occupied orbitals for ROHF calculations or a reasonable spin density for
UHF calculations. Therefore ORCA chooses a different way in the `PAtom` guess (which is the default guess): the
Hückel calculation is simply carried out *for all electrons* in a minimal basis of atomic SCF orbitals. These were
determined once and for all and are stored inside the program. This means that the densities around the atoms
are very close to the atomic ones, all orbitals on one center are exactly orthogonal, the initial electron distribution
already reflects the molecular shape and there are well defined singly occupied orbitals for ROHF calculations.

**7.6.6 Restarting SCF Calculations**

To restart SCF calculations, it can be very helpful and time-saving to read in the orbital information of a previous
calculation. To do this, specify:



This is done by default for single-point calculations if the `.gbw` file of the same name exists.

The program stores the current orbitals in every SCF cycle. Should a job crash, it can be restarted from the orbitals
that were present at this time by just re-running the calculation to use the present `.gbw` file. In addition, an effort has
been made to make `.gbw` files from different releases compatible with each other. If your input `.gbw` file is from an
older release, use `! rescue moread noiter` with `% moinp "name.gbw"` to produce an up-to-date `.gbw` . When
the `rescue` keyword is invoked, only the orbital coefficients are read from the `.gbw` file, and everything else from
the input file. Thus, make sure that the geometry and the basis set of the old `.gbw` file and the new input match.

Within the same ORCA version, neither the geometry nor the basis set stored in `name.gbw` need to match the
present geometry or basis set. The program merely checks if the molecules found in the current calculation and
`name.gbw` are consistent with each other and then performs one of the possible orbital projections. If the two basis
sets are identical the program by default only reorthogonalizes and renormalizes the input orbitals. However, this
can be overruled by explicitly specifying `GuessMode` in the `% scf` block as `CMatrix` or `FMatrix` .

**If redundant components were removed from the basis (see** ***Linear Dependence*** **), then** `! moread noiter`
**must not be used to read SCF orbitals from a previous calculation, as it is going to lead to wrong results. In**
**that case,** `! rescue moread` **may be used (without** `noiter` **) if doing the entire calculation in one go is not**
**possible.**

For pre 2.5-03 versions of ORCA the input `.gbw` file from the earlier calculation must have a different name than
the new calculation, because in the very beginning of a calculation, a new `.gbw` file is written. If the names are the

**512** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

same, the `.gbw` file from the earlier calculation is overwritten and all information is lost. Therefore, if you want to
restart a calculation with an input file of the same name as the previous calculation, you have to rename the `.gbw`
file first. This is good practice anyway to avoid surprises, particularly for expensive calculations.

There is an additional aspect of restarting SCF calculations — if you have chosen `SCFMode = Conventional` the
program stores a large number of integrals that might have been time consuming to calculate on disk. Normally
the program deletes these integrals at the end of the calculation. However, if you want to do a closely related
calculation that requires the same integrals (i.e. the *geometry*, the *basis set* and the *threshold* `Thresh` are the same)
it is faster to use the integrals generated previously. This is done by using `KeepInts = true` in the `% scf` block
of the first calculation and then use `ReadInts = true` in the `% scf` block of the second calculation. If the second
calculation has a different name than the first calculation you have to use `IntName = "FirstName"` to tell the
program the name of the integral files. Note that the file containing the integrals does not have an extension — it
is simply the name of the previous input file with `.inp` stripped off.



Note that, in general, restarting calculations with old integral files requires the awareness and responsibility of the
user. If properly used, this feature can save considerable amounts of time.

**7.6.7 Changing the Order of Initial Guess MOs and Breaking the Initial Guess**
**Symmetry**

Occasionally you will want to change the order of initial guess MOs — be it because the initial guess yielded an
erroneous occupation pattern or because you want to converge to a different electronic state using the orbitals of
a previous calculation. Reordering of MOs and other tasks (like breaking the symmetry of the electronic wavefunction) are conveniently handled with the `Rotate` feature in ORCA. `Rotate` is a subblock of the SCF block that
allows you to linearly transform pairs of MOs.



Here, `MO1` and `MO2` are the indices of the two MOs of interest. Recall that ORCA starts counting MOs with index
0, i.e. the MO with index 1 is the *second* MO. `Angle` is the rotation angle in degrees. A rotation angle of 90 *[∘]*

corresponds to flipping two MOs, an angle of 45 *[∘]* leads to a 50:50 mixture of two MOs, and a 180 *[∘]* rotation leads to
a change of phase. `Operator1` and `Operator2` are the orbitals sets for the rotation. For UHF calculations spin-up
orbitals belong to operator 0 and spin-down orbitals to operator 1. RHF and ROHF calculations only have a single
orbital set.

Among others, the `Rotate` feature can be used to produce broken-symmetry solutions, for example in transition
metal dimers. In order to do that, first perform a high-spin calculation, then find the pairs of MOs that are symmetric
and antisymmetric combinations of each other. Take these MOs as the initial guess and use rotations of 45 *[∘]* for each
pair to localize the starting MOs. If you are lucky and the broken symmetry solution exists, you have a good chance
of finding it this way. See section *Broken-Symmetry Wavefunctions and Exchange Couplings* for more details on
the broken-symmetry approach.

**7.6. Choice of Initial Guess and Restart of SCF Calculations** **513**

**ORCA Manual** **,** **Release 6.0.1**

**7.6.8 Automatically Breaking of the Initial Guess Symmetry**

Another simple way to break the initial guess symmetry for more trivial cases, is to simply use the keyword `!`
`GUESSMIX` . This will automatically mix 50% of the alpha LUMO into the alpha HOMO. That is equivalent to a 45
degree rotation as done above and only for these orbitals. It might be useful when one wants an open-shell singlet
and needs the alpha and beta orbitals to start differently.

The specific angle of rotation can be controlled with:



**7.6.9 Calculating only the energy of an input density**

In case you want to give the result of a previous SCF and recalculate the energy, or maybe some other property
(like the MP2 energy) using that density without changing the orbitals, you can use the flags `!CALCGUESSENERGY`

`NOITER` .

The SCF program will read the orbitals, compute the density and one Fock matrix necessary to get the energy and
move on with no orbital updates. This can be used to combine DFT orbitals with DLPNO-CCSD(T) for example.
Be careful with the results you get from this because these orbitals are not variational anymore!
### **7.7 SCF Convergence**

SCF convergence is a pressing problem in any electronic structure package because the total execution times increases linearly with the number of iterations. Thus, it remains true that the best way to enhance the performance of
an SCF program is to make it converge better. In some cases, especially for open-shell transition metal complexes,
convergence may be very difficult. ORCA makes a dedicated effort to achieve reasonable SCF convergence for
these cases without compromising efficiency.

Another issue is whether the solution found by ORCA is stable, i.e. a minimum on the surface of orbital rotations.
Especially for open-shell singlets it can be hard to achieve a broken-symmetry solution. The SCF stability analysis
(section *SCF Stability Analysis* ) may be able to help in such situations. Please also note that if `! TRAH` is used the
solution must be a true local minimum though not necessarily a global.

**7.7.1 Convergence Tolerances**

Before discussing how to converge a SCF calculation it should be defined what is meant by “converged”. ORCA
has a variety of options to control the target precision of the energy and the wavefunction that can be selected in the
`% scf` block, or with a simple input line keyword that merges the criterion label with “SCF”, e.g. `! StrongSCF`
or `! VeryTightSCF` :



Like other keys, `Convergence` is a compound key that assigns default values to a variety of other variables given
in the box below. In table *Threshold choices for compound convergence keys* we present the chosen values for

**514** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

each compound key. If the corresponding simple inputs are given ( `StrongSCF`, `VeryTightSCF`, ...etc), then in
addition the values of table *Additional threshold choices set by the simple input keys (strongSCF, ...etc.)* are also
set. The default convergence criteria are reasonable and should be sufficient for most purposes. For a cursory
look at populations weaker convergence may be sufficient, whereas other cases may require stronger than default
convergence. Note that `Convergence` does not only affect the target convergence tolerances but also the integral
accuracy as discussed in the section about direct SCF and alike. **This is very important: if the error in the**
**integrals is larger than the convergence criterion, a direct SCF calculation cannot possibly converge.**

The convergence criteria are always printed in the output. Given below is a list of the convergence criteria for
`! TightSCF`, which is often used for calculations on transition metal complexes.



Table 7.11: Threshold choices for compound convergence keys



continues on next page

**7.7. SCF Convergence** **515**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.11 – continued from p revious p a g e

continues on next page

**516** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.11 – continued from p revious p a g e

Table 7.12: Additional threshold choices set by the simple input keys (strongSCF, ...etc.)



continues on next page

**7.7. SCF Convergence** **517**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.12 – continued from p revious page

If `ConvCheckMode=0`, *all* convergence criteria have to be satisfied for the program to accept the calculation
as converged, which is a quite rigorous criterion. In this mode, the program also has mechanisms to decide
that a calculation is converged even if one convergence criterion is not fulfilled but the others are overachieved.
`ConvCheckMode=1` means that one criterion is enough. This is quite dangerous, so ensure that none of the criteria
are too weak, otherwise the result will be unreliable. The default `ConvCheckMode=2` is a check of medium rigor
— the program checks for the change in total energy and for the change in the one-electron energy. If the ratio
of total energy and one-electron energy is constant, the self-consistent field does not fluctuate anymore and the
calculation can be considered converged. If you have small eigenvalues of the overlap matrix, the density may not
be converged to the number of significant figures requested by `TolMaxP` and `TolRMSP` .

`ConvForced` is a flag to prevent time consuming calculations on non-converged wave functions. It will default to
`ConvForced=1` for Post-HF methods, Excited States runs and Broken Symmetry calculations. You can overwrite
this default behavior by setting `ConvForced=0` .

Irrespective of the `ConvForced` value that has been chosen, properties or numerical calculations (NumGrad, NumFreq) will not be performed on non-converged wavefunctions!

**7.7.2 Dynamic and Static Damping**

Damping is the oldest and simplest convergence aid. It was already invented by Douglas Hartree when he did his
famous atomic calculations. Damping consists of mixing the old density with the new density as:

*𝑃* new, damped = (1 *−* *𝛼* ) *𝑃* new + *𝛼𝑃* old (7.45)

where *𝛼* is the damping factor, which must have a value of less than 1. Thus the permissible range (not checked
by the program) is 0 ...0.999999. For *𝛼* values larger than 1, the calculation cannot proceed since no new density
is admixed. Damping is important in the early stages of a calculation where *𝑃* old and *𝑃* new are very different from
each other and the energy is strongly fluctuating. Many schemes have been suggested that vary the damping factor
dynamically to give strong damping in the beginning and no damping in the end of an SCF. The scheme implemented in ORCA is that by Hehenberger and Zerner [911] and is invoked with `CNVZerner=true` . Static damping
is invoked with `CNVDamp=true` . These convergers are mutually exclusive. They can be used in the beginning of a
calculation when it is not within the convergence radius of DIIS or SOSCF. Damping works reasonably well, but
most other convergers in ORCA are more powerful.

**518** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

If damping used in conjunction with DIIS or SOSCF, the value of `DampErr` is important: once the DIIS error falls
below `DampErr`, the damping is turned off. In case SOSCF is used, `DampErr` refers to the orbital gradient value at
which the damping is turned off. The default value is 0.1 Eh. In difficult cases, however, it is a good idea to choose
`DampErr` much smaller, e.g. 0.001. This is — to some extent — chosen automatically together with the keyword
`! SlowConv` .



**7.7.3 Level Shifting**

Level shifting is a frequently used technique. The basic idea is to shift the energies of the virtual orbitals such that after diagonalization the occupied and virtual orbitals mix less strongly and the calculation converges more smoothly
towards the desired state. Also, level shifting should prevent flipping of electronic states in near-degenerate cases.
In a special context it has been shown by Saunders and Hillier [335, 751] to be equivalent to damping.

Similar to `DampErr` described in the previous section, `ShiftErr` refers to the DIIS error at which the level shifting
is turned off.



**7.7.4 Direct Inversion in Iterative Subspace (DIIS)**

The direct inversion in iterative subspace (DIIS) is a technique that was invented by Pulay [702, 703]. It has become
the *de facto* standard in most modern electronic structure programs, because DIIS is robust, efficient and easy to
implement. Basically DIIS uses a criterion to judge how far a given trial density is from self-consistency. The
commutator of the Fock and density matrices [ **F**, **P** ] is a convenient measure for this error. With this information,
an extrapolated Fock matrix from the present and previous Fock matrices is constructed, which should be much
closer to self-consistency. In practice this is usually true, and better than linear convergence has been observed
with DIIS. In some rare (open-shell) cases however, DIIS convergence is slow or absent after some initial progress.
As self-consistency is approached, the set of linear equations to be solved for DIIS approaches linear dependency
and it is useful to bias DIIS in favor of the SCF cycle that had the lowest energy using the factor `DIISBfac` . This is
achieved by multiplying all diagonal elements of the DIIS matrix with this factor unless it is the Fock matrix/density
which leads to the lowest energy. The default value for `DIISBfac` is 1.05.

The value of `DIISMaxEq` is the maximum number of old Fock matrices to remember. Values of 5-7 have been recommended, while other users store 10-15 Fock matrices. Should the standard DIIS not achieve convergence, some
experimentation with this parameter can be worthwhile. In cases where DIIS causes problems in the beginning of
the SCF, it may have to be invoked at a later stage. The start of the DIIS procedure is controlled by `DIISStart` .
It has a default value of 0.2 Eh, which usually starts DIIS after 0-3 cycles. A different way of controlling the DIIS
start is adjusting the value `DIISMaxIt`, which sets the maximum number of cycles after which DIIS will be started
irrespective of the error value.

**7.7. SCF Convergence** **519**

**ORCA Manual** **,** **Release 6.0.1**



Note that for troublesome or lacking SCF convergence the `TRAH` algorithm should be used (see Sec. *Trust-Region*
*Augmented Hessian (TRAH) SCF* ). If not turned off explicitly, `TRAH` is switched on automatically whenever convergence problems are present by means of the `AutoTRAH` feature (see Sec. *Trust-Region Augmented Hessian (TRAH)*
*SCF* ).

**7.7.5 An alternative DIIS algorithm: KDIIS**

An alternative algorithm that makes use of the DIIS concept is called KDIIS (Kolmar’s DIIS[452, 453]) in ORCA.
The KDIIS algorithm is designed to bring the orbital gradient of any energy expression to zero using a combination
of DIIS extrapolation and first order perturbation theory. Thus, the method is diagonalization-free. In our hands
it is superior to the standard DIIS algorithm in many cases, but not always. The algorithm is invoked with the
keyword `! KDIIS` and is available for RHF, UHF and CASSCF.

**7.7.6 Approximate Second Order SCF (SOSCF)**

SOSCF is an approximately quadratically convergent variant of the SCF procedure [264, 608]. The theory is
relatively involved and will not be described here. In short – SOSCF computes an initial guess to the inverse orbital
Hessian and then uses the BFGS formula in a recursive way to update orbital rotation angles. As information from
a few iterations accumulates, the guess to the inverse orbital Hessian becomes better and better and the calculation
reaches a regime where it converges superlinearly. As implemented, the procedure converges as well or slightly
better than DIIS and takes a somewhat less time. However, it is also *a lot* less robust, so that DIIS is the method of
choice for many problems (see also the description of the full second-order trust-region augmented Hessian ( `TRAH` )
procedure in the next section). On the other hand, SOSCF is useful when DIIS gets stuck at some error around *∼*
0.001 or 0.0001. Such cases were the primary motive for the implementation of SOSCF into ORCA.

The drawback of SOSCF is the following: in the beginning of the SCF, the orbital gradient (the derivative of the
total energy with respect to rotations that describe the mixing of occupied and virtual MOs) is large, so that one is far
from the quadratic regime. In such cases, the procedure is not successful and may even wildly diverge. Therefore it
is recommended to only invoke the SOSCF procedure in the very end of the SCF where DIIS may lead to “trailing”
convergence. SOSCF is controlled by the variables `SOSCFStart` and `SOSCFMaxIt` . `SOSCFStart` is a threshold
for the orbital gradient. When the orbital gradient, or equivalently the DIIS Error, fall below `SOSCFStart`, the
SOSCF procedure is initiated. `SOSCFMaxIt` is the latest iteration to start the SOSCF even if the orbital gradient is
still above `SOSCFStart` .



For many calculations on transition metal complexes, it is a good idea to be conservative in the startup criterion
for SOSCF, it may diverge otherwise. A choice of 0.01 or lower is recommended.

**520** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.7.7 Trust-Region Augmented Hessian (TRAH) SCF**

The trust-region augmented Hessian ( `! TRAH` ) approach[64, 349, 381, 735] should be used if the standard SCF
solver[264, 608, 703, 704] DIIS+SOSCF fails or is expected to fail. TRAH-SCF should converge for any system.
Convergence to the electronic ground state is also guaranteed because information of the electronic Hessian is
exploited.

The TRAH approach constructs a quadratic model of the SCF energy as a function of the orbital rotation parameters

**x**,

*𝐸* ( **x** ) = *𝐸* 0 + **g** *[𝑇]* **x** + [1]

2 **[x]** *[𝑇]* **[Hx]**

and minimizes *𝐸* ( **x** ) w.r.t **x** with the constraint that orbital rotations should lie within a trust region *ℎ*

*||* **x** *|| ≤* *ℎ* .

Such a constraint minimization leads to the level-shifted Newton equations

( **H** *−* *𝜇* **I** ) **x** = *−* **g**,


which have the two unknowns ( *𝜇,* **x** ). Instead of solving the level-shifted Newtons equations, the eigenvalues and
eigenvectors of the scaled augmented Hessian are solved,

0 *𝛼* **g** *[𝑇]* 1˜ = *𝜇* 1˜,
(︂ *𝛼* **g** **H** )︂(︂ **x** )︂ (︂ **x** )︂

The TRAH eigenvalue equations are solved iteratively with the Davidson algorithm until the residual norm for ˜ **x**
is below a scaled (by `TolFacMicro` ) norm of the electronic gradient. The scaling parameter *𝛼* is adjusted in every
Davidson iteration (micro iteration) such that

*||* **x** *|| ≈||* [1]

*𝛼* **[x]** [˜] *[|| ≤]* *[ℎ]*

by using a bisection search within [ *𝛼* 0 *, 𝛼* 1 ] and ensures that the orbital rotation (update) vectors are within the
trust region. Once **x** is found, the orbitals are updated and a new macro iteration starts with the SCF energy and
electronic gradient computation **g** . TRAH terminates if the gradient norm *||* **g** *||* is below a user-given threshold
`TolG` .

The most time consuming steps of the algorithm are the computation of the electronic gradient **g** and the linear
transformations of the electronic Hessian **H** with some trial vectors during the Davidson micro iterations. Both
intermediates can be computed efficiently in the atomic-orbital basis using AO-Fock matrices as done for TD-DFT
or CP-SCF. Hence, TRAH-SCF can be also used for very large molecules. However, in contrast to a standard
DIIS approach, difference density matrices cannot be used which makes the shell pair screening based on Schwarz
estimates and density matrices less effective for TRAH. To accelerate the various sigma vector computations, we
choose for those steps in the micro iterations as for CP-SCF smaller grids for evaluation of XC functionals and
semi-numerical exchange COSX, which is controlled via


,
)︂


*𝛼* **g** **H**


1

**x** ˜
)︂(︂


1
= *𝜇* ˜
**x**
)︂ (︂



TRAH-SCF is currently implemented for restricted closed-shell ( `RHF` and `RKS` ) and unrestricted open-shell determinants ( `UHF` and `UKS` ) and can be accelerated with `RIJ`, `RIJONX`, `RIJK`, or `RIJCOSX` . Solvation effects can also be
accounted for with the `C-PCM` model. The implementation is also parallelized with MPI. A restricted open-shell
implementation (ROHF and ROKS) is not yet available.

The default preconditioner ( `diag` ) for the Davidson algorithm uses approximate matrix element of the diagonal Hessian. We have also added an improved preconditioner ( `full` ) that uses the exact orbital Hessian for a
subset of the most important occupied-virtual MO pairs (with smallest orbital-energy difference). This number
`PreconMaxRed` (default 250) cannot be too large.

**7.7. SCF Convergence** **521**

**ORCA Manual** **,** **Release 6.0.1**



Otherwise, additional computational bottlenecks would be introduced when transforming the two-electron integrals
in the MO basis or when diagonalizing this reduced-space Hessian. Note that for the integral transformation the
RI approximation is used and an auxiliary `/C` basis must be provided. Please also note that, so far, we have only
implemented an XC Hessian contribution for LDA functionals. From our experience, the “full” precondition is
very advantageous for RHF and UHF calculations of small molecules but does not provide any advantage for other
(TRAH-)SCF calculations.

In cases for which the conventional SCF procedures (DIIS/KDIIS/SOSCF) struggle, we invoke TRAH-SCF automatically ( `AutoTRAH` ). For this purpose, we perform a linear interpolation of the norm of the electronic gradient on
the log 10 scale after a minimum number of SCF iterations `AutoTRAHIter` (default 20). The number of iterations
for interpolations is controlled by `AutoTRAHNInter` (default 10). If the slope *𝑠* of the interpolated gradient norm
10 *[−][𝑠]* becomes smaller than `AutoTRAHTol` (default 1.125), conventional SCF is shut down and TRAH-SCF start
from the current set of MOs. Those parameters were optimized for a benchmark set with the purpose to minimize
the calculation times even for SCF calculations that are hard to converge. There is not really a need to modify the
`AutoTRAH` parameters except for turning TRAH off entirely.
```
! NoTRAH

```
The accuracy of the SCF calculation is controlled by via the simple keywords `NORMALSCF`, `LOOSESCF`, etc. The
accuracy threshold that checks the gradient norm for TRAH-SCF calculations is is read from the SCF input block.
Note that checking the Frobensius norm of *||* **g** *||* is the **only convergence check** in TRAH.



Below a complete list of input parameters is given for `TRAH` . Please note that all parameters influence the convergence and should not be changed carelessly!

(continues on next page)

**522** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

OBS.: The maximum number of macro iterations is defined by MAXITER under the %SCF block.

**7.7.8 Finite Temperature HF/KS-DFT**

A finite temperature can be used to apply a Fermi-like occupation number smearing over the orbitals of the system,
which may sometimes help to get convergence of the SCF equations in near hopeless cases. Through the smearing,
the electrons are distributed according to Fermi statistics among the available orbitals. The “chemical potential” is
found through the condition that the total number of electrons remains correct. Gradients can be computed in the
presence of occupation number smearing.



**Note:**

  - Finite temperature SCF (fractional occupation numbers or FOD analysis, see sections *Fractional Occupation*
*Numbers* and *Fractional Occupation Number Weighted Electron Density (FOD)*, respectively) *cannot* be
used together with the `CNVRico` or `SOSCF` methods.

**Fractional Occupation Numbers**

Only a very basic implementation of fractional occupation numbers is presently provided. It is meant to deal with
orbitally degenerate states in the UHF/UKS method. Mainly it was implemented to avoid symmetry breaking
in DFT calculations on orbitally degenerate molecules and atoms. The program checks the orbital energies of
the initial guess orbitals, finds degenerate sets and averages the occupation numbers among them. Currently the
criterion for degenerate orbitals is 10 *[−]* [3] Eh. The fractional occupation number option is invoked by:



Clearly, the power of fractional occupation numbers goes far beyond what is presently implemented in the program
and future releases will likely make more use of them. The program prints a warning whenever it uses fractional
occupation numbers. The fractionally occupied orbitals should be checked to ensure they are actually the intended

ones.

**Note:**

  - Using `GuessMode = CMatrix` will cause problems because there are no orbital energies for the initial guess
orbitals. The program will then average over *all* orbitals — which makes no sense at all.

**7.7. SCF Convergence** **523**

**ORCA Manual** **,** **Release 6.0.1**

**Fractional Occupation Number Weighted Electron Density (FOD)**

Many approximate QC methods do not yield reliable results for systems with significant static electron correlation
(SEC) but it is often difficult to predict if the system in question suffers from SEC or not. Existing scalar SEC
diagnostics (e.g., the *𝑇* 1 diagnostic) do not provide any information where the SEC is located in the molecule.
Furthermore, often quite expensive calculations have to be performed first (e.g., CCSD) in order to judge the reliability of the results based on a single number. Molecular systems with strong SEC (e.g. covalent bond-breaking,
biradicals, open-shell transition metal complexes) are usually characterized by small energy gaps between frontier orbitals, and hence, the appearance of many equally important determinants in their electronic wavefunction.
This finding is used in the FOD analysis[327] which is based on finite temperature KS-DFT where the fractional
occupation numbers are determined from the Fermi distribution (“Fermi smearing”)

1
*𝑓* *𝑖* =
*𝑒* [(] *[𝜀]* *[𝑖]* *[−][𝐸]* *[𝐹]* [)] *[/𝑘𝑇]* *[𝑒𝑙]* + 1

The central quantity of the FOD analysis is the fractional occupation number weighted electron density ( *𝜌* *[𝐹𝑂𝐷]* ), a
real-space function of the position vector *𝑟* :


*𝜌* *[𝐹𝑂𝐷]* ( *𝑟* ) =


*𝑁*
∑︁( *𝛿* 1 *−* *𝛿* 2 *𝑓* *𝑖* ) *|𝜙* *𝑖* ( *𝑟* ) *|* [2]

*𝑖*


( *𝛿* 1 and *𝛿* 2 are unity if the level is lower than *𝐸* *𝐹* while they are 0 and *−* 1, respectively, for levels higher than
*𝐸* *𝐹* ). The *𝑓* *𝑖* represent the fractional occupation numbers (0 *≤* *𝑓* *𝑖* *≤* 1; sum over all electronic single-particle levels
obtained by solving self-consistently the KS-SCF equations minimizing the *free* -electronic energy).

*𝜌* *[𝐹𝑂𝐷]* ( *𝑟* ) can be plotted using a pre-defined contour surface value (see *FOD plots* ). FOD plots only show the
contribution of the ‘hot’ (strongly correlated) electrons and can thus be used to choose a suitable QC method for
the system in question based on some rules of thumb (see *FOD plots* ). Mulliken reduced orbital charges based on
*𝜌* *[𝐹𝑂𝐷]* ( *𝑟* ) (see *Mulliken Population Analysis* ) offer a fast alternative to get the information of the FOD plot.

The integration of *𝜌* *[𝐹𝑂𝐷]* over all space yields as additional information a single size-extensive number termed
*𝑁* *𝐹𝑂𝐷* which correlates well with other scalar SEC diagnostics and can be used to globally quantify SEC effects
in the molecule.

*𝜌* *[𝐹𝑂𝐷]* (and *𝑁* *𝐹𝑂𝐷* ) strongly depend on the orbital energy gap which itself depends almost linearly on the amount
of the non-local Fock exchange admixture *𝑎* *𝑥* . The following (empirical) function of the optimal electronic temperature *𝑇* *𝑒𝑙* on *𝑎* *𝑥*

*𝑇* *𝑒𝑙* = 20000 K *× 𝑎* *𝑥* + 5000 K

is used to ensure that similar results of the FOD analysis are obtained with various functionals. For example, the
`SmearTemp` has to be 5000 K for TPSS ( *𝑎* *𝑥* = 0), 9000 K for B3LYP ( *𝑎* *𝑥* = 20%), 10000 K for PBE0 ( *𝑎* *𝑥* = 25%), and
15800 K for M06-2x ( *𝑎* *𝑥* = 54%). The result of the FOD analysis is not strongly dependent on the employed basis
set (see supplementary information of the original publication[327]). TPSS/def2-TZVP/TightSCF was chosen as
the default since it is fast and robust. The FOD analysis is a very efficient and practicable tool to get information
about the amount and localization of SEC in the system of question. It is called by a simple keyword:

**524** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


The respective output reads:



The default functional and basis set are TPSS and def2-TZVP respectively. If the FOD analysis should be done
employing a different functional, one has to explicitly specify the functional and basis set in the simple keyword
line and adjust the `SmearTemp` accordingly.




The FOD analysis may also be useful for finding a suitable active space for e.g. CASSCF calculations.

**Note:**

  - The FOD analysis will be always printed (including Mulliken reduced orbital charges based on *𝜌* *[𝐹𝑂𝐷]* ) if
`SmearTemp` *>* 0 K *𝜌* *[𝐹𝑂𝐷]* is stored on disk in the file `Basename.scfp_fod` which is included in the general
`Basename.densities` container).

  - Since the *𝑆* [ˆ] [2] expectation value is not defined for fractional occupation numbers, its printout is omitted.

**7.7. SCF Convergence** **525**

**ORCA Manual** **,** **Release 6.0.1**
### **7.8 Choice of Wavefunction and Integral Handling**

**7.8.1 Choice of Wavefunction Type**

The basic variable that controls the type of wavefunction to be computed is the variable `HFTyp` in the `%scf` block. If
nothing is specified for `HFTyp`, the program will check the multiplicity given in the input: for closed-shell molecules
with multiplicity 1, RHF/RKS is assumed; for open shell molecules with multiplicity larger than 1, UHF/UKS is
invoked. `RHF` will lead to a spin restricted closed-shell type computation [840]. For DFT calculations, `RKS`, `UKS`
and `ROKS` can be used as synonyms for `RHF`, `UHF` and `ROHF` . The restricted open-shell DFT method ( `ROKS` ) is only
operative for high-spin states that have *𝑛* unpaired electrons and *𝑆* = *𝑛/* 2. `UKS` wavefunctions will not be spinpurified.



In certain cases you may want to run open-shell molecules with RHF/RKS to get a “half-electron” type wavefunction [205]. The total energy is not corrected! Sometimes these half-electron computations lead to acceptable
convergence, and the resulting orbitals may be used as input for ROHF, UHF or MRCI calculations. Especially
for transition metal complexes the orbitals are quite different from ROHF or UHF orbitals, so that it is not recommended to over-interpret the wavefunctions from such calculations. The calculation is set up in the following

way:



**7.8.2 ROHF Options**

For ROHF calculations[102, 112, 125, 141, 243, 452, 453, 575, 598] the program will try to figure out what type
of open-shell situation is present on the basis of the initial guess orbitals and their energies. Most “simple” cases
are well recognized, but sometimes a little help from the user is needed.

The simplest ROHF case is the `HIGHSPIN` case, where all unpaired electrons in the open-shell are coupled parallel
to each other, resulting in the highest multiplicity possible. The user can request this case as follow:



The ROHF code also has a very powerful feature that goes back to insights of Mike Zerner [818, 907]. It can
average over either *all* states of a given configuration ( `CAHF` ) or *all states of a given spin* for a given configuration
( `SAHF` ). Especially the `SAHF` feature gives you easy access to most degenerate high symmetry situations and the
orbitals resulting from such calculations will be very convenient as input for CI calculations.



**526** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

The hypothetical example below could represent an excited state of an octahedral d [3] transition metal complex. In
this case there are five open-shell orbitals. The first three open-shell orbitals contain two electrons and the last two
one electron. The input for a SAHF calculation is identical, just replace CAHF with SAHF.



Another feature of the ROHF code is the ability to converge the SCF to a given Configuration State Function
( `CSF-ROHF` ) [512]. In this way one can approach results from MCSCF calculations. This can be requested in two

ways.

The user can give a specific coupling situation.



Or the user can give how many orbitals per shell. Where each open-shell will couple with antiparallel spin with
the previous one.



As an example, one can think of a Fe(III) dimer, where each center is locally high spin, but they couple antiferromagnetically to each other. In order to get the ROHF solution for this system, first one need a set of guess orbitals.
The guess orbitals can be obtained either from the QROs of an UHF calculation, or a high spin ROHF calculation,
or even a SAHF or CAHF. Independently of the method used, the orbitals need to be localized and ordered in a
way that the 5 3d orbitals of each iron are grouped together in sequence. From this, one can run a CSF-ROHF
calculation for the antiferromagnetic CSF as shown bellow:



The CSF-ROHF procedure can recognize doubly occupied and virtual orbitals in the definition of the CSF when
the `USER_CSF` case is invoked. When detected, these orbitals will be rotated out of the open-shells defined in the
ROHF method and the calculation will run normally:



(continues on next page)

**7.8. Choice of Wavefunction and Integral Handling** **527**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

The user can also directly input the ROHF variables by means of the `ROHFOPT Case User` keyword. For example
for the high spin case with three electrons in three orbitals gives two operators with vector coupling coefficients
*𝑎* = 1 and *𝑏* = 2 (Zerner convention).



One awkward feature of the ROHF theory is that the Fock operator is somewhat arbitrarily defined. Different
choices lead to the same wavefunction, but have different convergence properties that may vary from system to
system. ORCA thus lets the user choose the desired variant. Playing around with these choices may turn a divergent
or slowly converging ROHF calculation into a successful calculation!

The `ROHF_Restrict` feature is another feature that may be useful. If you suspect that the ROHF calculation does
not converge because an open-shell and a closed-shell orbital are flipping back and forth, you can try to avoid this
behavior by choosing `ROHF_Restrict true` . Of course there is no guarantee that it will work, and no guarantee
that the system stays in the desired state. However, it decreases the chances of large, uncontrolled steps.



**528** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.8.3 UHF Natural Orbitals**

The program can produce the UHF natural orbitals (UNOs). With these, the open-shell wavefunction can be
pictured conveniently. The syntax is simple:



There are various printing options for UNOs described in the output section *Population Analyses and Control of*
*Output* . The UNOs can also be plotted as described in the plots section *Orbital and Density Plots* . In general the
program stores a file `BaseName.uno`, where `BaseName` is by default the name of you input file with `.inp` stripped
off. Accordingly, the gbw file is named `BaseName.gbw` . The `.uno` file is a normal gbw file that contains the
geometry, basis set and the UNO orbitals. It could be used, for example, to start a ROHF calculation.

**7.8.4 Integral Handling (Conventional and Direct)**

As the number of nonzero integrals grows very rapidly and reaches easily hundreds of millions even with medium
sized basis sets in medium sized molecules, storage of all integrals is not generally feasible. This desperate situation
prevented SCF calculations on larger molecules for quite some time, so that Almlöf [19, 20, 21] made the insightful
suggestion to repeat the integral calculation, which was already the dominant step, in *every SCF cycle* to solve the
storage problem. Naively, one would think that this raises the effort for the calculation to *𝑛* iter *𝑡* integrals (where *𝑛* iter is
the number of iterations and *𝑡* integrals is the time needed to generate the nonzero integrals). However, this is not the
case because only the change in the Fock matrix is required from one iteration to the next, but not the Fock matrix
itself. As the calculations starts to converge, more and more integrals can be skipped. The integral calculation
time will still dominate the calculation quite strongly, so that ways to reduce this burden are clearly called for. As
integrals are calculated in *batches* [1] the cost of evaluating the given batch of shells *𝑝, 𝑞, 𝑟, 𝑠* may be estimated as:

cost *≈* *𝑛* *𝑝* *𝑛* *𝑞* *𝑛* *𝑟* *𝑛* *𝑠* (2 *𝑙* *𝑝* + 1) (2 *𝑙* *𝑞* + 1) (2 *𝑙* *𝑟* + 1) (2 *𝑙* *𝑠* + 1) (7.46)

Here, *𝑛* *𝑝* is the number of primitives involved in shell *𝑝*, and *𝑙* *𝑝* is the angular momentum for this shell. *Large*
integrals are also good candidates for storage, because small changes in the density that multiply large integrals are
likely to give a nonzero contribution to the changes in the Fock matrix.

ORCA thus features two possibilities for integral handling, which are controlled by the variable `SCFMode` . In the
mode `Conventional`, all integrals above a given threshold are stored on disk (in a compressed format that saves
much disk space). In the mode `Direct`, all two-electron integrals are recomputed in each iteration.

Two further variables are of importance: In the `Conventional` mode the program may write enormous amounts
of data to disk. To ensure this stays within bounds, the program first performs a so-called “statistics run” that gives
a pessimistic estimate of how large the integral files will be. Oftentimes, the program will overestimate the amount
of disk space required by a factor of two or more. The maximum amount of disk space that is allowed for the
integral files is given by `MaxDisk` (in Megabytes).

On the other hand, if the integral files in `Conventional` run are small enough to fit into the central memory, it is
faster to do this since it avoids I/O bottlenecks. The maximum amount of memory allocated for integrals in this
way is specified by `MaxIntMem` (in Megabytes). If the integral files are larger than `MaxIntMem`, no integrals will
be read into memory.



(continues on next page)

1 A *batch* is a set of integrals that arises from all components of the shells involved in the integral. For example a *⟨𝑝𝑝|𝑝𝑝⟩* batch gives rise
to 3 *×* 3 *×* 3 *×* 3 = 81 integrals due to all possible combinations of *𝑝* *𝑥*, *𝑝* *𝑦* and *𝑝* *𝑧* functions in the four shells. Computations based on batches
lead to great computational advantages because the 81 integrals involved in the *⟨𝑝𝑝|𝑝𝑝⟩* batch share many common intermediate quantities.

**7.8. Choice of Wavefunction and Integral Handling** **529**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

The flag `UseCheapInts` has the following meaning: In a `Direct` SCF calculation, the oscillations in the total
energy and density are initially quite large. High accuracy in the integrals is therefore not crucial. If `UseCheapInts`
is switched on, the program loosens the threshold for the integrals and thus saves a lot of computational time. After
having obtained a reasonable initial convergence, the thresholds are tightened to the target accuracy. One pitfall with
this method is that the number of cycles required to reach convergence may be larger relative to a calculation with
full integral accuracy throughout. [2] When restarting calculations that are close to convergence, it is recommended
to switch `UseCheapInts` off. `UseCheapInts` has no meaning in a conventional SCF.

The value of `DirectResetFreq` sets the number of incremental Fock matrix builds after which the program should
perform a full Fock matrix build in a `Direct` SCF calculation. To prevent numerical instabilities that arise from
accumulated errors in the recursively build Fock matrix, the value should not be too large, since this will adversely
affect the SCF convergence. If the value is too small, the program will update more frequently, but the calculation
will take considerably longer, since a full Fock matrix build is more expensive than a recursive one.

The thresholds `TCut` and `Thresh` also deserve a closer explanation. `Thresh` is a threshold that determines when to
neglect two-electron integrals. If a given integral is smaller than `Thresh` Eh, it will not be stored or used in Fock
matrix construction. Additionally, contributions to the Fock matrix that are smaller than `Thresh` Eh will not be
calculated in a `Direct` SCF.

Clearly, it would be wasteful to calculate an integral, then find out it is good for nothing and thus discard it. A
useful feature would be an efficient way to estimate the size of the integral *before it is even calculated*, or even have
an estimate that is a *rigorous upper bound* on the value of the integral. Häser and Ahlrichs [346] were the first to
recognize that such an upper bound is actually rather easy to calculate. They showed that:


*|⟨𝑖𝑗* *|𝑘𝑙* *⟩|* ⩽ √︀


*⟨𝑖𝑗* *|𝑖𝑗* *⟩* √︀


*⟨𝑘𝑙* *|𝑘𝑙* *⟩* (7.47)


where:

*⟨𝑖𝑗* *|𝑘𝑙* *⟩* = *𝜑* *𝑖* ( *⃗𝑟* 1 ) *𝜑* *𝑗* ( *⃗𝑟* 1 ) *𝑟* 12 *[−]* [1] *[𝜑]* *[𝑘]* [(] *[⃗𝑟]* [2] [)] *[ 𝜑]* *[𝑙]* [(] *[⃗𝑟]* [2] [)] *[ 𝑑⃗𝑟]* [1] *[𝑑⃗𝑟]* [2] (7.48)
∫︁∫︁

Thus, in order to compute an upper bound for the integral only the right hand side of this equation must be known.
This involves only two index quantities, namely the matrix of two center exchange integrals *⟨𝑖𝑗* *|𝑖𝑗* *⟩* . These integrals
are easy and quick to calculate and they are all ⩾0 so that there is no trouble with the square root. Thus, one has
a powerful device to avoid computation of small integrals. In an actual calculation, the Schwartz prescreening is
not used on the level of individual basis functions but on the level of shell batches because integrals are always
calculated in batches. To realize this, the largest exchange integral of a given exchange integral block is looked for
and its square root is stored in the so called *pre-screening* matrix **K** (that is stored on disk in ORCA). In a `Direct`
SCF this matrix is not recalculated in every cycle, but simply read from disk whenever it is needed. The matrix of
exchange integrals on the level of individual basis function is used in `Conventional` calculations to estimate the
disk requirements (the “statistics” run).

Once it has been determined that a given integral batch survives it may be calculated as:


*⟨𝑖𝑗* *|𝑘𝑙* *⟩* = ∑︁


*𝑑* *𝑝𝑖* ∑︁

*𝑝* *𝑞*


*𝑑* *𝑞𝑗* ∑︁

*𝑞* *𝑟*


*𝑑* *𝑘𝑟* ∑︁

*𝑟* *𝑠*


*𝑑* *𝑠𝑙* *⟨𝑖* *𝑝* *𝑗* *𝑞* *|𝑘* *𝑟* *𝑙* *𝑠* *⟩* (7.49)

*𝑠*


where the sums *𝑝, 𝑞, 𝑟, 𝑠* run over the primitive Gaussians in each basis function *𝑖, 𝑗, 𝑘, 𝑙* and the *𝑑* ’s are the contraction coefficients. There are more powerful algorithms than this one and they are also used in ORCA. However,
if many terms in the sum can be skipped and the total angular momentum is low, it is still worthwhile to compute
contracted integrals in this straightforward way. In equation (7.49), each primitive integral batch *⟨𝑖* *𝑝* *𝑗* *𝑞* *|𝑘* *𝑟* *𝑙* *𝑠* *⟩* contains a prefactor *𝐼* *𝐺𝑎𝑢𝑠𝑠𝑖𝑎𝑛𝑠* that depends on the position of the four Gaussians and their orbital exponents. Since

2 This might be an undesirable feature of the current implementation.

**530** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

a contracted Gaussian usually has orbital exponents over a rather wide range, it is clear that many of these primitive integral batches will contribute negligibly to the final integral values. In order to reduce the overhead, the
parameter `TCut` is introduced. If the common prefactor *𝐼* *𝑝𝑞𝑟𝑠* is smaller than `TCut`, the primitive integral batch is
skipped. However, *𝐼* *𝑝𝑞𝑟𝑠* is *not* a rigorous upper bound to the true value of the primitive integral. Thus, one has
to be more conservative with `TCut` than with `Thresh` . In practice it appears that choosing `TCut=0.01*Thresh`
provides sufficient accuracy, but the user is encouraged to determine the influence of `TCut` if it is suspected that
the accuracy reached in the integrals is not sufficient.

**Hint:**

  - If the direct SCF calculation is close to convergence but fails to finally converge, this maybe related to a numerical problem with the Fock matrix update procedure – the accumulated numerical noise from the update
procedure prevents sharp convergence. In this case, set `Thresh` and `TCut` lower and/or let the calculation
more frequently reset the Fock matrix ( `DirectResetFreq` ).

**Note:**

  - For a `Direct` calculation, there is no way to have `Thresh` larger than `TolE` . If the errors in the Fock matrix
are larger than the requested convergence of the energy, the change in energy can never reach `TolE` . The
program checks for that.

  - The actual disk space used for *all* temporary files may easily be larger than `MaxDisk` . `MaxDisk` only pertains
to the two-electron integral files. Other disk requirements are not currently checked by the program and
appear to be uncritical.
### **7.9 DeltaSCF: Converging to Arbitrary Single-Reference Wave-** **functions**

The regular SCF procedure is supposed to bring the wavefunction to a stationary point, and most times that means
a minimum. However, sometimes one might *want* to converge to some kind of “excited state”, that is, a higher
order saddle-point on the SCF surface.

Using the conventional SCF technology, it is usually not enough to start from an excited-state guess, but one needs
to make some extra effort to keep the convergence towards that state. The stack of such methods to keep convergence
to a given non-trivial state is called in the literature the `DeltaSCF` approach.

The general idea was first introduced by the group of Peter Gill [299] as the Maximum Overlap Method (MOM),
and in ORCA we also feature the more recent PMOM from the group of Hrant Hratchian [184]. It has also been
referred to as as “orbital optimized DFT for electronic excited states” [351].

To be very clear, let’s show one example in a picture:

**7.9. DeltaSCF: Converging to Arbitrary Single-Reference Wavefunctions** **531**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.2: A simple scheme of a HOMO-LUMO state using DeltaSCF

Using ORCA’s `DeltaSCF`, we can **choose** to converge the SCF to a HOMO/LUMO excited state. Now that excited
state was obtained by fully relaxing the orbitals and can include any contributions such as the VV10 correlation or
CPCM for solvation. We will also allow for gradients, geometry optimization, Hessian, EPR, NMR, or anything
else that ORCA can do for a “normal” ground state calculation.

**Important:** The states obtained here are still represented by single-determinant wavefunctions, and in some cases
might not even have physically correct meaning. Be careful and conscious of what you are doing! These are
relatively reasonable wavefunctions for cases when:

1. the excited state can be simply described by a particle-hole interaction. That is for example **NOT** the case
of a benzene molecule or most pi-pi* excited states.

2. the occupied and virtual orbitals are orthogonal or separated in space such that the relevant exchange integral
is zero. Eg. some n-pi* states, orthogonal or long-distance charge separated states, etc;

3. for open-shell and doubly-excited states which can be represented by a single-determinant wavefunction.

**7.9.1 First Example: HOMO-LUMO Excited State of Formaldehyde**

Let’s begin by trying to converge and optimize to the first excited state of formaldehyde, starting from its regular
planar structure:



Besides the regular keywords like method, basis set, `OPT` and `FREQ`, one needs to specify `DELTASCF` on the main
input, and in this case, `UHF`, since the alpha and beta orbitals will be different (for doubly-excited states `RHF` is
sufficient).

It is also necessary to add the `ALPHACONF` or `BETACONF` under the `%SCF` block. That is a minimal representation of
the configuration you want to converge to. In this case, `0,1` means a HOMO/LUMO transition, where the HOMO
has occupation zero and LUMO occupation one. For a HOMO-1/LUMO transition, it would be `ALPHACONF 0,1,`
`1` . For a HOMO/LUMO+1 it would be `ALPHACONF 0,0,1` and so on. Just picture how the frontier orbitals should

**532** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

look like. Any orbital below the first zero is assumed to be occupied and any orbital above the last occupied is
assumed to be empty.

After the regular startup, the `DeltaSCF` -specific print shows:

Here you can follow the initial configuration and some other important things:

1. `Hessian update` refers to which method will be used for the SOSCF Hessian update. ORCA’s default is
`L-BFGS`, which forces the electronic Hessian to be positive definite and will always push the system down to
a minimum. As we want to go to a saddle point the `L-SR1` is set by default for `DeltaSCF` . More details on
Hessian updates and their consequences at this reference from the group of Hannes Jónsson [510].

2. `Aufbau metric` is the way one measures the “overlap” between the actual and reference wavefunctions
(more details on [184]). It is `MOM` by default, but can be also set to `%SCF PMOM TRUE END` to use `PMOM` .

3. `Keep initial reference TRUE` means we will always try to keep the initial reference state defined after
the guess phase. That is sometimes called `IMOM` in the literature [71]. If `%SCF KEEPINITIALREF FALSE`
`END` is set, it is always the last SCF iteration that is taken as reference.

**Important:** Here are starting the orbitals from the `PMODEL` guess because it is trivial. In general we recommend
always starting the SCF by reading the orbitals of a previously converged ground-state SCF! Please check *Restarting*
*SCF Calculations* for more info on that.

This calculation trivially converges in 12 steps:



(continues on next page)

**7.9. DeltaSCF: Converging to Arbitrary Single-Reference Wavefunctions** **533**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**Note:** The statement `MOM changed the orbital occupation numbers` is normal, it is just printing what it
is doing. Nothing to worry about.

and one can see from the spin contamination, that this is indeed an open-shell singlet:



The gradient is then computed, and the geometry is optimized until convergence. Finally the frequencies show this
is actually not a minimum, but a saddle point on the geometry space!




The reason is: the HOMO/LUMO transition on formaldehyde populated the *𝜋* *[*]* LUMO, thus breaking the double
bound and making the carbon atom pyramidal. If one starts from a slightly distorted structure, it then converges to
the actual geometry minimum. Starting from a pyramidal structure:



now converges to a minimum, as shown by the absence of negative frequencies:

**534** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**




The final geometry is surprisingly accurate for the gas phase formaldehyde too! We will also show the results
here using the range-corrected, meta-GGA hybrid `wB97M-D4` and the double-hybrid DFT `!B2PLYP DEF2-QZVPP`
`AUTOAUX`, just to show that MP2 also works.

Table 7.13: Geometry of gas phase formaldehyde versus the DeltaSCF results, in Angstroem and degrees.

  - exp. taken from [299].

**Important:** We are using the default SCF algorithm here, `AO-DIIS` + `SOSCF` because this is relatively simple. In
general and for more complicated cases we suggest using directly the second order method, to avoid escaping back
to the ground state with `!NODIIS` .

**Important:** Do **NOT** combine DeltaSCF wavefunctions with CCSD, or any such method with single excitations.
It requires a speciallized version of CC which we don’t have yet.

**Important:** When running the same calculation above with `wB97M-D4`, there will **not** be a virtual orbital between
the alpha HOMO-1 and the HOMO (so no negative HOMO-LUMO gap). There is nothing wrong here, it just
optimized the orbitals to the excited state such that this is now a minimum on the SCF surface.

The energy is still higher than the non-DeltaSCF solution and if you plot the orbitals you will see that the alpha
HOMO is now a *𝜋* orbital instead of an *𝑛* .

**7.9. DeltaSCF: Converging to Arbitrary Single-Reference Wavefunctions** **535**

**ORCA Manual** **,** **Release 6.0.1**

**7.9.2 Core-ionized States**

Another big advantage of the `DeltaSCF` is the possibility to converge to core-excited and/or core-ionized states.
We have a simple keyword to kick out electrons from any orbital, even the deep core ones:
```
%SCF IONIZEALPHA 2 END

```
and the electron from orbital number two will be removed. `IONIZEBETA` works for beta orbitals. One can start

from an anion UHF -electronic structure obtained by adding one extra electron and remove a core electron like
this to obtain core-excited states too. Geometry optimization, EPR, and even TD-DFT calculations are all valid for
these states.

As an example, the input below will ionize the 1s electron from a water molecule, which corresponds to MO 0
here:



**Note:** If the orbital is not localized over a single atom one might need to localized them first!

and one can see from the results that is exactly where it converged to.



**Note:** ORCA automatically adjusts charge and multiplicity here. **The input should contain those from the**
**reference system!**

Here are some examples of binding energies for 1s electrons. The atom from where it was removed is highlighted
in bold:

Table 7.14: Binding energies from 1s electrons found by DeltaSCF using wB97M-V/DEF2-TZVPP, in eV.

  - exp. taken from [143]

**536** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.9.3 Diabatic Couplings**

`DeltaSCF` is also a quite accurate method to obtained diabatic couplings, which can later be used in Markus
theory to compute electron transfer rates. These can be computed by calculating the energy difference between
electron transfer states and using the Generalized Mulliken-Hush Approach (GMH). For more details please check
for example this paper from the group of Blumberger [477].

There is not enough space to go through the details here, but one can get these diabatic coupling from essentially
one regular SCF for the ground state + a `DeltaSCF` for the excited state. For symmetric systems, this is trivial:

2 *|𝐻* *𝑎𝑏* *|* = ∆ *𝐸* 12

where states *𝑎* and *𝑏* are diabatic states ∆ *𝐸* 12 is the energy difference between adiabatic states 1 and 2 (which are
obtained via SCF solution). Here is an example of the diabatic couplings obtained for a benzene dimer, obtained
by starting from the ground state cation and exciting the beta electron with:
```
%SCF BETACONF 0,1 END

```
Table 7.15: Diabatic couplings found by DeltaSCF using wB97M-V/DEF2-TZVPP, in meV.

  - MRCI+Q taken from [477]

**Note:** There is more to come with respect to `DeltaSCF` . We are collaborating further with Prof. Hannes Jónsson’s
group - stay tuned.

**7.9.4 Full keyword list**

Here we present a complete list of options to be given under `%SCF` related to `DeltaSCF` :



(continues on next page)

**7.9. DeltaSCF: Converging to Arbitrary Single-Reference Wavefunctions** **537**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)


### **7.10 CP-SCF Options**

The coupled perturbed self-consistent field (CP-SCF) equations have to be solved in many cases, such as when second derivative properties (e.g. vibrational frequencies, polarizability, NMR shielding, indirect spin-spin coupling,
hyperfine coupling, g-tensor) or the MP2 relaxed density (in this case they are referred to as Z-vector equations)
are calculated. They are a set of linear equations generally expressed as

**AU** *[𝑥]* = **B** *[𝑥]* *,*

where **U** *[𝑥]* is the vector of solutions for perturbation *𝑥*, the right-hand side (RHS) matrix **B** *[𝑥]* is perturbation-specific
and the left-hand side (LHS) matrix **A** is perturbation-independent and contains, among other terms, the twoelectron repulsion integrals ( *𝑖𝑗|𝑎𝑏* ) and ( *𝑖𝑎|𝑗𝑏* ). The equations are solved iteratively and the LHS is reassembled
at every step, while the RHS does not change. The generation and transformation of the two-electron integrals are
therefore the most time-consuming parts of the CP-SCF solution.

The ORCA module which solves these equations accepts several options given below with their default values:



Since ORCA 6, the same settings are used for all electric response property calculations as well as for CIS/TD-DFT
gradients and relaxed densities. For convenience, the keywords in the `%elprop` input block are still available but
they modify the same internal variables as those in `%method` . For magnetic response properties, the solver and
convergence tolerance are set separately in `%eprnmr`, because the convergence behavior of the magnetic response
CP-SCF equations is sometimes different.



(continues on next page)

**538** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



The keywords `Z_GridX` and `Z_IntAccX` are applicable if the RIJCOSX approximation is chosen for the treatment of two-electron integrals. They determine the angular and radial COSX integration grids, as discussed in
section *Changing TD-DFT, CP-SCF and Hessian grids* . Analogously, the keywords `Z_Grid` and `Z_IntAcc` determine the integration grid for DFT XC functionals.

Integrals on the RHS are evaluated differently for different perturbations - refer to sections *Using the RI Approx-*
*imation for Hartree-Fock and Hybrid DFT (RIJCOSX)*, *EPR and NMR properties*, *RIJCOSX-RI-MP2 Gradients*,
and *MP2 and RI-MP2 Second Derivatives* and *RI-MP2 and Double-Hybrid DFT Response Properties* for SCFlevel gradients, EPR/NMR calculations with GIAOs, MP2 gradients, and MP2 second derivatives, respectively.
For MP2 Z-vector equations, the RIJCOSX Fock-response terms in the RHS are evaluated with the COSX grid
specified by `Z_GridX_RHS` . Note that it is used differently to `Z_GridX` : instead, it selects one of the three grids used
in the SCF (see Sections *Using the RI Approximation for Hartree-Fock and Hybrid DFT (RIJCOSX)*, *COSX Grid*
*and Convergence Issues*, and *Details on the numerical integration grids* for details) and it is not recommended to
change the default value of 2.

If the RIJONX or RIJK approximation is used in the SCF, the same is also employed in the CP-SCF. Note, however,
that the RI-K approximation is not efficient for these terms.
### **7.11 SCF Stability Analysis**

The SCF stability analysis evaluates the electronic Hessian (with respect to orbital rotations) at the point indicated
by the SCF solution to determine the lowest eigenvalues of the Hessian. If one or more negative eigenvalues are
found, the SCF solution corresponds to a saddle point and not a true local minimum in the space considered in
the analysis. A typical case are stretched bonds of diatomics, where the symmetry of the initial guess leads to a
restricted solution instead of the often preferred unrestricted one. Several spaces are theoretically possible[780].
However, ORCA limits itself to the analysis RHF/RKS in the space of UHF/UKS or UHF/UKS in the space of
UHF/UKS. As such, it is on the available for the SCF parts of DFT and HF.[80] We mention passing, that a
stability analysis is also available for the CASSCF type wave function and is described elswhere in more detail
(Section *Detecting CASSCF Instabilities* ). In the following, HF is used to indicate both HF and KS. Consider the
following input (unless indicated otherwise, default values are shown):

(continues on next page)

**7.11. SCF Stability Analysis** **539**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



The determination of the electronic Hessian is structurally comparable to the TDHF/CIS/TDDFT procedure. Thus,
many options are very similar and the user is encouraged to read the section on TDDFT (Section *Excited States via*
*RPA, CIS, TD-DFT and SF-TDA* ) to clarify some of the options given here. Since one is usually only interested
in the qualitative determination “stable or not?”, three roots should be sufficient to find the lowest eigenvalue. By
the same philosophy, `StabMaxDim`, `StabMaxIter`, `StabNGuess` and the convergence criteria were chosen. The
parameter `StabLambda` refers to the *𝜆* of equation 37 of reference [780], which determines the mixing of the
original SCF solution and the new orbitals to yield a new guess. Choosing this value is not trivial, since positive
and negative values can lead to different new solutions (at least in principle). The convergence of the ensuing SCF
depends on it, as well, since all SCF procedures require a sufficiently good guess to converge in a decent number
of iterations (or even at all).

The orbital window and the energy window can be specified. Note that the `StabEWIN` will be overridden by the
appropriate `StabORBWIN` values. The automatic determination is also influenced by the `%method FrozenCore`
settings. Tests have shown that significant curtailing of the actual orbital window can drastically influence the
results to the point of qualitative failure.

Current limitations on the method are:

  - Only single-point-like calculations are supported. For geometry optimizations etc., one must use the guess
MORead feature *Choice of Initial Guess and Restart of SCF Calculations* to employ the guess obtained here.
Likewise, one must extract a geometry and run a separate calculation if one is interested in the SCF stability.

  - As for TDDFT, NORI, RIJONX, and RIJCOSX are supported. RI-JK is not supported.

  - Other, more advanced features like finite-temperature calculations and relativistic calculations (beside ECPs)
are not possible at this time.

Overall, the user is cautioned against using the stability analysis blindly without critically evaluating the result in
terms of energy difference and by investigating the orbitals (by the printout or by plotting). Its usefulness cannot
be denied, but it is certainly not black-box.

An SCF stability analysis with default settings can be requested via STABILITY, SCFSTABILITY, SCFSTAB or
STAB on the simple input line.
### **7.12 Frozen Core Options**

The frozen core (FC) approximation is usually applied in correlated calculation and consists in neglecting correlation effects for electrons in the low-lying core orbitals. The FC approximation and the number of core electrons
per element can be adjusted in the %method block. The default number of core electrons per element is listed in
Table 7.16.

Table 7.16: Default values for number of frozen core electrons.

**540** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**




For systems containing heavy elements, core electrons might have higher orbital energies compared to the orbital
energies of valence MOs of some lighter elements. In that case, core electrons might be included in the correlation
calculation, which ultimately leads to large errors in correlation energy. In order to prevent this, the MO ordering
is checked: Do all lower energy MOs in the core region have core electron character, i.e. are they strongly localized
on the individual elements? For post-(CAS)SCF calulations, this check is always performed both after the SCF
calculation, and after the initial guess (because the SCF may be skipped with `!NoIter` ). For other calculations,
the check is off by default but may be switched on with the `CheckFrozenCore` keyword in the `%method` block.
If core orbitals are found in the valence region, while more delocalized orbitals are found in the core region, the
corresponding MO pairs are swapped. This behavior can be disabled using the `CorrectFrozenCore` keyword.

**7.12. Frozen Core Options** **541**

**ORCA Manual** **,** **Release 6.0.1**

**Note:**

  - The FrozenCore options are applied to all post Hartree-Fock methods.

  - If including all electrons is desired, the `!NoFrozenCore` keyword can be simply inserted. For MP2: Frozen
virtual orbitals are not allowed in gradient runs or geometry optimization!

  - If ECPs are used, the number for NewNCore has to include the electrons represented by the ECPs as well.
E.g. if an element is supposed to have 60 electrons in the ECP and additional 8 electrons should be frozen
in the correlation calculation, NewNCore should be 68.

  - In ORCA we use rather conservative frozencore settings, i. e. a large number of electrons are included in
the correlation treatment. Therefore, we recommend to use properly optimized correlating basis functions
in all cases, such as the cc-pwCVXZ basis sets.

  - For DLPNO calculations the virtual space for core-core and core-valence correlation is adjusted by default,
which is described in detail in section *Including (semi)core orbitals in the correlation treatment* .

  - In general, `NewNCore` only has an effect in calculations with `FC_ELECTRONS` . In calculations using the
DLPNO approximation (except DLPNO-NEVPT2), `NewNCore` has also an effect in the other cases, as is
described in section *Including (semi)core orbitals in the correlation treatment* .

  - Double-hybrid density functional (section *DFT Calculations with Second Order Perturbative Correction*
*(Double-Hybrid Functionals)* ) calculations by default use the FrozenCore option for the perturbative part,
as is the case for MP2.
### **7.13 The Second Order Many Body Pertubation Theory Module** **(MP2)**

Throughout this section, indices *𝑖, 𝑗, 𝑘, . . .* refer to occupied orbitals in the reference determinant, *𝑎, 𝑏, 𝑐, . . .* to
virtual orbitals and *𝑝, 𝑞, 𝑟, . . .* to general orbitals from either set while *𝜇, 𝜈, 𝜅, 𝜏, . . .* refer to basis functions.

**7.13.1 Standard MP2**

The standard (or full accuracy) MP2 module has two different branches. One branch is used for energy calculations,
the other for gradient calculations.

For standard MP2 energies, the program performs two half-transformations and the half-transformed integrals are
stored on disk in compressed form. This appears to be the most efficient approach that can also be used for medium
sized molecules.The module should parallelize acceptably well as long as I/O is not limiting.

For standard MP2 gradients, the program performs four quarter transformations that are ordered by occupied orbitals. Here, the program massively benefits from large core memory ( `%maxcore` ) since this minimizes the number
of batches that are to be done. I/O demands are minimal in this approach.

In “memory mode” (Q1Opt>0) basically the program treats batches of occupied orbitals at the same time. Thus,
there must be at least enough memory to treat a single occupied MO at each pass. Otherwise the MP2 module will
fail. Thus, potentially, MP2 calculations on large molecules take significant memory and may be most efficiently
done through the RI approximation.

=
Alternatively, in the “disk based mode” (Q1Opt -1) the program performs a half transformation of the exchange
integrals and stores the transformed integrals on disk. A bin-sort then leads to the AO operator *𝐾* *[𝑖𝑗]* ( *𝜇, 𝜈* ) =

=
( *𝑖𝜇|𝑗𝜈* ) in (11|22) integral notation. These integrals are then used to make the final K *[𝑖𝑗]* (a,b) (a,b virtual MOs)
and the EMP2 pair energy contributions. In many cases, and in particular for larger molecules, this algorithm is
much more efficient than the memory based algorithm. It depends, however, much more heavily on the I/O system
of the computer that you use. It is important, that the program uses the flags `CFLOAT, UCFLOAT, CDOUBLE` or
`UCDOUBLE` in order to store the unsorted and sorted AO exchange integrals. Which flag is used will influence the
performance of the program and to some extent the accuracy of the result (float based single precision results are

**542** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

usually very slightly less accurate; *𝜇* Eh-range deviations from the double precision result [1] ). Finally, gradients are
presently only available for the memory based algorithm since in this case a much larger set of integrals is required.

The `! MP2` command does the following: (a) it changes the `Method` to `HFGTO` and (b) it sets the flag `DoMP2` to
`true` . The program will then first carry out a Hartree-Fock SCF calculation and then estimate the correlation
energy by MP2 theory. RHF, UHF and high-spin ROHF reference wavefunctions are permissible and the type of
MP2 calculation to be carried out (for high-spin ROHF the gradients are not available) is automatically chosen
based on the value of `HFTyp` . If the SCF is carried out conventionally, the MP2 calculation will also be done in a
conventional scheme unless the user forces the calculation to be direct. For `SCFMode` = `Direct` the MP2 energy
evaluation will be fully in the integral direct mode.

The following variables can be adjusted in the block for conventional MP2 calculations:



1 However, sometimes, and in particular when transition metals and core orbitals are involved we have met unpleasantly large errors. So –
be careful and double check when using floats!

**7.13. The Second Order Many Body Pertubation Theory Module (MP2)** **543**

**ORCA Manual** **,** **Release 6.0.1**

**7.13.2 RI-MP2**

The RI-MP2 module is of a straightforward nature. The program first transforms the three-index integrals ( *𝑖𝑎|𝑃* [˜] ),
where “ *𝑖* ” is a occupied, “ *𝑎* ” is a virtual MO and “ *𝑃* [˜] ” is an auxiliary basis function that is orthogonalized against
the Coulomb metric. These integrals are stored on disk, which is not critical, even if the basis has several thousand
functions. The integral transformation is parallelized and has no specifically large core memory requirements.

In the next step, the integrals are read ordered with respect to the occupied labels and the exchange operators
*𝐾* *[𝑖𝑗]* ( *𝑎, 𝑏* ) = ( *𝑖𝑎|𝑗𝑏* ) = [∑︀] [NAux] *𝑃* ˜ ( *𝑖𝑎|𝑃* [˜] )( *𝑃* [˜] *|𝑗𝑏* ) are formed in the rate limiting O(N [5] ) step. This step is done with
high efficiency by a large matrix multiplication and parallelizes well. From the exchange operators, the MP2
amplitudes and the MP2 energy is formed. The program mildly benefits from large core memory (%maxcore) as
this minimizes the number of batches and hence reads through the integral list.

The RI-MP2 gradient is also available. Here, all necessary intermediates are made on the fly.

In the RI approximation, one introduces an auxiliary fitting basis *𝜂* *𝑃* ( **r** ) and then approximates the two-electron
integrals in the Coulomb metric as:

( *𝑝𝑞|𝑟𝑠* ) *≈* ∑︁ ( *𝑝𝑞|𝑃* ) *𝑉* *𝑃𝑄* *[−]* [1] [(] *[𝑄][|][𝑟𝑠]* [)] (7.50)

*𝑃𝑄*

where *𝑉* *𝑃𝑄* = ( *𝑃* *|𝑄* ) is a two-index electron-electron repulsion integral. As first discussed by Weigend and Häser,
the closed-shell case RI-MP2 gradient takes the form:


∑︁ ( *𝜇𝜈|𝑃* ) [(] *[𝑥]* [)] [ ∑︁]

*𝜇𝜈𝑃* *𝑖*


∑︁ *𝑉* *𝑅𝑆* *[𝑥]* (︁ **V** *[−]* [1] *[/]* [2] *𝛾* **V** *[−]* [1] *[/]* [2] [)︁]

*𝑅𝑆*


*𝐸* RI-MP2 *[𝑥]* [= 2] ∑︁


*𝑐* *𝜇𝑖* Γ *[𝑃]* *𝑖𝜈* [+] ∑︁
*𝑖* *𝑅𝑆*


*𝑅𝑆* [+] *[ ⟨]* **[DF]** *[𝑥]* *[⟩]* (7.51)


The **F** -matrix derivative terms are precisely handled as in the non-RI case and need not be discussed any further.
Γ *[𝑃]* *𝑖𝑎* [is a three-index two-particle “density”:]

Γ *[𝑃]* *𝑖𝑎* [=] ∑︁ (1 + *𝛿* *𝑖𝑗* ) *𝑡* [˜] *[𝑖𝑗]* *𝑎𝑏* *[𝑉]* *𝑃𝑄* *[−]* [1] *[/]* [2] ( *𝑄|𝑗𝑏* ) (7.52)

*𝑗𝑏𝑄*

Which is partially transformed to the AO basis by:

Γ *[𝑃]* *𝑖𝜈* [=] ∑︁ *𝑐* *𝜈𝑎* Γ *[𝑃]* *𝑖𝑎* (7.53)

*𝑎*

The two-index analogue is given by:

*𝛾* *𝑃𝑄* = ∑︁ Γ *[𝑄]* *𝑖𝑎* [(] *[𝑖𝑎][|][𝑅]* [)] *[ 𝑉]* *𝑅𝑃* *[−]* [1] *[/]* [2] (7.54)

*𝑖𝑎𝑅*

The RI contribution to the Lagrangian is particularly convenient to calculate:


∑︁ Γ *[𝑃]* *𝑖𝜈* [(] *[𝜇𝜈][|][𝑄]* [)] *[ 𝑉]* *𝑃𝑄* *[−]* [1] *[/]* [2]

*𝑃𝑄𝜈*


⎤

(7.55)
⎦


*𝐿* *[𝑅𝐼]* *𝑎𝑖* [=] ∑︁ *𝑐* *𝜇𝑎*

*𝜇*


⎡


2
∑︁
⎣ *𝑃𝑄𝜈*


In a similar way, the remaining contributions to the energy weighted density matrix can be obtained efficiently.
Note, however, that the response operator and solution of the CP-SCF equations still proceed via traditional fourindex integrals since the SCF operator was built in this way. Thus, while the derivatives of the three-index integrals
are readily and efficiently calculated, one still has the separable contribution to the gradient, which requires the
derivatives of the four-index integrals.

The RI-MP2 energy and gradient calculations can be drastically accelerated by employing the RIJCOSX or the
RIJDX approximation.

**544** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.13.3 “Double-Hybrid” Density Functional Theory**

A slightly more general form is met in the double-hybrid DFT gradient. The theory is briefly described below.

The energy expression for perturbatively and gradient corrected hybrid functionals as proposed by Grimme is:


*𝐸* = *𝑉* *𝑁𝑁* + ⟨︀ **Ph** [+] [⟩︀] + [1]

2


*𝜌* ( **r** 1 ) *𝜌* ( **r** 2 )
∫︁∫︁ *|* **r** 1 *−* **r** 2 *|*


( **r** 1 ) *𝜌* ( **r** 2 )

*|* **r** 1 *−* **r** 2 *|* *[𝑑]* **[r]** [1] *[𝑑]* **[r]** [2] *[ −]* [1] 2


2 *[𝑎]* *[𝑥]* ∑︁


∑︁ *𝑃* *𝜇𝜅* *[𝜎]* *[𝑃]* *𝜈𝜏* *[𝜎]* [(] *[𝜇𝜈][|][𝜅𝜏]* [) +] *[ 𝑐]* [DF] *[𝐸]* [XC] [[] *[𝜌]* *[𝛼]* *[, 𝜌]* *[𝛽]* [] +] *[ 𝑐]* [PT] *[𝐸]* [PT]

*𝜇𝜈𝜅𝜏𝜎*


*𝐸* = *𝐸* SCF + *𝑐* PT *𝐸* PT (7.56)

Here *𝑉* *𝑁𝑁* is the nuclear repulsion energy and *ℎ* *𝜇𝜈* is a matrix element of the usual one-electron operator which
contains the kinetic energy and electron-nuclear attraction terms ( *⟨* **ab** *⟩* denotes the trace of the matrix product **ab** ).
As usual, the molecular spin-orbitals are expanded in atom centered basis functions ( *𝜎* = *𝛼, 𝛽* ):

*𝜓* *𝑝* *[𝜎]* [(] **[r]** [) =] ∑︁ *𝑐* *[𝜎]* *𝜇𝑝* *[𝜙]* *[𝜇]* [(] **[r]** [)] (7.57)

*𝜇*

with MO coefficients *𝑐* *[𝜎]* *𝜇𝑝* [. The total density is given by (real orbitals are assumed throughout):]


*|𝜓* *𝑖* *[𝜎]* [(] **[r]** [)] *[|]* [2] [ =] ∑︁

*𝑖𝜎*


*𝜌* ( **r** ) = ∑︁


*𝑃* *[𝜎]*

∑︁ *𝜇𝜈* *[𝜙]* *[𝜇]* [(] **[r]** [)] *[ 𝜙]* *[𝜈]* [(] **[r]** [) =] *[ 𝜌]* *[𝛼]* [(] **[r]** [) +] *[ 𝜌]* *[𝛽]* [(] **[r]** [)] (7.58)

*𝜇𝜈𝜎*


Where **P** = **P** *[𝛼]* + **P** *[𝛽]* and *𝑃* *𝜇𝜈* *[𝜎]* [=][ ∑︀] *𝑖* *𝜎* *[𝑐]* *[𝜎]* *𝜇𝑖* *[𝑐]* *𝜈𝑖* *[𝜎]* [.]

The second term of (7.56) represents the Coulombic self-repulsion. The third term represents the contribution of
the Hartree-Fock exchange with the two-electron integrals being defined as:

( *𝜇𝜈|𝜅𝜏* ) = *𝜑* *𝜇* ( **r** 1 ) *𝜑* *𝜈* ( **r** 1 ) *𝑟* 12 *[−]* [1] *[𝜑]* *[𝜅]* [(] **[r]** [2] [)] *[ 𝜑]* *[𝜏]* [(] **[r]** [2] [)] *[ 𝑑]* **[r]** [1] *[𝑑]* **[r]** [2] (7.59)
∫︁∫︁

The mixing parameter *𝑎* *𝑥* controls the fraction of Hartree-Fock exchange and is of a semi-empirical nature. The
exchange correlation contribution may be written as:

*𝐸* XC [ *𝜌* *𝛼* *, 𝜌* *𝛽* ] = (1 *−* *𝑎* *𝑥* ) *𝐸* X [GGA] [ *𝜌* *𝛼* *, 𝜌* *𝛽* ] + *𝑏𝐸* C [GGA] [ *𝜌* *𝛼* *, 𝜌* *𝛽* ] (7.60)

Here, *𝐸* X [GGA] [ *𝜌* *𝛼* *, 𝜌* *𝛽* ] is the exchange part of the XC- functional in question and *𝐸* C [GGA] [ *𝜌* *𝛼* *, 𝜌* *𝛽* ] is the correlation
part. The parameter *𝑏* controls the mixing of DFT correlation into the total energy and the parameter *𝑐* DF is a
global scaling factor that allows one to proceed from Hartree-Fock theory ( *𝑎* X = 1, *𝑐* DF = 0, *𝑐* PT = 0) to MP2
theory ( *𝑎* X = 1, *𝑐* DF = 0, *𝑐* PT = 1) to pure DFT ( *𝑎* X = 1, *𝑐* DF = 0, *𝑐* PT = 1) to hybrid DFT (0 *< 𝑎* X *<* 1,
*𝑐* DF = 1, *𝑐* PT = 0) and finally to the general perturbatively corrected methods discussed in this work (0 *< 𝑎* X *<* 1,
*𝑐* DF = 1, 0 *< 𝑐* PT *<* 1). As discussed in detail by Grimme, the B2- PLYP functional uses the Lee-Yang-Parr
(LYP) functional as correlation part, the Becke 1988 (B88) functional as GGA exchange part and the optimum
choice of the semi-empirical parameters was determined to be *𝑎* X = 0 *.* 53, *𝑐* PT = 0 *.* 27, *𝑐* DF = 1, *𝑏* = 1 *−* *𝑐* PT .
For convenience, we will suppress the explicit reference to the parameters *𝑎* X and *𝑏* in the XC part and rewrite the
gradient corrected XC energy as:

*𝐸* XC [︀ *𝜌* *[𝛼]* *, 𝜌* *[𝛽]* []︀] = *𝑓* (︀ *𝜌* *[𝛼]* *, 𝜌* *[𝛽]* *, 𝛾* *[𝛼𝛼]* *, 𝛾* *[𝛽𝛽]* *, 𝛾* *[𝛼𝛽]* [)︀] *𝑑* **r** (7.61)
∫︁

with the gradient invariants *𝛾* *[𝜎𝜎]* *[′]* = *∇* *[⃗]* *𝜌* *[𝜎]* *∇* *[⃗]* *𝜌* *[𝜎]* *[′]* . The final term in eq (48) represents the scaled second order
perturbation energy:


*𝐸* [PT2] = [1]

2


∑︁

*𝑖* *𝛼* *<𝑗* *𝛼*


∑︁

*𝑖* *𝛽* *<𝑗* *𝛽*


⟨︀ **t** *[𝑖]* *[𝛼]* *[𝑗]* *[𝛼]* **K** **[¯]** *[𝑖]* *[𝛼]* *[𝑗]* *[𝛼]* [+] [⟩︀] + [1]

2


⟨︀ **t** *[𝑖]* *[𝛽]* *[𝑗]* *[𝛽]* **K** **[¯]** *[𝑖]* *[𝛽]* *[𝑗]* *[𝛽]* [+] [⟩︀] + ∑︁

*𝑖* *𝛼* *,𝑗* *𝛽*


⟨︀ **t** *[𝑖]* *[𝛼]* *[𝑗]* *[𝛽]* **K** **[¯]** *[𝑖]* *[𝛼]* *[𝑗]* *[𝛽]* [+] [⟩︀] (7.62)


The PT2 amplitudes have been collected in matrices **t** *[𝑖]* *[𝜎]* *[𝑗]* *[𝜎][′]* with elements:

*−* 1
*𝑡* *[𝑖]* *𝑎* *[𝜎]* *𝜎* *[𝑗]* *𝑏* *[𝜎]* *𝜎* *[′]* *′* [= ¯] *[𝐾]* *𝑎* *[𝑖]* *[𝜎]* *𝜎* *[𝑗]* *𝑏* *[𝜎]* *𝜎* *[′]* *′* (︁ *𝜀* *[𝜎]* *𝑖* [+] *[ 𝜀]* *[𝜎]* *𝑗* *[′]* *[−]* *[𝜀]* *𝑎* *[𝜎]* *[−]* *[𝜀]* *[𝜎]* *𝑏* *[′]* )︁ (7.63)

**7.13. The Second Order Many Body Pertubation Theory Module (MP2)** **545**

**ORCA Manual** **,** **Release 6.0.1**

Where the orbitals were assumed to be canonical with orbital energies *𝜀* *[𝜎]* *𝑝* [. The exchange operator matrices are]
*𝐾* *[𝑖]* *[𝜎]* *[𝑗]* *[𝜎][′]*
*𝑎* *𝜎* *𝑏* *𝜎′* [= (] *[𝑖]* *[𝜎]* *[𝑎]* *[𝜎]* *[|][𝑗]* *[𝜎]* *[′]* *[𝑏]* *[𝜎]* *[′]* [)][ and the anti-symmetrized exchange integrals are defined as][ ¯] *[𝐾]* *𝑎* *[𝑖]* *[𝜎]* *𝜎* *[𝑗]* *𝑏* *[𝜎]* *𝜎* *[′]* *′* [= (] *[𝑖]* *[𝜎]* *[𝑎]* *[𝜎]* *[|][𝑗]* *[𝜎]* *[′]* *[𝑏]* *[𝜎]* *[′]* [)] *[ −]*
*𝛿* *𝜎𝜎* *′* ( *𝑖* *𝜎* *𝑏* *𝜎* *|* *𝜎* *𝑎* *𝜎* ).

The orbitals satisfy the SCF equations with the matrix element of the SCF operator given by:

*𝐹* *𝜇𝜈* *[𝜎]* [=] *[ ℎ]* *[𝜇𝜈]* [+] ∑︁ *𝑃* *𝜅𝜏* ( *𝜇𝜈|𝜅𝜏* ) *−* *𝑎* X *𝑃* *𝜅𝜏* *[𝜎]* [(] *[𝜇𝜅][|][𝜈𝜏]* [) +] *[ 𝑐]* [DF] [(] *[𝜇][|][𝑉]* XC *[𝜎]* *[|][𝜈]* [)] (7.64)

*𝜅𝜏*

The matrix elements of the XC–potential for a gradient corrected functional are: [840]

( *𝜇|𝑉* XC *[𝛼]* *[|][𝜈]* [) =] *𝛿* *𝑓* *[𝛿]* *[𝑓]* *∇⃗* *𝜌* *𝛼* *∇⃗* ( *𝜙* *𝜇* *𝜙* *𝜈* ) + *𝛿* *𝑓* *∇⃗* *𝜌* *𝛽* *∇⃗* ( *𝜙* *𝜇* *𝜙* *𝜈* ) *𝑑* **r** (7.65)
∫︁{︂ *𝛿𝜌* *𝛼* ( **r** ) [(] *[𝜙]* *[𝜇]* *[𝜙]* *[𝜈]* [) + 2] *𝛿𝛾* *𝛼𝛼* *𝛿𝛾* *𝛼𝛽* }︂

The energy in equation (7.56) depends on the MO-coefficients, the PT2-amplitudes and through *𝑉* *𝑁𝑁*, *𝑉* *𝑒𝑁* (in *ℎ* )
and the basis functions also explicitly on the molecular geometry. Unfortunately, the energy is only stationary with
respect to the PT2 amplitudes since they can be considered as having been optimized through the minimization of
the Hylleraas functional:

*̸*


∑︁

*𝑖* *𝛽* *<𝑗* *𝛽*

*̸*


⟨︀ **t** *[𝑖]* *[𝛼]* *[𝑗]* *[𝛼]* **K** **[¯]** *[𝑖]* *[𝛼]* *[𝑗]* *[𝛼]* [+] [⟩︀] + [1]

2

*̸*


⟨︀ **t** *[𝑖]* *[𝛽]* *[𝑗]* *[𝛽]* **K** **[¯]** *[𝑖]* *[𝛽]* *[𝑗]* *[𝛽]* [+] [⟩︀] + ∑︁

*𝑖* *𝛼* *𝑗* *𝛽*

*̸*


⎫
⟨︀ **t** *[𝑖]* *[𝛼]* *[𝑗]* *[𝛽]* **K** **[¯]** *[𝑖]* *[𝛼]* *[𝑗]* *[𝛽]* [+] [⟩︀] + ⟨︀ **D** *[′][𝛼]* **F** *[𝛼]* [+] [⟩︀] + ⟨ **D** *[′][𝛽]* **F** *[𝛽]* [+] [⟩] ⎬

⎭

*̸*


*𝐸* PT2 = min
**t**

*̸*


⎧
⎨ 12

⎩

*̸*


∑︁

*𝑖* *𝛼* *<𝑗* *𝛼*

*̸*


The unrelaxed PT2 difference density is defined as:

*̸*


*𝐷* *′* *𝛼*
*𝑖𝑗* [=] *[ −]* [1] 2

*̸*


∑︁

*𝑘* *𝛼*

*̸*


⟨︀ **t** *[𝑖]* *[𝛼]* *[𝑘]* *[𝛼]* **t** *[𝑘]* *[𝛼]* *[𝑗]* *[𝛼]* [⟩︀] *−* ∑︁

*𝑘* *𝛽*

*̸*


(7.66)

⟨︀ **t** *[𝑖]* *[𝛼]* *[𝑘]* *[𝛽]* **t** *[𝑘]* *[𝛽]* *[𝑗]* *[𝛼]* [⟩︀] (7.67)

*̸*


*𝐷* *𝑎𝑏* *′* *𝛼* [=] ∑︁

*̸*


**t** *[𝑖]* *[𝛽]* *[𝑗]* *[𝛼]* [+] **t** *[𝑖]* *[𝛽]* *[𝑗]* *[𝛼]*

∑︁ (7.68)

*𝑖* *𝛽* *𝑗* *𝛼*

*̸*


**t** *[𝑖]* *[𝛼]* *[𝑗]* *[𝛼]* **t** *[𝑖]* *[𝛼]* *[𝑗]* *[𝛼]* [+] +

∑︁ ∑︁

*𝑖* *𝛼* *<𝑗* *𝛼* *𝑖* *𝛽* *𝑗* *𝛼*

*̸*


With analogous expressions for the spin-down unrelaxed difference densities. Minimization of this functional with
respect to the amplitudes yields the second order perturbation energy. The derivative of the SCF part of equation
(7.56) with respect to a parameter “ *𝑥* ” is straightforward and well known. It yields:

*̸*


*𝐸* SCF *[𝑥]* [=] *[ 𝑉]* *𝑁𝑁* *[𝑥]* [+] *[ ⟨]* **[Ph]** *[𝑥]* *[⟩]* [+] ⟨︀ **W** *[𝑆𝐶𝐹]* **S** [(] *[𝑥]* [)] [⟩︀] + [∑︀]

*̸*


*𝜇𝜈𝜅𝜏* [Γ] *[𝜇𝜈𝜅𝜏]* [(] *[𝜇𝜈][|][𝜅𝜏]* [)] [(] *[𝑥]* [)]

*̸*


+
∑︁

*𝜎*
⏟ ⏞
( *𝜎* *[′]* = *̸* *𝜎* )


∫︀ [{︁] *𝛿𝜌𝛿* *𝜎* *𝑓* ( **r** ) *[𝜌]* *𝜎* [(] *[𝑥]* [)] + 2 *𝛿𝛾* *[𝛿]* *[𝑓]*

*̸*


*𝛿𝛾* *[𝛿]* *𝜎𝜎* *[𝑓]* *[∇][⃗]* *[𝜌]* *[𝜎]* *[∇][⃗]* *[𝜌]* *𝜎* [(] *[𝑥]* [)] + *𝛿𝛾𝛿* *𝜎𝜎* *𝑓* *′* *[∇][⃗]* *[𝜌]* *[𝜎]* *[′]* *[ ⃗][∇][𝜌]* *𝜎* [(] *[𝑥]* [)] }︁ *𝑑* **r** (7.69)

*̸*


*̸*

Superscript “ *𝑥* ” refers to the derivative with respect to some perturbation “ *𝑥* ” while a superscript in parentheses
indicates that only the derivative of the basis functions with respect to “ *𝑥* ” is to be taken. For example:


*̸*

*𝜕* *𝜙* *𝜇*
*𝜇𝜈* *[𝑃]* *𝜇𝜈* *[𝜎]* {︁ *𝜕𝑥*


*̸*

*𝜙* *𝜈*

*𝜕𝑥* }︁


*̸*

(7.70)

*[𝜕][ℎ]* [^]

*𝜕𝑥* *[|][𝜙]* *[𝜈]* )︁


*̸*

*𝜌* [(] *𝜎* *[𝑥]* [)] = [∑︀]


*̸*

*𝜙* *𝜇* *𝜕* *𝜙* *𝜈*

*𝜕𝑥* *[𝜙]* *[𝜈]* [+] *[ 𝜙]* *[𝜇]* *𝜕𝑥*


*̸*

*ℎ* *[𝑥]* *𝜕* *𝜙* *𝜇*
*𝜇𝜈* [=] (︁ *𝜕𝑥*


*̸*

*[𝜙]* *[𝜈]*

*𝜕𝑥* )︁ + (︁ *𝜙* *𝜇* *|* *[𝜕]* *𝜕𝑥* *[ℎ]* [^]


*̸*

*𝜕𝑥* *𝜙* *𝜇* *[|][ℎ]* [ˆ] *[|][𝜙]* *[𝜈]* )︁ + (︁ *𝜙* *𝜇* *|ℎ* [ˆ] *|* *[𝜕]* *𝜕𝑥* *[𝜙]* *[𝜈]*


*̸*

In equation (7.69), **S** is the overlap matrix and **W** [SCF] the energy weighted density:

*𝑊* *𝜇𝜈* [SCF] = *𝑊* *𝜇𝜈* *[𝛼]* [;][SCF] + *𝑊* *𝜇𝜈* *[𝛽]* [;][SCF] = *−* ∑︁ *𝑐* *[𝜎]* *𝜇𝑖* *[𝑐]* *𝜈𝑖* *[𝜎]* *[𝜀]* *[𝜎]* *𝑖* (7.71)

*𝑖𝜎*

At this point, the effective two-particle density matrix is fully separable and reads:


*̸*

Γ *𝜇𝜈𝜅𝜏* = [1]


*̸*

[1]

2 *[𝑃]* *[𝜇𝜈]* *[𝑃]* *[𝜅𝜏]* *[−]* [1] 2


*̸*

[1]

2 *[𝑎]* *[𝑥]* *[𝑃]* *𝜇𝜅* *[𝛼]* *[𝑃]* *𝜈𝜏* *[𝛼]* *[−]* [1] 2


*̸*

2 *[𝑎]* *[𝑥]* *[𝑃]* *𝜇𝜅* *[𝛽]* *[𝑃]* *𝜈𝜏* *[𝛽]* (7.72)


*̸*

The derivative of the PT2 part is considerably more complex, since *𝐸* PT2 is not stationary with respect to changes
in the molecular orbitals. This necessitates the solution of the coupled-perturbed SCF (CP-SCF) equations. We
follow the standard practice and expand the perturbed orbitals in terms of the unperturbed ones as:

*𝜓* *𝑝* *[𝜎]* [;] *[𝑥]* ( **r** ) = ∑︁ *𝑈* *𝑞𝑝* *[𝜎]* [;] *[𝑥]* *[𝜓]* *𝑞* *[𝜎]* [(] **[r]** [)] (7.73)

*𝑞*

**546** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

The occupied-occupied and virtual-virtual blocks of **U** are fixed, as usual, through the derivative of the orthonormality constraints:

*𝑈* *[𝜎]* [;] *[𝑥]* = *−* [1] (7.74)
*𝑖𝑗* 2 *[𝑆]* *𝑖𝑗* *[𝜎]* [(] *[𝑥]* [)]

*𝑈* *𝑎𝑏* *[𝜎]* [;] *[𝑥]* = *−* 2 [1] *[𝑆]* *𝑎𝑏* *[𝜎]* [(] *[𝑥]* [)] (7.75)

*𝑈* *𝑖𝑎* *[𝜎]* [;] *[𝑥]* = *−𝑆* *𝑖𝑎* *[𝜎]* [(] *[𝑥]* [)] *−* *𝑈* *𝑎𝑖* *[𝜎]* [;] *[𝑥]* (7.76)

Where *𝑆* *𝑝𝑞* *[𝜎]* [(] *[𝑥]* [)] = [∑︀] *𝜇𝜈* *[𝑐]* *𝜇𝑝* *[𝜎]* *[𝑐]* *𝜈𝑞* *[𝜎]* *[𝑆]* *𝜇𝜈* [(] *[𝑥]* [)] [. The remaining virtual-occupied block of] **[ U]** *[ 𝑥]* [must be determined through the]

solution of the CP-SCF equations. However, as shown by Handy and Schaefer, this step is unnecessary and only a
single set of CP-SCF equations (Z-vector equations) needs to be solved. To this end, one defines the Lagrangian:

︁ ︂



[+ 2][ ∑︀] *𝑗* *𝛼* *𝑏* *𝛼* *𝑐* *𝛼* [(] *[𝑎]* *[𝛼]* *[𝑐]* *[𝛼]* *[|][𝑗]* *[𝛼]* *[𝑏]* *[𝛼]* [)] *[ 𝑡]* *𝑐* *[𝑖]* *[𝛼]* *𝛼* *[𝑗]* *𝑏* *[𝛼]* *𝛼* *[−]* [2][ ∑︀] *𝑗* *𝛼* *𝑘* *𝛼* *𝑏* *𝛼* [(] *[𝑘]* *[𝛼]* *[𝑖]* *[𝛼]* *[|][𝑗]* *[𝛼]* *[𝑏]* *[𝛼]* [)] *[ 𝑡]* *𝑎* *[𝑘]* *[𝛼]* *𝛼* *[𝑗]* *𝑏* *[𝛼]* *𝛼*

+2 [∑︀] *𝑏* *𝑐* [(] *[𝑎]* *[𝛼]* *[𝑐]* *[𝛼]* *[|][𝑗]* *[𝛽]* *[𝑏]* *[𝛽]* [)] *[ 𝑡]* *𝑏* *[𝑗]* *[𝛽]* *[𝑖]* *𝑐* *[𝛼]* *[−]* [2][ ∑︀] *𝑘* *𝑏* [(] *[𝑘]* *[𝛼]* *[𝑖]* *[𝛼]* *[|][𝑗]* *[𝛽]* *[𝑏]* *[𝛽]* [)] *[ 𝑡]* *𝑏* *[𝑗]* *[𝛽]* *[𝑘]* *𝑎* *[𝛼]*

︁ ︂


*𝑗* *𝛼* *𝑏* *𝛼* *𝑐* *𝛼* [(] *[𝑎]* *[𝛼]* *[𝑐]* *[𝛼]* *[|][𝑗]* *[𝛼]* *[𝑏]* *[𝛼]* [)] *[ 𝑡]* *𝑐* *[𝑖]* *[𝛼]* *𝛼* *[𝑗]* *𝑏* *[𝛼]* *𝛼* *[−]* [2][ ∑︀]

*𝑗* *𝛽* *𝑏* *𝛽* *𝑐* *𝛼* [(] *[𝑎]* *[𝛼]* *[𝑐]* *[𝛼]* *[|][𝑗]* *[𝛽]* *[𝑏]* *[𝛽]* [)] *[ 𝑡]* *𝑏* *[𝑗]* *[𝛽]* *𝛽* *[𝑖]* *𝑐* *[𝛼]* *𝛼* *[−]* [2][ ∑︀]

︁ ︂


*𝐿* *[𝛼]* *𝑎𝑖* [=] *[ 𝑅]* *[𝜎]* [(] **[D]** *[′]* [)] *𝑎𝑖* [+ 2][ ∑︀]

︁ ︂


*𝛼* *𝛼* *𝛼* *𝛼* *𝛼* (7.77)

*𝑗* *𝛽* *𝑘* *𝛼* *𝑏* *𝛽* [(] *[𝑘]* *[𝛼]* *[𝑖]* *[𝛼]* *[|][𝑗]* *[𝛽]* *[𝑏]* *[𝛽]* [)] *[ 𝑡]* *𝑏* *[𝑗]* *[𝛽]* *𝛽* *[𝑘]* *𝑎* *[𝛼]* *𝛼*

︁ ︂


An analogous equation holds for *𝐿* *[𝛽]* *𝑎𝑖* [. The matrix elements of the response operator] *[ 𝑅]* *[𝛼]* [(] **[D]** *[′]* [)][ are best evaluated in]
the AO basis and then transformed into the MO basis. The AO basis matrix elements are given by:

*𝑅* *[𝛼]* ( **D** *[′]* ) *𝜇𝜈* = ∑︁ 2 *𝐷* *𝜅𝜏* *[′]* [(] *[𝜇𝜈][|][𝜅𝜏]* [)] *[ −]* *[𝐷]* *𝜅𝜏* *′* *𝛼* [[(] *[𝜇𝜅][|][𝜈𝜏]* [) + (] *[𝜈𝑘][|][𝜇𝜏]* [)]]

*𝜅𝜏*

︁ ︂


︁ ︂

+
∑︁

*𝜁*


︁ ︂ *𝛿* 2 *𝑓* *𝛿* [2] *𝑓* *⃗* *𝛿* [2] *𝑓* *⃗*

2 *∇𝜌* *[𝛼]* **P** [+] *∇𝜌* *[𝛽]* **P**

∫ [ *𝛿𝜌* *𝛼* *𝛿𝜁* *[𝜁]* [(] **[D]** *[′]* [) (] *[𝜑]* *[𝜇]* *[𝜑]* *[𝜈]* [) +] (︂ *𝛿𝛾* *𝛼𝛼* *𝛿𝜁* *𝛿𝛾* *𝛼𝛽* *𝛿𝜁*


︁ ︂

*𝜁* ( **D** *[′]* ) *∇* *[⃗]* ( *𝜑* *𝜇* *𝜑* *𝜈* )
)︂


︁ ︂

(7.78)


︁ ︂

*⃗* *𝛿* *𝑓* *⃗*

+ 2 *[𝛿]* *[𝑓]* *∇𝜌* *[𝛼]* **D** *[′]* [ +] *∇𝜌* *[𝛽]* **D** *[′]*
(︂ *𝛿𝛾* *𝛼𝛼* *𝛿𝛾* *𝛼𝛽*


︁ ︂

*⃗*
*∇* ( *𝜑* *𝜇* *𝜑* *𝜈* ) *𝑑* **r**
)︂ ]︂


︁ ︂

where

*𝜁* ( **D** *[′]* ) = *𝜌* *[𝛼]* **D** *[′]* *[, 𝜌]* *[𝛽]* **D** *[′]* *[, 𝛾]* *[𝛼𝛼]* [(] **[D]** *[′]* [)] *[, 𝛾]* *[𝛽𝛽]* [(] **[D]** *[′]* [)] *[, 𝛾]* *[𝛼𝛽]* [(] **[D]** *[′]* [)] (7.79)

The *𝜁* -gradient-parameters are evaluated as a mixture of PT2 difference densities and SCF densities. For example:

*𝛾* *𝛼𝛼* (D *[′]* ) = 2 *∇* *[⃗]* *𝜌* *[𝛼]* D *′* *∇* *[⃗]* *𝜌* *[𝛼]* P *′* (7.80)

With

*𝜌* *[𝛼]* **D** *[′]* [ (] **[r]** [) =] ∑︁ *𝐷* *𝜇𝜈* *′* *𝛼* *[𝜑]* *[𝜇]* [(] **[r]** [)] *[ 𝜑]* *[𝜈]* [(] **[r]** [)] (7.81)

*𝜇𝜈*

*𝜌* *[𝛼]* **P** [(] **[r]** [) =] ∑︁ *𝑃* *𝜇𝜈* *[𝛼]* *[𝜑]* *[𝜇]* [(] **[r]** [)] *[ 𝜑]* *[𝜈]* [(] **[r]** [)] (7.82)

*𝜇𝜈*

Having defined the Lagrangian, the following CP-SCF equations need to be solved for the elements of the “Zvector”:

( *𝜀* *[𝜎]* *𝑎* *[−]* *[𝜀]* *[𝜎]* *𝑖* [)] *[ 𝑍]* *𝑎𝑖* *[𝜎]* [+] *[ 𝑅]* *[𝜎]* [(] **[Z]** [)] *𝑎𝑖* [=] *[ −][𝐿]* *𝑎𝑖* *[𝜎]* (7.83)

The solution defines the occupied-virtual block of the relaxed difference density, which is given by:

**D** *[𝜎]* = **D** *[′][𝜎]* + **Z** *[𝜎]* (7.84)

For convenience, **D** *[𝜎]* is symmetrized since it will only be contracted with symmetric matrices afterwards. After
having solved the Z-vector equations, all parts of the energy weighted difference density matrix can be readily
calculated:


︁ ︂

*𝑊* *[𝛼]* [;][PT2] = *−* [1]
*𝑖𝑗*


︁ ︂

2 *[𝑅]* [(] **[D]** [)] *[𝑖𝑗]* *[−]* ∑︁


︁ ︂

[1] 2 *[𝐷]* *𝑖𝑗* *[𝛼]* (︀ *𝜀* *[𝛼]* *𝑖* [+] *[ 𝜀]* *[𝛼]* *𝑗* )︀ *−* 2 [1]


︁ ︂

∑︁ ( *𝑖* *𝛼* *𝑎* *𝛼* *|𝑘* *𝛼* *𝑏* *𝛼* ) *𝑡* *[𝑗]* *𝑎* *[𝛼]* *𝛼* *[𝑘]* *𝑏* *[𝛼]* *𝛼* *[−]* ∑︁

*𝑘* *𝛼* *𝑎* *𝛼* *𝑏* *𝛼* *𝑘* *𝑎* *𝛼*


︁ ︂

∑︁ ( *𝑖* *𝛼* *𝑎* *𝛼* *|𝑘* *𝛽* *𝑏* *𝛽* ) *𝑡* *𝑏* *[𝑘]* *𝛽* *[𝛽]* *𝑎* *[𝑗]* *[𝛼]* *𝛼* (7.85)

*𝑘* *𝛽* *𝑎* *𝛼* *𝑏* *𝛽*


︁ ︂

*𝑊* *𝑎𝑏* *[𝛼]* [;][PT2] = *−* [1]


︁ ︂

∑︁ ( *𝑖* *𝛼* *𝑎* *𝛼* *|𝑗* *𝛼* *𝑐* *𝛼* ) *𝑡* *[𝑖]* *𝑏* *[𝛼]* *𝛼* *[𝑗]* *𝑐* *[𝛼]* *𝛼* *[−]* ∑︁

*𝑖* *𝛼* *𝑗* *𝛼* *𝑐* *𝛼* *𝑖* *𝛼* *𝑗* *𝛽* *𝑐*


︁ ︂

2 *[𝐷]* *𝑎𝑏* *[𝛼]* [(] *[𝜀]* *[𝛼]* *𝑎* [+] *[ 𝜀]* *[𝛼]* *𝑏* [)] *[ −]* ∑︁


︁ ︂

∑︁ ( *𝑖* *𝛼* *𝑎* *𝛼* *|𝑗* *𝛽* *𝑐* *𝛽* ) *𝑡* *𝑐* *[𝑗]* *[𝛽]* *𝛽* *[𝑖]* *𝑏* *[𝛼]* *𝛼* (7.86)

*𝑖* *𝛼* *𝑗* *𝛽* *𝑐* *𝛽*


︁ ︂

**7.13. The Second Order Many Body Pertubation Theory Module (MP2)** **547**

**ORCA Manual** **,** **Release 6.0.1**

*̸*


∑︁ ( *𝑘* *𝛼* *𝑖* *𝛼* *|𝑗* *𝛼* *𝑏* *𝛼* ) *𝑡* *[𝑘]* *𝑎* *[𝛼]* *𝛼* *[𝑗]* *𝑏* *[𝛼]* *𝛼* *[−]* [2] ∑︁

*𝑗* *𝛼* *𝑘* *𝛼* *𝑏* *𝛼* *𝑗* *𝛽* *𝑘* *𝛼*

*̸*


*𝑊* *𝑎𝑖* *[𝛼]* [;][PT2] = *−* 2 ∑︁

*̸*


∑︁ ( *𝑘* *𝛼* *𝑖* *𝛼* *|𝑗* *𝛽* *𝑏* *𝛽* ) *𝑡* *𝑏* *[𝑗]* *[𝛽]* *𝛽* *[𝑘]* *𝑎* *[𝛼]* *𝛼* (7.87)

*𝑗* *𝛽* *𝑘* *𝛼* *𝑏* *𝛽*

*̸*


*𝑊* *𝑖𝑎* *[𝛼]* [;][PT2] = *−𝜀* *[𝛼]* *𝑖* *[𝑍]* *𝑎𝑖* *[𝛼]* (7.88)

Once more, analogous equations hold for the spin-down case. With the relaxed difference density and energy
weighted density matrices in hand, one can finally proceed to evaluate the gradient of the PT2 part as ( **W** [PT2] =
**W** *[𝛼]* [;][PT2] + **W** *[𝛽]* [;][PT2] ):

*̸*


*𝐸* PT2 *[𝑥]* [=] *[ ⟨]* **[Dh]** *[𝑥]* *[⟩]* [+] ⟨︀ **W** [PT2] **S** [(] *[𝑥]* [)] [⟩︀] + [∑︀]

*̸*


*𝜇𝜈𝜅𝜏* [Γ] *𝜇𝜈𝜅𝜏* [PT2] [(] *[𝜇𝜈][|][𝜅𝜏]* [)] [(] *[𝑥]* [)]

*̸*


*𝑟* *𝑟*
*∇𝜌* *𝜎* *′* *∇𝜌* *𝜎* [(] *[𝑥]* [)]

*̸*


(7.89)
*𝑑* **r**

*̸* }︂


+ [∑︀] *𝜎*

( *𝜎* = *̸* *𝜎* *[′]* )


*𝛿𝜌𝛿* *𝜎* *𝑓* ( **r** ) *[𝜌]* [(] *𝜎* *[𝑥]* [)] + 2 *𝛿𝛾* *[𝛿]* *𝜎𝜎* *[𝑓]*

*̸* ∫︁{︂


*∇* *𝑟* *𝜌* *𝜎* *∇* *𝑟* *𝜌* *𝜎* [(] *[𝑥]* [)] + *𝛿𝛾𝛿* *𝜎𝜎* *𝑓*

*̸*


*̸*

The final derivative of eq. (7.56) is of course the sum *𝐸* *𝑆𝐶𝐹* *[𝑥]* [+] *[ 𝑐]* *[𝑃𝑇]* *[𝐸]* PT2 *[𝑥]* [. Both derivatives should be evaluated]
simultaneously in the interest of computational efficiency.

Note that the exchange-correlation contributions to the gradient take a somewhat more involved form than might
have been anticipated. In fact, from looking at the SCF XC-gradient (eq. (7.69)) it could have been speculated that
the PT2 part of the gradient is of the same form but with *𝜌* *[𝜎]* **P** [(] *[𝑥]* [)] being replaced by *𝐻* [ˆ], the relaxed PT2 difference
density. This is, however, not the case. The underlying reason for the added complexity apparent in equation (7.89)
is that the XC contributions to the PT2 gradient arise from the contraction of the relaxed PT2 difference density with
the derivative of the SCF operator. Since the SCF operator already contains the first derivative of the XC potential
and the PT2 energy is not stationary with respect to changes in the SCF density, a response type term arises which
requires the evaluation of the second functional derivative of the XC-functional. Finally, as is well known from
MP2 gradient theory, the effective two- particle density matrix contains a separable and a non-separable part:

Γ [PT2] *𝜇𝜈𝜅𝜏* [=] *[ 𝐷]* *[𝜇𝜈]* *[𝑃]* *[𝜅𝜏]* *[−]* *[𝐷]* *𝜇𝜅* *[𝛼]* *[𝑃]* *𝜈𝜏* *[𝛼]* *[−]* *[𝐷]* *𝜇𝜅* *[𝛽]* *[𝑃]* *𝜈𝜏* *[𝛽]* [+ Γ] [NS] *𝜇𝜈𝜅𝜏* (7.90)


*̸*

∑︁ *𝑐* *[𝛼]* *𝜇𝑖* *[𝑐]* *𝜈𝑎* *[𝛼]* *[𝑐]* *[𝛼]* *𝜅𝑗* *[𝑐]* *𝜏𝑏* *[𝛼]* *[𝑡]* *[𝑖]* *𝑎* *[𝛼]* *𝛼* *[𝑗]* *𝑏* *[𝛼]* *𝛼* [+] ∑︁

*𝑖* *𝛼* *𝑗* *𝛼* *𝑎* *𝛼* *𝑏* *𝛼* *𝑖* *𝛽* *𝑗* *𝛽* *𝑎* *𝛽*


*̸*

∑︁ *𝑐* *[𝛼]* *𝜇𝑖* *[𝑐]* *𝜈𝑎* *[𝛼]* *[𝑐]* *[𝛽]* *𝜅𝑗* *[𝑐]* *𝜏𝑏* *[𝛽]* *[𝑡]* *𝑎* *[𝑖]* *[𝛼]* *𝛼* *[𝑗]* *𝑏* *[𝛽]* *𝛽* (7.91)

*𝑖* *𝛼* *𝑗* *𝛽* *𝑎* *𝛼* *𝑏* *𝛽*


*̸*

Γ [NS]
*𝜇𝜈𝜅𝜏* [=] ∑︁


*̸*

∑︁ *𝑐* *[𝛽]* *𝜇𝑖* *[𝑐]* *𝜈𝑎* *[𝛽]* *[𝑐]* *[𝛽]* *𝜅𝑗* *[𝑐]* *𝜏𝑏* *[𝛽]* *[𝑡]* *𝑎* *[𝑖]* *[𝛽]* *𝛽* *[𝑗]* *𝑏* *[𝛽]* *𝛽* [+ 2] ∑︁

*𝑖* *𝛽* *𝑗* *𝛽* *𝑎* *𝛽* *𝑏* *𝛽* *𝑖* *𝛼* *𝑗* *𝛽* *𝑎* *𝛼*


*̸*

Thus, the non-separable part is merely the back-transformation of the amplitudes from the MO to the AO basis. It
is, however, important to symmetrize the two-particle density matrix in order to be able to exploit the full permutational symmetry of the AO derivative integrals.

**7.13.4 Orbital Optimized MP2**

The MP2 energy can be regarded as being stationary with respect to the MP2 amplitudes, since they can be considered as having been optimized through the minimization of the Hylleraas functional:


*̸*

*𝐸* MP2 = min
**t**


*̸*

2 Ψ 1 *|𝐻* [ˆ] *|* Ψ 0 + Ψ 1 *|𝐻* [ˆ] 0 *−* *𝐸* 0 *|* Ψ 1 (7.92)
{︁ ⟨ ⟩ ⟨ ⟩}︁


*̸*

*𝐻* ˆ is the 0 *[𝑡ℎ]* order Hamiltonian as proposed by Møller and Plesset, Ψ 0 is the reference determinant, Ψ 1 is the
first-order wave function and *𝐸* 0 = *𝐸* HF = *⟨* Ψ HF *|* *𝐻* [ˆ] *|* Ψ HF *⟩* is the reference energy. The quantities **t** collectively
denote the MP2 amplitudes.

The fundamental idea of the OO-MP2 method is to not only minimize the MP2 energy with respect to the MP2
amplitudes, but to minimize the total energy additionally with respect to changes in the orbitals. Since the MP2
energy is not variational with respect to the MO coefficients, no orbital relaxation due to the correlation field is taken
into account. If the reference determinant is poor, the low-order perturbative correction then becomes unreliable.
This may be alleviated to a large extent by choosing better orbitals in the reference determinant. Numerical evidence
for the correctness of this assumption will be presented below.

In order to allow for orbital relaxation, the Hylleraas functional can be regarded as a functional of the wavefunction
amplitudes **t** and the orbital rotation parameters **R** that will be defined below. Through a suitable parameterization
it becomes unnecessary to ensure orbital orthonormality through Lagrange multipliers. The functional that we
minimize reads:

*𝐿* *{* **t** *,* **R** *}* = *𝐸* 0 [ **R** ] + 2 *⟨* Ψ 1 *|* *𝐻* [ˆ] *|* Ψ 0 *⟩* + *⟨* Ψ 1 *|* *𝐻* [ˆ] 0 *−* *𝐸* 0 *|* Ψ 1 *⟩* (7.93)

**548** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Ψ 0 is the reference determinant. However, it does no longer correspond to the Hartree-Fock (HF) determinant.
Hence, the reference energy *𝐸* 0 [ **R** ] = *⟨* Ψ 0 [ **R** ] *|* *𝐻* [ˆ] *|* Ψ 0 [ **R** ] *⟩* also changes during the variational process and is no
longer stationary with respect to the HF MO coefficients. Obviously, *𝐸* 0 [ **R** ] ⩾ *𝐸* HF since the HF determinant is,
by construction, the single determinant with the lowest expectation value of the full Hamiltonian.

The reference energy is given as:


*⟨𝑖| ℎ* *|𝑖⟩* + [1]

2

*𝑖*


*𝐸* 0 [ **R** ] = ∑︁


2


∑︁ *⟨𝑖𝑗||𝑖𝑗⟩* (7.94)

*𝑖𝑗*


The first-order wave function excluding single excitations is:


*|* Ψ 1 *⟩* = [1]

4


∑︁ *𝑡* *[𝑖𝑗]* *𝑎𝑏* *[|]* [ Ψ] *[𝑎𝑏]* *𝑖𝑗* ⟩︀ (7.95)

*𝑖𝑗𝑎𝑏*


A conceptually important point is that Brillouin’s theorem [419] is no longer obeyed since the Fock matrix will
contain off-diagonal blocks. Under these circumstances the first-order wavefunction would contain contributions
from single excitations. Since the orbital optimization brings in all important effects of the singles we prefer to
leave them out of the treatment. Any attempt to the contrary will destroy the convergence properties. We have
nevertheless contemplated to include the single excitations perturbatively:


*𝐸* Singles [(2)] [=] *[ −]* ∑︁

*𝑖𝑎*


*|* *𝐹* *𝑖𝑎* *|* [2]

*𝜀* *𝑎* *−* *𝜀* *𝑖* (7.96)


The perturbative nature of this correction would destroy the stationary nature of the total energy and is hence not
desirable. Furthermore, results with inclusion of single excitation contributions represent no improvement to the
results reported below. They will therefore not be documented below and henceforth be omitted from the OO-MP2
method by default.

The explicit form of the orbital-optimized MP2 Hylleraas functional employing the RI approximation (OO-RIMP2) becomes:


*⟨𝑖|ℎ* [ˆ] *|𝑖⟩* + [1]

2

*𝑖*


*𝐷* *𝑎𝑏* *𝐹* *𝑎𝑏* (7.97)
*𝑎𝑏*


*𝐿* *∞* [ **t** *,* **R** ] = ∑︁


2


∑︁ ( *𝑖𝑎|𝑃* )Γ *′* *𝑖𝑎𝑃* [+] ∑︁

*𝑖𝑎𝑃* *𝑖𝑗*


*𝐷* *𝑖𝑗* *𝐹* *𝑖𝑗* + ∑︁
*𝑖𝑗* *𝑎𝑏*


∑︁


*⟨𝑖𝑗||𝑖𝑗⟩* + ∑︁
*𝑖𝑗* *𝑖𝑎𝑃*


with:


Γ *′* *𝑖𝑎𝑃* [=] ∑︁


( *𝑄|𝑗𝑏* ) *𝑡* *[𝑖𝑗]* *𝑎𝑏* (7.98)
*𝑗𝑏*


*𝑉* *[−]* [1]

∑︁ *𝑃𝑄* ∑︁

*𝑄* *𝑗𝑏*


1
( *𝑖𝑎|𝑃* ) = *𝜓* *𝑖* ( **r** 1 ) *𝜓* *𝑎* ( **r** 1 ) (7.99)
∫︁∫︁ *|* **r** 1 *−* **r** 2 *|* *[𝜂]* *[𝑃]* [(] **[r]** [2] [)] *[𝑑]* **[r]** [1] *[𝑑]* **[r]** [2]

1
( *𝑃* *|𝑄* ) = *𝜂* *𝑝* ( **r** 1 ) (7.100)
∫︁∫︁ *|* **r** 1 *−* **r** 2 *|* *[𝜂]* *[𝑄]* [(] **[r]** [2] [)] *[𝑑]* **[r]** [1] *[𝑑]* **[r]** [2]

Here, *{𝜓}* is the set of orthonormal molecular orbitals and *{𝜂}* denotes the auxiliary basis set. *𝐹* *𝑝𝑞* denotes a Fock
matrix element:

*𝐹* *𝑝𝑞* = *⟨𝑝|* *ℎ* [ˆ] *|𝑞⟩* + ∑︁ *⟨𝑝𝑘||𝑞𝑘⟩* (7.101)

*𝑘*

and it is insisted that the orbitals diagonalize the occupied and virtual subspaces, respectively:

*𝐹𝐹* *𝑖𝑗𝑎𝑏* == *𝛿 𝛿* *𝑖𝑗𝑎𝑏* *𝐹𝐹* *𝑖𝑖𝑎𝑎* == *𝛿 𝛿* *𝑖𝑗𝑎𝑏* *𝜀* *𝑖* *𝜀* *𝑎* (7.102)

The MP2 like density blocks are,


*𝐷* *𝑖𝑗* = *−* [1] 2 ∑︀ *𝑘𝑎𝑏* *[𝑡]* *𝑎𝑏* *[𝑖𝑘]* *[𝑡]* *[𝑗𝑘]* *𝑎𝑏*

*𝐷* *𝑎𝑏* = [1] ∑︀ *[𝑡]* *[𝑖𝑗]* *[𝑡]* *[𝑖𝑗]*


*𝐷* *𝑖𝑗* = *−* [1] 2


(7.103)
*𝑖𝑗𝑐* *[𝑡]* *𝑎𝑐* *[𝑖𝑗]* *[𝑡]* *[𝑖𝑗]* *𝑏𝑐*



[1] 2 ∑︀


**7.13. The Second Order Many Body Pertubation Theory Module (MP2)** **549**

**ORCA Manual** **,** **Release 6.0.1**

where the MP2 amplitudes in the case of a block diagonal Fock matrix are obtained through the condition *[𝜕𝐿]* *𝜕𝑡* *[𝑖𝑗]* *𝑎𝑏* *[∞]* [= 0][:]

*⟨* *𝑖* *𝑗||* *𝑎𝑏* *⟩*
*𝑡* *[𝑖𝑗]* *𝑎𝑏* [=] *[ −]* *𝜀* *𝑎* + *𝜀* *𝑏* *−* *𝜀* *𝑖* *−* *𝜀* *𝑗* (7.104)

The orbital changes are parameterized by an anti-Hermitian matrix **R** and an exponential Ansatz,

**c** [new] = **c** [old] exp( **R** )


0 **R** *𝑖𝑎*
**R** =
(︂ *−* **R** *𝑖𝑎* 0


)︂ (7.105)


The orbitals changes to second order are,


*𝑎* **[R]** *[𝑎𝑖]* *[|][𝑎][⟩−]* 2 [1]


exp( **R** ) *|𝑖⟩* = *|𝑖⟩* + [∑︀]


2 [1] ∑︀


(7.106)
2 [1] ∑︀ *𝑗𝑏* **[R]** *[𝑎𝑗]* **[R]** *[𝑏𝑗]* *[|][𝑏][⟩]* [+] *[ . . .]*


exp( **R** ) *|𝑖⟩* = *|𝑖⟩* + [∑︀] *𝑎* **[R]** *[𝑎𝑖]* *[|][𝑎][⟩−]* 2 ∑︀ *𝑗𝑏* **[R]** *[𝑏𝑖]* **[R]** *[𝑏𝑗]* *[|][𝑗][⟩]* [+] *[ . . .]*

exp( **R** ) *|𝑎⟩* = *|𝑎⟩−* [∑︀] *𝑖* **[R]** *[𝑎𝑖]* *[|][𝑖][⟩−]* 2 [1] ∑︀ **[R]** *[𝑎𝑗]* **[R]** *[𝑏𝑗]* *[|][𝑏][⟩]* [+] *[ . . .]*


Through this Ansatz it is ensured that the orbitals remain orthonormal and no Lagrangian multipliers need to be
introduced. The first-order expansion of the Fock operator due to the orbital rotations are:

*𝐹* *𝑝𝑞* [ *𝑅* ] = *𝐹* *𝑝𝑞* [0] + *𝑅* *𝑝𝑞* [(1)] [+] ∑︁ *𝑅* *𝑟𝑝* *𝐹* *𝑟𝑞* [0] + *𝑅* *𝑟𝑞* *𝐹* *𝑝𝑟* [0] (7.107)

*𝑟*

*𝑅* *𝑝𝑞* [(1)] [=] ∑︁ *𝑅* *𝑐𝑘* *{⟨𝑝𝑐||𝑞𝑘⟩* + *⟨𝑝𝑘||𝑞𝑐⟩}* (7.108)

*𝑘𝑐*

The first-order energy change becomes *ℎ* *𝑝𝑞* *≡⟨𝑝|* *ℎ* [ˆ] *|𝑞⟩* *, 𝑔* *𝑝𝑞𝑟𝑠* *≡⟨𝑝𝑞||𝑟𝑠⟩* :
(︁ )︁



[1]
*𝑖𝑐* *[𝑅]* *[𝑐𝑖]* [(] *[ℎ]* *[𝑐𝑖]* [+] *[ ℎ]* *[𝑖𝑐]* [) +] 2


*𝐿* *∞* [ **t** *,* **R** ] = [∑︀]



[1] 2 ∑︀


+2 *𝑖𝑐* *[𝑅]* [∑︀] *[𝑐𝑖]* *𝑖𝑎𝑐𝑃* [(] *[ℎ]* *[𝑐𝑖]* *[𝑅]* [+] *[𝑐𝑖]* *[ ℎ]* [(] *[𝑖𝑐]* *[𝑎𝑐]* [) +] *[|][𝑃]* [)Γ] 2 ∑︀ *′* *𝑖𝑎𝑃* *𝑖𝑗𝑐* *[−]* *[𝑅]* [2][ ∑︀] *[𝑐𝑖]* [(] *𝑖𝑘𝑎𝑃* *[𝑔]* *[𝑐𝑗𝑖𝑗]* *[𝑅]* [+] *[𝑎𝑘]* *[ 𝑔]* [(] *[𝑖𝑗𝑐𝑗]* *[𝑖𝑘][|][𝑃]* [) +][)Γ] *[ 𝑅]* *′* *𝑖𝑎𝑃* *[𝑐𝑗]* [(] *[𝑔]* *[𝑖𝑐𝑖𝑗]* [+] *[ 𝑔]* *[𝑖𝑗𝑖𝑐]* [)]



[∑︀] *𝑖𝑎𝑐𝑃* *[𝑅]* *[𝑐𝑖]* [(] *[𝑎𝑐][|][𝑃]* [)Γ] *′* *𝑖𝑎𝑃* *[−]* [2][ ∑︀] *𝑖𝑘𝑎𝑃* *[𝑅]* *[𝑎𝑘]* [(] *[𝑖𝑘][|][𝑃]* [)Γ] *′* *𝑖𝑎𝑃*

*−* [∑︀] *[𝐷]* *[𝑖𝑗]* *𝑅* [(1)] [+][ ∑︀] *𝑐* [(] *[𝑅]* *[𝑐𝑖]* *[𝐹]* *[𝑐𝑗]* [+] *[ 𝑅]* *[𝑐𝑗]* *[𝐹]* *[𝑖𝑐]* [)]


*′* *𝑃*
*𝑖𝑎𝑐𝑃* *[𝑅]* *[𝑐𝑖]* [(] *[𝑎𝑐][|][𝑃]* [)Γ] *𝑖𝑎* *[−]* [2][ ∑︀]


*𝑐* [(] *[𝑅]* *[𝑐𝑖]* *[𝐹]* *[𝑐𝑗]* [+] *[ 𝑅]* *[𝑐𝑗]* *[𝐹]* *[𝑖𝑐]* [)]
)︁


*𝑅* [(1)]
*𝑖𝑗* *[𝐷]* *[𝑖𝑗]* (︁ *𝑖𝑗* [+][ ∑︀]


*𝑎𝑏* *[𝐷]* *[𝑎𝑏]* *𝑅* *𝑎𝑏* [(1)] *[−]* [∑︀]
(︁


+ [∑︀]


(7.109)

*𝑐* [(] *[𝑅]* *[𝑐𝑖]* *[𝐹]* *[𝑐𝑗]* [+] *[ 𝑅]* *[𝑐𝑗]* *[𝐹]* *[𝑖𝑐]* [)]
)︁

*𝑘* [(] *[𝑅]* *[𝑎𝑘]* *[𝐹]* *[𝑘𝑏]* [+] *[ 𝑅]* *[𝑏𝑘]* *[𝐹]* *[𝑎𝑘]* [)]
)︁


*𝜕𝐿* *∞* [ **t** *,* **R** ]
The condition for the energy functional to be stationary with respect to the orbital rotations (︁ *𝜕𝑅* *𝑎𝑖* = 0)︁, yields

the expression for the orbital gradient and hence the expression for the OO-RI-MP2 Lagrangian.


*𝜕𝐿* *∞* [ **t** *,* **R** ]


*𝐷* *𝑖𝑗* *𝐹* *𝑎𝑗* *−* 2 ∑︁
*𝑗* *𝑏*


*∞* *,*

*𝜕𝑅* *𝑎𝑖* *≡* *𝑔* *𝑎𝑖* = 2 *𝐹* *𝑎𝑖* + 2 ∑︁


*𝐷* *𝑎𝑏* *𝐹* *𝑖𝑏* + *𝑅* [(1)] ( **D** ) *𝑎𝑖* (7.110)

*𝑏*


∑︁ ( *𝑎𝑐|𝑃* )Γ *[′]* *𝑖𝑎* *[𝑃]* *[−]* [2] ∑︁

*𝑐𝑃* *𝑘𝑃*


+2
∑︁


∑︁ ( *𝑖𝑘|𝑃* )Γ *[′]* *𝑖𝑎* *[𝑃]*

*𝑘𝑃*


The goal of the orbital optimization process is to bring this gradient to zero. There are obviously many ways to
achieve this. In our experience, the following simple procedure is essentially satisfactory. We first build a matrix
**B** in the current MO basis with the following structure:

**B** *𝑖𝑗* = *𝛿* *𝑖𝑗* **F** *𝑖𝑖*
**B** *𝑎𝑏* = *𝛿* *𝑎𝑏* ( **F** *𝑎𝑎* + **Δ** ) (7.111)
**B** *𝑎𝑖* = **B** *𝑖𝑎* = **g** *𝑎𝑖*

where ∆ is a level shift parameter. The occupied/occupied and virtual/virtual blocks of this matrix are arbitrary
but their definition has a bearing on the convergence properties of the method. The orbital energies of the block
diagonalized Fock matrix appear to be a logical choice. If the gradient is zero, the **B** -matrix is diagonal. Hence
one obtains an improved set of orbitals by diagonalizing **B** .

In order to accelerate convergence a standard DIIS scheme is used. [451, 576] However, in order to carry out the
DIIS extrapolation of the **B** -matrix it is essential that a common basis is used that does not change from iteration
to iteration. Since the **B** -matrix itself is defined in the molecular orbitals of the current iteration we choose as a
common set of orthonormal orbitals the MOs of the HF calculation. The extrapolation is carried out in this basis
and the extrapolated **B** -matrix is transformed back to the current set of MOs prior to diagonalization. Obviously,
the same strategy can be used for orbital optimization in any method for which an orbital gradient is available.

For well behaved cases this simple scheme converges in 5-10 iterations. Transition metals and more complicated
molecules may require up to 20 iterations and level shifting in order to achieve convergence.

Upon convergence the sum of the matrix **D** and the density of the reference determinant *𝑃* *𝜇𝜈* = [∑︀] *𝑖* *[𝑐]* *[𝜇𝑖]* *[𝑐]* *[𝜈𝑖]* [form the]

true one-particle density matrix of the OO-MP2 approach that can be used for property or gradient calculations.

**550** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.13.5 Regularized MP2 and RI-MP2**

Regularized MP2 is a variant of second-order Moller-Plesset theory (MP2) introduced by J. Shee, M. Loipersberger,
A. Rettig, J. Lee, and M. Head-Gordon [791] that aims to improve its accuracy for systems with *𝜋* -driven dispersion
interactions and dative bonds in transition metal complexes. The approach achieves this by introducing a singleparameter, energy-gap dependent regularization that dampens overestimated pairwise additive contributions, thus
renormalizing first-order amplitudes to empirically mimic higher-order correlations.

For this, the standard MP2 energy and thus the standard algorithms are modified. For the *𝜎* ( *𝑝* = 1) and *𝜎* [2] ( *𝑝* = 2)
regularization, the energy is modified according to


*𝐸* *𝜎* *𝑝* -MP2 = *−* [1] 4


∑︁

*𝑖𝑗𝑎𝑏*


*|* *⟨* *𝑖* *𝑗||* *𝑎𝑏* *⟩|* [2]

(1 *−* *𝑒* *[−][𝜎]* [(Δ] *𝑖𝑗* *[𝑎𝑏]* [)] *[𝑝]* )
∆ *[𝑎𝑏]*
*𝑖𝑗*


which corresponds to regularizing the first-order amplitudes. For the *𝜅* regularization, the MP2 energy is modified
according to


*𝐸* *𝜅* -MP2 = *−* [1] 4


∑︁

*𝑖𝑗𝑎𝑏*


*|* *⟨* *𝑖* *𝑗||* *𝑎𝑏* *⟩|* [2]

∆ *[𝑎𝑏]*
*𝑖𝑗*


(︁1 *−* *𝑒* *[−][𝜅]* [(Δ] *𝑖𝑗* *[𝑎𝑏]* [)] [)︁] [2]


which corresponds to regularizing the first-order amplitudes and the exchange integrals.

Regularized MP2 is available for standard MP2 in “memory mode” (Q1Opt *>* 0) and RI-MP2 (RIJDX, RIJCOSX,
RIJK).

The usage of regularized MP2 is controlled by the `DoRegMP2` keyword, the type of regularization can be specified
by setting the `RegMP2Type` parameter to 0 for *𝜅*, 1 for *𝜎*, or 2 for *𝜎* [2] . The value of the regularizers can be specified
by `RegMP2Kappa` and `RegMP2Sigma` respectively.



It is important to note that only single point energies are available and tested for regularized MP2. Density, Gradient,
and Hessian calculations are not yet supported.

**7.13.6 RIJCOSX-RI-MP2 Gradients**

Additional grids are introduced for the RIJCOSX-MP2 gradient. They have sensible default settings and therefore
do not usually require any intervention from the user. However, a number of expert options are available, as
described below.

The COSX terms in the Z-vector equations are calculated on a grid, controlled by the keywords `Z_GridX` and
`Z_IntAccX`, as discussed in sections *Changing TD-DFT, CP-SCF and Hessian grids* and *CP-SCF Options* . For
example, the `DefGrid3` CP-SCF COSX grid can be requested as:



The grid used for evaluation of the response operator on the right-hand side of the Z-vector equations (see for
example eqs (7.77) and (7.78)) can be independently selected using the keyword `Z_GridX_RHS` . Note that starting
with ORCA 5, the usage is different to `Z_GridX` - the choice is between one of the three grids used during the
RIJCOSX SCF procedure: a small grid for the initial iterations, a medium grid for the final iterations (default in
ORCA 5), and a large grid to evaluate the energy more accurately after the iterations have converged.

**7.13. The Second Order Many Body Pertubation Theory Module (MP2)** **551**

**ORCA Manual** **,** **Release 6.0.1**



Yet another grid is used to evaluate basis functions derivatives. Appropriate parameters are chosen through `!`
`DefGridn` (in addition to the three SCF grids), but one can override this by setting the angular ( `GridX` ) and radial
( `IntAccX` ) grids explicitly through:



**7.13.7 MP2 and RI-MP2 Second Derivatives**

Analytical second-order properties with the MP2, RI-MP2 and double-hybrid DFT methods are available in ORCA
for calculations without frozen core orbitals. The most expensive term in the second derivative calculations is the
four-external contribution which can be evaluated either via an AO direct (default) or a semi-numerical Chain-ofSpheres approach. In case that the latter approach is chosen, appropriate grid parameters are defined through the
`! DefGridn` settings. However, a more fine-grained specification is available to expert users as follows:



Alternatively, all the grid settings can be defined in the `%method` block, as discussed in section *SCF grid keyword*
*list* . The first three entries define the three SCF grids, the fourth entry the MP2 grid for basis function derivatives
(refer to section *RIJCOSX-RI-MP2 Gradients* ) and the fifth entry the grid for the four-external contribution.



**7.13.8 RI-MP2 and Double-Hybrid DFT Response Properties**

Starting from ORCA 5, both the electric (for the dipole polarizability) and the magnetic (for NMR shielding and
the EPR g-tensor) field response as well as the nucleus-orbit response (hyperfine couplings *𝐴* orb term) for RI-MP2
(and double-hybrid functionals) is handled by a different implementation of the RI-MP2 second derivatives than
that used for geometric Hessian calculations ( *MP2 and RI-MP2 Second Derivatives* ). This code is more efficient,
uses the RI approximation throughout (including the four-external contribution) and supports frozen core orbitals.
The implementation is described in detail in refs [829, 850]. Consider the following input for a GIAO-RI-MP2
NMR shielding calculation:



(continues on next page)

**552** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

By default perturbed canonical orbitals are used for the occupied block, i.e., the internal orbital rotation coefficients
are chosen as

*𝐹* *𝑖* [(] *𝑗* **[B]** [)] *−* *𝑆* *𝑖* [(] *𝑗* **[B]** [)] *[𝜀]* *[𝑗]*
*𝑈* **[B]**
*𝑖𝑗* [=] *𝜀* *𝑗* *−* *𝜀* *𝑖*

which results in *𝐹* **[B]**
*𝑖𝑗* [= 0][, thereby eliminating its contribution to the perturbed amplitudes:]


*𝑇* *𝑎𝑏* *[𝑖𝑗,]* **[B]** *←−* ∑︁

*𝑘*



[︁ *𝑇* *𝑎𝑏* *[𝑖𝑘]* *[𝐹]* *𝑘𝑗* **[B]** [+] *[ 𝑇]* *𝑎𝑏* *[𝑘𝑗]* *[𝐹]* *𝑘𝑖* **[B]** ]︁ (7.112)


If *|𝜖* *𝑗* *−* *𝜖* *𝑖* *| <* `PertCan_EThresh` or *|𝑈* *𝑖𝑗* *[𝐵]* *[|][ >]* `[ PertCan_UThresh]` [, then] *[ 𝑈]* *𝑖𝑗* **[B]** [is chosen using the standard formula]

*𝑈* **[B]**
*𝑖𝑗* [=] *[ −]* 2 [1] *[𝑆]* *𝑖𝑗* [(] **[B]** [)]

And the relevant contributions to eq (7.112) are added, unless ⃒⃒ *𝐹* *𝑖𝑗* **B** ⃒⃒ *<* `FCut` . The required amplitudes **T** *𝑖𝑘* and **T** *𝑘𝑗*

(all amplitudes, in case `UsePertCanOrbs = false` ) are stored on disk if `RespStoreT = true` or recalculated
as needed otherwise. The latter option is significantly slower and not recommended unless disk space is an issue.
Similarly, in the case of insufficient RAM, the option `RespDijConv = true` tells ORCA to store all amplitudes in
the batch (required to calculate *𝐷* *𝑖𝑗* **[B]** [) on disk, rather than keep them in memory. The 3-index 2-particle densities,]
needed for the right-hand side of the Z-vector equations, are always stored on disk.

Note also that in this implementation the RIJCOSX Fock-response terms are calculated with one of the SCF grids,
chosen with `Z_GridX_RHS` (see section *CP-SCF Options* ).

**7.13.9 Local MP2**

In analogy to the domain-based local pair natural orbital coupled-cluster methods, there is also a local linear scaling
version of MP2 (DLPNO-MP2) implemented in ORCA. Its default thresholds are chosen to reproduce about 99.9%
of the total RI-MP2 correlation energy, resulting in an accuracy of a fraction of 1 kcal/mol for energy differences.
The theory has been described in the literature.[654, 685]

Further information of local correlation methods in ORCA can be found in section *Local correlation* . The local
MP2 method becomes truly beneficial for very large molecules and can be used to compute energies of systems
containing several hundred atoms. Fig. 7.3 shows the scaling behavior for linear alkane chains. Note that this
represents an idealized situation. For three-dimensional molecules the crossover with canonical RI-MP2 is going
to occur at a later point.

**7.13. The Second Order Many Body Pertubation Theory Module (MP2)** **553**

**ORCA Manual** **,** **Release 6.0.1**

*̸* *̸*


Fig. 7.3: Scaling of the DLPNO-MP2 method with default thresholds for linear alkane chains in def2-TZVP basis.
Shown are also the times for the corresponding Hartree-Fock calculations with RIJCOSX and for RI-MP2.

In the following, the most important design principles of the RHF-DLPNO-MP2 are pointed out.

  - Unlike in the 2013 version of the DLPNO methodology, domains are selected by means of the differen
tial overlap ~~√~~ ︁∫︀ *𝑖* [2] ( **r** )˜ *𝜇* *[′]* [2] ( **r** ) *𝑑* **r** between localized MOs *𝑖* and projected atomic orbitals (PAOs) ˜ *𝜇* *[′]* which are

normalized to unity. The default value for the corresponding cutoff is *𝑇* CutDO = 10 *[−]* [2] .

  - MP2 amplitudes for each pair of localized orbitals *𝑖𝑗* are expressed in a basis of pair natural orbitals (PNOs)
*𝑎* ˜ *𝑖𝑗* . PNOs are obtained from diagonalization of an approximate, “semicanonical” MP2 pair density **D** *[𝑖𝑗]* .
Only PNOs with an occupation number *> 𝑇* CutPNO are retained, with a default value of *𝑇* CutPNO = 10 *[−]* [8] for
DLPNO-MP2. The pair density is given by:

( *𝑖* *𝜇* ˜ *|𝑗* *𝜈* ˜ )
**D** *[𝑖𝑗]* = **T** *[𝑖𝑗][†]* [ ˜] **T** *[𝑖𝑗]* + **T** *[𝑖𝑗]* **T** [˜] *[𝑖𝑗][†]* where ˜ *𝑇* *𝜇* ˜ *[𝑖𝑗]* *𝜈* ˜ [=] *[ −]* *𝜀* *𝜇* ˜ + *𝜀* *𝜈* ˜ *−* *𝐹* *𝑖𝑖* *−* *𝐹* *𝑗𝑗*
**T** *[𝑖𝑗]* = (1 + *𝛿* *𝑖𝑗* ) *[−]* [1] [ (︀] 4 **T** *[𝑖𝑗]* *−* 2 **T** *[𝑖𝑗][†]* [)︀]

  - Since the occupied block of the Fock matrix is not diagonal in the basis of localized orbitals, the MP2
amplitudes **T** *[𝑖𝑗]* are obtained by solving the following set of residual equations iteratively (where subscripts
of PNOs have been dropped):

*̸* *̸*


*𝑅* *𝑎* *[𝑖𝑗]* ˜ [˜] *𝑏* [=] (︁ *𝑖𝑎* ˜⃒⃒⃒ *𝑗* ˜ *𝑏* )︁ + (︀ *𝜀* *𝑎* ˜ + *𝜀* ˜ *𝑏* *−* *𝐹* *𝑖𝑖* *−* *𝐹* *𝑗𝑗* )︀ *𝑇* *𝑎* ˜ *[𝑖𝑗]* [˜] *𝑏* *[−]* ∑︁

*𝑘* = *̸* *𝑖* *̸*


*𝐹* *𝑖𝑘* *𝑆* *𝑎* ˜ *[𝑖𝑗,𝑘𝑗]* *𝑐* ˜ *𝑇* *𝑐* ˜ *[𝑘𝑗]* *𝑑* [˜] *[𝑆]* *𝑑* *[𝑘𝑗,𝑖𝑗]* ˜˜ *𝑏* *−* ∑︁

*̸* *𝑐* ˜ *𝑑* [˜] *𝑘* = *̸* *𝑗*


*̸* *𝑘* = *̸* *𝑗*


∑︁

*̸* *̸*


∑︁ *𝐹* *𝑘𝑗* *𝑆* *𝑎* ˜ *[𝑖𝑗,𝑖𝑘]* *𝑐* ˜ *𝑇* *𝑐* ˜ *[𝑖𝑘]* *𝑑* [˜] *[𝑆]* *𝑑* *[𝑖𝑘,𝑖𝑗]* ˜˜ *𝑏* = 0

*̸* *̸* *𝑐* ˜ *𝑑* [˜]


*̸* *̸*

  - The largest part of the error relative to canonical RI-MP2 is controlled by the domain ( `TCutDO` ) and PNO
( `TCutPNO` ) thresholds, which should be adequate for most applications. If increased accuracy is needed
(e.g. for studying weak interactions), tighter truncation criteria can be invoked by means of the `! TightPNO`
keyword. Conversely, a less accurate but faster calculation can be performed with the `! LoosePNO` keyword.
For more details refer to table Table 7.17.

  - Fitting domains are determined by means of orbital Mulliken populations with a threshold *𝑇* CutMKN = 10 *[−]* [3] .
This threshold results in an error contribution that is typically about an order of magnitude smaller than the
overall total energy deviation from RI-MP2.

**554** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

  - Prior to performing the local MP2 calculation, pairs of localized molecular orbitals *𝑖𝑗* are prescreened using
an MP2 energy estimate with a dipole approximation, and the differential overlap integral between orbitals
*𝑖* and *𝑗* . This procedure has been chosen conservatively and leads to minimal errors.

  - Residual evaluation can be accelerated significantly by neglecting terms with associated Fock matrix elements *𝐹* *𝑖𝑘* and *𝐹* *𝑘𝑗* below *𝐹* Cut = 10 *[−]* [5] . Errors resulting from this approximation are typically below 1 *𝜇* E h
and thus negligible.

  - Sparsity of the MO and PAO coefficient matrices in atomic orbital basis is exploited to accelerate integral
transformations for large systems. Truncation of the coefficients is controlled by a parameter *𝑇* CutC . Neglect
of these coefficients has to be performed very carefully in order to avoid uncontrollable errors. The threshold
has been chosen so as to make the errors essentially vanish.

  - By default, core orbitals are frozen in the MP2 module. However, if core orbitals are subject to an MP2
treatment, it is necessary to use a tighter PNO cutoff for pairs involving at least one core orbital. For this
purpose core orbitals and valence orbitals are localized separately. The cutoff for pairs involving core orbitals
is given by *𝑇* CutPNO *× 𝑇* ScalePNO_Core, where *𝑇* ScalePNO_Core = 10 *[−]* [2] by default. For more details refer to
section *Including (semi)core orbitals in the correlation treatment* .

The UHF-DLPNO-MP2 implementation differs somewhat from the RHF case, particularly regarding construction
of PNOs, as described below.

  - A separate set of PAOs ˜ *𝜇* *[′]* *𝛼* [and][ ˜] *[𝜇]* *[′]* *𝛽* [is obtained for each spin case.]

  - For *𝛼𝛽* pairs, separate pair domains of PAOs need to be determined for each spin case. For example, the *𝛼*
pair domain [ *𝑖* *𝛼* *𝑗* *𝛽* ] *𝛼* is the union of the domains [ *𝑖* *𝛼* ] *𝛼* and [ *𝑗* *𝛽* ] *𝛼* . The latter domain [ *𝑗* *𝛽* ] *𝛼* is determined by
evaluating the spatial differential overlap between *𝑗* *𝛽* and *𝛼* -spin PAOs ˜ *𝜇* *[′]* *𝛼* [.]

  - One set of PNOs is needed for each same-spin pair. Opposite-spin pairs require a set of *𝛼* -PNOs and a set
of *𝛽* -PNOs. In total this results in four types of PNO sets.

  - Semicanonical amplitudes are obtained as follows, where *𝑖, 𝑗* are spin orbitals and ˜ *𝜇𝜈* ˜ are nonredundant spin
PAOs.

*⟨* *𝑖* *𝑗||𝜇* ˜ *𝜈* ˜ *⟩*
*𝑇* *𝜇* ˜ *[𝑖𝑗]* *𝜈* ˜ [=] *[ −]* *𝜀* *𝜇* ˜ + *𝜀* *𝜈* ˜ *−* *𝐹* *𝑖𝑖* *−* *𝐹* *𝑗𝑗*

In the same-spin case *⟨𝑖* *𝛼* *𝑗* *𝛼* *||𝜇* ˜ *𝛼* *𝜈* ˜ *𝛼* *⟩* = *⟨𝑖𝑗|𝜇* ˜ *𝜈* ˜ *⟩−⟨𝑖𝑗|𝜈* ˜ *𝜇* ˜ *⟩*, while in the opposite-spin case *⟨𝑖* *𝛼* *𝑗* *𝛽* *||𝜇* ˜ *𝛼* *𝜈* ˜ *𝛽* *⟩* =
*⟨𝑖𝑗|𝜇* ˜ *𝜈* ˜ *⟩* .

  - For opposite-spin pairs, *𝛼* -PNOs and *𝛽* -PNOs are obtained from diagonalisation of **T** *[𝑖𝑗]* **T** *[𝑖𝑗][†]* and **T** *[𝑖𝑗][†]* **T** *[𝑖𝑗]*,
respectively. For same-spin pairs the pair density is symmetric and only one set of PNOs is needed. PNOs
are discarded whenever the absolute value of their natural occupation number is below the threshold *𝑇* CutPNO .

  - The following residual equations need to be solved for the cases *𝑅* *𝑎* *[𝑖]* ˜ *[𝛼]* *𝛼* *[𝑗]* [˜] *𝑏* *[𝛼]* *𝛼* [,] *[ 𝑅]* *𝑎* *[𝑖]* ˜ *[𝛽]* *𝛽* *[𝑗]* [˜] *𝑏* *[𝛽]* *𝛽* [and] *[ 𝑅]* *𝑎* *[𝑖]* ˜ *[𝛼]* *𝛼* *[𝑗]* [˜] *𝑏* *[𝛽]* *𝛽* [:]

*𝑅* *𝑎* *[𝑖]* ˜ *[𝜎]* *𝜎* *[𝑗]* [˜] *𝑏* *[𝜏]* *𝜏* [=] ⟨ *𝑖𝑗* ⃒⃒⃒⃒⃒⃒ *𝑎* ˜˜ *𝑏* ⟩ + (︀ *𝜀* *𝑎* ˜ + *𝜀* ˜ *𝑏* *−* *𝐹* *𝑖𝑖* *−* *𝐹* *𝑗𝑗* )︀ *𝑇* *𝑎* ˜ *[𝑖𝑗]* [˜] *𝑏*

*̸* *̸*


*−*
∑︁

*𝑘* *𝜎* = *̸* *𝑖* *𝜎* *̸*


∑︁ *𝐹* *𝑖𝑘* *𝑆* *𝑎* ˜ *[𝑖𝑗,𝑘𝑗]* *𝑐* ˜ *𝑇* *𝑐* ˜ *[𝑘𝑗]* *𝑑* [˜] *[𝑆]* *𝑑* *[𝑘𝑗,𝑖𝑗]* ˜˜ *𝑏* *−* ∑︁

*̸* *𝑐* ˜ *𝜎* *𝑑* [˜] *𝜏* *𝑘* *𝜏* = *̸* *𝑗*


∑︁

*̸* *̸*


*̸* *𝑘* *𝜏* = *̸* *𝑗* *𝜏*


∑︁ *𝐹* *𝑘𝑗* *𝑆* *𝑎* ˜ *[𝑖𝑗,𝑖𝑘]* *𝑐* ˜ *𝑇* *𝑐* ˜ *[𝑖𝑘]* *𝑑* [˜] *[𝑆]* *𝑑* *[𝑖𝑘,𝑖𝑗]* ˜˜ *𝑏* = 0

*̸* *̸* *𝑐* ˜ *𝜎* *𝑑* [˜] *𝜏*


*̸* *̸*

  - Most approximations are consistent between the RHF and UHF schemes, with the exception of the PNO
truncation. This means that results would match for closed-shell molecules with *𝑇* CutPNO = 0 (provided both
Hartree-Fock solutions are identical), but this is not true whenever the PNO space is truncated. Therefore,
UHF-DLPNO-MP2 energies should only be compared to other UHF-DLPNO-MP2 energies, even for closedshell species.

  - We found that it is necessary to use tighter PNO thresholds for UHF-DLPNO-MP2. With NormalPNO
settings the default value is *𝑇* CutPNO = 10 *[−]* [9] . For an overview of accuracy settings refer to table Table 7.17.
As in the RHF implementation, the PNO cutoff for pairs involving core orbitals is scaled with *𝑇* ScalePNO_Core .

Table 7.17: Accuracy settings for DLPNO-MP2.

**7.13. The Second Order Many Body Pertubation Theory Module (MP2)** **555**

**ORCA Manual** **,** **Release 6.0.1**

Options specific to DLPNO-MP2 are listed below.

**Local MP2 Gradient**

The analytical gradient has been implemented for the RHF variant of the DLPNO-MP2 method.[686, 687] It is
a complete derivative of all components in the DLPNO-MP2 energy, and the results are therefore expected to
coincide with numerical derivatives of DLPNO-MP2 (minus the noise). General remarks:

  - No gradient is presently implemented for the UHF-DLPNO-MP2 variant.

  - Spin-component scaled MP2 is supported by the gradient.

  - Double-hybrid density functionals are supported by the gradient.

  - Only Foster-Boys localization is presently supported. The default converger is `AHFB` with a convergence
tolerance that is automatically bound by a constant factor to the SCF orbital gradient tolerance. Using a
different converger is possible, but discouraged, as the orbital localization needs to be sufficiently tightly
converged.

  - When calculating properties without the full nuclear gradient, the relaxed MP2 density should be requested.

A number of points regarding geometry optimizations (not all of them specific to DLPNO-MP2) are worth keeping
in mind:

  - As of 2018, we expect that the DLPNO-MP2 gradient can most beneficially be used for geometry optimizations of systems containing around 70-150 atoms. It may be faster than RI-MP2 even for systems containing
50-60 atoms or less, but the timing difference is probably not going to be very large. Of course, structures
containing 200 atoms and above can (and have been) optimized, but this may take long if many geometry

**556** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

steps are required. On the other hand, single point gradient or density calculations can be performed for
systems containing many hundred atoms.

  - DLPNO-MP2 is a substantially more expensive method for geometry optimizations than GGA or hybrid
DFT functionals. Therefore, it is generally a good idea to start a geometry optimization with a structure that
is already optimized at dispersion-corrected DFT level.

  - RIJCOSX can be used to accelerate exchange evaluation substantially. However, great care needs to be exercised with the grid settings. Insufficiently large grids may lead, for example, to non-planar distortions of
planar molecules. The updated default grids in ORCA 5 ( `DefGrid2-3` ) should be sufficiently accurate to
optimize neutral main group compounds. We therefore recommend these grids for general use with some
careful checking in more complicated cases. Even with these grids, the calculation is a lot faster than “regular” Hartree-Fock with basis sets of triple zeta quality (or larger).

Using RIJONX is also possible.

  - Sufficiently large grids should be used for the exchange-correlation functional of double hybrids. The SCF
calculation takes only a fraction of the time that is needed for DLPNO-MP2, and sacrificing quality because
of an insufficiently accurate grid is a waste of computer time.

  - Optimization of large structures is often a challenge for the geometry optimizer. It may help to change the
trust radius settings, to modify the settings of the `AddExtraBonds` feature, or to change other settings of the
geometry optimizer. Sometimes it may be beneficial to check the geometry optimizer settings with a less
demanding electronic structure method.

  - Finally, problems with a geometry optimization may in some cases indeed be caused by the DLPNO approximations. Using `LoosePNO` for accurate calculations is not recommended anyway, and difficulties with
`NormalPNO` settings are possibly rectified by switching to `TightPNO` .

During the development process, a number of difficulties were encountered related to the orbital localization Zvector equations. Great care was taken to work around these problems and to make the procedures as robust
as possible, but a number of settings can be changed. For more information on these aspects, we recommend
consulting the full paper on the DLPNO-MP2 gradient [687].

  - Several different solvers are implemented for the orbital localization Z-vector equations. The default is an
iterative conjugate gradient solver. As an alternative, the DIIS-accelerated Jacobi solver can be used, but
it tends to be inferior to the conjugate gradient solver. Moreover, a direct solver is available as a fail-safe
alternative for smaller systems. As the dimension of the linear equation system is *𝑛* ( *𝑛* *−* 1) */* 2 for *𝑛* occupied
orbitals, the memory requirement and FLOP count increase as *𝑂* ( *𝑛* [4] ) and *𝑂* ( *𝑛* [6] ), respectively, and using the
direct solver becomes unfeasible for large systems.

  - Settings for the CPSCF solver are specified the same way as for canonical MP2.

  - Under specific circumstances, the orbital Hessian of the orbital localization function may have zero or nearzero eigenvalues, which can lead to singular localization Z-vector equations. In particular, it is typically a
consequence of continuously degenerate localized orbitals, which may (but do not need to) appear in some
molecular symmetries.[761] A typical symptom are natural occupation number above 2 and below 0 for
systems that would be expected to have MP2 density eigenvalues between 2 and 0 without the DLPNO
approximations.

  - In order to work around the aforementioned problem, a procedure has been implemented to eliminate singular or near-singular eigenvectors of the localization function orbital Hessian. Vectors with an eigenvalue
smaller than `ZLoc_EThresh` (or `ZLoc_EThresh_core` for the core orbitals) are subject to the modified procedure. If the program eliminates any eigenvectors, it might sometimes be a good idea to check if calculated
properties are reasonable (or at least to check the natural occupation numbers). Eigenvectors of the Hessian
are calculated by Davidson diagonalization by default, but direct diagonalization can be chosen for smaller
systems, instead.

  - Diagonalization of the localization orbital Hessian can be switched off altogether by setting `ZLoc_EThresh`
to 0.

  - If the “Asymmetric localization equation residual norm” exceeds the localization Z-vector equation tolerance ( `ZLoc_Tol` ), there are typically two plausible reasons: (1) the localized orbitals are not sufficiently
tightly converged (too large `LocTol` ) or unconverged, or (2) the orbital localization Hessian has got small
eigenvalues that were not eliminated.

**7.13. The Second Order Many Body Pertubation Theory Module (MP2)** **557**

**ORCA Manual** **,** **Release 6.0.1**

This is an overview over the options related to the gradient:



**Local MP2 Response Properties**

Analytical second derivatives with respect to electric and magnetic fields are implemented for closed-shell DLPNOMP2 (as well as double-hybrid DFT).[827] Thus, analytic dipole polarizability and NMR shielding tensors (with
our without GIAOs) are available. All considerations and options discussed in sections *Local MP2* and *Local MP2*
*Gradient* apply here as well, while additional remarks specific to second derivatives are given below.

  - DLPNO-MP2 response property calculations are expected to be faster than the RI-MP2 equivalents for systems larger than about 70 atoms or 300 correlated electrons.

  - Using the `NormalPNO` default thresholds, relative errors in the calculated properties, due to the local approximations, are smaller than 0.5%, or 5–10 times smaller than the inherent inaccuracy of MP2 vs a more
accurate method like CCSD(T).

  - DLPNO-MP2 second derivatives are much more sensitive to near-linear dependencies and other numerical
issues than the energy or first-order properties. We have made efforts to choose reasonable and robust defaults, however we encourage the user to be critical of the results and to proceed with caution, especially if
diffuse basis sets or numerical integration (DFT, COSX) are used. In the latter case, `DefGrid3` is recommended.

  - In particular, the near-redundancy of PAO domains introduces numerical instabilities in the algorithm.
Hence, these should be truncated at `PAOOverlapThresh=1e-5`, which is higher than the default for the
energy and gradient. Therefore, the energy and gradient in jobs, which include response property calculations, may deviate from jobs, which do not. The difference is much smaller than the accuracy of the method

**558** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(vs RI-MP2) but it is still advisable to use the same value of `PAOOverlapThresh` in all calculations, when
calculating, e.g., relative energies.

  - For the same reason, if diffuse basis sets are used, it is advised to set `SThresh=1e-6` in the `%scf` block.

  - Another instability arises due to small differences between the occupation number of kept and discarded
PNOs and may result in very large errors. The smallest difference is printed during the DLPNO-MP2 relaxed
density calculation:

Smallest occupation number difference between PNOs and complementary PNOs. Absolute: 3.10e-10 Relative: 3.28e-02

We found that a relative difference under 10 *[−]* [3], which is not uncommon, may be cause for concern. To regularize the unstable equations, a level shift is applied, which is equal to *𝑇* CutPNO multiplied by *𝑇* ScalePNO_LShift .
A reasonable value of `TScalePNO_LShift=0.1` is set by default for response property calculations but not
for gradient (or energy) calculations, as these were not found to suffer from this issue, so the same considerations as above apply.

  - The option `DLPNOGrad_Opt=BUFFERED` is not implemented for response properties.

A summary of the additional options used for DLPNO-MP2 response properties is given below:



An example input for a DSD-PBEP86 calculation of the NMR shielding and dipole polarizability tensors employing
DLPNO-MP2 is given below. Note that the def2-TZVP basis set is not necessarily ideal for either shielding or
polarizability.



**Numerical DLPNO-MP2 derivatives**

The various truncations in local correlation methods introduce small discontinuities in the potential energy surface. For example, a small displacement may change the sizes of correlation domains, leading to a slightly larger
or smaller error from the domain approximation. The default DLPNO-MP2 truncation thresholds are conservative enough, so that these discontinuities should not cause problems in geometry optimizations using analytic
gradients.[687] However, if one wishes to calculate (semi-)numerical derivatives of the DLPNO-MP2 energy,
gradient, or properties using finite differences, large errors can occur. Therefore, in these cases it is advisable
to keep the pair lists and correlation domains fixed upon displacement. Currently, this can be achieved using
the following procedure: first, the calculation at the reference geometry is carried out with the additional setting

`StoreDLPNOData=true` :



(continues on next page)

**7.13. The Second Order Many Body Pertubation Theory Module (MP2)** **559**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

This will produce the additional files *calc0.MapDLPNO00.tmp*, *calc0.MapDLPNOPre0.tmp*, *calc0.IJLIST.0.tmp*,
*calc0.IJLISTSCR.0.tmp*, and *calc0.IJNPNO.0.tmp*, which are needed in the working directory for the next step
together with the localized orbitals in *calc0.loc* . The calculation at the displaced geometry is then requested as:



The program will use the orbitals from *calc0.loc* as a starting guess for the localization and map the reference
orbitals to the new ones based on maximal overlap. The lists of correlated and screened out pairs are read from the
files *calc0.IJLIST.0.tmp* and *calc0.IJLISTSCR.0.tmp*, while the domain information (MO-PAO, MO-Aux, etc.) is
read from *calc0.MapDLPNO00.tmp* and *calc0.MapDLPNOPre0.tmp* . The number of PNOs for a each pair (stored
in *calc0.IJNPNO.0.tmp* ) is also kept consistent with the reference calculation: the ones with the higest occupation
numbers are kept, disregarding *𝑇* CutPNO .

This procedure should improve the accuracy and numerical stability for manually calculated geometric derivatives
of various DLPNO-MP2 properties (including those that require analytic first or second derivatives at the displaced
geometries). For semi-numerical Hessian calculations ( `NumFreq` ), it is sufficient to add `StoreDLPNOData=true`
as shown below and ORCA will handle the rest. For the sake of numerical stability, it is also recommended to
increase `PAOOverlapThresh` and add a PNO level shift for the reasons described in section *Local MP2 Response*
*Properties* .



Note that in case the orbital localization Hessian is (near-)singular, the mapping of orbitals from reference to
displaced geometries will likely fail. No solution is presently implemented for this problem.

**Multi-Level DLPNO-MP2 calculations**

With the DLPNO-MP2 method it is possible to treat the interactions among different fragments of a system with
varying accuracy, or exclude some interactions from the electron correlation treatment entirely. A more detailed
discussion in the DLPNO-CCSD(T) context is given in section *Multi-Level Calculations* and in ref. [812]. Here we
just present the technical capabilities of the MP2 module and the required input. Currently, multilayer calculations
are only available for closed-shell DLPNO-MP2. Multilayer gradients and response properties are also possible.
Fragments must be defined – see *Fragment Specification* .



(continues on next page)

**560** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Note that a given pair or fragments can only belong to a single layer and definitions later in the input overwrite
previous ones. This means that if the above input is used in a 4-fragment calculation, the 1-4 interfragment interactions will be treated with `LoosePNO` thresholds, the interactions within fragment 1 and with fragment 2 – with
`NormalPNO` thresholds, 2-3 pairs – with `TightPNO`, 1-3 and 2-4 pairs will be left at the HF level, 3-4 and 4-4 pairs
will be treated with *𝑇* CutPNO = 10 *[−]* [8] and *𝑇* CutDO = 10 *[−]* [2] (i.e. the `NormalPNO` defaults), and 2-2 and 3-3 pairs will
be left at the global ( `TightPNO` ) settings.
### **7.14 The Single Reference Correlation Module**

ORCA features a variety of single-reference correlation methods for single point energies (restricted to a RHF or
RKS determinant in the closed-shell case and a UHF or UKS determinant in the open-shell case; quasi-restricted
orbitals (QROs)[612] are also supported in the open-shell case). They are all fairly expensive but maybe be used in
order to obtain accurate results in the case that the reference determinant is a good starting point for the expansion
of the many-body wavefunction. The module is called `orca_mdci` for “matrix driven configuration interaction”.
This is a rather technical term to emphasize that if one wants to implement these methods (CCSD, QCISD etc.)
efficiently, one needs to write them in terms of matrix operations which pretty much every computer can drive at
peak performance. Let us first briefly describe the theoretical background of the methods that we have implemented
in ORCA.

**7.14.1 Theory**

We start from the full CI hierarchy in which the wavefunction is expanded as:

*|* Ψ *⟩* = *|* 0 *⟩* + *|𝑆⟩* + *|𝐷⟩* + *|𝑇* *⟩* + *|𝑄⟩* + *...* (7.113)

where *|* 0 *⟩* is a single-determinant reference and S, D, T, Q, ...denote the single, double, triple quadruple and higher
excitations relative to this determinant at the spin-orbital level. As usual, labels *𝑖, 𝑗, 𝑘, 𝑙* refer to occupied orbitals
in *|* 0 *⟩*, *𝑎, 𝑏, 𝑐, 𝑑* to unoccupied MOs and *𝑝, 𝑞, 𝑟, 𝑠* to general MOs. The action of the second quantized excitation
operators *𝑎* *[𝑎]* *𝑖* [=] *[ 𝑎]* *𝑎* *[†]* *[𝑎]* *[𝑖]* [on] *[ |]* [0] *[⟩]* [lead to excited determinants] *[ |]* [Φ] *[𝑎]* *𝑖* *[⟩]* [that enter] *[ |]* [Ψ] *[⟩]* [with coefficients] *[ 𝐶]* *𝑎* *[𝑖]* [. The variational]
equations are:

*⟨* Φ *[𝑎]* *𝑖* *[|][𝐻]* *[−]* *[𝐸]* [0] *[|]* [ 0 +] *[ 𝑆]* [+] *[ 𝐷][⟩]* [=] *[ 𝐸]* [C] *[𝐶]* *𝑎* *[𝑖]* *[−⟨]* [Φ] *[𝑎]* *𝑖* *[|][𝐻]* *[−]* *[𝐸]* [0] *[|][ 𝑇]* *[⟩]* (7.114)

⟨︀Φ *[𝑎𝑏]* *𝑖𝑗* *[|][𝐻]* *[−]* *[𝐸]* [0] *[|]* [ 0 +] *[ 𝑆]* [+] *[ 𝐷]* ⟩︀ = *𝐸* C *𝐶* *𝑎𝑏* *[𝑖𝑗]* *[−]* ⟨︀Φ *[𝑎𝑏]* *𝑖𝑗* *[|][𝐻]* *[−]* *[𝐸]* [0] *[|][ 𝑇]* [+] *[ 𝑄]* ⟩︀ (7.115)

*Further equations coupling triples with singles through pentuples etc.*

The total energy is the sum of the reference energy *𝐸* 0 = *⟨* 0 *|𝐻|* 0 *⟩* and the correlation energy

*𝐸* C = *⟨* 0 *|𝐻| 𝑆* + *𝐷⟩* (7.116)


which requires the exact singles- and doubles amplitudes to be known. In order to truncate the series to singlesand doubles one may either neglect the terms containing the higher excitations on the right hand side (leading to
CISD) or approximate their effect thereby losing the variational character of the CI method (CCSD, QCISD and
CEPA methods). Defining the one- and two-body excitation operators as *𝐶* [ˆ] 1 = [∑︀] *𝑖𝑎* *[𝐶]* *𝑎* *[𝑖]* *[𝑎]* *[𝑎]* *𝑖* [,][ ˆ] *[𝐶]* [2] [ =] [1] ∑︀ *[𝐶]* *𝑎𝑏* *[𝑖𝑗]* *[𝑎]* *[𝑎𝑏]*


*𝑖𝑎* *[𝐶]* *𝑎* *[𝑖]* *[𝑎]* *[𝑎]* *𝑖* [,][ ˆ] *[𝐶]* [2] [ =] 4 [1]


CEPA methods). Defining the one- and two-body excitation operators as *𝐶* [ˆ] 1 = [∑︀] *𝑖𝑎* *[𝐶]* *𝑎* *[𝑖]* *[𝑎]* *[𝑎]* *𝑖* [,][ ˆ] *[𝐶]* [2] [ =] 4 [1] ∑︀ *𝑖𝑗𝑎𝑏* *[𝐶]* *𝑎𝑏* *[𝑖𝑗]* *[𝑎]* *[𝑎𝑏]* *𝑖𝑗*

one can proceed to approximate the triples and quadruples by the disconnected terms:


4 [1] ∑︀


*|𝑇* *⟩* = *𝐶* [ˆ] 1 *𝐶* [ˆ] 2 *|* 0 *⟩* (7.117)

**7.14. The Single Reference Correlation Module** **561**

**ORCA Manual** **,** **Release 6.0.1**


*|𝑄⟩* = [1] *𝐶* ˆ 2 [2] *[|]* [0] *[⟩]* (7.118)

2


As is well known, the CCSD equations contain many more disconnected contributions arising from the various
powers of the *𝐶* [ˆ] 1 operator (if one would stick to CC logics one would usually label the cluster amplitudes with
*𝑡* *[𝑖]* *𝑎* *[, 𝑡]* *[𝑖𝑗]* *𝑎𝑏* [,...and the] *[ 𝑛]* [-body cluster operators with][ ˆ] *[𝑇]* *[𝑛]* [; we take a CI point of view here). In order to obtain the CEPA]
type equations from ((7.114)-(7.118)), it is most transparent to relabel the singles and doubles excitations with a
compound label *𝑃* for the internal indices ( *𝑖* ) or ( *ij* ) and *𝑥* for ( *𝑎* ) or ( *ab* ). Then, the approximations are as follows:


1

2


⟨Φ *[𝑥]* *𝑃* ⃒⃒⃒( *𝐻* *−* *𝐸* 0 ) ˆ *𝐶* 22 ⃒⃒⃒ 0⟩ = [1] 2


∑︁ *𝐶* *𝑦* *[𝑄]* *[𝐶]* *𝑧* *[𝑅]* ⟨Φ *[𝑥]* *𝑃* *[|][𝐻]* *[−]* *[𝐸]* [0] *[|]* [ Φ] *[𝑦𝑧]* *𝑄𝑅* ⟩ (7.119)

*𝑄𝑅𝑦𝑧*


*≈* *𝐶* *𝑥* *[𝑃]* ∑︁ *𝐶* *𝑦* *[𝑄]* ⟨Φ *[𝑥]* *𝑃* *[|][𝐻][|]* [ Φ] *[𝑥𝑦]* *𝑃𝑄* ⟩

*𝑄𝑦*


∑︁ *𝐶* *𝑦* *[𝑄]* ⟨0 *|𝐻|* Φ *[𝑦]* *𝑄* ⟩ *−* *𝐶* *𝑥* *[𝑃]* ∑︁

*𝑄𝑦* *𝑄𝑦∪*


(7.120)

(7.121)


= *𝐶* *𝑥* *[𝑃]* ∑︁


∑︁ *𝐶* *𝑦* *[𝑄]* ⟨0 *|𝐻|* Φ *[𝑦]* *𝑄* ⟩

*𝑄𝑦∪𝑃𝑥*


*𝜀* *𝑄*

*𝑄∪𝑃*


*≈* *𝐶* *𝑥* *[𝑃]*


⎛


*𝐸* C *−* ∑︁
⎝ *𝑄∪𝑃*


⎞

(7.122)
⎠


Here the second line contains the approximation that only the terms in which either *Qy* or *Rz* are equal to *Px*
are kept (this destroys the unitary invariance) and the fourth line contains the approximation that only “exclusion
principle violating” (EPV) terms of internal labels are considered. The notation *𝑄𝑦* *∪𝑃𝑥* means “ *Qy* joint with *Px* ”
(containing common orbital indices) and *𝜀* *𝑄* is the pair correlation energy. The EPV terms must be subtracted from
the correlation energy since they arise from double excitations that are impossible due to the fact that an excitation
out of an occupied or into an empty orbital of the reference determinant has already been performed. Inserting eq.
(7.122) into eq. (7.115) *𝐶* *𝑥* *[𝑃]* *[𝐸]* *[𝐶]* [cancels and effectively is replaced by the “partial correlation energy”][ ∑︀] *𝑄∪𝑃* *[𝜀]* *[𝑄]* [.]

The resulting equations thus have the appearance of a diagonally shifted (“dressed”) CISD equation
*⟨* Φ *[𝑥]* *𝑃* *[|][𝐻]* *[−]* *[𝐸]* [0] [ + ∆] *[|]* [ 0 +] *[ 𝑆]* [+] *[ 𝐷][⟩]* [= 0][. If the second approximation mentioned above is avoided Malrieu’s (SC)]
2 -CISD arises. [38, 63, 647, 720, 912] Otherwise, one obtains CEPA/3 with the shift:

*−* ∆ *[𝑖𝑗]* *𝑎𝑏* [=] ∑︁ ( *𝜀* *𝑖𝑘* + *𝜀* *𝑗𝑘* ) *−* *𝜀* *𝑖𝑗* (7.123)

*𝑘*

CEPA/2 is obtained by *−* ∆ *[𝑖𝑗]* *𝑎𝑏* [=] *[ 𝜀]* *[𝑖𝑗]* [and CEPA/1 is the average of the CEPA/2 and CEPA/3. As mentioned by]
Ahlrichs, [11] no consensus appears to exist in the literature for the appropriate shift on the single excitations. If
one proceeds straightforwardly in the same way as above, one obtains:


Φ *[𝑎]* *𝑖* ( *𝐻* *−* *𝐸* 0 ) ˆ *𝐶* 1 ˆ *𝐶* 2 0 *≈* *𝐶* *𝑎* *[𝑖]*
⟨ ⃒⃒⃒ ⃒⃒⃒ ⟩


(︃


*𝜀* *𝑖𝑘*

*𝑘*


*𝐸* C *−* 2 ∑︁


)︃


(7.124)


as the appropriate effect of the disconnected triples on the singles. It has been assumed here that only the singles
*|* Φ *[𝑎]* *𝑖* *[⟩]* [in][ ˆ] *[𝐶]* [1] [ contribute to the shift. If] *[ |]* [0] *[⟩]* [is a HF determinant, the effect of the disconnected triples in the doubles]
projection vanishes under the same CEPA approximations owing to Brillouin’s theorem. Averaged CEPA models
are derived by assuming that all pair correlation energies are equal (except *𝜀* *𝑖𝑖* = 0). As previously discussed by
Gdanitz [291], the averaging of CEPA/1 yields *𝑛* [2] *[𝐸]* [C] [ and CEPA/3] *[ 𝐸]* [C] *𝑛* [4] ( *[𝑛]* *𝑛* *[−]* *−* [6] 1) [where] *[ 𝑛]* [is the number of correlated]

electrons. These happen to be the shifts used for the averaged coupled-pair functional (ACPF [292]) and averaged
quadratic coupled-cluster (AQCC [841]) methods respectively. However, averaging the singles shift of eq. (7.124)
gives *𝑛* [4] *[𝐸]* [C] [. The latter is also the leading term in the expansion of the AQCC shift for large] *[ 𝑛]* [. In view of the]

instability of ACPF in certain situations, Gdanitz has proposed to use the AQCC shift for the singles and the
original ACPF shift for the doubles and called his new method ACPF/2 [292]. Based on what has been argued
above, we feel that it would be most consistent with the ACPF approach to simply use *𝑛* [4] *[𝐸]* [C] [ as the appropriate]

singles shift. We refer to this as NACPF.

It is readily demonstrated that the averaged models may be obtained by a variation of the modified correlation
energy functional:

*𝐸* C = *[⟨]* [0 +] *[ 𝑆]* [+] *[ 𝐷]* *[|]* *[𝐻]* *[−]* *[𝐸]* [0] *[|]* [ 0 +] *[ 𝑆]* [+] *[ 𝐷]* *[⟩]* (7.125)

1 + *𝑔* *𝑠* *⟨𝑆|𝑆⟩* + *𝑔* *𝐷* *⟨𝐷|𝐷⟩*

**562** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


with g *𝑆* and g *𝐷* being the statistical factors [4]


with g *𝑆* and g *𝐷* being the statistical factors *𝑛* [4] [,] *𝑛* [2] [,] *𝑛* 4 ( *𝑛* *𝑛−−* 6 1) [, as appropriate for the given method. Thus, unlike the]

CEPA models, the averaged models fulfill a stationarity principle and are unitarily invariant. However, if one thinks
about localized internal MOs, it appears evident that the approximation of equal pair energies must be one of rather
limited validity and that a more detailed treatment of the electron pairs is warranted. Maintaining a stationarity
principle while providing a treatment of the pairs that closely resembles that of the CEPA methods was achieved
by Ahlrichs and co-workers in an ingenious way with the development of the CPF method [16]. In this method,
the correlation energy functional is written as:



[4] [2]

*𝑛* [,] *𝑛*


Φ *[𝑥]*
⟨ *𝑝* *[|][𝐻]* *[−]* *[𝐸]* [0] *[|]* [ Φ] *[𝑦]* *𝑄* ⟩


*𝐸* C = 2 ∑︁

*𝑃𝑥*


⟨ Φ *[𝑥]* *𝑝* *[|][𝐻][|]* [ 0] ⟩


+
*𝑁* *𝑃* ∑︁


*𝑃𝑄𝑥𝑦*


√︀


(7.126)
*𝑁* *𝑃* *𝑁* *𝑄*


with


*𝑁* *𝑃* = 1 + ∑︁


∑︁ *𝑇* *𝑃𝑄* ∑︁

*𝑄* *𝑦*


( *𝐶* *𝑦* *[𝑄]* [)] [2] (7.127)
*𝑦*


The topological matrix for pairs *𝑃* =( *ij* ) and *𝑄* = ( *𝑘𝑙* ) is chosen as: [440]


*𝑇* *𝑃𝑄* = *[𝛿]* *[𝑖𝑘]* [+] *[ 𝛿]* *[𝑖𝑙]*


(7.128)
2 *𝑛* *𝑗*



[+] *[ 𝛿]* *[𝑖𝑙]*

+ *[𝛿]* *[𝑗]* *[𝑘]* [+] *[ 𝛿]* *[𝑗]* *[𝑙]*
2 *𝑛* *𝑖* 2 *𝑛*


with *𝑛* *𝑖* being the number of electrons in orbital *𝑖* in the reference determinant. The singles out of orbital *𝑖* are
formally equated with *𝑃* = ( *𝑖𝑖* ). At the spin-orbital level, *𝑛* *𝑖* = 1, for closed shells *𝑛* *𝑖* = 2. Using the same
topological matrix in ∆ *𝑃* = [∑︀] *𝑄* *[𝑇]* *[𝑃𝑄]* *[𝜀]* *[𝑄]* [one recovers the CEPA/1 shifts for the doubles in eq. (][7.124][). It is]

straightforward to obtain the CPF equivalents of the other CEPA models by adjusting the *𝑇* *𝑃𝑄* matrix appropriately.
In our program, we have done so and we refer below to these methods as CPF/1, CPF/2 and CPF/3 in analogy to the
CEPA models (CPF/1 *≡* CPF). In fact, as discussed by Ahlrichs and co-workers, variation of the CPF-functional
leads to equations that very closely resemble the CEPA equation and can be readily implemented along the same
lines as a simple modification of a CISD program. Ahlrichs *et al.* argued that the energies of CEPA/1 and CPF/1
should be very close. We have independently confirmed that in the majority of cases, the total energies predicted
by the two methods differ by less than 0.1 mEh.

An alternative to the CPF approach which is also based on variational optimization of an energy functional is
the VCEPA method [455]. The equations resulting from application of the variational principle to the VCEPA
functional are even closer to the CEPA equations than for CPF so that the resulting energies are practically indistinguishable from the corresponding CEPA values. The VCEPA variants are referred to as VCEPA/1, VCEPA/2,
and VCEPA/3 in analogy to CEPA and CPF. A strictly size extensive energy functional (SEOI) which is invariant
with respect to unitary transformations within the occupied and virtual orbital subspaces is also available [456] (an
open-shell version is not implemented yet).

Again, a somewhat critical point concerns the single excitations. They do not account for a large fraction of the
correlation energy. However, large coefficients of the single excitations lead to instability and deterioration of the
results. Secondly, linear response properties are highly dependent on the effective energies of the singles and their
balanced treatment is therefore important. Since the CEPA and CPF methods amount to shifting down the diagonal
energies of the singles and doubles, instabilities are expected if the effective energy of an excitation approaches
the reference energy of even falls below it. In the CPF method this would show up as denominators *𝑁* *𝑃* that are
too small. The argument that the CPF denominators are too small has led Chong and Langhoff to the proposal
of the MCPF method which uses a slightly more elaborate averaging than ( *𝑁* *𝑃* *𝑁* *𝑄* ) [1] *[/]* [2] [173]. [1] However, their
modification was solely based on numerical arguments rather than physical or mathematical reasoning. In the light
of Eq. (7.124) and the performance of the NACPF, it appears to us that for the singles one should use twice the
*𝑇* *𝑃𝑄* proposed by Ahlrichs and co-workers. The topological matrix *𝑇* *𝑃𝑄* is modified in the following way for the
(very slightly) modified method to which we refer to as NCPF/1:



[+] *[ 𝛿]* *[𝑖𝑙]*

+ *[𝛿]* *[𝑗]* *[𝑘]* [+] *[ 𝛿]* *[𝑗]* *[𝑙]*
2 *𝑛* *𝑖* 2 *𝑛*


*𝑇* *𝑖𝑗,𝑘𝑙* = *[𝛿]* *[𝑖𝑘]* [+] *[ 𝛿]* *[𝑖𝑙]*


(7.129)
2 *𝑛* *𝑗*


*𝑇* *𝑖𝑗,𝑘* = 0 (7.130)

1 This method – although it has been rather extensively used in the past – is not implemented in ORCA. We recommend to use our NCPF/1
instead.

**7.14. The Single Reference Correlation Module** **563**

**ORCA Manual** **,** **Release 6.0.1**

*̸*


*𝑇* *𝑖,𝑘𝑙* = 2 *[𝛿]* *[𝑖𝑘]* [+] *[ 𝛿]* *[𝑖𝑙]* (7.131)

*𝑛* *𝑖*

*̸*


*𝑇* *𝑖,𝑘* = 0 (7.132)

(note that *𝑇* *𝑃𝑄* = *̸* *𝑇* *𝑄𝑃* for this choice). Thus, the effect of the singles on the doubles is set to zero based on the
analysis of the CEPA approximations and the effect of the singles on the singles is also set to zero. This is a sensible
choice since the product of two single excitations is a double excitation which is already included in the SD space
and thus none of them can belong to the outer space. It is straightforward to adapt this reasoning about the single
excitations to the CEPA versions as well as to NCPF/2 and NCPF/3.

The aforementioned ambiguities arising from the use of single excitations in coupled-pair methods can be avoided
by using correlation-adapted orbitals instead of Hartree-Fock orbitals thus eliminating the single excitations. There
are two alternatives: (a) Brueckner orbitals and (b) optimized orbitals obtained from the variational optimization of
the electronic energy with respect to the orbitals. Both approaches have already been used for the coupled-cluster
doubles (CCD) method [360, 777] and later been extended to coupled-pair methods [454]. In the case of CCD,
orbital optimization requires the solution of so-called Λ (or Z vector) equations [745]. There is, however, a cheaper
alternative approximating the Z vector by a simple analytical formula [457].

Furthermore, the parametrized coupled-cluster (pCCSD) method of Huntington and Nooijen [405], which combines the accuracy of coupled-pair type methods for (usually superior to CCSD, at least for energies and energy
differences) with the higher stability of the coupled-cluster methods, is an attractive alternative. Comprehensive numerical tests [404] indicate that particularly pCCSD(-1,1,1) (or pCCSD/1a) and pCCSD (-1.5,1,1) (or pCCSD/2a)
have great potential for accurate computational thermochemistry. These methods can be employed by adding the
“simple” keywords `pCCSD/1a` or `pCCSD/2a` to the first line of input. As mentioned in section *Local Coupled Pair*
*and Coupled-Cluster Calculations*, the LPNO variants of the pCCSD methods are also available for RHF and UHF
references via usage of the simple keywords `LPNO-pCCSD/1a` and `LPNO-pCCSD/2a` .

**7.14.2 Closed-Shell Equations**

Proceeding from spin-orbitals to the spatial orbitals of a closed-shell determinant leads to the actual working equations of this work. Saebo, Meyer and Pulay have exploited the generator state formalism to arrive at a set of highly
efficient equations for the CISD problem [705]. A similar set of matrix formulated equations for the CCSD and
QCISD cases has been discussed by Werner and co-workers [355] and the MOLPRO implementation is widely recognized to be particularly efficient. Equivalent explicit equations for the CISD and CCSD methods were published
by Scuseria *et al* . [778] [2] The doubles equations for the residual “vector” *𝜎* are ( *𝑖* ⩽ *𝑗*, all *𝑎, 𝑏* ):


*̸*

*𝜎* *𝑎𝑏* *[𝑖𝑗]* [=] *[ 𝐾]* *𝑎𝑏* *[𝑖𝑗]* [+] *[ 𝐾]* (︀ **C** *[𝑖𝑗]* [)︀]


*̸*

*𝑎𝑏* [+] {︀ **F** *[𝑉]* **C** *[𝑖𝑗]* + **C** *[𝑖𝑗]* **F** *[𝑉]* [}︀]


*̸*

*𝑎𝑏* *[−]* [∑︀]

*𝑘*


*̸*

*𝐹* *𝑗𝑘* *𝐶* *𝑎𝑏* *[𝑖𝑘]* [+] *[ 𝐹]* *[𝑖𝑘]* *[𝐶]* *𝑎𝑏* *[𝑘𝑗]* + [∑︀] *𝐾* *𝑘𝑙* *[𝑖𝑗]* *[𝐶]* *𝑎𝑏* *[𝑘𝑙]*
{ }︁ *𝑘𝑙*


*̸*

+ [∑︀]

*𝑘*


*̸*

2 **C** *[𝑖𝑘]* *−* **C** *[𝑖𝑘]* [+] [)︀(︀] **K** *[𝑘𝑗]* *−* [1]
{︀(︀ 2


*̸*

2 2 *𝑎𝑏*

*−* [∑︀] {︀ 1 **[C]** *[𝑖𝑘]* [+] **[J]** *[𝑗𝑘]* [+] [ +] [1] **[J]** *[𝑖𝑘]* **[C]** *[𝑘𝑗]* [+] [ +] **[ J]** *[𝑗𝑘]* **[C]** *[𝑖𝑘]* [+] **[ C]** *[𝑘𝑗]* **[J]** *[𝑖𝑘]* [+] [}︀]


*̸*

2 [1] **[J]** *[𝑘𝑗]* [)︀] + (︀ **K** *[𝑖𝑘]* *−* [1] 2


*̸*

[1] 2 **C** *[𝑘𝑗]* *−* **C** *[𝑘𝑗]* [+] [)︀}︀]

2 **[J]** *[𝑖𝑘]* [)︀(︀]


*̸*

1
{︀ 2


*̸*

1 [1]

2 **[C]** *[𝑖𝑘]* [+] **[J]** *[𝑗𝑘]* [+] [ +] 2


*̸*

[1]

2 **[J]** *[𝑖𝑘]* **[C]** *[𝑘𝑗]* [+] [ +] **[ J]** *[𝑗𝑘]* **[C]** *[𝑖𝑘]* [+] **[ C]** *[𝑘𝑗]* **[J]** *[𝑖𝑘]* [+] [}︀]


*̸*

*𝑎𝑏*


*̸*

*𝑘*

The singles equations are:


*̸*

+ *𝐶* *𝑎* *[𝑖]* *[𝐹]* *𝑏* *[𝑗]* [+] *[ 𝐶]* *𝑏* *[𝑗]* *[𝐹]* *𝑎* *[𝑖]* *[−]* [∑︀]

*𝑘*

*−* ∆ *[𝑖𝑗]* *𝐶* *𝑎𝑏* *[𝑖𝑗]*


*̸*

{︁ *𝐾* *𝑘𝑎* *[𝑗𝑖]* *[𝐶]* *𝑏* *[𝑘]* [+] *[ 𝐾]* *𝑘𝑏* *[𝑖𝑗]* *[𝐶]* *𝑎* *[𝑘]* }︁ + {︀ **K** *[𝑖𝑎]* **C** *[𝑗]* + **K** *[𝑗𝑎]* **C** *[𝑖]* [}︀]


*̸*

*𝑏*


*̸*

(7.133)

(7.134)


*̸*

*𝜎* *𝑎* *[𝑖]* [=] *[ 𝐹]* *𝑎* *[𝑖]* [+] {︀ **F** *[𝑉]* **C** *[𝑖]* [}︀]


*̸*

*𝑎* *[−]* [∑︀]


*̸*

*𝐹* *𝑖𝑗* *𝐶* *𝑎* *[𝑗]* *[−]* [∑︀]
*𝑗* *𝑗𝑘𝑏*


*̸*

*𝑗𝑘𝑏*


*̸*

(︁2 *𝐾* *𝑗𝑏* *[𝑖𝑘]* *[−]* *[𝐽]* *𝑗𝑏* *[𝑖𝑘]* )︁ *𝐶* *𝑏𝑎* *[𝑘𝑗]*


*̸*

+ [∑︀]

*𝑗*


*̸*

{︀(︀2 **K** *[𝑖𝑗]* *−* **J** *[𝑖𝑗]* [)︀] **C** *[𝑗]* + **F** *[𝑗]* [(︀] 2 **C** *[𝑖𝑗]* [+] *−* **C** *[𝑖𝑗]* [)︀] + ⟨︀(︀2 **K** *[𝑖𝑎]* *−* **K** *[𝑖𝑎]* [+] [)︀] **C** *[𝑖𝑗]* [+] [⟩︀}︀]

*−* ∆ *[𝑖]* *𝐶* *𝑎* *[𝑖]*


*̸*

*𝑎*


*̸*

The following definitions apply:


*̸*

*𝐾* (︀ **C** *[𝑖𝑗]* [)︀]


*̸*

*𝑎𝑏* [=] ∑︁ ( *𝑎𝑐|𝑏𝑑* ) *𝐶* *𝑐𝑑* *[𝑖𝑗]* (7.135)

*𝑐𝑑*


*̸*

*𝐾* *𝑟𝑠* *[𝑝𝑞]* [= (] *[𝑝𝑟][|][𝑞𝑠]* [)] (7.136)

2 Our coupled-cluster implementation is largely based on this nice paper. The equations there have been extensively verified to be correct.

**564** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

*𝐽* *𝑟𝑠* *[𝑝𝑞]* [= (] *[𝑝𝑞][|][𝑟𝑠]* [)] (7.137)

*⟨* **AB** *⟩* = ∑︁ *𝐴* *𝑝𝑞* *𝐵* *𝑞𝑝* (7.138)

*𝑝𝑞*

The two-electron integrals are written in (11|12) notation and **F** is the closed-shell Fock operator with **F** *[𝑉]* being
its virtual sub-block. We do not assume the validity of Brillouin’s theorem. The amplitudes *𝐶* *𝑎* *[𝑖]* *[, 𝐶]* *𝑎𝑏* *[𝑖𝑗]* [have been]
collected in vectors **C** *[𝑖]* and matrices **C** *[𝑖𝑗]* wherever appropriate. The shifts ∆ *[𝑖]* and ∆ *[𝑖𝑗]* are dependent on the method
used and are defined in Table Table 7.18 for each method implemented in ORCA.

Table 7.18: Summary of the diagonal shifts used in various singles- and doubles methods discussed in this chapter.
The quantities *𝜀* *𝑖* and *𝜀* *𝑖𝑗* are the correlation energy increments brought about by the single- and the double excitations respectively. The partial denominators for the CPF type methods *𝑁* *𝑖* and *𝑁* *𝑖𝑗* are specified in eq. (7.127).











































































The QCISD method requires some slight modifications. We found it most convenient to think about the effect of the
nonlinear terms as a “dressing” of the integrals occurring in equations (7.133) and (7.134). This attitude is close
to the recent arguments of Heully and Malrieu and may even open interesting new routes towards the calculation
of excited states and the incorporation of connected triple excitations.[391] The dressed integrals are given by:


¯
*𝐹* *𝑖𝑘* = *𝐹* *𝑖𝑘* + ∑︁

*𝑙*


⟨︀ **C** *[𝑖𝑙]* [(︀] 2 **K** *[𝑘𝑙]* *−* **K** *[𝑘𝑙]* [+] [)︀⟩︀] (7.139)


¯
*𝐹* *𝑎𝑏* = *𝐹* *𝑎𝑏* *−* ∑︁

*𝑘𝑙*


{︀ **C** *[𝑘𝑙]* [(︀] 2 **K** *[𝑘𝑙]* *−* **K** *[𝑘𝑙]* [+] [)︀}︀] *𝑎𝑏* (7.140)


¯
*𝐹* *𝑘𝑐* = *𝐹* *𝑘𝑐* + ∑︁

*𝑙*


(︀2 **K** *[𝑘𝑙]* *−* **K** *[𝑘𝑙]* [+] [)︀] **C** *[𝑙]* (7.141)


*𝐾* ¯ *𝑘𝑙* *[𝑖𝑗]* [=] *[ 𝐾]* *𝑘𝑙* *[𝑖𝑗]* [+] ⟨︀ **K** *[𝑘𝑙]* **T** *[𝑘𝑙]* [+] [⟩︀] (7.142)


**C** *[𝑖𝑘]* **K** *[𝑘𝑗]* *−* [1] + **C** *[𝑘𝑖]* **K** *[𝑘𝑗]*
{ ( 2 **[K]** *[𝑗𝑘]* ) }


*𝐾* ¯ *[𝑖𝑗]*
*𝑎𝑏* [=] *[ 𝐾]* *𝑎𝑏* *[𝑖𝑗]* [+] ∑︁

*𝑘*


(7.143)
*𝑎𝑏*


**7.14. The Single Reference Correlation Module** **565**

**ORCA Manual** **,** **Release 6.0.1**


*𝐽* ¯ *𝑎𝑏* *[𝑖𝑗]* [=] *[ 𝐽]* *𝑎𝑏* *[𝑖𝑗]* [+] ∑︁ {︀ **C** *[𝑘𝑖]* **K** *[𝑗𝑘]* [}︀]

*𝑘*


*𝑎𝑏* (7.144)


The CCSD method can be written in a similar way but requires 15 additional terms that we do not document here.
They may be taken conveniently from our paper about the LPNO-CCSD method [617].

A somewhat subtle point concerns the definition of the shifts in making the transition from spin-orbitals to spatial
orbitals. For example, the CEPA/2 shift becomes in the generator state formalism:


*−* [1]
(︂ 3


1
(︂ 3


*−* ⟨˜Φ *[𝑎𝑏]* *𝑖𝑗* *[|]* [∆] *[𝑖𝑗]* *[|]* [Ψ] ⟩ = *𝐶* *𝑎𝑏* *[𝑖𝑗]*


1

*𝑖𝑗* [+ 2]
3 *[𝜀]* *[𝛼𝛼]* 3


3 *[𝜀]* *𝑖𝑗* *[𝛼𝛽]*


+ *𝐶* *𝑏𝑎* *[𝑖𝑗]*
)︂



[1]

*𝑖𝑗* [+ 1]
3 *[𝜀]* *[𝛼𝛼]* 3


3 *[𝜀]* *𝑖𝑗* *[𝛼𝛽]*


(7.145)
)︂


(Φ [˜] *[𝑎𝑏]* *𝑖𝑗* [is a contravariant configuration state function, see Pulay] *[ et al]* [. [][745][]. The parallel and antiparallel spin pair]
energies are given by:


*𝜀* *[𝛼𝛼]*
*𝑖𝑗* [= 1] 2 ∑︁

*𝑎𝑏*



[︁ *𝐾* *𝑎𝑏* *[𝑖𝑗]* *[−]* *[𝐾]* *𝑏𝑎* *[𝑖𝑗]* ]︁(︁ *𝐶* *𝑎𝑏* *[𝑖𝑗]* *[−]* *[𝐶]* *𝑏𝑎* *[𝑖𝑗]* )︁ (7.146)


*𝜀* *[𝛼𝛽]*
*𝑖𝑗* [= 1] 2


*𝐾* *[𝑖𝑗]*

∑︁ *𝑎𝑏* *[𝐶]* *𝑎𝑏* *[𝑖𝑗]* (7.147)

*𝑎𝑏*


This formulation would maintain the exact equivalence of an orbital and a spin-orbital based code. Only in the
(unrealistic) case that the parallel and antiparallel pair correlation energies are equal the CEPA/2 shift of Table
7.18 arise. However, we have not found it possible to maintain the same equivalence for the CPF method since the
electron pairs defined by the generator state formalism are a combination of parallel and antiparallel spin pairs. In
order to maintain the maximum degree of internal consistency we have therefore decided to follow the proposal of
Ahlrichs and co-workers and use the topological matrix *𝑇* *𝑃𝑄* in equation (7.128) and the equivalents thereof in the
CEPA and CPF methods that we have programmed.

**7.14.3 Open-Shell Equations**

We have used a non-redundant set of three spin cases ( *𝛼𝛼*, *𝛽𝛽*, *𝛼𝛽* ) for which the doubles amplitudes are optimized
separately. The equations in the spin-unrestricted formalism are straightforwardly obtained from the corresponding
spin orbital equations by integrating out the spin. For implementing the unrestricted QCISD and CCSD method,
we applied the same strategy (dressed integrals) as in the spin-restricted case. The resulting equations are quite
cumbersome and will not be shown here explicitly [361].

Note that the definitions of the spin-unrestricted CEPA shifts differ from those of the spin-restricted formalism
described above (see Kollmar et al. [361]). Therefore, except for CEPA/1 and VCEPA/1 (and of course CEPA/0),
for which the spin-adaptation of the shift can be done in a consistent way, CEPA calculations of closed-shell
molecules yield slightly different energies for the spin-restricted and spin-unrestricted versions. Since variant 1 is
also the most accurate among the various CEPA variants [618], we recommend to use variant 1 for coupled-pair
type calculations. For the variants 2 and 3, reaction energies of reactions involving closed-shell and open-shell
molecules simultaneously should be calculated using the spin-unrestricted versions only.

A subtle point for open-shell correlation methods is the choice of the reference determinant [619]. Single reference
correlation methods only yield reliable results if the reference determinant already provides a good description of
the systems electronic structure. However, an UHF reference wavefunction suffers from spin-contamination which
can spoil the results and lead to convergence problems. This can be avoided if quasi-restricted orbitals (QROs)
are used [391, 612] since the corresponding zeroth-order wavefunction is an eigenfunction of the *𝑆* [ˆ] [2] operator and
thus, no severe spin-contamination will appear. The coupled-pair and coupled-cluster equations will be still solved
in a spin-unrestricted formalism but the energy will be slightly higher compared to the results obtained with a
spin-polarized UHF reference determinant. Furthermore, especially for more difficult systems like e.g. transition
metal complexes, it is often advantageous to use Kohn-Sham (KS) orbitals instead of HF orbitals.

**566** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.14.4 Local correlation**

As described in previous sections of the manual, ORCA features the extremely powerful LPNO and DLPNO methods. “LPNO” stands for “local pair natural orbital” approximation and DLPNO for “domain based LPNO”. These
methods are designed to provide results as close as possible to the canonical coupled-cluster results while gaining
orders of magnitude of efficiency through a series of well-controlled approximations. In fact, typically about 99.8%
to 99.9% of the canonical correlation energy is recovered in such calculations. Even higher accuracy is achievable
but will ultimately come at much higher computational cost. The default cut-offs are set such that the vast majority of chemically meaningful energy differences are reproduced to better than 1 kcal/mol relative to the canonical
results with the same basis set. Of the LPNO and DLPNO methods, the LPNO is the older one and will eventually
be discarded from ORCA. It has some higher order scaling steps (up to *𝑁* [5] ) while DLPNO is linear scaling and
of similar accuracy. Amongst the DLPNO methods, the first generation implementation of the DLPNO methods
(DLPNO2013) is only near-linear scaling, while the DLPNO implementation since ORCA 4.0 is linear scaling.

It is important to understand that the LPNO and DLPNO implementations are intimately tied to the RI approximation. Hence, in these calculations one *must* specify a fitting basis set. The same rules as for RI-MP2 apply: the
auxiliary basis sets optimized for MP2 are just fine for PNO calculations. You can specify several aux bases for
the same job and the program will sort it out correctly.

The theory of the LPNO methods has been thoroughly described in the literature in a number of original research
papers.[617, 623, 721, 723]

Hence, it is sufficient to only point to a few significant design principles and features of these methods:

1. The correlation energy of any molecule can be written as a sum over the correlation energies of pairs of
electrons, labelled by the internal indices ( *𝑖𝑗* ) of pairs of orbitals that are occupied in the reference determinant. If the orbitals ( *𝑖* ) and ( *𝑗* ) are localized, the pair correlation energy *𝜖* *𝑖𝑗* falls off very quickly with
distance, quite typically by about an order of magnitude per chemical bond that is separating orbitals ( *𝑖* ) and
( *𝑗* ). Hence, by using a suitable cut-off for a reasonable pair correlation energy estimate many electron pairs
can be removed from the high-level treatment and only a linear scaling number of electron pairs will make
a significant contribution to the correlation energy.

2. The natural estimate for the pair correlation energy comes from second order many body perturbation theory
(MP2). However, canonical MP2 is scaling with the fifth power of the molecular size and hence, is not
really attractive from a theoretical nor computational point of view. Owing to the small pre-factor RI-MP2
goes a long way to provide reasonably cheap estimates for pair correlation energies. However, if one uses
localized internal orbitals, then the MP2 energy expression must be cast in form of linear equations. On the
other hand, if one uses canonical virtual orbitals together with localized internal orbitals and neglects the
coupling terms coming from purely internal Fock matrix elements F( *𝑖*, *𝑘* ) and F( *𝑘*, *𝑗* ) then one ends up with
a fair approximation that is termed “semi-canonical MP2” in ORCA. It serves as a guess in the older LPNO
method. For DLPNO this method is also not attractive.

3. In DLPNO, the guess is more sophisticated. Here the virtual space is spanned by projected atomic orbitals
(PAOs) that are assigned to domains of atoms that are associated with each local internal orbital ( *𝑖* ) and
with the union of two such domains ( *𝑖* ) and ( *𝑗* ) for the electron pair ( *𝑖𝑗* ). If one applies the semi-local
approximation, one obtains an excellent approximation to the semi-canonical MP2 energy. This is called the
“semi-local” approximation and it scales linearly with respect to computational effort. If one iterates these
equations to self-consistency to eliminate the coupling terms F( *𝑖*, *𝑘* ) and F( *𝑘*, *𝑗* ) then one obtains the full local
MP2 method (LMP2 or L-MP2). By making the domains large enough the results approach the canonical
MP2 energy to arbitrary accuracy while still being linear scaling with respect to computational resources.
This method is the default for the DLPNO method.

4. Basically, the high-spin open-shell version of the DLPNO uses the same strategy as the closed-shell variant
to efficiently generate the open-shell PNOs in a consistent manner to the closed-shell formalism. Through the
development of the UHF-LPNO-CCSD method, we have realized that use of the unrestricted MP2 (UMP2)
approach to define the open-shell PNOs introduces a few complexities; (1) the PNOs for *𝛽* spin orbitals
cannot be defined for *𝛼*    - *𝛼* electron pairs and vice versa, (2) the diagonal PNOs for singly occupied orbitals
cannot be properly defined, and (3) the PNO space does not become identical to that in the closed-shell
LPNO framework in the closed-shell limit. However, to program all the unrestricted CCSD terms in the
LPNO basis, those PNOs are certainly necessary. Therefore, in the UHF-LPNO-CCSD implementation,
several terms, which, in many cases, give rather minor contributions in the correlation energy are omitted.
Due to these facts, the UHF-LPNO-CCSD does not give identical results to that of RHF-LPNO-CCSD in

**7.14. The Single Reference Correlation Module** **567**

**ORCA Manual** **,** **Release 6.0.1**

the closed-shell limit. In addition, screening of the weak pairs on the basis of the semi-canonical UMP2
pair-energy results in somewhat unbalanced treatment of the closed- and open-shell states in some cases,
leading to rather larger errors in the reaction energies. To overcome those issues, in the high-spin openshell DLPNO-CCSD method, the PNOs are generated in the framework of semi-canonical NEVPT2 which
smoothly converges to the RHF-MP2 counterpart in the closed-shell limit. The open-shell DLPNO-CCSD,
which is made available from ORCA 4.0, includes a full set of the open-shell CCSD equations and is designed
as a natural extension to the RHF-DLPNO-CCSD.

5. Screening of the electron pairs according to a truncation parameter (in ORCA it is called *𝑇* CutPairs ) is not
sufficient to obtain a highly performing local electronic structure method. The original work of Pulay suggested to limit excitations out of the internal orbitals ( *𝑖* ) and ( *𝑗* ) to the domain associated with the pair ( *𝑖𝑗* ).
While this works well and has been implemented to perfection by Werner, Schütz and co-workers over the
years,[755, 756, 775, 776] the pre-factor of such calculations is high, since the domains have to be chosen
large in order to recover 99.9% or more of the canonical correlation energy.

6. The ORCA developers have therefore turned to an approach that has been used with a high degree of success in the early 1970s by Meyer, Kutzelnigg, Staemmler and their co-workers, namely the method of “pair
natural orbitals” (PNOs).[10, 583, 584, 887]
As shown by Loewdin in his seminal paper from 1955, natural orbitals (the eigenfunctions of the one-particle
density matrix) provide the fastest possible convergence of the correlated wavefunction with respect to the
number of one-particle functions included in the virtual space. It has been amply established that approximate natural orbitals are almost as succesful as the true natural orbitals (which would require the knowledge
of the exact wavefunction) in this respect. While the success of approximate correlation treatments of many
particle systems that use approximate natural orbitals of the whole systems are somewhat limited, this is not
the case for pair natural orbitals. The latter have first been suggested as a basis for correlation calculations
by England and co-workers and, at the time, were given the name “pseudonatural orbitals”, a term that was
used by Meyer throughout his pioneering work.

7. The PNOs are approximate natural orbitals of a given electron pair. In order to generate them one requires a
one particle pair density matrix *𝐷* *𝑖𝑗* the eigenfunctions of which are the PNOs themselves while the corresponding eigenvalues are the PNO occupation numbers. While there are many creative possibilities that can
lead to slightly different PNO sets, a quite useful and natural approximation is to generate such a density from
the MP2 amplitudes as an expectation value (the “unrelaxed” MP2 density. One then uses a second threshold (in ORCA *𝑇* CutPNO ) that controls the PNOs to be included in the calculation. PNOs with an occupation
number *< 𝑇* CutPNO are neglected.

8. PNOs of a given electron pair form an orthonormal set. However, PNOs belonging to different electron pairs
are not orthonormal and hence they overlap. This non-orthogonality leads to surprisingly few complications because the PNOs stay orthogonal to all occupied orbitals. In practice, the equations for PNO-based
correlation calculations are hardly more complex than the canonical equations.

9. The nice feature of these pair densities is that they become small when the pair interaction becomes small.
Hence weak pairs are correlated by very few PNOs. Therefore, the PNO expansion of the wavefunction is
extremely compact and there only is a linear scaling number of significant excitation amplitudes that need to
be considered.

10. A great feature of the PNOs is that they are “self-adapting” to the correlation situation that they are supposed
to describe. Hence, they are as delocalized as required by the physics and there is no ad-hoc assumption
about their location in space. However, it is clear that the PNOs are located in the same region of space as
the internal orbitals that they correlate because otherwise they would not contribute to the correlation energy.

11. In the iterative local MP2, a set of PNOs is calculated for the MP2 calculation from the semicanonical
amplitudes first using the cutoff `TCutPNO` *×* `LMP2ScaleTCutPNO` . The size of the resulting PNO space should
be comparable with DLPNO-MP2. After the iterations have converged, a (smaller) set of PNOs for the
CCSD double excitation amplitudes is generated from the iterated local MP2 amplitudes in the (larger) PNO
basis. The PNOs for the single excitation amplitudes are always calculated using the semicanonical MP2
amplitudes, as they require a much more conservative PNO truncation threshold.

12. Capitalizing on this feature one can define generous domains and expand the PNOs in terms of the PAOs
and auxiliary fit functions (for the RI approximations) that are contained in these domains. In ORCA this is
controlled by the third significant truncation parameter *𝑇* CutMKN . This is the basis of the DLPNO method.
In the older LPNO method, the PNOs are expanded in terms of the canonical virtual orbitals and *𝑇* CutMKN

**568** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

is only used for a local fit to the PNOs. In the linear-scaling DLPNO implementation the domains expanding
the PNOs in terms of the PAOs are controlled via *𝑇* CutDO .

13. PNO expansions have the amazing advantage that the PNOs converge to a well-defined set as the basis set is
approaching completeness. Hence, the increase in the number of PNOs per electron pair is very small upon
enlargement of the orbital basis. In other words, correlation calculations with large basis sets are not that
much more expensive than correlation calculations with small basis sets. Thus, the advantage of PNO over
canonical calculations increases with the size of the basis set. This is a great feature as large and flexible
basis sets are a requirement for meaningful correlation calculations.

14. In summary, DLPNO and LPNO calculations are controlled by only three cut-off parameters with welldefined meanings: a) *𝑇* CutPairs, the cut-off for the electron pairs to be included in the coupled-pair or coupledcluster iterations, b) *𝑇* CutPNO which controls how many PNOs are retained for a given electron pair and c)
*𝑇* CutMKN that controls how large the domains are that the PNOs expand over. For the linear-scaling DLPNO
calculations the domain sizes are controlled via *𝑇* CutDO .

15. It is clear that owing to the truncations a certain amount of error is introduced in the results. However, having
the LMP2 results available, one can compensate for the errors coming from *𝑇* CutPairs and *𝑇* CutPNO . This
is done in ORCA and the correction is added to the final correlation energy, thus bringing it very close (to
mEh accuracy or better) to the canonical result. *𝑇* CutMKN is best dealt with by making it conservative (at
1e *−* 3 to 1e *−* 4 the domains are about 20–30 atoms large, which is sufficient for an accurate treatment).

16. Note that the LPNO and DLPNO methods do not introduce any real space cut-offs. We refrain from doing
so and insist in our method development by making all truncations based on wavefunction or energy parameters. We feel that this is the most unbiased approach and it involves no element of “chemical intuition” or
“prejudice”.

17. In the DLPNO method a highly efficient screening mechanism is operative. In this method one first obtains
a (quadratically scaling) multipole estimate for the pair correlation energy that is extremely fast to compute
(a few seconds, even for entire proteins). Only if this estimate is large enough, a given electron pair is even
considered for a LMP2 treatment. Quite typically pairs with energy contributions of 1e *−* 6 Eh and smaller
are very well described by the dipole-dipole estimate. Specifically, we drop pairs with estimated energies
*<* 0 *.* 01 *×𝑇* CutPairs and add their multipole energy sum to the final correlation energy. These corrections tend
to be extremely small, even for large molecules and are insignificant for the energy. However, importantly, the
multipole estimate ensures linear scaling in the MP2 treatment. The pairs that then do not survive the pairprescreening are called “weak pairs” in the ORCA or DLPNO sense. They still play a role in the calculation
of the triple excitation correction.

18. The calculation of triple excitation contributions is more involved and one does not have a perturbative
estimate available since the (T) contribution is perturbative itself. While the (T) contribution is much smaller
than the CCSD correlation energy, the errors introduced by the various local and PNO approximations can
be significant. We found that one has to include triples with at least one pair being a “weak” LMP2 pair
(with its LMP2 amplitudes) in order to arrive at sufficiently accurate results.

Given these explanations the various cut-off parameters that can be controlled in LPNO and DLPNO calculations should be understandable and are listed below. We emphasize again that only the three thresholds *𝑇* CutPairs,
*𝑇* CutPNO and *𝑇* CutMKN should be touched by the user, unless very specific questions are addressed. The recommended way to control the accuracy of calculations is to specify “TightPNO”, “NormalPNO” or “LoosePNO”
keywords, rather than to change numeric values of cutoffs. Individual thresholds should normally not be changed,
as the defaults are sensible and lead to good cost/performance ratios.



(continues on next page)

**7.14. The Single Reference Correlation Module** **569**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



For larger systems and tighter thresholds the disk I/O of a DLPNO calculation may become challenging. In this
case, it might be usefull to keep some integrals in memory, if enough RAM is available. With the following flag



ORCA will try to store certain much-used integrals in shared memory. If the amount of memory is not sufficient,
ORCA will fall back to on-disk storage. **NOTE:** This flag will only work if all processes work on the same node.

IMPORTANT NOTE REGARDING ORBITAL LOCALIZATION

   - **Localized orbitals for DLPNO are obtained via the Foster-Boys method with an augmented Hessian**
**converger (** `AHFB` **) by default.**

  - The localization tolerance ( `LocTol` ) is coupled to the SCF gradient tolerance ( `TolG` ) with a constant factor
by default. Selecting specific SCF convergence settings (such as `TightSCF` ) therefore also ensures obtaining
a set of appropriately well converged localized orbitals. This can be overridden by setting a different value

**570** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

for `LocTol` .

  - An important feature of the augmented Hessian converger is that it systematically approaches a local maximum of the localization function (even though convergence to the global maximum cannot be guaranteed).
As opposed to that, the conventional localization method ( `FB` ) may stop, for example, at a saddle point. In
bad cases, this can lead to deviations of several kJ/mol in the DLPNO energy. Likewise, it can contribute
towards lack of reproducibility of results.

  - No similar procedure has been implemented for the other localization methods (such as Pipek-Mezey) yet.
The same problems as with the FB converger can occur in these cases.

  - No randomization is used for the `AHFB` converger.

The old default orbital localization settings of ORCA 4.0 can be reproduced with the following options:



Regarding the methods that employ randomization ( `FB`, `PM`, `IAOIBO`, `IAOBOYS` ) only, the following notes apply:

  - Generally, better DLPNO results are obtained when several runs of localization are undertaken using different
initial guesses. The different initial guesses are obtained using randomization (LocRandom).

  - However, randomization of the initial guess can lead to differently localized MOs in different calculations.
This can yield non-identical correlation energies, varying in the sub-kJ/mol range, for different runs on the
same machine.

  - In order to yield identical correlation energy results, randomization can be switched off (LocRandom 0).
However, switching off randomization only leads to identical results on the same machine, but can still lead
to slightly different results (in the sub-kJ/mol range) on different machines.

  - Reproducibility of the correlation energy is expected to increase further if LocNAttempts is set to higher
values.

The input below shows how to perform a DLPNO calculation with settings that exactly reproduce the canonical
RI-MP2 result. They are not recommended for production use, but merely to show that if the local approximations
are pushed, then the result coincides with the canonical one. If one would set *𝑇* CutPNO to zero this would give
canonical RI-CCSD. However, this is an absurdly inefficient calculation and hence not done.



(continues on next page)

**7.14. The Single Reference Correlation Module** **571**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**Including (semi)core orbitals in the correlation treatment**

In some chemical applications some or all of the chemical (semi)core electrons must be included in the correlation
treatment. In this case, it is necessary to tighten the TCutPNO thresholds for electron pairs in which chemical
(semi)core electrons are involved. This is now the default in DLPNO calculations.

For instance, one can decide to switch off the frozen-core approximation and include all the electrons in the correlation treatment. In this case, the program will use tighter thresholds by default for all electron pairs and Singles that
involve chemical core electrons. Note that, in this case, the use of properly optimized basis functions for correlating
the inner electrons is highly recommened.



Another option is to choose the involved chemical core electrons by using an energy window. In this way all electron
pairs and Singles that involve chemical core electrons, which are in the defined energy window, are affected by
TScalePNO_CORE.



A summary with the number of electrons affected by TScalePNO_Core for the examples just discussed is shown
in Table Table 7.19.

**572** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.19: Number of chemical core electrons included in the DLPNO calculation and affected by
TScalePNO_Core for the TiF 4 examples

*𝑎* using TScalePNO_Core.

By default, ORCA provides a chemical meaningful definition for the number of electrons which belong to the
chemical core of each element. As already discussed, these default values define which pairs are affected by
TScalePNO_Core. However, the user can modify the number of chemical core electrons for a specific element via
the NewNCore keyword.



In the previous example, the number of chemical core electrons for Ti has been fixed to 8.

Starting from ORCA 6.0, in DLPNO calculations, tightened TCutPNO thresholds are used by default for “semicore”
electron pairs involving the 3s and 3p orbitals of first-row transition metals.[32] This improves not only the accuracy
of the results noticeably but also the efficiency of the computations as the system size grows (ref.). To reproduce
results obtained with earlier versions, the number of semicore orbitals on first-row transition metals needs to be set
to zero (the old default) instead of eight (the current default), as done below for a Zn atom with the NewNSemiCore
keyword in the method block:
```
%method NewNSemiCore Zn 0 end end

```
NOTE

  - Of course, if electrons are replaced by ECPs, they are not included in the correlation treatment.

  - If ECPs are used, the number for NewNCore has to include the electrons represented by the ECPs as well.
E.g. if an element is supposed to have 60 electrons in the ECP and additional 8 electrons should be frozen
in the correlation calculation, NewNCore should be 68.

  - The different sets of orbitals (chemical core electrons included in the correlation treatment and valence
electrons) are localized separately in order to avoid the mixing of core and valence orbitals.

**7.14. The Single Reference Correlation Module** **573**

**ORCA Manual** **,** **Release 6.0.1**

**Multi-Level Calculations**

In many applications events are investigated that are located in a relatively small region of the system of interest.
In these cases, combined quantum-mechanics/molecular-mechanics (QM/MM) approaches have been proved to be
extremely useful, especially in the modeling of enzymatic reactions. The basic idea of any QM/MM method is to
treat a small region of the system at the QM level and to use an MM treatment for the remaining part of the system.
Alternatively, QM/QM methods, where different parts of a system are studied at various quantum mechanical
levels, are also available. Quantum mechanical methods are more computationally demanding than the molecular
mechanics treatment, and this limits the applicability of all-QM approaches. Nevertheless, QM/QM methods retain
some strong advantages over QM/MM schemes. For instance, force field parameters for the molecular mechanics
part of the calculation are not necessary, and thus there are no restrictions on the type of chemical systems that can
be treated. Moreover, problems usually caused by boundaries between QM and MM parts do not occur. Finally,
the accuracy of an all-QM calculation is expected to be higher compared to the accuracy of QM/MM approaches,
that is limited by the MM treatment.

In ORCA, the different methods that can be used in a QM/QM calculations are:

  - DLPNO-CCSD(T) with TightPNO thresholds

  - DLPNO-CCSD(T) with NormalPNO thresholds

  - DLPNO-CCSD(T) with LoosePNO thresholds

  - DLPNO-CCSD

  - DLPNO-MP2

  - HF

The user can define an arbitrary number of fragments in the input, the level of theory to be used for each fragment
and for the interaction between different fragments. Localized molecular orbitals are then assigned to a given
fragment on the basis of their Mulliken populations.

The following example shows the calculation of a benzene dimer, for which the individual monomers are calculated
on MP2 level, and the interaction between the two monomers is calculated on TightPNO DLPNO-CCSD(T) level.
More realistic use cases are discussed in ref. [812].

(continues on next page)

**574** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

  - For the calculation of the interaction energy, the energy of the individual benzene monomer should be calculated on the accuracy level of the monomer in the dimer calculation, i.e. using MP2 with full LMP2 guess
for the above example.

All possible settings for the multi-level calculation are listed below.



**Multi-Level Calculations for IP and EA-EOM-DLPNO-CCSD**

The multi-layer method can be used to include the environmental effect in IP-and EA-EOM-DLPNO-CCSD
method. A typical input file for the multi-layer IP-EOM-CCSD method will look like



(continues on next page)

**7.14. The Single Reference Correlation Module** **575**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



Here the example is a mono-hydrated thymine molecule, where the thymine is treated at the main fragment and
water is treated at the environment. It will result in the following output



The result of a full a IP-EOM-DLPNO-CCSD calculation with NORMALPNO setting would have looked like



(continues on next page)

**576** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)


The results in multi-layer IP-EOM-DLPNO-CCSD method has been found to be in excellent agreement with standard variant. The *𝑀𝑃* 2 *𝐹𝑟𝑎𝑔𝐼𝑛𝑡𝑒𝑟* treatment is not available for the EOM method. To get a reasonable accuracy
one need to treat the fragment from where the ionization is happening (thymine in the above example) at the highest
possible level. The interaction between the main fragment (thymine) and environment (water) should be treated
at the intermediate level accuracy. The environment can safely be treated with *𝐻𝐹𝐹𝑟𝑎𝑔𝐼𝑛𝑡𝑒𝑟* for almost all the
cases. One can decide the size of the main fragment by looking at HF occupied orbitals as the Koopmans’ approximation is a very good zeroth order guess for the IP values. The electron attached states are much less localized as
compared to the ionization problem. Consequently, the multi-layer EA-EOM-DLPNO-CCSD requires much more
tighter thresholds than the IP variant. An typical input file for multi-layer EA-EOM-DLPNO-CCSD will look as
follows.




(continues on next page)

**7.14. The Single Reference Correlation Module** **577**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

It is a thymine-glycine complex where the thymine is treated as the main fragment and glycine as the environment.
One needs to use a more tighter value of *𝑇𝐶𝑢𝑡𝑃𝑁𝑂𝑆𝑖𝑛𝑔𝑙𝑒𝑠* for EA as in the case of standard EA-EOM-DLPNOCCSD. The *𝑇𝐶𝑢𝑡𝑃𝑁𝑂𝑆𝑖𝑛𝑔𝑙𝑒𝑠* for the respective fragments automatically gets adjusted based on their respective
*𝑇𝐶𝑢𝑡𝑃𝑁𝑂* values. The output will be



The results are in excellent agreement with the standard EA-EOM-DLPNO-CCSD method.




(continues on next page)

**578** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

To get the reasonable accuracy in multi-layer EA-EOM-CCSD one need to treat the environment and inter-fragment
interaction atleast at *𝐿𝑜𝑜𝑠𝑒𝑃𝑁𝑂𝐹𝑟𝑎𝑔𝐼𝑛𝑡𝑒𝑟* level.

**7.14.5 The singles Fock term**

In most MDCI calculations, there is an intermediate, which resembles closely to the SCF Fock matrix, and similar
methods are available to efficiently calculate it. In the followings, a short discussion will be given of the so-called
singles Fock term, which in the closed shell case has the form


*𝐺* ( **t** 1 ) *𝑝𝑞* = ∑︁


*𝑐* *[𝑝]* *𝜇* *[𝑐]* *𝜈* *[𝑞]* *[𝐺]* [(] **[t]** [1] [)] *[𝜇𝜈]* *[,]*

*𝜇𝜈*


*𝑡* *[𝑗]* *𝑏* [(2(] *[𝑝𝑞][|][𝑗𝑏]* [)] *[ −]* [(] *[𝑝𝑗][|][𝑞𝑏]* [)) =] ∑︁
*𝑗𝑏* *𝜇𝜈*


The singles Fock matrix can be obtained via transformation from its counterpart ( *𝐺* ( **t** 1 ) *𝜇𝜈* ) in the atomic orbital
(AO) basis


*𝐺* ( **t** 1 ) *𝜇𝜈* = ∑︁


*𝑡* *[𝑗]* *𝑏* [(2(] *[𝜇𝜈][|][𝑗𝑏]* [)] *[ −]* [(] *[𝜇𝑗][|][𝜈𝑏]* [)) =] ∑︁
*𝑗𝑏* *𝜅𝜏*


*𝑃* ( **t** 1 ) *𝜅𝜏* (2( *𝜇𝜈|𝜅𝜏* ) *−* ( *𝜇𝜅|𝜈𝜏* )) *,*
(7.148)

*𝜅𝜏*


where


*𝑃* ( **t** 1 ) *𝜅𝜏* = ∑︁ *𝑡* *[𝑗]* *𝑏* *[𝑐]* *𝜅* *[𝑗]* *[𝑐]* *[𝑏]* *𝜏*

*𝑗𝑏*


is the analogue of the SCF density matrix for the singles Fock case. For the singles Coulomb ( *𝐽* ( **t** 1 ) *𝜇𝜈* ) case,
the density may be symmetrized ( *𝑃* [˜] ( **t** 1 ) *𝜅𝜏* = *𝑃* ( **t** 1 ) *𝜅𝜏* + *𝑃* ( **t** 1 ) *𝜏𝜅* ), and one may use the resolution of identity
approximation


*𝐽* ( **t** 1 ) *𝜇𝜈* = ∑︁


∑︁ *𝑃* ˜( **t** 1 ) *𝜅𝜏* ( *𝜇𝜈|𝜅𝜏* ) *≈* ∑︁

*𝜅𝜏* *𝐴𝐵*


*𝐴𝐵*


∑︁ *𝑃* ˜( **t** 1 ) *𝜅𝜏* ( *𝜇𝜈|𝑟* 12 *[−]* [1] *[|][𝐴]* [)] *[𝑉]* *𝐴𝐵* *[−]* [1] [(] *[𝐵][|][𝑟]* 12 *[−]* [1] *[|][𝜅𝜏]* [)] *[,]*

*𝜅𝜏*


where *𝐴, 𝐵* are elements of the RI/DF auxiliary fitting basis. Note that the factor of 2 in ((7.148)) is taken care
of by symmetrization. Since we are using a symmetric density, we may use the same efficient routine to evaluate
the singles Coulomb term as in the SCF case, see *Using the RI-J Approximation to the Coulomb Part* and *The*
*Split-RI-J Coulomb Approximation* .

For the exchange case ( *𝐾* ( **t** 1 ) *𝜇𝜈* ), one possibility is to use the COSX approximation (see *Using the RI Approxima-*
*tion for Hartree-Fock and Hybrid DFT (RIJCOSX)* )


*𝐾* ( **t** 1 ) *𝜇𝜈* = ∑︁


∑︁ *𝑃* ( **t** 1 ) *𝜅𝜏* ( *𝜇𝜅|𝜈𝜏* ) *≈* ∑︁

*𝜅𝜏*


*𝑄* *𝜇𝑔* ∑︁

*𝑔* *𝜏*


*𝐴* *𝜈𝜏* ( **r** *𝑔* ) ∑︁

*𝜏* *𝜅*


*𝑃* ( **t** 1 ) *𝜅𝜏* *𝑋* *𝜅𝑔* *,*

*𝜅*


The COSX routine is able to deal with asymmetric densities as well, and thus, it can be used here similar to the
SCF case.

The other possibility is to use RI for exchange (RIK),


*𝐾* ( **t** 1 ) *𝜇𝜈* = ∑︁


∑︁ *𝑐* *[𝑗]* *𝜅* *[𝐶]* [(] **[t]** [1] [)] *[𝑗]* *𝜏* [(] *[𝜇𝜅][|][𝜈𝜏]* [)] *[ ≈]* ∑︁

*𝑗𝜅𝜏* *𝑗𝐴𝐵*


∑︁( *𝜇𝑗|𝑟* 12 *[−]* [1] *[|][𝐴]* [)] *[𝑉]* *𝐴𝐵* *[−]* [1] [(] *[𝐵][|][𝑟]* 12 *[−]* [1] *[|][𝜈]* [˜] *[𝑗]* [)] *[,]*

*𝑗𝐴𝐵*


where


*𝐶* ( **t** 1 ) *[𝑗]* *𝜏* [=] ∑︁ *𝑡* *[𝑗]* *𝑏* *[𝑐]* *𝜏* *[𝑏]* *[,]*

*𝑏*


and the [˜] *𝑗* is an “orbital” transformed using *𝐶* ( **t** 1 ).

**7.14. The Single Reference Correlation Module** **579**

**ORCA Manual** **,** **Release 6.0.1**

Using these approximations, there are two approximations for the total singles Fock term, RIJCOSX called by
the simple keyword RCSinglesFock and RIJK called by RIJKSinglesFock, see *Basics* . For canonical and LPNO
methods, by default the program chooses the same approximation used in the SCF calculation. DLPNO2013 uses
RIJCOSX by default, while in DLPNO, the singles Fock term is also evaluated using PNOs via SinglesFockUsePNOs, see *Local correlation* . This behavior can also be changed by keywords in the method block.



**7.14.6 Use of the MDCI Module**

The MDCI module is fairly easy to use. The flags for the “simple” input lines have been described in section
*Keyword Lines* . The detailed listing of options is found below:



(continues on next page)

**580** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
               # (citype chosen as CCSD or QCISD and
               # Denmat as orbopt) by using an
               # analytical formula
          false # explicit solution of Z vector
               # equations
               # in case of orbital optimized CCD
               # (default: false)
      UseQROs # use of quasi-restricted orbitals
               # (default false)
      Localize 0 # use localized MOs. Presently very little
             # use is made of locality. It may help
             # for interpretations. Localization is
             # incompatible with the (T) correction
          PM # Use Pipek-Mezey localized MOs
          FB # use Foster-Boys localized MOs
      NatOrbIters 0 # Perform natural orbital iterations.
             # default is none. Not possible for CCSD
             # and QCISD
      pCCSDAB # the three parameters for parametrized
      pCCSDCD # coupled-cluster (default is 1.0 which
      pCCSDEF # corresponds to normal CCSD
      # this defines how the rate limiting step is handled
      # MO and AOX need lots of disk and I/O but if they
      # can be done they are fast
      KCOpt KC_MO # Perform full 4-index transformation
         KC_AOBLAS# AO direct with BLAS (preferred)
              # (not yet available for UHF, switch to KC_AOX)
         KC_AO # AO direct handling of 3,4 externals
              # (not yet available for UHF, switch to KC_AOX)
         KC_RI # RI approximation of 3,4 externals
              # (not yet available for UHF)
         KC_RI2 # Alternative RI (not recommended)
              # (not yet available for UHF)
         KC_AOX # Do it from stored AO exchange integrals
      PrintLevel 2 # Control the amount of output. For 3 and
              # higher things like pair correlation
              # energies are printed.
      MaxIter 35 # Max. number of iterations
      # How the integral transformation is done.
      # Note that it is fine to do AOX or AO or AOBLAS
      # together with trafo_ri
      TrafoType trafo_jk # Partial trafo to J+K operators
           trafo_ri # RI transformation of all
                 # integrals up to 2-externals
                 # (3-ext for (T))and rest on the
                 # fly
           trafo_full # Full four index transformation.
                 # Automatically chosen for
                 # KCOpt=KC_MO
      MaxCore 350 # Memory in MB - used for integral
              # trafos and batching and for storage of
              # integrals and amplitudes
              # don't be too generous
      STol 1e-5 # Max. element of the residual vector
              # for convergence check
      LShift 0.3 # Level shift to be used in update of
              # coefficients
      MaxDIIS 7 # Max number of DIIS vectors to be stored
      # this lets you control how much and what is residing
      # in central memory. May speed up things. Note that
      # MaxCore is not respected here

```
(continues on next page)

**7.14. The Single Reference Correlation Module** **581**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
### **7.15 The Complete Active Space Self-Consistent Field (CASSCF)** **Module**

**7.15.1 General Description**

The complete active space self-consistent field (CASSCF) method is a special form of a multiconfigurational SCF
method and can be thought of as an extension of the Hartree-Fock method. It is a very powerful method to study
static correlation effects and a solid basis for MR-CI and MR-PT treatments. It can be applied to the ground state
and excited states or averages thereof. The implementation in ORCA is fairly general and reasonably efficient.
However, CASSCF calculations are fairly complex and ultimately require a lot of insight from the user in order
to be successful. In addition to detailed description here, the manual explores some typical examples in section
*CASSCF Natural Orbitals as Input for Coupled-Cluster Calculations* . Furthermore, the manual is supplemented
with a tutorial for CASSCF that covers many practical tips on the calculation design and usage of the program.

**The wavefunction.** The wavefunction of a given CASSCF state is written as

⃒⃒Ψ *𝑆𝐼* ⟩︀ = ∑︁ *𝐶* *𝑘𝐼* ⃒⃒Φ *𝑆𝑘* ⟩︀ *.* (7.149)

*𝑘*

Here, ⃒⃒Ψ *𝑆𝐼* ⟩︀ is the CASSCF *𝑁* -electron wavefunction for state *𝐼* with total spin S. The set of ⃒⃒Φ *𝑆𝑘* ⟩︀ is a set of
configuration state functions (for example linear combination of Slater determinants) each adapted to a total spin
*𝑆* . The expansion coefficients *𝐶* *𝑘𝐼* represent the first set of variational parameters. Each CSF is constructed from
a common set of orthonormal molecular orbitals *𝜓* *𝑖* ( **r** ) which are in turn expanded in basis functions *𝜓* *𝑖* ( **r** ) =
∑︀ *𝜇* *[𝑐]* *[𝜇𝑖]* *[𝜑]* *[𝜇]* [(] **[r]** [)][. The MO coefficients] *[ 𝑐]* *[𝜇𝑖]* [form the second set of variational parameters.]

**The energy.** The energy of the CASSCF wavefunction is given by the Rayleigh quotient


*𝐸* ( **c** *,* **C** ) =


Ψ *[𝑆]* *𝐼* ⃒⃒ *𝐻* ˆ BO ⃒⃒ Ψ *𝑆𝐼*
⟨ ⃒ ⃒ ⟩ (7.150)

⟨︀Ψ *[𝑆]* *𝐼* ⃒⃒Ψ *𝑆𝐼* ⟩︀ *,*


and represents an upper bound to the true total energy. However, CASSCF calculations are *not* designed to provide
values for total energy which are close to the exact energy. The purpose of a CASSCF calculation is to provide a
qualitatively correct wavefunction, which forms a good starting point for a treatment of dynamic electron correla
tion.

The CASSCF method is fully variational in the sense that the energy is made stationary with respect to variations
in both sets of MO and CI coefficients. At convergence, the gradient of the energy with respect to the MO and CI
coefficients vanishes

*𝜕𝐸* ( **c** *,* **C** )

= 0 *,* (7.151)
*𝜕𝑐* *𝜇𝑖*

*𝜕𝐸* ( **c** *,* **C** )

= 0 *.* (7.152)
*𝜕𝐶* *𝑘𝐼*

**Orbital spaces.** In CASSCF calculations, the MO space is divided into three user defined subspaces:

**582** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

  - The “inactive orbitals” are the orbitals which are doubly occupied in all configuration state functions (labels
*𝑖, 𝑗, 𝑘, 𝑙* ).

  - The “active orbitals” are the orbitals with variable occupation numbers in the various CSFs (labels *𝑡, 𝑢, 𝑣, 𝑤* ).

  - The “external orbitals” (labels *𝑎, 𝑏, 𝑐, 𝑑* )

Note that in older publications, the inactive and active orbitals are distinguished and referred to as “internal” orbitals.

The wavefunction and energy is invariant with respect to unitary transformations within the three subspaces. The
special feature of a CASSCF wavefunction is that a fixed number of electrons is assigned to each subspace. The
internal subspace is of course completely filled but the CSFs in the active space constitute a full-CI of *𝑛* -electrons
in *𝑚* -orbitals. The CSF list is constructed such, however, that a wavefunction of well defined total spin (and
potential space) symmetry results. Such a wavefunction is referred to as a **CASSCF(** *𝑛* **,** *𝑚* **)** wavefunction. The
CSF list grows extremely quickly with the number of active orbitals and the number of active electrons (basically
factorially). Depending on the system, the limit of feasibility is roughly around *∼* 14 active orbitals or about one
million CSFs in the active space. Larger active spaces are tractable with approximate CI solver such as the IterativeConfiguration-Expansion CI (ICE-CI) described in *Approximate Full CI Calculations in Subspace: ICE-CI* or the
Density Matrix Renormalization Group (DMRG) discussed in *Density Matrix Renormalization Group* . [1]

Since the orbitals within the subspaces are only defined up to a unitary transformation, the program needs to make
some canonicalization choice.

In ORCA, the final orbitals by default are:

1. natural orbitals in the active space,

2. orbitals which diagonalize the CASSCF Fock matrix in the internal space and

3. orbitals which diagonalize the CASSCF Fock matrix in the external space.

**State averaging.** In many circumstances, it is desirable to optimize the orbitals not for a single state but for the
average of several states. In order to see what is done, the energy for state *𝐼* is re-written as:


Γ *[𝑝]* *𝑞* [(] *[𝐼]* [)] *ℎ* *𝑝𝑞* + ∑︁

*𝑝𝑞* *𝑝𝑞𝑟𝑠*


*𝐸* *𝐼* ( **c** *,* **C** ) = ∑︁


∑︁ Γ *[𝑝𝑟]* *𝑞𝑠* [(] *[𝐼]* [)] ( *𝑝𝑞* *|𝑟𝑠* ) (7.153)

*𝑝𝑞𝑟𝑠*


Here, Γ *[𝑝]* *𝑞* [(] *[𝐼]* [)] and Γ *[𝑝𝑟]* *𝑞𝑠* [(] *[𝐼]* [)] are the one-and two-particle reduced electron density matrices for this state (labels *𝑝, 𝑞, 𝑟, 𝑠*
span the internal and active subspaces):

Γ *[𝑝]* *𝑞* [(] *[𝐼]* [)] = ⟨︀Ψ *[𝑆]* *𝐼* ⃒⃒ *𝐸* *𝑞𝑝* ⃒⃒ Ψ *𝑆𝐼* ⟩︀ (7.154)

Γ *[𝑝𝑟]* *𝑞𝑠* [(] *[𝐼]* [)] = [1] 2 ⟨︀Ψ *[𝑆]* *𝐼* ⃒⃒ *𝐸* *𝑞𝑝* *[𝐸]* *𝑠* *[𝑟]* *[−]* *[𝛿]* *[𝑞𝑟]* *[𝐸]* *𝑠* *[𝑝]* ⃒⃒ Ψ *𝑆𝐼* ⟩︀ (7.155)

The average energy is simply obtained from averaging the density matrices using arbitrary weights *𝑤* *𝐼* that are user
defined but are constrained to sum to unity.

Γ *[𝑝]* *𝑞* [(] *[𝑎𝑣]* [)] = ∑︁ *𝑤* *𝐼* Γ *[𝑝]* *𝑞* [(] *[𝐼]* [)] (7.156)

*𝐼*

Γ *[𝑝𝑟]* *𝑞𝑠* [(] *[𝑎𝑣]* [)] = ∑︁ *𝑤* *𝐼* Γ *[𝑝𝑟]* *𝑞𝑠* [(] *[𝐼]* [)] (7.157)

*𝐼*

∑︁ *𝑤* *𝐼* = 1 (7.158)

*𝐼*

**Optimization of CASSCF wavefunctions.** In general, except for trivial cases, CASSCF wavefunctions are considerably more difficult to optimize than RHF (or UHF) wavefunctions. The underlying reason is that variations
in **c** and **C** maybe strongly coupled and the energy functional may have many local minima in ( **c**, **C** ) space. Consequently, the choice of starting orbitals is of really high importance and the choice which orbitals and electrons are
included in the active space has decisive influence on the success of a CASSCF study. In general, after transformation to natural orbitals, one can classify the active space orbitals by their occupation numbers which vary between
0.0 and 2.0. In general, convergence problems are almost guaranteed if orbitals with occupation numbers close

1 For approximate full CI approaches, CASSCF is neither invariant to active-active rotations nor exactly size-consistent.

**7.15. The Complete Active Space Self-Consistent Field (CASSCF) Module** **583**

**ORCA Manual** **,** **Release 6.0.1**

to zero or close to 2.0 are included in the active space. Occupation numbers between 0.02 and 1.98 are typically
very reasonable and should not lead to large convergence problems. The reason for the occurrence of convergence
problems is that the energy is only very weakly dependent on rotations between internal and active orbitals if the
active orbital is almost doubly occupied and similarly for the rotations between external and weakly occupied active
orbitals. However, in some cases (for example in the study of potential energy surfaces) it may not be avoidable
to include weakly or almost inactive orbitals in the active space and in these cases the use of the most powerful
convergence aids is necessary ( *vide infra* ). As in the case of single-determinant wavefunctions (RHF, UHF, RKS,
UKS) there are first and second order converging methods available. The first order CASSCF methods require the
transformed integrals ( *𝑡𝑢|𝑣𝑥* ) with *𝑥* belonging to any subspace. This is a very small subspace of the total transformed integral list and is readily held in central storage even for larger calculations. On the other hand, second
order CASSCF methods require the integrals ( *𝑝𝑞|𝑥𝑦* ) and ( *𝑝𝑥|𝑞𝑦* ) ( *𝑝, 𝑞* = internal, active; *𝑥, 𝑦* = any orbital). This
is a fairly large set of integrals and their generation is laborious in terms of CPU time and disk storage. Second
order CASSCF calculations are therefore more limited in the size of the molecules which can be well treated. It

would be possible to basically avoid the integral transformation also in the case of second-order CASSCF calculations and proceed to fully direct calculations. Such calculations may become quite time consuming since there
may be a large number of Fock matrix builds necessary.


The augmented Hessian method (Newton-Raphson) solves the eigenvalue problem:

0 **g** 1 = *𝜀* 1
(︂ **g** **H** )︂(︂ **t** )︂ (︂ **t** )︂


1

**t**
)︂(︂


1
= *𝜀*
**t**
)︂ (︂


(7.159)
)︂


Here, **g** is the orbital gradient (derivative of the total energy with respect to a non-redundant rotation between two
orbitals) and **H** is the orbital Hessian (second derivative of the energy with respect to two non-redundant orbital
rotations). The vector **t** (in intermediate normalization obtained from the CI like vector) summarizes the rotation
angles. The angles are used to define the antisymmetric matrix ( *𝑋* *𝑝𝑞* = *−𝑋* *𝑞𝑝* is thus the rotation angle between
orbitals *𝑝* and *𝑞* ):


**0** **t**
**X** =
*−* **t** **0**
(︂


*,* (7.160)
)︂


which is used to parametrize the unitary matrix **U** = exp ( **X** ) which is used to update the orbitals according to:

**c** [new] = **c** [old] **U** (7.161)

(where **c** is an MO coefficient matrix).

**Starting orbitals.** You cannot be careful enough with your starting orbitals. What type of initial guess works best
depends on the system. Quite often it is not the magnitude of the initial gradient, but the similarity between initial
and final active orbitals. The CASSCF tutorial discusses a number of guess options in more detail. Generally
speaking, canonical orbitals HF orbitals from a RHF calculation are not good choice, as the identification and
selection of the active space orbitals is often difficult. Usually DFT orbitals (quasi-restricted or RKS) perform
better in this respect. Alternatively, if CASSCF orbitals from a previous run or a close-by geometry are available
this is a good choice. For coordination chemistry complexes, the guess generated with `orca_mergefrag` (see
the CASSCF tutorial), is probably the best choice - especially for heave metals. Natural orbitals from a simple
correlation calculation like MP2 or a calculation with the MRCI module are usually a good choice and easily
generated. For example:



**584** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Now examine the occupation numbers of the natural orbitals (you will find that in the output of the MP2 part of
the calculation):



A rule of thumb is that orbitals with occupation numbers between 1.98 and 0.02 should be in the active space.
Thus, in the present case we speculate that a 10 electrons in 8 orbitals active space would be appropriate for the
CASSCF of the ground state. Let’s try:



If we run that calculation, it converges and produces the following:



From which we see that we had *two orbitals too many in the active space* with occupation numbers very close to
two. The presence of barely correlated orbitals (occupation close to 0.0 or 2.0) can cause convergence problems.
Their inclusion in the active space does not significantly change the energy and it might better to omit these orbitals
from the start.

**7.15. The Complete Active Space Self-Consistent Field (CASSCF) Module** **585**

**ORCA Manual** **,** **Release 6.0.1**

In the present case, we re-run the CASSCF with 6 active electrons in six orbitals. The result is:



(continues on next page)

**586** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



The calculation converges very quickly and the occupation numbers show you that all of these orbitals are actually
needed in the active space. The omission of the two orbitals from the active space came at an increase of the energy
by *∼* 4 mEh which seems to be tolerable. Let’s look what we have in the active space in figure Fig. 7.4.

**7.15. The Complete Active Space Self-Consistent Field (CASSCF) Module** **587**

**ORCA Manual** **,** **Release 6.0.1**

(a) MO5 (b) MO6 (c) MO7

(d) MO10 (e) MO9 (f) MO8

Fig. 7.4: Orbitals of the active space for the CASSCF(6,6) calculation of H 2 CO.

Thus, we can see that we got a fairly nice result: our calculation has correlated the in-plane oxygen lone pair, the
C-O *𝜎* and the C-O *𝜋* bond. For each strongly occupied bonding orbital, there is an accompanying weakly occupied
antibonding orbital in the active space that is characterized by one more node. In particular, the correlating lone
pair and the C-O *𝜎* *[*]* orbital would have been hard to find with any other procedure than the one chosen based on
natural orbitals. We have now done it blindly and looked at the orbitals only after the CASSCF — a better approach
is normally to look at the starting orbitals *before* you enter a potentially expensive CASSCF calculation. If you have
bonding/antibonding pairs in the active space plus perhaps the singly-occupied MOs of the system you probably
have chosen a reasonable active space.

We can play the game now somewhat more seriously and optimize the geometry of the molecule using a reasonable
basis set:



and get:

**588** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**



Let us compare to MP2 geometries (this job was actually run first):





The results are actually extremely similar (better than 1 pm agreement). Compare to RHF:




(continues on next page)

**7.15. The Complete Active Space Self-Consistent Field (CASSCF) Module** **589**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Thus, one can observe that the correlation brought in by CASSCF or MP2 has an important effect on the C=O

*∼*
distance ( 4 pm), while the rest of the geometry is not much affected.

**More on the technical use of the CASSCF program.**

The most elementary input information which is always required for CASSCF calculations is the specification of
the number of active electrons and orbitals.



The CASSCF program in ORCA can average states of several multiplicities. The multiplicities are given as a list.
For each multiplicity the number of roots should be specified:

If the symmetry handling in ORCA is enabled ( `! UseSym` ) each multiplicity block must have an irreducible representation assigned. Numbers corresponding to the “irrep” within a given symmetry are printed in the output of
ORCA.



Several roots and multiplicities usually imply a state average CASSCF (SA-CASSCF) calculation. Note that the
program by default chooses equal weights for the multiplicity blocks. Roots within a given block have equal weight.
Users can define a custom weighting scheme for the multiplicity blocks and roots:



The program automatically normalizes these weights such that the sum over all weights is unity. If convergence
on an excited state is desired then the `weights[0]` array may look like `0.0,0.0,1.0` (this would optimize the
orbitals for the third excited state. If several states cross during the orbital optimization this will ultimately cause
convergence problems.

We note passing that the converged orbitals of the state averaged procedure are a compromise for the set of states.
ORCA by default only prints the SA-CASSCF gradient norm. State-specific gradients are summarized at the end
of the calculation with the keyword `PrintGState` .



**Orbital optimization methods.** In the following we discuss the available options for orbital optimization. A number of convergence problems can be resolved changing the guess orbitals. **The following keywords are optional**
**and should only be used facing severe convergence difficulties.** Aside from the `SuperCI_PT` (default),[459]
several orbital optimization methods (list below) are implemented.

**590** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**



The different convergers have different strengths. First order method are cheap but typically require more iterations
compared to second order methods. When the gradient is far off from convergence the program uses the converger
defined as `orbstep` while close to convergence the `switchstep` is used. The actual criteria for switchstep are
defined with the keywords `SwitchConv` and `SwitchIter` .



Picking a convergence strategy, the program has to balance speed and robustness. The default strategy uses the
`SuperCI_PT` as converger for `orbstep` and `switchstep` .[459] This approach determines the elements *𝑋* *𝑝𝑞* of the
anti-Hermitean matrix used in the orbital update according to

**C** *[𝑛𝑒𝑤]* = **C** *[𝑜𝑙𝑑]* *𝑒* **[X]**

from first order perturbation theory using the Dyall-Hamiltonian [238] in zeroth order and a first-order perturbed
wave function given as Ψ [(1)] = [∑︀] *𝑝𝑞* [Ψ] *𝑝* *[𝑞]* *[𝑋]* *[𝑞𝑝]* [where the][ Ψ] *[𝑞]* *𝑝* [represent singly excited functions obtained from the]

CASSCF wave function by excitation from orbital *𝜓* *𝑝* to orbital *𝜓* *𝑞* . The `SuperCI_PT` is robust with respect to
orbitals that are exactly doubly occupied or empty. Rotations with orbital close to this critical occupations can
further be eliminated with the keyword `DThresh` (default=1e-6). However, the method is quiet aggressive in the
orbital optimization. In some cases, such as basis set projection or `PATOM` guess (intrinsic basis set projection), the
program might pick a step-size that is too big. Then restricting the step-size via the keyword `MaxRot` (default=0.2)
might be useful. The keywords `DThresh` and `MaxRot` described below are specific to `SuperCI_PT` . For many users,
`MaxRot` is less palpable than level shifting. Therefore, the present version allows level shifts as well. **In contrast**
**to other convergers, level shifts are not needed and highly discouraged.** With the exception of `GradScaling`
( *vide infra* ), other damping techniques described further below do not apply to the `SuperCI_PT` .



In case of convergence problems with the default settings, it is recommended to try the combination of `orbstep`
`SuperCI` and `switchstep DIIS`, which in conjuction with a large level shift (2 Eh), which may be immediately
successful. The proposed scheme typically requires more iterations. Moreoever, in contrast to the SuperCI(PT),
the `SuperCI`, `DIIS` and `KDIIS` should not be used when the active orbitals have an occupation of exactly 2.0 or 0.0!
The `DIIS` may sometimes converge slowly or “trail” towards the end such that real convergence is never reached.
The `KDIIS` [452, 453] — based on perturbation theory — is an approximation to the regular `DIIS` procedure
avoiding redundant rotations. Both DIIS schemes avoid linear dependencies in the expansion space.



The combination of `SuperCI` and `DIIS` (switchstep) is particularly suited to protect the active space composition. Adjusting the level shift will do the job. **Here, level shift is the single most important lever to control**

**convergence** .

**7.15. The Complete Active Space Self-Consistent Field (CASSCF) Module** **591**

**ORCA Manual** **,** **Release 6.0.1**



Level-shift is particularly important if the active, inactive and virtual orbitals overlap in their orbital energies. The
energy separation of the subspaces is printed in the output. Ideally, the entries `Ext-Act` and `Act-Int` should be
positive and larger than 0.2 Eh. This will help the program to preserve your active space composition throughout
the iterations. If no shift is specified in the input, ORCA will choose a level-shift to guarantee an energy separation
between the subspaces ( `MinShift` ).



In difficult cases the use of the Newton-Raphson method ( `NR` ) is recommended even if each individual iteration is
considerably more expensive. It is strong towards the end but it would be a waste to start orbital optimization with
the expensive `NR` method since its radius of quadratic convergence is quite small. The computationally cheaper
alternative is the `SOSCF` procedure belonging to the family of quasi-Newton updates.

Keep in mind that the Newton-Raphson is designed for optimization on a **convex surface** (Hessian is semidefinite).
If the NR is switched on too early, there is a good chance that this condition is not fulfilled. In this case the program
will complain about negative eigenvalues or diagonal elements of the Hessian as can be seen in the snippet below.
The next optimization step is large and unpredictable. It is a wildcard that can get you closer to convergence or
immediate divergence of the CASSCF procedure.



For larger system, the augmented Hessian equations are solved iteratively (NR iterations). The augmented Hessian is considered solved when the residual norm, *< 𝑟|𝑟>*, is small enough. Aside from the overall CASSCF
convergence, negative eigenvalues affect these NR iterations.



There are a number of refined NR settings that influence the convergence behavior on a non-convex energy surface.
We mention the keywords for completeness and dis-encourage from changing the default settings. If overall convergence cannot be changed due to negative eigenvalues, it is recommended to delay the NR switchstep ( `switchconv,`
`switchiter` ). This will require some trial and error, since the curvature of the surface is *a priori* not know.



(continues on next page)

**592** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

In general, convergence is strongly influenced by numerical noise, especially in the final iterations. One source
of numerical noise is the incremental Fock build. Thus, it can help to enforce more frequent full Fock matrix
formation.
```
ResetFreq 1 # reset frequency for direct SCF

```
If the orbital change in the active space is small, the active Fock matrix in ORCA is approximated using the density
matrix from the previous cycle saving a second Fock matrix build. However, this approximation might also be
a source of numerical instability. The threshold “SwitchDens” can be set to zero to enable the exact build. The
program default starts with a rather large value (1e-2) and will reduce this parameter automatically when necessary.
```
switchdens 0.0001 # ~gtol * 0.1

```
In all of the implemented orbital optimization schemes the step-size correlates with the gradient-norm. A constant
damping factor can be set with the keyword `GradScaling` . Note, damping and level shifting techniques are not
recommended for the default converger ( `SuperCI_PT` ).
```
GradScaling 0.5 # constant damping in all steps

```
There are situations when the active space has been chosen carefully, but the initial gradient is still far off. To keep
the “good” active space, we can suppress all rotation but the inactive-external ones until the gradient-norm is small
enough to continue safely. The threshold can be set with `FreezeIE` keyword. Once the components of the gradient
in the inactive-external direction have a weight of less than `FreezeIE`, all constraints are lifted. ORCA by default
freezes active rotations if the total gradient norm is larger than 1.0 and the active rotations have a weight of less
than 5%. The feature can be turned off setting the threshold to zero.

Similarly, rotations of the almost doubly occupied orbitals with the inactive orbitals can be damped using the threshold `FreezeActive` . Rotations of this type are damped as long as all their weight is smaller than `FreezeActive` .
In contrast to the `ShiftDn`, it damps just the “troublesome” parts of internal-active rotations. This option applies
to all of the orbital optimization schemes but the `SuperCI_PT` .



If the calculation starts from a converged Hartree-Fock orbitals, the core orbitals should not change dramatically

**7.15. The Complete Active Space Self-Consistent Field (CASSCF) Module** **593**

**ORCA Manual** **,** **Release 6.0.1**

by the CASSCF optimization. Often trailing convergence is associated to rotations with low lying orbitals. Their
contribution to the total energy is fairly small. With the keyword `FreezeGrad` these rotations can be omitted from
the orbital optimization procedure.
```
FreezeGrad 0.2 # omit hitting a gradient norm ||g|| <0.2

```
The affected orbitals are printed at the startup of CASSCF.

By default rotations with frozencore (or deleted virtuals) are not omitted. If the option FreezeGrad is active, the
ratio with respect to the total gradient is printed.



**Using the RI Approximation.**

Aside from the Fock matrices, integrals appearing in the orbital gradient and Hessian require substantial computation time. A good way to speed up the calculations at the expense of “only” obtaining approximate results is to
introduce the RI approximation. `TrafStep RI` approximated the aforementioned integrals. Here are sufficiently
large auxiliary basis must be provided - ideally a /JK or /C. Further acceleration can be achieved approximating the
Fock matrix construction with `!RIJCOSX` or `!RIJK` as described in section *RI, RIJCOSX and RIJK approximations*
*for CASSCF* . More details can also be found in the CASSCF tutorial. Note that with ORCA 4.1, there are three
destinct auxiliary basis slots, that need to be set if the auxiliary basis is defined via the `%basis` block.



**Monitoring the active space**

During the iterations, the **active orbitals are chosen to maximize the overlap** with active orbitals from the previous
iterations. Maximizing the overlap does not make any restrictions on the nature of the orbitals. Thus initially
localized orbitals will stay localized and ordered, which is sometimes a desired feature e.g. in the density matrix
renormalization group approach (DMRG). This feature is set with the keyword `ActConstraints` and is enabled by
default (after the first 3 macroiterations). For some orbital optimization procedures, such as the SuperCI, natural
orbitals are more advantageous. Therefore, the `ActConstraints` can be turned off in favor of natural orbital
construction (see below). If the keyword is not set by the user, ORCA picks the best choice for the given orbital
optimization step.



In addition to maximizing the overlap, `"ActConstraints 1"` **checks if the composition of the active space has**
**changed** i.e. an orbital has been rotated out of the active space. In this case, ORCA aborts and stores the last valid
set of orbitals. Below is an example error message.



(continues on next page)

**594** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

In the snippet above, the active space ranges from 37-43. The program reports that orbitals 37,38 and 43 have
changed their character. The overlap of orbital 43 (active) with the previous set of active orbitals is just 3% and the
program aborts. There are a number of reasons, why this happens in the calculation. If this error occurs constantly
with the same orbitals, it is worthwhile to inspect the rotating partner orbitals (visualize). It might be sign that
the active space is not balanced and should be extended. In many instances changing the level-shift or lowering
switchconv is sufficient to protect the active space. In some cases, turning off the sanity check ( `"ActConstraints`
`0"` ) and re-rotating orbitals will bring CASSCF closer to convergence. Some problems can be avoided by a better
design of the calculation. The CASSCF tutorial elaborates on the subject in more detail.

There are situations such as parameter scans, where “actconstraints” is counter-productive and should be disabled.
In other words, we want to allow changes in the active space composition. As an example, consider the rotation
of ethylene around its double-bond represented by a CAS(2,2). Although the active space consists of the bonding
and anti-bonding orbitals *𝜋* -orbitals, their composition in terms of atomic orbitals changes from the eclipsed to the
staggered conformation. Depending on the actual input settings (orbstep and number of scan points), this might
trigger an abort.

**Final orbitals options.**

Once the calculation has converged, ORCA will do a final macro-iteration, where the orbital are “finalized”. For
complete active spaces (CAS), these transformations do not alter the final energy and wavefunction. Note, that
solutions from approximate CAS-CI solvers such as the ICE approach or the DMRG ansatz are affected by the
final orbital transformation. The magnitude depends on the truncation level (e.g. `TGen`, `TVar` and `MaxM` ) of the
approximated wavefunction. The default final orbitals are canonical in the internal and external space with respect
to state-averaged Fock operator. The active orbitals are chosen as natural orbitals. Other orbital choices are equally
valid and can be selected for the individual subspaces.



(continues on next page)

**7.15. The Complete Active Space Self-Consistent Field (CASSCF) Module** **595**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

SDOs are specific for the active orbital space.[491] The set of options ( `PMOS, OSZ, DOI, DoubelShell` ) are
specific for the inactive and external space. They aim to assist the extension of the current active space. All four
options, re-design the first `NOrb` (number of active orbitals) next to the active space, while the remaining orbitals
of the same subspace are canonical. The re-designed orbital are based on different concepts.

   - `PMOS` generates the bonding / anti-bonding partner orbitals for the chosen active space. It is based on the
orthogonalization tail of the active orbitals.

   - `OSZ` generates a single orbital for each active orbital, that maximizes the dipole-dipole interaction.

   - `DOI` follows the same principle as OSZ, but the differential overlap is maximized instead.

   - `DoubleShell` is specific to the external space. The highest active MO or `DoubleShellMO` is analyzed. A
set of orbitals with the same angular momentum but larger radial distribution is generated.

Optionally, the four options above can be supplemented with a reference MO using the keyword `RefMO/`
`DoubleShellMO` . The presence of `RefMO/DoubleShellMO` changes the default behavior. In case of `PMOS`, `OSZ`
and `DOI`, all orbitals of the given subspace are chosen to maximize a single objective function with respect to the
reference MO (must be active). This contrasts the default settings, where for each active MO an objective function
is maximized and a single “best” orbital is picked. In other words, in the default setting, each active orbital has a
corresponding “best” orbital in the selected subspace neighboring the active space.



The aforementioned options are aids and the resulting orbitals should be inspected prior extension of the active
space. In particular the `PMOS` option is useful in the context of transition metal complexes to find suitable Ligand based orbitals. There are more options ( `dorbs, forbs, DoubleShell` ), that are specifically designed for
coordination chemistry. A more detailed description is found in the CASSCF tutorial that supplements the manual.

If the active space consists of a single set of metal d-orbitals, natural orbitals may be a mixture of the d-orbitals.
The active orbitals are remixed to obtain “pure” d-orbitals (ligand field orbitals) if the `actorbs` is set to `dorbs` .
The same holds for f-orbitals and the option `forbs` . Furthermore, the keyword `dorbs` automatically triggers the
*ab initio* ligand field analysis (AILFT).[57, 490]The approach has been reported in a number of applications.[53,
56, 154, 169, 170, 428, 799, 837] Note that the actual representation depends on the chosen axis frame. It is
thus recommended to align the molecule properly. For more details on the AILFT approach, we refer to the AILFT
section ( *1- and 2-shell Abinitio Ligand Field Theory* ), the original paper and the CASSCF tutorial, where examples
are shown. For a few applications, a printing of the complete wavefunction is useful and can be requested.



The CI-step default setting is CSF based and is done in the present program by generating a partial “formula tape”
which is read in each CI iteration. The tape may become quite large beyond several hundred thousand CSFs which
limits the applicability of the CASSCF module. The accelerated CI (ACCCI) has the same limitations, but uses a
slightly different algorithm that handles multi-root calculations much more efficiently. For now, properties (spinorbit coupling, g-Tensor...) as well as NEVPT2 corrections are not available with ACCCI. Nevertheless, it is the
recommended option to converge a CASSCF calculation with multiple roots. The resulting .gbw file may be used
in a successive run to obtain properties or NEVPT2 corrections.

Larger active spaces are tractable with the DMRG approach or the iterative configuration expansion (ICE) developed in our own group.[171, 172] DMRG and ICE return approximate full CI results. The maximum size of the

**596** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

active space depends on the system and the required accuracy. Active spaces of 10–20 orbitals should be feasible
with both approaches. The CASSCF tutorial covers examples with ACCCI and ICE as CI solvers.



In the ICE approach, the computation of the coupling coefficients is time-consuming and by default repeated in
every macro-iteration. To avoid the reconstruction, it is recommended to once generate a coupling coefficient
library ( `cclib` ) and to use it for all of your ICE calculations. The details of the methodology and the `cclib` are
described in the ICE section *Approximate Full CI Calculations in Subspace: ICE-CI* .

Detailed settings for the conventional CI solvers (CSFCI, ACCCI, ICE) can be controlled in a sub-block. **Not all**
**of the options and properties are available for CISteps apart from the default!** NEVPT2, transition densities
and spin-dependent properties such as spin-orbit coupling are not yet available for `ACCCI` and `ICE` .



The `CI-step` DMRGCI interfaces to the **BLOCK** program developed in the group of G. K.-L. Chan [156, 157,
296, 789]. A detailed description of the **BLOCK** program, its input parameters, general information and examples on the density matrix renormalization group (DMRG) approach, are available in the section *Density Matrix*
*Renormalization Group* of the manual.

The implementation of DMRG in **BLOCK** is fully spin-adapted. However, spin-densities and related properties are
not available in the current version of the **BLOCK** code. To start a DMRG calculation add the keyword “ `CIStep`
`DMRGCI` ” into a regular CASSCF input. ORCA will set default parameters and generate and input for the **BLOCK**
program. In general, DMRG is not invariant to rotation in the active space. The program by **default** will run an
automatic ordering procedure ( `Fiedler` ). More and refined options can be set in the `dmrg` sub-block of CASSCF
— see section *Density Matrix Renormalization Group* for a complete list of keywords.

It is highly recommended to start the calculation with split-localized orbitals. Any set of starting orbitals (gbw file)
can be localized using the `orca_loc` program. Typing `orca_loc` in the shell will return a small help-file with
details on how to setup an input for the localization. Examples for DMRG including the localization are in the
corresponding section of the manual *Density Matrix Renormalization Group* . The utility program `orca_loc` is
documented in section *orca_loc* . Split-localization refers to an independent localization of the internal and virtual
part of the desired active orbitals.

NOTE:

**7.15. The Complete Active Space Self-Consistent Field (CASSCF) Module** **597**

**ORCA Manual** **,** **Release 6.0.1**

  - Let us stress again: it is strongly recommended to first LOOK at your orbitals and make sure that the ones
that will enter the active space are really the ones that you want to be in the active space! Many problems can
be solved by thinking about the desired physical contents of the reference space before starting a CASSCF.
A poor choice of orbitals results in poor convergence or poor accuracy of the results! Choosing the active
orbitals always requires chemical and physical insight into the molecules that you are studying!

  - Please try the program with default settings before playing with the more advanced options. If you encounter
convergence problems, have a look into your output, read the warning and see how the gradient and energy
evolves. Increasing `MaxIter` will not help in many cases.

  - Be careful with keywords such as `!tightscf`, `!verytightscf` and so on. These keywords set higher
integral thresholds, which is a good idea, but also tighten the CASSCF convergence thresholds. If you do
not need a tighter energy convergence, reset the criteria in the casscf block using `ETol` . For many applications
an energy convergence beyond 10 *[−]* [7] is unnecessary.

**7.15.2 CASSCF Densities**

The one-particle electron and spin density can be stored on disk using the keyword `!KeepDens` . ORCA stores
all densities in a container ( **.densities** file on disk), which can be used in conjunction with `orca_plot` to plot the
charge and spin densities. Please check Section *orca_plot* for more details on the procedure. The state-specific
densities will have a name postfix that reflects the root, multiplicity and potentially irreducible representation of the
state. Densities arising from a calculation with the spin-orbit coupling, will have an additional flag in the density
container marking their origin (e.g. “cas_qdsoc” or “nev_qdsoc”).

**7.15.3 CASSCF Properties**

The CASSCF program is able to calculate UV transition, CD spectra, SOC, SSC, Zeeman splittings, EPR gmatrices and A-matrices (the latter implemented in the same way as in the DCD-CAS(2) method[491]), magnetization, magnetic susceptibility and MCD spectra. Note that the results for the Fermi contact contribution to A will
not be reliable if the spin density is dominated by spin polarization, which is a dynamic correlation effect. The
properties are exercised in more detail in the CASSCF tutorial. The techniques used to calculate SOC, and Zeeman
splittings are identical to those implemented into the MRCI program. Input and keywords mimic the ones in the
MRCI module described in section *Properties Calculation Using the SOC Submodule* . As an example, the input
file to calculate g-values and HFC constants A of CO [+] is listed below:



In addition to pseudo-spin 1/2 A-tensors for individual Kramers doublets, the CASSCF module also features the
calculation of “intrinsic” HFC A-tensors for the whole lowest nonrelativistic spin multiplet in the effective Hamiltonian approach.[489]

In contrast to the MRCI module, the CASSCF module also supports the calculation of susceptibility tensors at
non-zero magnetic fields. The corresponding keywords are

**598** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**



This example input calculates the susceptibility tensor at the two (vector-valued!) magnetic fields (35000,0,0)
and (70000,0,0) (in Gauss). Note that for practical reasons it is necessary to specify the number of user-defined
magnetic fields using the keyword `susctensor_nfields` .

Until ORCA 4.0 it was possible to access spin-spin couplings only via running CAS-CI type calculations in MRCI.
Converged CASSCF orbitals can be read setting the following flags



Starting with ORCA 4.1, spin-spin couplings are also directly accessible in the CASSCF module via the keyword
`DoSSC true` in the `rel` subblock. Note that the calculation of SSC requires the definition of an auxiliary basis
set ( `AuxC` auxiliary basis set slot), since it is only implemented in conjunction with RI integrals. A common
way to introduce dynamical correlation for the property computation, is to replace the energies entering the quasidegenerate perturbation theory. If the NEVPT2 energy correction is computed in CASSCF, there will be additional
printings where CASSCF energies are replaced by the more accurate NEVPT2 values. Alternatively, these diagonal
energies can be taken from the input file similarly how it is described for the MRCI module. A more detailed
documentation is presented in the MRCI property section.

**Note:**

  - The program does NOT print the SOC matrix by default! To obtain SOCMEs at the CASSCF/NEVPT2/...
levels, please set the `PrintLevel` in the `rel` block to at least 2.

**7.15. The Complete Active Space Self-Consistent Field (CASSCF) Module** **599**

**ORCA Manual** **,** **Release 6.0.1**

**7.15.4 1- and 2-shell Abinitio Ligand Field Theory**

Starting from ORCA 5.0, ORCA features a 1- and 2-shell AILFT module. AILFT was originally developed for 1shell d- and f- LFT problems [57, 490]. In ORCA 5.0 an extenion to 2-shell AILFT provides access to all common
1- and 2-shell AILFT problems namely:

1. Valence LFT problems, involving the d-, f-, sp-, ds- and df-shells

2. Core LFT problems involving the sd-, pd-, sf- and pf-shells become readily accesible.

Requesting an CAS-AILFT calcultion withing the CASSCF module is provided in two ways:

1. Through the ActOrbs xOrbs keywords (e.g. xOrbs: dOrbs, fOrbs spOrbs, psOrbs, sdOrbs, dsOrbs, sfOrbs,
fsOrbs, pdOrbs, dpOrbs, pfOrbs, fpOrbs, dfOrbs, fdOrbs)

2. Through the LFTCase keyword where particular LFT problems can be requested according to the above 1and 2-shell combinations (e.g. LFTCase 3d, LFTCase 4f, LFTCase 1s3d, LFTCase 2p3d ...)

Note: that the LFTCase keyword overwrites the ActOrbs keyword and as it will be discussed below provides a
particular utility that simplifies the 2-shell AILFT input.

A simple input for the Ni [2+] *𝑑* [8] ion is provided below:

The programm after the CASSCF convergence will undergo few important steps and sanity checks which involve

1. an Orbital purification step

2. a Phase correction of the 1 and 2-electron integrals

It is then important from the user’s perspective to monitor that these steps have been succesfully performed. The
relevant parts of the output are provided below:



(continues on next page)

**600** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

In a subsequent step the program will

1. compute the AI Hamiltonian

2. construct the parameterized LFT Hamiltonian

3. and perform the fit

The relevant output can be seen below:



In following the fitted 1-electron energies and SCP parameters also Racah parameters for 1-shells will be printed
at the CASSCF and NEVPT2 levels of theory



(continues on next page)

**7.15. The Complete Active Space Self-Consistent Field (CASSCF) Module** **601**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
dz2 -8.111733 -0.000000 -0.000000 0.000000 -0.000000
dxz -0.000000 -8.111733 -0.000000 -0.000000 0.000000
dyz -0.000000 -0.000000 -8.111733 -0.000000 0.000000
dx2-y2 0.000000 -0.000000 -0.000000 -8.111733 -0.000000
dxy -0.000000 0.000000 0.000000 -0.000000 -8.111733
------------------------------------------------Slater-Condon Parameters (electronic repulsion) :
------------------------------------------------F0dd(from 2el Ints) = 0.980960738 a.u. = 26.693 eV = 215296.0 cm**-1 (fixed)
F2dd = 0.451725025 a.u. = 12.292 eV = 99142.2 cm**-1
F4dd = 0.280604669 a.u. = 7.636 eV = 61585.6 cm**-1
------------------Racah Parameters :
------------------A(F0dd from 2el Ints) = 0.949782441 a.u. = 25.845 eV = 208453.2 cm**-1
B = 0.006037419 a.u. = 0.164 eV = 1325.1 cm**-1
C = 0.022270212 a.u. = 0.606 eV = 4887.7 cm**-1
C/B = 3.689
----------------------------------------------------------------------------------------------------------------------The ligand field one electron eigenfunctions:
----------------------------------------Orbital Energy (eV) Energy(cm-1) dz2 dxz dyz dx2-y2 dxy
1 0.000 0.0 -0.999978 -0.000164 -0.001934 0.005783 -0.002568
2 0.000 0.0 -0.005768 -0.000269 -0.000262 -0.999967 -0.005788
3 0.000 0.0 0.002600 0.000424 0.001046 0.005773 -0.999979
4 0.000 0.0 0.000241 -0.999246 -0.038831 0.000280 -0.000462
5 0.000 0.0 0.001930 0.038832 -0.999243 0.000246 -0.001022
Ligand field orbitals were stored in ni.3d.casscf.lft.gbw
...
-----------------------------AILFT MATRIX ELEMENTS (NEVPT2)
-------------------------------Ligand field one-electron matrix VLFT (a.u.) :
Orbital dz2 dxz dyz dx2-y2 dxy
dz2 -8.118685 0.000000 0.000000 0.000005 -0.000000
dxz 0.000000 -8.118666 -0.000000 -0.000000 0.000000
dyz 0.000000 -0.000000 -8.118674 -0.000000 0.000000
dx2-y2 0.000005 -0.000000 -0.000000 -8.118676 0.000000
dxy -0.000000 0.000000 0.000000 0.000000 -8.118667
------------------------------------------------Slater-Condon Parameters (electronic repulsion) :
------------------------------------------------F2dd = 0.415943380 a.u. = 11.318 eV = 91289.0 cm**-1
F4dd = 0.259145554 a.u. = 7.052 eV = 56875.9 cm**-1
------------------Racah Parameters :
------------------B = 0.005550482 a.u. = 0.151 eV = 1218.2 cm**-1
C = 0.020567107 a.u. = 0.560 eV = 4514.0 cm**-1
C/B = 3.705
----------------------------------------------------------------------------------------------------------------------The ligand field one electron eigenfunctions:

```
(continues on next page)

**602** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Note that:

  - At the CASSCF level F0 (and subsequently racah A) is computed from CASSCF 2-electron coulomb integrals

  - On the other hand at the NEVPT2 level F0 is not defined hence F0 and racah A are not printed. Below an
alternative using the effective Slater exponnets will be provided.

  - The LFT orbitals are saved in *.lft.gbw files which can be processed by the orca_plot to generate orbital
visualization files.

AILFT provides a Fit quality analysis (see the original paper [57, 490])

Note: That at the CASSCF level the AI matrix of free atoms and ions is exactly parameterized in the chosen LFT
parameterization scheme. As a result the RMS AI-LFT fitting errors is expected to be practically zero. This is not
the case when a correlation treatment is chosen like NEVPT2 and the errors are expected to be somewhat larger.

The above is shown below:



(continues on next page)

**7.15. The Complete Active Space Self-Consistent Field (CASSCF) Module** **603**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)




(continues on next page)

**604** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Several utilities are offered for more specialized tasks that provide better control of the AILFT inputs and outputs:

  - Skipping orbital otimization or reading in previously computed orbitals can be requested in two ways:

1. By the !NoIter keyword in the command line

2. By the AILFT_SkipOrbOpt in the ailft block (see example below)

  - Estimating F0 SCPs or Racah A from single zeta Slater Exponents can be requested from the
AILFT_EffectveSlaterExponents true keyword in the ailft block

  - For the above task the knowledge of the principle quantum numbers is required. This can be specidied in

two ways:

1. By the AILFT_PQN x keyword in the ailft block (x=3 for 3d)

2. By the LFTCase x keyword (LFTCase 3d, ommiting in this way the ActOrbs dOrbs keyword)

Let us see how all the above translates in the above example of the Ni [2+] *𝑑* [8] ion



(continues on next page)

**7.15. The Complete Active Space Self-Consistent Field (CASSCF) Module** **605**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



By running the above input the fitted 1-electron energies and SCP parameters also Racah parameters for 1-shells
will be printed at the CASSCF and NEVPT2 levels of theory, including F0s and Racah A as estimated from single
zeta effective Slater exponents from the fitted F2dd SCPs.



(continues on next page)

**606** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



It is also possible to treat only the High Spin states in the d- and f- 1-shell AILFT. Note that not all the cases can be
treated as this renters the different SCP parameters undefined. In the beggining, AILFT will check whether such
case is detected and will drop a warning message

For example in the case of the Fe [2+] *𝑑* [6] ion with an input like the following:



(continues on next page)

**7.15. The Complete Active Space Self-Consistent Field (CASSCF) Module** **607**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



the following Warning will be printed in the beggining of the calculation



Spin orbit coupling effects (SOC) can be introduced by parametrizing the effective SOC constant *𝜁* . As long as
SOC is requested in the rel CASSCF block the respective requested shell effective SOC constant *𝜁* will be computed
at the end of every AILFT calculation

Hence in the above examples one gets:



(continues on next page)

**608** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Starting fron ORCA 5.0 it is also possible in addition to CASSCF and NEVPT2 to employ DCDCAS(2) and
Hermitian QD-NEVPT2 Abinitio Hamiltonians in AILFT Example inputs are provided below for DCDCAS(2):




and Hermitian QD-NEVPT2:



(continues on next page)

**7.15. The Complete Active Space Self-Consistent Field (CASSCF) Module** **609**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



Running the above inputs the respective DCDCAS(2) and Hermitian QD-NEVPT2 Hamiltonians will be processed:



It should be noted that NEVPT2 and Hermitian QD-NEVPT2 AILFT require a complete saturation of the excitation
space. This implies that if less roots than the required are requested the AILFT analyis will be skipped in these cases.
This is on the contrary not the case in CASSCF or DCDCAS(2) in which AILFT can operate under incomplete
saturation of the excitation space.

**610** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

In a similar fashion one can request a 2-shell AILFT calulation.

For this purpose the recomended steps are the following:

  - In a first step the valence active space orbitals are optimized in the framework of SA-CASSCF calculation.e.g.
the 3d MOs in a core 1s3d or 2p3d AILFT calculation, or the f MOs in an 4f5d AILFT calculation)

  - In a second step the relevant core or virtual orbitals are rotated into the active space and the chosen CASCI/AILFT problem is solved by saturating the excitation space with all the involved excitations/multiplicity.

  - In the most of the cases the excitation space of two multiplicities the High-Spin one and the subsequent
Low-Spin one are enouph for a succesfull fitting of the parameters

It should be noted that 2-shell AILFT ivolves a 2-step fitting process following a bottom up shell angular momentum
approach :

1. At first when possible an intra-shell fitting is performed

2. In following the respective effective Slater exponents are derived

3. In a last step an inter-shell fitting is performed and all the computed/fitted parameters are printed

This implies that:

  - the flag of computing effective Slater exponents is always on by default in 2-shell AILFT

  - the desired LFT problem is best requested by the LFTCase keywords (e.g. LFTCase 1s3d)

Let look at the case of 1s3d LFT problem of the Ni [2+] *𝑑* [8] ion. A relevant input is provided below:



**7.15. The Complete Active Space Self-Consistent Field (CASSCF) Module** **611**

**ORCA Manual** **,** **Release 6.0.1**

Like in 1-shell AILFT, 2-shells AILFT starts with a sanity check



In following the AI-LFT Hamiltonians are constructed and the LFT parameters are fitted at the CASSCF and at the
NEVPT2 levels of theory



(continues on next page)

**612** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



As discussed above saturation of the excitation space is a requirement also in the case of 2-shell AILFT. It is usually
enough to specify a large number of roots for two multiplicites (e.g. 100 singlets and triplets in the above example)
The exact number of roots will be automatically detected.



(continues on next page)

**7.15. The Complete Active Space Self-Consistent Field (CASSCF) Module** **613**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)


However very often the required number of states to be computed in the framework of NEVPT2 type of calculations
are quite large. In these cases a Hamiltonian reduction process on the basis of the Restrictive Active Space (RAS)
is required. In fact all LFT parameters can be determined by considering up to double excitations from the donorshell.

Let us consider the 2p3d case of the Fe [2+] *𝑑* [6] ion. Saturation of the active space requires to consider 70 triplet and
378 singlet states. Restriction of the active space to only up to double excitations from the 2p-shell results in 65
quintet and 330 triplet states. The Hamiltonian reduction can be requested in the ailft block:



(continues on next page)

**614** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
end

```
Hence the relevant input can be now formulated as:

Note that before running the above calculation:

  - An initial SA-CASSCF calculation has been performed on the valence states of Fe in the 3d active space.
These orbitals (fe.3d.gbw) are read in

  - The computation of the g- and D- tensors is switched off. This is recomended if the magnetism analysis is
not required

  - As core spectroscopy is targeted the frozen core is switched off

At the NEVPT2 part the reduced AI and LFT Hamiltonians will be constructed



(continues on next page)

**7.15. The Complete Active Space Self-Consistent Field (CASSCF) Module** **615**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

As a result the CASSCF and NEVPT2 LFT parameters will be determined in the requested reduced basis

In the above example inclusion of SOC will result in the computation of the effective SOC *𝜁* constants of both p
and d shells:



One important feature of 1- and in particular of the 2-shell AILFT is that it is connected to the standalone orca_lft
multiplet program. Hence every succesfull AILFT calculation will automatically construct relevant inputs for the
orca_lft.

For example in the avove 2p3d case of the Fe [2+] *𝑑* [6] ion the following inputs will be constructed

**616** **Chapter 7. Detailed Documentation**

with the NEVPT2 one looking like this:


**ORCA Manual** **,** **Release 6.0.1**

(continues on next page)



**7.15. The Complete Active Space Self-Consistent Field (CASSCF) Module** **617**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



Further details regardin orca_lft can be found in the orca_lft section ( *orca_lft* ) and the orca_lft tutorial.

**7.15.5 Core excited states with (C/R)ASCI/NEVPT2**

Starting from ORCA 4.1, a CASCI/NEVPT2 protocol can be used to compute core excited spectra, namely Xray absorption (XAS) and resonant inelastic scattering (RIXS) spectra. RASCI calculations can also be easily
specified.

The XAS/RIXS spectra calculations requires two steps:

  - In a first step one needs to optimize the valence active space orbitals in the framework of SA-CASSCF
calculations, e.g. including valence excited states in the range between 6 to 15 eV.

  - In a second step the relevant core orbitals are rotated into the active space and the (C/R)ASCI/NEVPT2
problem is solved by saturating the excitation space with singly core-excited electronic configurations using
the previously optimized sets of orbitals

Further information can be found in reference[163]

A relevant input for Fe L-edge XAS calculation of a Fe(III) complex like Fe(acac) 3 is given below for
CASCI/NEVPT2:



(continues on next page)

**618** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



For RASCI/NEVPT2 calculations the valence d AS is set to RAS2. The RAS3 space is usually set empty. The
RAS1 space contains the previously rotated core orbitals. To generate a single core hole, the number of maximum
holes in the RAS1 space must be set to 1. Accordingly, the maximum number of particles in the RAS3 space must
be 0. The RASCI input should thus look the following



As it is explicitly described in the respective ROCIS section RIXS spectra can be requested by the following keywords:



Please consult section *Resonant Inelastic Scattering Spectroscopy* for processing and analyzing the generated spec
tra.

**7.15. The Complete Active Space Self-Consistent Field (CASSCF) Module** **619**

**ORCA Manual** **,** **Release 6.0.1**

**7.15.6 CASCI-XES**

Starting from ORCA 5.0 likewise to RASCI-XES (see section *X-ray Spectroscopy* ) orca features a CASCI-XES
protocol.

Likewise to the RASCI-XES the CASCI-XES calculations requires two steps:

  - In a first step one needs to optimize the valence active space orbitals in the framework of SA-CASSCF
calculations, e.g. including valence excited states in the range between 6 to 15 eV.

  - In a second step the relevant core orbitals e.g metal 1s and 3p are rotated into the active space and the
CASCI problem is solved for the ionized system by saturating the excitation space with singly core-excited
electronic configurations using the previously optimized sets of orbitals. In CASCI-XES this can be acheived
by defining reference configurations. or via the RAS functionality.

The XESSOC calculation is called by speciyfing the following keywords in the rel block:



Following a SA-CASSCF calculation:



A relevant input for Fe XES calculation of a Fe(III) complex like FeCl 6 is given below:




(continues on next page)

**620** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)




In ORCA 6 all these inputs between like MRCI, CASSCF and LFT have been unified so like in *X-ray Spectroscopy*
one can also specify the respective RAS excitation space as following:



(continues on next page)

**7.15. The Complete Active Space Self-Consistent Field (CASSCF) Module** **621**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

In the above inputs one notes that the exact knowledge of the states to saturate the excitations space is not required.
One only need to specify a large number (e.g. 1000) and the program will automatically detect the required 19
septet and 270 quintet states:



By now running the above input for the 4 septet and the 81 quintet states the following output is generated




(continues on next page)

**622** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Finally by processing the .out file with orca_mapspc:
```
orca_mapspc fecl6_xes.out XESSOC -x07140 -x17190 -w4.0 -eV -n10000

```
and by plotting the resulted XES spectrum one will get the respective RASCI-XES spectrum presented in Fig. 7.42

Since Orca 6.0 the computed transition moments in the presence of SOC can be taken beyond the dipole approximation by using the OPS tool, check section ( *One Photon Spectroscopy* ) for details.

All the possible approximations can be requested with the following commands:



This wil generate a list of tables which for the case of XESSOC will look like the following:



(continues on next page)

**7.15. The Complete Active Space Self-Consistent Field (CASSCF) Module** **623**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Orca_mapspc can process all these files. The list of the relevant keywords is:



A more complete list can be found in ( *orca_mapspc* )

**624** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**
### **7.16 CASSCF Linear Response**

Similar to the SCF linear response (see *CP-SCF Options* ), second-derivative properties can be calculated at the
CASSCF level by solving the coupled perturbed (CP-)CASSCF equations for the linear response of the wavefunction parameters to a perturbation. These linear response equations are expressed as


*𝜕* [2] *𝐸* *𝜕* ***𝜆***

*𝜕* ***𝜆*** [2] *𝜕* **R** [=] *[ −]* *𝜕* *[𝜕]* ***𝜆*** [2] *𝜕* *[𝐸]*


*𝜕* [2] *𝐸*


*𝜕* ***𝜆*** *𝜕* **R**


where ***𝜆*** are the CASSCF wavefunction parameters and **R** are the perturbations for which the response equations
are being solved [378, 861]. The property gradient on the right-hand side (RHS) is a known perturbation-dependent
quantity, but the left-hand side (LHS) depends on the solution of the response of the wavefunction parameters to
**R** . Therefore, the response to the perturbation must be solved for iteratively, which is done using the trial vectors
**X** . This leads to the LHS being computed as a sigma-vector, which is reassembled at every iteration. The linear
response equation for perturbation *𝑅* *𝑖* can then be written as

***𝜎*** = **HX** [(] *[𝑅]* *[𝑖]* [)] = **G** [(] *[𝑅]* *[𝑖]* [)]

where **H** is the perturbation-independent Hessian matrix and **G** is the perturbation-specific RHS matrix. Once the
linear equation converges, the solution vector of the response parameters can then be contracted with the electronand spin-density matrices to yield the AO response density matrices, [︀ **P** *[𝛼][±][𝛽]* []︀] [(] **[R]** [)] . The response densities can
then be contracted with appropriate AO 1-electron property integrals to compute the second-order contributions to
second-derivative properties.

In ORCA these equations are solved by the `orca_casscfresp` program and the underlying solver is `BHP22`, a
Davidson-type linear equation solver. The RHS is built from the property integrals calculated in the `orca_propint`
program. After the solution converges and the response densities are made and stored, the `orca_prop` program is
called, wherein the appropriate densities and response densities are contracted with the necessary property integrals
(also from `orca_propint` ). This use of densities keeps the response property calculations in `orca_prop` generally
applicable to all methods as the densities house the method-specific information.

**7.16.1 Input Block**

The input block `%casresp` is available for requesting the following options (given below with their default values):



Note that the solver-related options in the `%elprop` and `%eprnmr` blocks do not affect the solution of the CPCASSCF equations.

**7.16. CASSCF Linear Response** **625**

**ORCA Manual** **,** **Release 6.0.1**

**7.16.2 Technical Notes**

It should be noted that CASSCF linear response uses the optimized CASSCF wavefunction as a starting point. Thus,
a `%casscf` block with the appropriate inputs (see *Complete Active Space Self-Consistent Field Method* ) must be
provided in the input. State-specific (SS-)CASSCF response is run on SS ( `NRoots 1` ) CASSCF wavefunctions. If
the CASSCF wavefunction is state-averaged (SA), the response is run over the averaged manifold of states and not
on a specific root. In this case, one should analyze the output carefully. It is wise to only average states which are
(nearly-)degenerate.

By default, a CASSCF calculation will be run from scratch before running the CASSCF Response. Alternatively,
orbitals from a previously converged CASSCF calculation may be used with `!MOREAD NoIter` and supplying the
appropriate `.gbw` file via `%moinp` . In this case, be sure that the input in the `%casscf` block matches that from the
same input block of the previously converged calculation and be sure to check the orbitals well!

The appropriate property flags in the `%elprop` and `%eprnmr` blocks must be set to calculate the properties that
are wanted (see *Electric Properties*, *EPR and NMR properties*, and *Calculation of Properties* ). While all firstderivative properties work with CASSCF, not all second-derivative properties are currently available with CASSCF.
The static properties currently available (sorted by perturbation taken for the response) include:

  - Electric ( **E** ) Field

**–**
Dipole/dipole Polarizability

**–**
Dipole/quadrupole Polarizability

  - Quadrupole ( **Q** ) Field

**–**
Quadrupole/Quadrupole Polarizability

  - Magnetic ( **B** ) Field ( **without** GIAOs)

**–**
EPR g-Tensor

**–**
NMR Chemical Shieldings

  - Velocity ( **v** )

**–**
Velocity Polarizability

The magnetic properties are currently implemented without gauge-including atomic orbitals (GIAOs). Thus, an
appropriate gauge-origin must be provided in the `%eprnmr` block! For the EPR g-tensor, using a large basis set with
a chemically relevant gauge origin is recommended. However, one should in general be wary of NMR chemical
shieldings without GIAOs. GIAOs for CASSCF linear response are coming soon to ORCA!

**7.16.3 Notes on Printing**

The information on the types of property integrals computed can be found in the `ORCA PROPERTY INTEGRAL`
`CALCULATIONS` section of the output file. The `orca_casscfresp` output begins with the header `ORCA CASSCF`
`RESPONSE CALCULATION` . After information about the types and number of perturbations, the calculation splits
into the major types of perturbations: real and imaginary. All response equations of the same type can be solved
simultaneously.

Each of these types has its own section in the output file. These sections begin with information on the orbital
ranges and the CI space, then go into the iterative solution of the equations. The printout here gives an overview
of the iteration number, the residual norm of each response equation, and if that response equation has met the
convergence criteria. The following is an example of this output (with iterations 3–7 removed for simplicity):



(continues on next page)

**626** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Before going on to the necessary property modules, the significant contributions to the RHS and/or response vectors
will be outputted if they were requested (via `PrintRHSVec` and `PrintRspVec` ). Here, outputs such as the following
can be seen.



The majority of the output has been removed for the sake of simplicity. Here, the significant contributions to
the response vector are printed if the square of the vector element is larger than `1.0e-02` (the default value for
`TolPrintVec` ). Each line begins with either a `(+)` or `(-)`, which denote the Hermiticity of the excitation operator.
With static CASSCF linear response, `(+)` always denotes an imaginary perturbation and `(-)` a real perturbation.
For the first vector (i.e. `IPERT: 0` ), four contributions have been listed here.

The first three are from particle-hole excitations going from the left size of the arrow to the right. On each side of
the arrow has three things: a letter designating if it is an inactive ( `I` ), active ( `A` ), or virtual ( `V` ) orbital; a number
designating the index within that orbital subblock, and a number in parentheses designating the overall orbital
number. Further to the right, the coefficient (i.e. the vector element) is given in parentheses and the square of that
value is given to the left of it. This is how the relative contributions of each excitation can be analyzed.

The final contribution shown is from a CI excitation. Its weight is listed, followed by the index in brackets and the
corresponding configuration of the active electrons among the active orbitals.

**7.16. CASSCF Linear Response** **627**

**ORCA Manual** **,** **Release 6.0.1**

**7.16.4 Troubleshooting**

If the `%casresp` block is specified and the calculation does not run through the CASSCF Response section, then
the properties requested are not second-derivatives and therefore do not require linear response equations to be
solved. If, however, the job aborts, watch for these possibilities:

  - At least one of the second-derivative properties requested is not available at the CASSCF level (see list above
of those currently implemented)

   - `MaxIter` may need to be increased or `TolR` decreased

  - A magnetic property is requested without setting the gauge-origin in the `%eprnmr` block

  - An appropriate auxiliary basis (or the `!AutoAux` keyword) may be required, especially for:

**–**
The diagonal preconditioner (which is on by default)

**–** `TrafoStep RI` in the `%casscf` block

**–**
RIJCOSX, RIJONX

  - RIJK was specified (this is **NOT** supported)

**7.16.5 Minimal Input File**

The following is an overview of the blocks required for a property calculation with


### **7.17 Interface to SINGLE_ANISO module**

**7.17.1 General description**

The `SINGLE_ANISO` program allows the non-perturbative calculation of effective spin (pseudospin) Hamiltonians
and static magnetic properties of mononuclear complexes and fragments on the basis of an *ab initio*, including the
spin-orbit interaction. As a starting point it uses the results of a `CASSCF/NEVPT2/SOC` calculation for the ground
and several excited spin-orbit multiplets.

The following quantities can be computed:

  - Parameters of pseudospin magnetic Hamiltonians (the methodology is described in [168]) :

**628** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

1. First order (linear after pseudospin) Zeeman splitting tensor ( *𝑔* tensor), including the determination of
the sign of the product *𝑔* *𝑋* *· 𝑔* *𝑌* *· 𝑔* *𝑍* .

2. Second order (bilinear after pseudospin) zero-field splitting tensor ( *𝐷* tensor).

3. Higher order zero-field splitting tensors ( *𝐷* [2] *, 𝐷* [4] *, 𝐷* [6] *, ..., 𝑒𝑡𝑐.* )

4. Higher order Zeeman splitting tensors ( *𝐺* [1] *, 𝐺* [3] *, 𝐺* [5] *, ..., 𝑒𝑡𝑐.* )

  - Crystal-Field parameters for the ground atomic *𝐽* [˜] multiplet for lanthanides. [414, 859]

  - Crystal-Field parameters for the ground atomic *𝐿* [˜] term for lanthanides and transition metals.

  - Static magnetic properties [857, 858]:

1. Van Vleck susceptibility tensor *𝜒* *𝛼𝛽* ( *𝑇* ).

2. Powder magnetic susceptibility function *𝜒* ( *𝑇* ).

3. Magnetisation vector *𝑀* *[⃗]* ( *𝐻* *[⃗]* ) for specified directions of the applied magnetic field *𝐻* *[⃗]* .

4. Powder magnetisation *𝑀* *𝑚𝑜𝑙* ( *𝐻, 𝑇* ).

5. Magnetisation torque function *⃗𝜏* *𝑚𝑜𝑙* ( *𝐻, 𝑇* ).

The magnetic Hamiltonians are defined for a desired group of *𝑁* low-lying electronic states obtained in `CASSCF/`
`SOC` calculation to which a *pseudospin* *𝑆* [˜] is subscribed according to the relation *𝑁* = 2 *𝑆* [˜] + 1. The *pseudospin* *𝑆* [˜]
reduces to a true spin *𝑆* in the absence of spin-orbit coupling. For instance, the two wave functions of a Kramers
doublet correspond to the pseudospin *𝑆* ˜, and controlled by the keyword `MLTP` *𝑆* [˜] . = 1 */* 2. The implementation is done for *𝑎𝑛𝑦* dimension of the pseudospin

The calculation of magnetic properties takes into account the contribution of excited states (the ligand-field and
charge transfer states of the complex or mononuclear fragment which were included in the `CASSCF/CASPT2` calculation) via their thermal population and Zeeman admixture. The effect of intermolecular exchange interaction
between magnetic molecules on the resulting magnetic properties in a crystal is described by a phenomenological
parameter *𝑧𝐽* specified by the user.

**7.17.2 Running** `SINGLE_ANISO` **calculations**

The `SINGLE_ANISO` is, in principle, a stand-alone utility ( `otool_single_aniso` ) that can be called directly from
the shell with its own input file, provided that the *ab initio* datafile is available:



However, this usage may not be so convenient, as the file `single_aniso.input` must include the true name of
the datafile. For the user’s convenience, a deeper integration between `SINGLE_ANISO` and CASSCF program in
ORCA was implemented, as described below.

As a prerequisite for using the `SINGLE_ANISO` module to calculate the magnetic properties of the investigated
compound, **spin-orbit coupling and other relativistic effects are already taken fully into account at the stage**
**of quantum chemistry calculation of the investigated compound** . The necessary information of the *ab initio*
calculation is provided in a form of a “datafile”: energy spectra, angular momentum integrals, etc. The interface
with ORCA generates the required `datafile` automatically. The following naming conventions were adopted for
the `datafile` in function of the employed computational method:

   - `CASSCF+SOC+SINGLE_ANISO` = *>* `"$orca_input_name.CASSCF.anisofile"`

   - `CASSCF+QD-NEVPT2+SOC+SINGLE_ANISO` = *>* `"$orca_input_name.NEVPT2.anisofile"`

Note that if the `CASSCF+QD-NEVPT2+SOC+SINGLE_ANISO` calculation is requested, then the `SINGLE_ANISO` will
be executed twice, and the above two datafiles will be generated. The interface will generate the `SINGLE_ANISO` input file with the keywords information provided in the `CASSCF/aniso` subblock. These filename of the `datafile`

**7.17. Interface to SINGLE_ANISO module** **629**

**ORCA Manual** **,** **Release 6.0.1**

is included automatically in the input file for the `SINGLE_ANISO` utility (keyword `DATA` ), also generated automatically by the interface. The naming convention for the generated input files for the `SINGLE_ANISO` utility is
“$orca_input_name.anisofile”.

All keywords of the `SINGLE_ANISO` program are possible to be specified within the `CASSCF/ANISO` subblock.
They are referenced in Section *Reference list of CASSCF/ANISO keywords* . Optionally, a working `SINGLE_ANISO`
input file can be passed directly to the `CASSCF` module setting the filename with keyword `InputNameOnDisk` in
the `ANISO` subblock.

An example of the full ORCA input for performing magnetic properties calculations within the `CASSCF/SOC/`
`SINGLE_ANISO` methodology for a hypothetical Co(II) compound is provided below:



(continues on next page)

**630** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

The input above utilises the following keywords: `MLTP` keyword requires the computation of the *𝑔* tensor for 4
groups of spin-orbit states, the dimensionality of each group being 2 (Kramers or Ising doublets). `TINT` requires
computation of the magnetic susceptibility in the temperature interval 0 K - 300 K distributed equally in 300 temperature intervals. `TMAG` requires computation of powder molar magnetisation at 6 temperature points, in Kelvin
(K): 1.0 K, 1.2 K, 1.8 K, 2.5 K, 2.9 K and 3.6 K. `HINT` defines the range for the magnetic field strength, in Tesla.
`PLOT` keyword invokes the plotting function of the module. `CRYS_element + CRYS_charge` request for the computation of the crystal field parameters for the ground term of the Co [2+] ion. For more information about the
keywords in `SINGLE_ANISO` module, you can refer to section *Reference list of CASSCF/ANISO keywords* .

**Please always check the obtained orbitals after** `CASSCF` **calculation** . In this particular case, the active orbitals
(45-49) are localised on the Co site and display dominant 3 *𝑑* character.



We see that in the above output section, the five active orbitals have dominant contribution from the Co-3 *𝑑* basis
functions. This is OK and is expected for common transition metal compounds. For lanthanide compounds, the
seven active orbitals should have dominant contribution from the 4 *𝑓* shell. Larger active spaces must be carefully
inspected and analysed. We refer here to the respective section of this manual describing the CASSCF method and
how to achieve convergence *The Complete Active Space Self-Consistent Field (CASSCF) Module* .

The results calculated by using `SINGLE_ANISO` module are placed after the `SOC` section in ORCA output. Here is
the explanation for these results.



The section above shows the *𝑔* tensor for the ground Kramers doublet. Since the *𝑔* *𝑋* and *𝑔* *𝑌* are much smaller
than the *𝑔* *𝑍* component, the *𝑍𝑚* axis is denoted as the *𝑚𝑎𝑖𝑛𝑚𝑎𝑔𝑛𝑒𝑡𝑖𝑐𝑎𝑥𝑖𝑠* of the computed molecule. The “Zm
*|* -0.614361 0.788985 0.007914 *|* ” denotes the Cartesian components of the *𝑍𝑚* vector.

In the case the computation of the parameters of the crystal field is requested by `CRYS_element` and `CRYS_charge`,
the following section will be found in the output:

**7.17. Interface to SINGLE_ANISO module** **631**

**ORCA Manual** **,** **Release 6.0.1**



(continues on next page)

**632** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

In the above section, the low-lying CASSCF states of the Co [2+] site originating from the free ion [4] F term are
transformed towards the eigenstates of the ( *𝐿* [˜] = 3), and the low-lying CASSCF *diagonal* 7 *×* 7 energy matrix
is re-written in this basis. The *non-diagonal* “Ab Initio Crystal-Field Splitting Matrix” is printed in the above
section. In the subsequent output sections, the obtained crystal field matrix is decomposed in a linear combination
of Irreducible Tensorial Operators (ITOs) and the obtained expansion coefficients are listed in the output.


*−𝑘,* + *𝑘*

*𝐵* *[𝑞]*

∑︁ *𝑘* *[𝑂]* [ˆ] *𝑘* *[𝑞]* [(˜] *[𝐿]* [)]

*𝑞*


ˆ
*𝐻* *𝐶𝐹* =

The parameters are given for several sets of ITOs.


2 *𝐿*
∑︁

*𝑘*




In the sections below, the weight of various expansion terms on the total energy splitting of the corresponding term
or multiplet is analysed.

**7.17. Interface to SINGLE_ANISO module** **633**

**ORCA Manual** **,** **Release 6.0.1**



(continues on next page)

**634** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

In the case of lanthanide compounds, the same keywords ( `CRYS_element` and `CRYS_charge` ) trigger the energy
decomposition of the lowest energy matrix corresponding to the ground *𝐽−* multiplet of the respective lanthanide

ion.



This section shows the computed magnetic susceptibility. The formula used for this calculation assumes the zerofield limit, *𝑖.𝑒.𝐻* = 0 *.* 0 Tesla. A picture called “XT_no_field.png” using the above data will be created in the
working directory whenever the `PLOT` keyword is included in the `SINGLE_ANISO` input. The picture shows the
temperature dependence of the magnetic susceptibility.



(continues on next page)

**7.17. Interface to SINGLE_ANISO module** **635**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



The section above shows how the main axes of the susceptibility tensor evolves with temperature.



This section shows the field dependence of the powder molar magnetisation. A picture named “MH.png” can be
created by using the `PLOT` keyword in the `SINGLE_ANISO` input file.

Running `CASSCF` calculations on lanthanides compounds in ORCA might be a bit more cumbersome compared to
transition metal compounds, due to the convergence of this method. However, following the instructions in the *The*
*Complete Active Space Self-Consistent Field (CASSCF) Module* section and the related tips in this manual and on
the Forum, the calculations could be performed. From our experience, the main reason for the poor convergence of
`CASSCF` calculation originates from the wrong orbitals occupying the active space. This issue can be overcame by
performing a proper rotation of the molecular orbitals such that the seven orbitals with dominant 4 *𝑓* contribution
are placed in the active space. As soon as the active orbitals acquire the dominant 4 *𝑓* weight, the convergence is
quite straightforward.

Below we describe the calculation on a lanthanide fragment [Ce(COT) 2 ] *[−]* (COT=(C 8 H 8 ) [2] *[−]* ) as an example:

**636** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**



This is the first step of the calculation. For heavier elements like lanthanides, we must consider relativistic effect by
using `DKH` keyword. We explicitly use `KDIIS` in the calculation to smoothen out convergence. The orbital file called
“CeCOT2_1.gbw” will be generated after this step. We further use this gbw file to do the `CASSCF` calculation.




(continues on next page)

**7.17. Interface to SINGLE_ANISO module** **637**

**ORCA Manual** **,** **Release 6.0.1**


(continued from previous page)


We need to check the orbitals after the `CASSCF` step with the orbital file named “CeCOT2_2.gbw” obtained.



Orbitals 85, 86, 88-91 and 130 are occupied and strongly metal based 4 *𝑓* -orbitals. For comparison, the converged
`CASSCF` orbitals are pure 4 *𝑓* -orbitals (99% metal-based). The orbitals need to be rotated in order to fit the active
space (85-91). Then we can use the results of `CASSCF/SOC` calculation to call for the `SINGLE_ANISO` program.




(continues on next page)

**638** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



The order of the keywords listed in the `CASSCF/ANISO` subblock does not matter.

**7.17.3 Reference list of CASSCF/ANISO keywords**

The only required keyword for `SINGLE_ANISO` is the `DATA`, specifying the name of the datafile containing the *ab*
*initio* information. The ORCA interface includes this keyword automatically and therefore it is not referenced here.
All other keywords are extra and allow various customisation of the execution. For the computation of the EPR
*𝑔* -tensor, the only unknown variable for `SINGLE_ANISO` is the dimension (multiplicity) of the pseudospin(s). This
information can be provided by the `MLTP` keyword. For example, in cases where spin-orbit coupling is weak, the
multiplicity of the effective spin Hamiltonian is usually the same as the multiplicity of the lowest term (e.g. high spin
*𝐹𝑒* [3+] : *𝑆* = *𝑆* [˜] = 5 */* 2), while in the cases with strong anisotropy (lanthanide, actinide complexes, *𝐶𝑜* [2+] complexes,
cases with near-orbital degeneracy, etc.) the lowest energy levels form a group of states which may differ drastically
from the spins of the lowest term. In these cases the user should specify the multiplicity corresponding to a chosen
value of pseudospin (2 *𝑆* [˜] +1). For instance, in *𝐷𝑦* [3+] the spin of the ground state term is *𝑆* = 5 */* 2, but in most of real
compounds only the ground Kramers doublet is considered. In such case, the multiplicity of the pseudospin equals
to 2 (see `MLTP` keyword). For the calculation of the parameters of the crystal field corresponding to the ground
atomic `multiplet` *𝐽* for lanthanides should be requested with the keywords `CRYS_element` and `CRYS_charge` .
Similarly, the parameters of the crystal field corresponding to the ground atomic `term` *𝐿* for lanthanides and transition metals compounds can be requested with same keywords: `CRYS_element` and `CRYS_charge` .

Note that the keywords/syntax in the ORCA CASSCF/ANISO block are slightly different from the genuine
`SINGLE_ANISO` input, where some of the keywords are grouped together. We aimed at keeping the control keywords as close as possible.

Optional general keywords to control the input within the ORCA interface (CASSCF/ANISO subblock):
```
InputNameOnDisk

```
This keyword reads the name of the input file for `SINGLE_ANISO`, a string given between quotations. Example:
```
   InputNameOnDisk "my_input_for_aniso.inp"

```
The interface with ORCA will add the `DATA` keyword with specific name of the datafile for the performed
calculation. All the other keywords provided inside this file must follow their original names, as in `MOLCAS` .
```
MLTP

```
The number of molecular multiplets ( *𝑖.𝑒.* groups of spin-orbital eigenstates) for which *𝑔*, *𝐷* and higher magnetic tensors will be calculated (default `MLTP` =1). With `MLTP` an comma separated list of numbers specifying
the dimension of each multiplet is passed. The default is to select one multiplet which has the dimension
equal to the multiplicity of the ground term. In cases of strong spin-orbit coupling the usage of this keyword
is mandatory. Example:
```
   MLTP 4, 4, 2, 2

```
**7.17. Interface to SINGLE_ANISO module** **639**

**ORCA Manual** **,** **Release 6.0.1**

`SINGLE_ANISO` will compute the *𝑔* tensor for 4 groups of states: 2 groups having the effective spin *𝑆* =
*|* 3 */* 2 *>*, and other 2 groups of states being Kramers doublets.
```
TINT

```
Specifies the temperature points for the evaluation of the magnetic susceptibility. The program will read
three numbers: *𝑇* *𝑚𝑖𝑛*, *𝑇* *𝑚𝑎𝑥*, and *𝑛𝑇* .

      - *𝑇* *𝑚𝑖𝑛*      - the minimal temperature (Default 0.0K)

      - *𝑇* *𝑚𝑎𝑥*      - the maximal temperature (Default 300.0K)

      - *𝑛𝑇*      - number of temperature points (Default 101)

Example:
```
   TINT 0.0, 330.0, 331

```
`SINGLE_ANISO` will compute temperature dependence of the magnetic susceptibility in 331 points evenly
distributed in temperature interval: 0.0K - 330.0K.
```
HINT

```
Specifies the field points for the evaluation of the magnetisation in a certain direction. The program will read
three numbers: *𝐻* *𝑚𝑖𝑛*, *𝐻* *𝑚𝑎𝑥* and *𝑛𝐻* .

      - *𝐻* *𝑚𝑖𝑛*      - the minimal field (Default 0.0T)

      - *𝐻* *𝑚𝑎𝑥*      - the maximal filed (Default 10.0T)

      - *𝑛𝐻*      - number of field points (Default 101)

Example:
```
   HINT 0.0, 20.0, 201

```
`SINGLE_ANISO` will compute the molar magnetisation in 201 points evenly distributed in field interval: 0.0T

   - 20.0T.
```
TMAG

```
Specifies the temperature(s) at which the field-dependent magnetisation is calculated. The program will read
the temperatures (in Kelvin) at which magnetisation is to be computed. Default is to compute magnetisation
at one temperature point (2.0 K). Example:
```
   TMAG 1.8, 2.0, 3.0, 4.0, 5.0

```
`SINGLE_ANISO` will compute the molar magnetisation at 5 temperature points (1.8 K, 2.0 K, 3.4 K, 4.0 K,
and 5.0 K).
```
ENCU

```
The keyword expects to read two integer numbers. The two parameters ( `NK` and `MG` ) are used to define the cutoff energy for the lowest states for which Zeeman interaction is taken into account exactly. The contribution
to the magnetisation coming from states that are higher in energy than *𝐸* (see below) is done by second
order perturbation theory. The program will read two integer numbers: *𝑁𝐾* and *𝑀𝐺* . Default values are:
*𝑁𝐾* = 100 *, 𝑀𝐺* = 100.

*𝐸* = *𝑁𝐾* *· 𝑘* *𝐵𝑜𝑙𝑡𝑧* *·* `TMAG` *𝑚𝑎𝑥* + *𝑀𝐺* *· 𝜇* *𝐵𝑜ℎ𝑟* *· 𝐻* *𝑚𝑎𝑥*

The field-dependent magnetisation is calculated at the maximal temperature value given by `TMAG` keyword.
Example:
```
   ENCU 250, 150

```
If *𝐻* *𝑚𝑎𝑥* = 10 T and `TMAG` = 1.8 K, then the cut-off energy is: $ *𝐸* = 250 *· 𝑘* *𝐵𝑜𝑙𝑡𝑧* *·* 1 *.* 8 + 150 *· 𝜇* *𝐵𝑜ℎ𝑟* *·* 10 =
1013 *.* 06258( *𝑐𝑚* *[−]* [1] )$

This means that the magnetisation arising from all spin-orbit states with energy lower than *𝐸* =
1013 *.* 06258( *𝑐𝑚* *[−]* [1] ) will be computed exactly (i.e. are included in the exact Zeeman diagonalisation) The

**640** **Chapter 7. Detailed Documentation**

```
NCUT
ERAT

```

**ORCA Manual** **,** **Release 6.0.1**

keywords `NCUT`, `ERAT` and `ENCU` have similar purpose. If two of them are used at the same time, the following
priority is defined: `NCUT > ENCU > ERAT` .

This flag is used to define the cut-off energy for the low-lying spin-orbit states for which Zeeman interaction is
taken into account exactly. The contribution to the magnetisation arising from states that are higher in energy
than lowest *𝑁* *𝐶𝑈𝑇* states, is done by second-order perturbation theory. The program will read one integer
number. In case the number is larger than the total number of spin-orbit states( *𝑁* *𝑆𝑆*, then the *𝑁* *𝐶𝑈𝑇* is set to
*𝑁* *𝑆𝑆* (which means that the molar magnetisation will be computed exactly, using full Zeeman diagonalisation
for all field points). The field-dependent magnetisation is calculated at the temperature value(s) defined by
`TMAG` . Example:
```
NCUT 32

```
The keywords `NCUT`, `ERAT` and `ENCU` have similar purpose. If two of them are used at the same time, the
following priority is defined: `NCUT > ENCU > ERAT` .

This flag is used to define the cut-off energy for the low-lying spin-orbit states for which Zeeman interaction
is taken into account exactly. The program will read one single real number specifying the ratio of the energy
states which are included in the exact Zeeman Hamiltonian. As example, a value of 0.5 means that the lowest
half of the energy states included in the spin-orbit calculation are used for exact Zeeman diagonalisation.

Example:
```
ERAT 0.333

```
The keywords `NCUT`, `ERAT` and `ENCU` have similar purpose. If two of them are used at the same time, the
following priority is defined: `NCUT > ENCU > ERAT` .

```
MVEC_x MVEC_y MVEC_z

```
`MVEC_x`, `MVEC_y` and `MVEC_z` define a number of directions for which the magnetisation vector will be
computed. The directions are given as unitary vectors specifying the direction *i* of the applied magnetic
field).

Example:


```
ZEEM
MAVE

```

The above input will request computation of the Zeeman spectra along six directions: Cartesian axes X,
Y, Z (directions 1,2 and 3), and between any two Cartesian axes: YZ, XZ and XY, respectively. The program will re-normalise the input vectors according to unity length. In combination with `PLOT` keyword, the
corresponding `zeeman_energy_xxx.png` images will be produced.

The keyword requires two integer numbers, denoted `MAVE_nsym` and `MAVE_ngrid` . The parameters
`MAVE_nsym` and `MAVE_ngrid` specify the grid density in the computation of powder molar magnetisation.
The program uses Lebedev-Laikov distribution of points on the unit sphere. The parameters are integer
numbers: *𝑛* *𝑠𝑦𝑚* and *𝑛* *𝑔𝑟𝑖𝑑* . The *𝑛* *𝑠𝑦𝑚* defines which part of the sphere is used for averaging. It takes one of


This keyword allows to compute Zeeman splitting spectra along certain directions of applied field. Directions
of applied field are given as three real number for each direction, specifying the projections along each
direction: Example:



**7.17. Interface to SINGLE_ANISO module** **641**

**ORCA Manual** **,** **Release 6.0.1**

the three values: 1 (half-sphere), 2 (a quarter of a sphere) or 3 (an octant of the sphere). *𝑛* *𝑔𝑟𝑖𝑑* takes values
from 1 (the smallest grid) till 32 (the largest grid, i.e. the densest). The default is to consider integration
over a half-sphere (since *𝑀* ( *𝐻* ) = *−𝑀* ( *−𝐻* )): *𝑛* *𝑠𝑦𝑚* = 1 and *𝑛* *𝑠𝑦𝑚* = 15 (i.e 185 points distributed over
half-sphere). In case of symmetric compounds, powder magnetisation may be averaged over a smaller part
of the sphere, reducing thus the number of points for the integration. The user is responsible to choose the
appropriate integration scheme. Note that the program’s default is rather conservative.

Example:
```
   MAVE 1, 8
TEXP_temp TEXP_chiT

```
The parameters `TEXP_temp` and `TEXP_chiT` allow the computation of the magnetic susceptibility *𝜒𝑇* ( *𝑇* ) at
experimental points. The experimental temperature (in *𝐾* ) and the experimental magnetic susceptibility (in
*𝑐𝑚* [3] *𝐾𝑚𝑜𝑙* *[−]* [1] ) are read as comma separated list. In the case both `TEXP` and `TINT` keywords are given, the
`TEXP` will be used while the `TINT` input will be ignored.

Example:


```
HEXP_temp HEXP_H HEXP_M

```
The three keywords `HEXP_temp`, `HEXP_H` and `HEXP_M` enable the computation of the molar magnetisation
*𝑀* *𝑚𝑜𝑙* ( *𝐻* ) at experimental points. The experimental field strength (in Tesla) and the experimental magnetisation (in *𝜇* *𝐵𝑜ℎ𝑟* ) are read as a comma separated list. In the case both `HEXP` and `HINT` keywords are given, the
`HEXP` will be used while the `HINT` input will be ignored. The magnetisation routine will print the standard
deviation from the experiment. Example:


```
ZJPR
TORQ

```

This keyword specifies the value (in *𝑐𝑚* *[−]* [1] ) of a phenomenological parameter of a mean molecular field
acting on the spin of the complex (the average intermolecular exchange constant). It is used in the calculation
of all magnetic properties (not for spin Hamiltonians) (Default is 0.0).
```
ZJPR -0.02

```
This keyword specifies the number of angular points for the computation of the magnetisation torque function, *⃗𝜏* *𝛼* as function of the temperature, field strength and field orientation.
```
TORQ 55

```
The torque is computed at all temperature given by `TMAG` or `HEXP_temp` inputs. Three rotations around
Cartesian axes X, Y and Z are performed.

```
PrintLevel

```
This keyword controls the print level.

     - 2 - normal. (Default)

     - 3 or larger (debug)
```
CRYS_element CRYS_charge

```
The keywords `CRYS_element` and `CRYS_charge` request the computation of all 27 Crystal-Field parameters
acting on the ground atomic multiplet of a lanthanide. With `CRYS_element` the chemical symbol of the
lanthanide is set. **Note that the element symbol must be enclosed in quotation marks** . The charge is
defined with `CRYS_charge` . By default the program will not compute the parameters of the Crystal-Field.

Example:

**642** **Chapter 7. Detailed Documentation**

```
QUAX
UBAR

```

**ORCA Manual** **,** **Release 6.0.1**
```
CRYS_element "Dy" CRYS_charge 3

```
This keyword controls the quantisation axis for the computation of the Crystal-Field parameters acting on
the ground atomic multiplet of a lanthanide. On the next line, the program will read one of the three values:
1, 2 or 3.

  - 1 - quantisation axis is the main magnetic axis *𝑍𝑚* of the ground pseudospin multiplet, whose size is
specified within the `MLTP` keyword. (Default)

  - 2 - quantisation axis is the main magnetic axis *𝑍𝑚* of the entire atomic multiplet *|𝐽, 𝑀* *𝐽* *>* .

  - 3 - quantisation axis is the original Cartesian Z axis. Rotation matrix is unity.

Example:
```
QUAX 3

```
With `UBAR` set to “true”, the blocking barrier of a single-molecule magnet is estimated. The default is not to
compute it. The method prints transition matrix elements of the magnetic moment according to the Figure
below:

In this figure, a qualitative performance picture of the investigated single-molecular magnet is estimated
by the strengths of the transition matrix elements of the magnetic moment connecting states with opposite
magnetisaskytions ( *𝑛* + *→* *𝑛−* ). The height of the barrier is qualitatively estimated by the energy at which
the matrix element ( *𝑛* + *→* *𝑛−* ) is large enough to induce significant tunnelling splitting at usual magnetic
fields (internal) present in the magnetic crystals (0.01-0.1 Tesla). For the above example, the blocking barrier
closes at the state (8+ *→* 8 *−* ).

All transition matrix elements of the magnetic moment are given as (( *|𝜇* *𝑋* *|* + *|𝜇* *𝑌* *|* + *|𝜇* *𝑍* *|* ) */* 3). The data is
given in Bohr magnetons ( *𝜇* *𝐵𝑜ℎ𝑟* ).


**7.17. Interface to SINGLE_ANISO module** **643**

**ORCA Manual** **,** **Release 6.0.1**

Example:
```
   UBAR true
ABCC_abc ABCC_center

```
The keywords `ABCC_abc` and `ABCC_center` set the computation of magnetic and anisotropy axes in the
crystallographic *𝑎𝑏𝑐* system. With `ABCC_abc`, the program reads six real values, namely *𝑎, 𝑏, 𝑐, 𝛼, 𝛽*, and *𝛾*,
defining the crystal lattice. The values must be separated by a comma. With `ABCC_center`, the program
reads the fractional coordinates of the magnetic center (from the CIF file) - again separated by comma. It is
assumed that the XYZ coordinates used for the *ab initio* calculations did not rotate or translate the molecule

from its crystallographic position. This input will ensure that all tensors computed by `SINGLE_ANISO` are
given also in the *𝑎𝑏𝑐* system. The computed values in the output correspond to the crystallographic position
of three “dummy atoms” located on the corresponding anisotropy axes, at the distance of 1.0 *𝐴* [˚] from the
metal site. Example:


```
XFIE
PLOT

```

This keyword specifies the value (in T) of applied magnetic field for the computation of magnetic susceptibility by *𝑑𝑀/𝑑𝐻* and *𝑀/𝐻* formulas. A comparison with the usual formula (in the limit of zero applied
field) is provided. (Default is 0.0). Example:
```
XFIE 0.35

```
This keyword together with the keyword `PLOT` will enable the generation of two additional plots:
`XT_with_field_dM_over_dH.png` and `XT_with_field_M_over_H.png`, one for each of the two above
formula used, alongside with respective `gnuplot` scripts and gnuplot datafiles.

Set to “true”, the program generates a few plots (png or eps format) via an interface to the linux program
*gnuplot* . The interface generates a datafile, a *gnuplot* script and attempts execution of the script for generation of the image. The plots are generated only if the respective function is invoked. The magnetic
susceptibility, molar magnetisation and blocking barrier ( `UBAR` ) plots are generated. The files are named:
`XT_no_field.dat`, `XT_no_field.plt`, `XT_no_field.png`, `MH.dat`, `MH.plt`, `MH.png`, `BARRIER_TME.`
`dat`, `BARRIER_ENE.dat`, `BARRIER.plt` and `BARRIER.png`, `zeeman_energy_xxx.png` etc. All files produced by `SINGLE_ANISO` are referenced in the corresponding output section. Example:
```
PLOT true

```

**7.17.4 How to cite**

We would appreciate if you cite the following papers in publications resulting from the use of `SINGLE_ANISO` :

  - Chibotaru, L. F.; Ungur, L. *J. Chem. Phys.*, **2012**, *137*, 064112.

  - Ungur, L. Chibotaru, L. F. *Chem. Eur. J.*, **2017**, *23*, 3708-3718.

In addition, useful information like the definition of pseudospin Hamiltonians and their derivation can be found in
this paper.

**644** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**
### **7.18 Interface to POLY_ANISO module**

**7.18.1 General description**

The `POLY_ANISO` is a stand-alone utility allowing for a semi- *ab initio* description of the (low-lying) electronic
structure and magnetic properties of polynuclear compounds. The model behind it is based on the *localised* nature of the magnetic orbitals (i.e. the *𝑑* and *𝑓* orbitals containing unpaired electrons). For many compounds of
interest, the localised character of the magnetic orbitals leads to very weak character of the exchange interaction
between magnetic centers. Due to this weakness of the inter-site interaction, the molecular orbitals and corresponding localised ground and excited states may be optimized in the absence of the magnetic interaction at all.
For this purpose, various fragmentation models may be applied. The most commonly used fragmentation model
is exemplified in Fig. 7.5:

Fig. 7.5: Fragmentation model of a polynuclear compound.

The upper scheme shows a schematic overview of a tri-nuclear compound and the resulting three mononuclear
fragments obtained by *diamagnetic atom substitution method* . By this scheme, the neighbouring magnetic centers,
containing unpaired electrons are computationally replaced by their diamagnetic equivalents. As example, transition metal (TM) sites are best described by either a diamagnetic Zn(II) or Sc(III), in function of which one is
the closest (in terms of charge and atomic radius). For lanthanides (LN), the same principle is applicable, La(III),
Lu(III) or Y(III) are best suited to replace a given magnetic lanthanide. Individual mononuclear metal fragments
are then investigated by the common `CASSCF` + `SOC` / `NEVPT2` + `SOC` / `SINGLE_ANISO` computational method. A single `datafile` for each magnetic site, produced by the `SINGLE_ANISO` run, is needed by the `POLY_ANISO` code as
input.

Magnetic interaction between metal sites is very important for accurate description of low-lying states and their
properties. While the full exchange interaction is quite complex (e.g. requiring a multipolar description employing
a large set of parameters [413, 871]), in a simplified model it can be viewed as a sum of various interaction mechanisms: magnetic exchange, dipole-dipole interaction, antisymmetric exchange, etc. In the `POLY_ANISO` code we
have implemented several mechanisms, which can be invoked simultaneously for each interacting pair.

The description of the magnetic exchange interaction is done within the Lines model[527]. This model is exact in
three cases:

1. interaction between two isotropic spins (Heisenberg),

2. interaction between one Ising spin (only S *𝑍* component) and one isotropic (i.e. usual) spin, and

3. interaction between two Ising spins.

In all other cases when magnetic sites have intermediate anisotropy (i.e. when the spin-orbit coupling and crystal
field effects are of comparable strengths), the Lines model represents an approximation. However, it was successfully applied for a wide variety of polynuclear compounds so far.

In addition to the magnetic exchange, magnetic dipole-dipole interaction can be accounted exactly, by using the *ab*
*initio* computed magnetic moment for each metal site (as available inside the `datafile` ). In the case of strongly
anisotropic lanthanide compounds (like Ho [3+] or Dy [3+] ), the magnetic dipole-dipole interaction is usually the dominant one. For example, a system containing two magnetic dipoles *⃗𝜇* 1 and *⃗𝜇* 2, separated by distance *⃗r* have a total

**7.18. Interface to POLY_ANISO module** **645**

**ORCA Manual** **,** **Release 6.0.1**

energy:

*𝐸* *𝑑𝑖𝑝* = *[𝜇]* *𝐵𝑜ℎ𝑟* [2] [ *⃗𝜇* 1 *· ⃗𝜇* 2 *−* 3( *⃗𝜇* 1 *⃗𝑛* 1 *,* 2 ) *·* ( *⃗𝜇* 2 *⃗𝑛* 1 *,* 2 )] *,*

*𝑟* [3]

where *⃗𝜇* 1 *,* 2 are the magnetic moments of sites 1 and 2, respectively; *𝑟* is the distance between the two magnetic
dipoles, *⃗𝑛* 1 *,* 2 is the directional vector connecting the two magnetic dipoles (of unit length). *𝜇* [2] *𝐵𝑜ℎ𝑟* [is the square of]
the Bohr magneton; with an approximate value of 0.43297 in *𝑐𝑚* *[−]* [1] /T. As inferred from the above Equation, the
dipolar magnetic interaction depends on the distance and on the angle between the magnetic moments on magnetic
centers. Therefore, the Cartesian coordinates of all non-equivalent magnetic centers must be provided in the input.

In brief, the `POLY_ANISO` is performing the following operations:

1. read the input and information from the datafiles

2. build the exchange coupled basis

3. compute the magnetic exchange, magnetic dipole-dipole, and other magnetic Hamiltonians using the *ab*
*initio* -computed spin and orbital momenta of individual magnetic sites and the input parameters

4. sum up all the magnetic interaction Hamiltonians and diagonalise the total interaction Hamiltonian

5. rewrite the spin and magnetic moment in the exchange-coupled eigenstates basis

6. use the obtained spin and magnetic momenta for the computation of the magnetic properties of entire polynuclear compound

The actual values of the inter-site magnetic exchange could be derived from e.g. broken-symmetry DFT calculations. Alternatively, they could be regarded as fitting parameters, while their approximate values could be extracted
by minimising the standard deviation between measured and calculated magnetic data.

**7.18.2 Files**

`POLY_ANISO` is called independently of ORCA for now. In the future versions of ORCA we will aim for a deeper
integration, for a better experience.



The actual names of the `poly_aniso.input` and `poly_aniso.output` are not hard coded, and can take any
names. A bash script for a more convenient usage of `POLY_ANISO` can be provided upon request or made available
on the Forum.

**Input files**

The program `POLY_ANISO` needs the following files:
```
aniso_i.input

```
This is an ASCII text file generated by the `CASSCF` / `SOC` / `SINGLE_ANISO` run. It should be provided for
`POLY_ANISO` as `aniso_i.input` (i=1,2,3, etc.): one file for each magnetic center. In cases when the entire
polynuclear cluster or molecule has exact point group symmetry, only `aniso_i.input` files for crystallographically non-equivalent centers should be given. This saves computational time since equivalent metal
sites do not need to be computed *ab initio* .
```
poly_aniso.input

```
The standard input file defining the computed system and various input parameters. This file can take any

name.

**646** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**Output files**

**7.18.3 List of keywords**

This section describes the keywords used to control the `POLY_ANISO` input file. Only two keywords `NNEQ`, `PAIR`
(and `SYMM` if the polynuclear cluster has symmetry) are mandatory for a minimal execution of the program, while
the other keywords allow customisation of the execution of the `POLY_ANISO` .

The format of the “poly_aniso.input” file resembles to a certain extent the input file for `SINGLE_ANISO` program.
The input file must start with “ `&POLY_ANISO` ” text.

**Mandatory keywords defining the calculation**

*Keywords defining the polynuclear cluster:*

`NNEQ` This keyword defines several important parameters of the calculation. On the first line after the keyword the
program reads 2 values: 1) the number of types of different magnetic centers (NON-EQ) of the cluster and 2) a
letter `T` or `F` in the second position of the same line. The number of NON-EQ is the total number of magnetic
centers of the cluster which cannot be related by point group symmetry. In the second position the answer to the
question: “Have all NON-EQ centers been computed *ab initio* ?” is given: T for True and F for False. On the
following line the program will read NON-EQ values specifying the number of equivalent centers of each type. On
the following line the program will read NON-EQ integer numbers specifying the number of low-lying spin-orbit
functions from each center forming the local exchange basis.

Some examples valid for situations where all sites have been computed *ab initio* (case T, True):



There are two kinds of magnetic centers in the cluster; both have been computed *ab initio* ; the cluster consists of
3 magnetic centers: one center of the first kind and two centers of the second kind. From each center we take
into the exchange coupling only the ground doublet. As a result, the *𝑁* *𝑒𝑥𝑐ℎ* = 2 [1] *×* 2 [2] = 8, and the two datafiles
`aniso_1.input` (for-type 1) and `aniso_2.input` (for-type 2) files must be present.



There are three kinds of magnetic centers in the cluster; all three have been computed *ab initio* ; the cluster consists
of four magnetic centers: two centers of the first kind, one center of the second kind and one center of the third
kind. From each of the centers of the first kind we take into exchange coupling four spin-orbit states, two states
from the second kind and three states from the third center. As a result the *𝑁* *𝑒𝑥𝑐ℎ* = 4 [2] *×* 2 [1] *×* 3 [1] = 96. Three
files `aniso_i.input` for each center ( *𝑖* = 1 *,* 2 *,* 3) must be present.



There are six kinds of magnetic centers in the cluster; all six have been computed *ab initio* ; the cluster consists of
6 magnetic centers: one center of each kind. From the center of the first kind we take into exchange coupling two
spin-orbit states, four states from the second center, three states from the third center, five states from the fourth
center and two states from the fifth and sixth centers. As a result the *𝑁* *𝑒𝑥𝑐ℎ* = 2 [1] *×* 4 [1] *×* 3 [1] *×* 5 [1] *×* 2 [1] *×* 2 [1] = 480.
Six files `aniso_i.input` for each center ( *𝑖* = 1 *,* 2 *, ...,* 6) must be present.

Only in cases when some centers have NOT been computed *ab initio* (i.e. for which no `aniso_i.input` file exists),
the program will read an additional line consisting of NON-EQ letters ( *𝐴* or *𝐵* ) specifying the type of each of the
NON-EQ centers: *𝐴* - the center is computed *ab initio* and *𝐵* - the center is considered isotropic. On the following

**7.18. Interface to POLY_ANISO module** **647**

**ORCA Manual** **,** **Release 6.0.1**

number-of-B-centers line(s) the isotropic *𝑔* factors of the center(s) defined as *𝐵* are read. The spin of the B center(s)
is defined: *𝑆* = ( *𝑁* *−* 1) */* 2, where *𝑁* is the corresponding number of states to be taken into the exchange coupling
for this particular center. Some examples valid for mixed situations: the system consists of centers computed *ab*
*initio* and isotropic centers (case *𝐹*, False):



There are two kinds of magnetic centers in the cluster; the center of the first type has been computed *ab initio*,
while the centers of the second type are considered isotropic with *𝑔* *𝑋* = *𝑔* *𝑌* = *𝑔* *𝑍* =2.3; the cluster consists of
three magnetic centers: one center of the first kind and two centers of the second kind. Only the ground doublet
state from each center is considered for the exchange coupling. As a result the *𝑁* *𝑒𝑥𝑐ℎ* = 2 [1] *×* 2 [2] = 8. File
`aniso_i.input` (for-type 1) must be present.



There are three kinds of magnetic centers in the cluster; the first center type has been computed *ab initio*, while the
centers of the second and third types are considered empirically with *𝑔* *𝑋* = *𝑔* *𝑌* =2.3; *𝑔* *𝑍* =2.0 (second type) and
*𝑔* *𝑋* = *𝑔* *𝑌* =2.0; *𝑔* *𝑍* =2.5 (third type); the cluster consists of four magnetic centers: two centers of the first kind, one
center of the second kind and one center of the third kind. From each of the centers of the first kind, four spin-orbit
states are considered for the exchange coupling, two states from the second kind and three states from the center
of the third kind. As a result the *𝑁* *𝑒𝑥𝑐ℎ* = 4 [2] *×* 2 [1] *×* 3 [1] = 96. The file `aniso_i.input` must be present.



There are six kinds of magnetic centers in the cluster; only three centers have been computed *ab initio*, while the
other three centers are considered isotropic; the *𝑔* factors of the first center is 2.12 (S=1/2); of the second center
2.43 (S=3/2); of the fifth center 2.00 (S=1/2); the entire cluster consists of six magnetic centers: one center of each
kind. From the center of the first kind, two spin-orbit states are considered in the exchange coupling, four states
from the second center, three states from the third center, five states from the fourth center and two states from the
fifth and sixth centers. As a result the *𝑁* *𝑒𝑥𝑐ℎ* = 2 [1] *×* 4 [1] *×* 3 [1] *×* 5 [1] *×* 2 [1] *×* 2 [1] = 480. Three files `aniso_3.input`
and `aniso_4.input` and `aniso_6.input` must be present.

There is no maximal value for `NNEQ`, although the calculation becomes quite heavy in case the number of exchange
functions is large.

`SYMM` Specifies rotation matrices to symmetry equivalent sites. This keyword is mandatory in the case more centers
of a given type are present in the calculation. This keyword is mandatory when the calculated polynuclear compound has exact crystallographic point group symmetry. In other words, when the number of equivalent centers
of any kind *𝑖* is larger than 1, this keyword must be employed. Here the rotation matrices from the one center to
all the other of the same type are declared. On the following line the program will read the number 1 followed on
the next lines by as many 3 *×* 3 rotation matrices as the total number of equivalent centers of type 1. Then the
rotation matrices of centers of type 2, 3 and so on, follow in the same format. When the rotation matrices contain

~~*√*~~ 3

irrational numbers (e.g. sin *[𝜋]* [=] [), then more digits than presented in the examples below are advised to be]


~~*√*~~

*[𝜋]*

6 [=] 2


3
2 [), then more digits than presented in the examples below are advised to be]


**648** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


~~*√*~~ 3
given: 2 [= 0] *[.]* [8660254][. Examples:]



The cluster computed here is a tri-nuclear compound, with one center computed *ab initio*, while the other two
centers, related to each other by inversion, are considered isotropic with *𝑔* *𝑋* = *𝑔* *𝑌* = *𝑔* *𝑍* = 2 *.* 3. The rotation
matrix for the first center is *𝐼* (identity, unity) since the center is unique. For the centers of type 2, there are two
matrices 3 *×* 3 since we have two centers in the cluster. The rotation matrix of the first center of type 2 is Identity
while the rotation matrix for the equivalent center of type 2 is the inversion matrix.



In this input a tetranuclear compound is defined, all centers are computed *ab initio* . There are two centers of
type “1”, related one to each other by *𝐶* 2 symmetry around the Cartesian Z axis. Therefore the `SYMM` keyword is
mandatory. There are two matrices for centers of type 1, and one matrix (identity) for the centers of type 2 and
type 3.



(continues on next page)

**7.18. Interface to POLY_ANISO module** **649**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

In this case the computed system has no symmetry. Therefore, the `SYMM` keyword is not required. `End of Input`
Specifies the end of the input file. No keywords after this one will be processed.

**Keywords defining the magnetic exchange interactions**

This section defines the keywords used to set up the interacting pairs of magnetic centers and the corresponding
exchange interactions.

A few words about the numbering of the magnetic centers of the cluster in the `POLY_ANISO` . First all equivalent
centers of the type 1 are numbered, then all equivalent centers of the type 2, etc. These labels of the magnetic
centers are used further for the declaration of the magnetic coupling.

`PAIR` **or** `LIN1`

This keyword defines the interacting pairs of magnetic centers and the corresponding exchange interaction. A
few words about the numbering of the magnetic centers of the cluster in the `POLY_ANISO` . First all equivalent
centers of the type 1 are numbered, then all equivalent centers of the type 2, etc. These labels of the magnetic
centers are used now for the declaration of the magnetic coupling. Interaction Hamiltonian is:


*𝑁* *𝑝𝑎𝑖𝑟𝑠*

ˆ ˆ ˆ
*𝐻* *𝐿𝑖𝑛𝑒𝑠* = *−* ∑︁ *𝐽* *𝑝* *𝑠* *𝑖* *𝑠* *𝑗* *,*

*𝑝* =1


where *𝑖* an *𝑗* are the indices of the metal sites of the interacting pair *𝑝* ; *𝐽* *𝑝* is the user-defined magnetic
exchange interaction between the corresponding metal sites; ˆ *𝑠* *𝑖* and ˆ *𝑠* *𝑗* are the `ab initio` spin operators for
the low-lying exchange eigenstates.


```
LIN3
LIN9

```

The input above is applicable for a tri-nuclear molecule. Two interactions are antiferromagnetic while ferromagnetic interaction is given for the last interacting pair.

This keyword defines a more involved exchange interaction, where the user is allowed to define 3 parameters
for each interacting pair. The interaction Hamiltonian is given by:


The input above is applicable for a mononuclear molecule.

This keyword defines a more involved exchange interaction, where the user is allowed to define 9 parameters
for each interacting pair. The interaction Hamiltonian is given by:


ˆ
*𝐻* *𝐿𝑖𝑛𝑒𝑠* = *−*

where the *𝛼* defines the Cartesian axis *𝑥, 𝑦, 𝑧* .


*𝑁* *𝑝𝑎𝑖𝑟𝑠*
∑︁

*𝑝* =1


∑︁ *𝐽* *𝑝,𝛼* *𝑠* ˆ *𝑖,𝛼* *𝑠* ˆ *𝑗,𝛼* *,*

*𝛼*



ˆ
*𝐻* *𝐿𝑖𝑛𝑒𝑠* = *−*


*𝑁* *𝑝𝑎𝑖𝑟𝑠*
∑︁

*𝑝* =1


∑︁ *𝐽* *𝑝,𝛼,𝛽* *𝑠* ˆ *𝑖,𝛼* *𝑠* ˆ *𝑗,𝛽* *,*

*𝛼,𝛽*


∑︁


where the *𝛼* and *𝛽* defines the Cartesian axis *𝑥, 𝑦, 𝑧* .

**650** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


```
COOR

```

The input above is applicable for a mononuclear molecule.

The `COOR` keyword turns ON the computation of the dipolar coupling for those interacting pairs which were
declared under `PAIR`, `LIN3` or `LIN9` keywords. On the NON-EQ lines following the keyword the program will
read the symmetrised Cartesian coordinates of NON-EQ magnetic centers: one set of symmetrised Cartesian
coordinates for each type of magnetic centers of the system. The *symmetrized Cartesian coordinates* are
obtained by translating the original coordinates to the origin of Coordinate system, such that by applying the
corresponding SYMM rotation matrix onto the input COOR data, the position of all other sites are generated.



The magnetic dipole-dipole Hamiltonian is computed as follows:


ˆ ˆ ˆ ˆ
*𝜇* *𝑖* *𝜇* *𝑗* *−* 3 ( *𝜇* *𝑖* *⃗𝑛* *𝑖* *,𝑗* )( *𝜇* *𝑗* *⃗𝑛* *𝑖* *,𝑗* )

*⃗*
*𝑟* [3]
*𝑖,𝑗*


ˆ
*𝐻* *𝑑𝑖𝑝* = *𝜇* [2] *𝐵𝑜ℎ𝑟*


*𝑁* *𝑝𝑎𝑖𝑟𝑠*
∑︁

*𝑝* =1


and is added to *𝐻* [ˆ] *𝑒𝑥𝑐ℎ* computed using other models. The *𝐻* [ˆ] *𝑑𝑖𝑝* is added for all magnetic pairs.

**Optional general keywords to control the input**

Normally `POLY_ANISO` runs without specifying any of the following keywords. However, some properties are only
computed if it is requested by the respective keyword. Argument(s) to the keyword are always supplied on the next
line of the input file.
```
MLTP

```
The number of molecular multiplets (i.e. groups of spin-orbital eigenstates) for which *𝑔*, *𝐷* and higher
magnetic tensors will be calculated (default `MLTP` =1). The program reads two lines: the first is the number
of multiplets ( *𝑁* *𝑀𝑈𝐿𝑇* ) and the second the array of *𝑁* *𝑀𝑈𝐿𝑇* numbers specifying the dimension (multiplicity)
of each multiplet. Example:


```
TINT

```

`POLY_ANISO` will compute the EPR *𝑔* and *𝐷* - tensors for 10 groups of states. The groups 1 and 4-10 are
doublets ( *𝑆* [˜] = *|* 1 */* 2 *⟩* ), while the groups 2 and 3 are quadruplets, having the effective spin *𝑆* [˜] = *|* 3 */* 2 *⟩* . For the
latter cases, the ZFS (D-) tensors will be computed. We note here that large degeneracies are quite common
for exchange coupled systems, and the data for this keyword can only be rendered after the inspection of the
exchange spectra.

Specifies the temperature points for the evaluation of the magnetic susceptibility. The program will read
three numbers: *𝑇* *𝑚𝑖𝑛*, *𝑇* *𝑚𝑎𝑥*, and *𝑛𝑇* .

  - *𝑇* *𝑚𝑖𝑛*   - the minimal temperature (Default 0.0 K)

  - *𝑇* *𝑚𝑎𝑥*   - the maximal temperature (Default 300.0 K)

  - *𝑛𝑇*   - number of temperature points (Default 301)

Example:


**7.18. Interface to POLY_ANISO module** **651**

**ORCA Manual** **,** **Release 6.0.1**


```
HINT
TMAG
ENCU
UBAR

```

`POLY_ANISO` will compute temperature dependence of the magnetic susceptibility in 331 points evenly distributed in temperature interval: 0.0 K - 330.0 K.

Specifies the field points for the evaluation of the molar magnetisation. The program will read three numbers:
*𝐻* *𝑚𝑖𝑛*, *𝐻* *𝑚𝑎𝑥*, *𝑛𝐻* .

  - *𝐻* *𝑚𝑖𝑛*   - the minimal field (Default 0.0 T)

  - *𝐻* *𝑚𝑎𝑥*   - the maximal filed (Default 10.0 T)

  - *𝑛𝐻*   - number of field points (Default 101)

Example:


If *𝐻* *𝑚𝑎𝑥* = 10 T and `TMAG` = 1.8 K, then the cut-off energy is:

*𝐸* = 250 *· 𝑘* *𝐵𝑜𝑙𝑡𝑧* *·* 1 *.* 8 + 150 *· 𝜇* *𝐵𝑜ℎ𝑟* *·* 10 = 1013 *.* 06258( *𝑐𝑚* *[−]* [1] )

This means that the magnetisation arising from all exchange states with energy lower than *𝐸* =
1013 *.* 06258( *𝑐𝑚* *[−]* [1] ) will be computed exactly (i.e. are included in the exact Zeeman diagonalisation) The
keywords `NCUT`, `ERAT` and `ENCU` have similar purpose. If two of them are used at the same time, the following
priority is defined: `NCUT > ENCU > ERAT` .

With `UBAR` set to “true”, the blocking barrier of a single-molecule magnet is estimated. The default is not to
compute it. The method prints transition matrix elements of the magnetic moment according to the Figure
below:



`POLY_ANISO` will compute the molar magnetisation in 201 points evenly distributed in field interval: 0.0 T

- 20.0 T.

Specifies the temperature(s) at which the field-dependent magnetisation is calculated. Default is one temperature point, T = 2.0 K.

Example:



The keyword expects to read two integer numbers. The two parameters ( `NK` and `MG` ) are used to define the cutoff energy for the lowest states for which Zeeman interaction is taken into account exactly. The contribution
to the magnetisation coming from states that are higher in energy than *𝐸* (see below) is done by second
order perturbation theory. The program will read two integer numbers: *𝑁𝐾* and *𝑀𝐺* . Default values are:
*𝑁𝐾* = 100 *, 𝑀𝐺* = 100.

*𝐸* = *𝑁𝐾* *· 𝑘* *𝐵𝑜𝑙𝑡𝑧* *·* `TMAG` *𝑚𝑎𝑥* + *𝑀𝐺* *· 𝜇* *𝐵𝑜ℎ𝑟* *· 𝐻* *𝑚𝑎𝑥*

The field-dependent magnetisation is calculated at the maximal temperature value given by `TMAG` keyword.
Example:



**652** **Chapter 7. Detailed Documentation**

```
ERAT
NCUT

```

**ORCA Manual** **,** **Release 6.0.1**

In this figure, a qualitative performance picture of the investigated single-molecular magnet is estimated
by the strengths of the transition matrix elements of the magnetic moment connecting states with opposite
magnetisations ( *𝑛* + *→* *𝑛−* ). The height of the barrier is qualitatively estimated by the energy at which
the matrix element ( *𝑛* + *→* *𝑛−* ) is large enough to induce significant tunnelling splitting at usual magnetic
fields (internal) present in the magnetic crystals (0.01-0.1 Tesla). For the above example, the blocking barrier
closes at the state (8+ *→* 8 *−* ). All transition matrix elements of the magnetic moment are given as (( *|𝜇* *𝑋* *|* +
*|𝜇* *𝑌* *|* + *|𝜇* *𝑍* *|* ) */* 3). The data is given in Bohr magnetons ( *𝜇* *𝐵𝑜ℎ𝑟* ). Example:
```
UBAR

```
This flag is used to define the cut-off energy for the low-lying exchange-coupled states for which Zeeman
interaction is taken into account exactly. The program will read one single real number specifying the ratio
of the energy states which are included in the exact Zeeman Hamiltonian. As example, a value of 0.5 means
that the lowest half of the energy states included in the spin-orbit calculation are used for exact Zeeman
diagonalisation. Example:


The keywords `NCUT`, `ERAT` and `ENCU` have similar purpose. If two of them are used at the same time, the
following priority is defined: `NCUT > ENCU > ERAT` .

This flag is used to define the cut-off energy for the low-lying exchange states for which Zeeman interaction is
taken into account exactly. The contribution to the magnetisation arising from states that are higher in energy
than lowest *𝑁* *𝐶𝑈𝑇* states, is done by second-order perturbation theory. The program will read one integer
number. In case the number is larger than the total number of exchange states( *𝑁* *𝑒𝑥𝑐ℎ*, then the *𝑁* *𝐶𝑈𝑇* is set to
*𝑁* *𝑆𝑆* (which means that the molar magnetisation will be computed exactly, using full Zeeman diagonalisation
for all field points). The field-dependent magnetisation is calculated at the temperature value(s) defined by
`TMAG` . Example:



**7.18. Interface to POLY_ANISO module** **653**

**ORCA Manual** **,** **Release 6.0.1**


```
MVEC
ZEEM
MAVE
TEXP

```

The keywords `NCUT`, `ERAT` and `ENCU` have similar purpose. If two of them are used at the same time, the
following priority is defined: `NCUT > ENCU > ERAT` .

`MVEC`, define a number of directions for which the magnetisation vector will be computed. The directions
are given as vectors specifying the direction *i* of the applied magnetic field).

Example:



This keyword allows to compute Zeeman splitting spectra along certain directions of applied field. Directions
of applied field are given as three real number for each direction, specifying the projections along each
direction: Example:



The above input will request computation of the Zeeman spectra along six directions: Cartesian axes X,
Y, Z (directions 1,2 and 3), and between any two Cartesian axes: YZ, XZ and XY, respectively. The program will re-normalise the input vectors according to unity length. In combination with `PLOT` keyword, the
corresponding `zeeman_energy_xxx.png` images will be produced.

The keyword requires two integer numbers, denoted `MAVE_nsym` and `MAVE_ngrid` . The parameters
`MAVE_nsym` and `MAVE_ngrid` specify the grid density in the computation of powder molar magnetisation.
The program uses Lebedev-Laikov distribution of points on the unit sphere. The parameters are integer
numbers: *𝑛* *𝑠𝑦𝑚* and *𝑛* *𝑔𝑟𝑖𝑑* . The *𝑛* *𝑠𝑦𝑚* defines which part of the sphere is used for averaging. It takes one of
the three values: 1 (half-sphere), 2 (a quarter of a sphere) or 3 (an octant of the sphere). *𝑛* *𝑔𝑟𝑖𝑑* takes values
from 1 (the smallest grid) till 32 (the largest grid, i.e. the densest). The default is to consider integration
over a half-sphere (since *𝑀* ( *𝐻* ) = *−𝑀* ( *−𝐻* )): *𝑛* *𝑠𝑦𝑚* = 1 and *𝑛* *𝑠𝑦𝑚* = 15 (i.e 185 points distributed over
half-sphere). In case of symmetric compounds, powder magnetisation may be averaged over a smaller part
of the sphere, reducing thus the number of points for the integration. The user is responsible to choose the
appropriate integration scheme. Note that the program’s default is rather conservative.

Example:



This keyword allows computation of the magnetic susceptibility *𝜒𝑇* ( *𝑇* ) at experimental points. On the line
below the keyword, the number of experimental points *𝑁* *𝑇* is defined, and on the next *𝑁* *𝑇* lines the program
reads the experimental temperature (in K) and the experimental magnetic susceptibility (in *𝑐𝑚* [3] *𝐾𝑚𝑜𝑙* *[−]* [1] ).
The magnetic susceptibility routine will also print the standard deviation from the experiment.

**654** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


```
HEXP
ZJPR
XFIE
TORQ

```

This keyword together with the keyword `PLOT` will enable the generation of two additional plots:
`XT_with_field_dM_over_dH.png` and `XT_with_field_M_over_H.png`, one for each of the two above
formula used, alongside with respective `gnuplot` scripts and gnuplot datafiles.

This keyword specifies the number of angular points for the computation of the magnetisation torque function, *⃗𝜏* *𝛼* as function of the temperature, field strength and field orientation.


This keyword allows computation of the molar magnetisation *𝑀* *𝑚𝑜𝑙* ( *𝐻* ) at experimental points. On the
line below the keyword, the number of experimental points *𝑁* *𝐻* is defined, and on the next *𝑁* *𝐻* lines the
program reads the experimental field intensity (in Tesla) and the experimental magnetisation (in *𝜇* *𝐵𝑜ℎ𝑟* ).
The magnetisation routine will print the standard deviation from the experiment.



This keyword specifies the value (in *𝑐𝑚* *[−]* [1] ) of a phenomenological parameter of a mean molecular field
acting on the spin of the complex (the average intermolecular exchange constant). It is used in the calculation
of all magnetic properties (not for spin Hamiltonians) (Default is 0.0).



This keyword specifies the value (in T) of applied magnetic field for the computation of magnetic susceptibility by *𝑑𝑀/𝑑𝐻* and *𝑀/𝐻* formulas. A comparison with the usual formula (in the limit of zero applied
field) is provided. (Default is 0.0). Example:




**7.18. Interface to POLY_ANISO module** **655**

**ORCA Manual** **,** **Release 6.0.1**

The torque is computed at all temperature given by `TMAG` or `HEXP_temp` inputs. Three rotations around
Cartesian axes X, Y and Z are performed.
```
PRLV

```
This keyword controls the print level.

     - 2 - normal. (Default)

     - 3 or larger (debug)
```
PLOT

```
Set to “true”, the program generates a few plots (png or eps format) via an interface to the linux program
*gnuplot* . The interface generates a datafile, a *gnuplot* script and attempts execution of the script for generation of the image. The plots are generated only if the respective function is invoked. The magnetic
susceptibility, molar magnetisation and blocking barrier ( `UBAR` ) plots are generated. The files are named:
`XT_no_field.dat`, `XT_no_field.plt`, `XT_no_field.png`, `MH.dat`, `MH.plt`, `MH.png`, `BARRIER_TME.`
`dat`, `BARRIER_ENE.dat`, `BARRIER.plt` and `BARRIER.png`, `zeeman_energy_xxx.png` etc. All files produced by `SINGLE_ANISO` are referenced in the corresponding output section. Example:
```
   PLOT
### **7.19 N-Electron Valence State Pertubation Theory**

```
CASPT2 and NEVPT2 belongs to the family of internally contracted perturbation theories with CASCI reference
wavefunctions. Several studies indicate that CASPT2 and NEVPT2 produce energies of similar quality.[366, 757]
The NEVPT2 methodology developed by Angeli et al exists in two formulations namely the strongly-contracted
NEVPT2 (SC-NEVPT2) and the partially contracted NEVPT2 (PC-NEVPT2). [44, 45, 46] Irrespective of the
name “partially contracted” coined by Angeli et al, the latter approach employs a fully internally contracted wavefunction (FIC). Hence, we use the term “FIC-NEVPT2” in place of PC-NEVPT2. ORCA features the fully internally contracted and the strongly contracted NEVPT2. The latter employs strongly contracted CSFs, which form a
more compact and orthogonal basis making it computationally slightly more attractive. Hence, the SC-NEVPT2
has been our work horse a for long time. NEVPT2 has many desirable properties - among them:

   - It is **intruder state free** due to the choice of the Dyall Hamiltonian [238] as the 0th order Hamiltonian.

  - The **0th order Hamiltonian is diagonal** in the perturber space. Therefore no linear equation system needs
to be solved.

   - It is **strictly size consistent** . The total energy of two non-interacting systems is equal to the sum of two
isolated systems.

   - It is **invariant under unitary transformations** within the active subspaces.

  - “ **strongly contracted** ”: Perturber functions only interact via their active part. Different subspaces are orthogonal and hence no time is wasted on orthogonalization issues.

  - “ **fully internally contracted** ”: Invariant to rotations of the inactive and virtual subspaces.

As described in Section *N-Electron Valence State Perturbation Theory (NEVPT2)* of the manual, NEVPT2 requires
a single keyword on top of a working CASSCF input. The methods are called within the CASSCF block and detailed
settings can be adjusted in the `PTSettings` subblock.

We will go through some of the detailed setting in the next few subsections. For historical reasons, a few features,
such as the quasi-degenerate NEVPT2, are only available for the strongly contracted NEVPT2. As shown elsewhere, the strong contraction is not a good starting point for linear scaling approaches.[806] Thus newer additions
such as the DLPNO and the F12 correction rely on the FIC variant. [338, 344, 345] Note that ORCA by default employs the frozencore approximation, which can be disabled with the simple keyword `!NoFrozenCore` . A complete
description of the frozecore settings can be found in section *Frozen Core Options* .



(continues on next page)

**656** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



NEVPT2 can also be set using the simple keywords on top of any valid CASSCF input.



The two computationally most demanding steps of the NEVPT2 calculation are the initial integral transformation
involving the two-external labels and the formation of the fourth order density matrix (D4). Efficient approximations to both issues are available in ORCA.

If not otherwise specified (keyword `CIStep` ), CASSCF and consequently NEVPT2 use a conventional CSF based
solver for the CAS-CI problem. In principle, the NEVPT2 approach can be combined with approximate CI solution
such as the DMRG approach described in section *Density Matrix Renormalization Group* . Starting with ORCA
4.0 it is possible to run NEVPT2-DMRG calculations for the FIC and SC type ansatz using the methodology developed by the Chan group.[336] Aside from the usual DMRG input, the program requires an additional parameter
( `nevpt2_MaxM` ) in the DMRG block. However, some of the features will be restricted to the default `CIStep` .

**7.19. N-Electron Valence State Pertubation Theory** **657**

**ORCA Manual** **,** **Release 6.0.1**



For the value `nevpt2_MaxM 2000` cf [336].

Using the RI approximation, large molecules with actives spaces of up to 20 orbitals should be computable. The
DMRG extension can be combined with DLPNO and F12 variants. Future version might also support the `CIStep`
`ACCCI` and `CIStep ICE` .

**7.19.1 RI, RIJK and RIJCOSX Approximation**

Setting the RI approximation on the CASSCF level, will set the RI options for NEVPT2 respectively. The three
index integrals are computed and partially stored on disk. Three index integral with two internal labels are kept in
main memory. The two-electron integrals are assembled on the fly. The auxiliary basis must be large enough to fit
the integrals appearing in the CASSCF orbital gradient/Hessian and the NEVPT2 part. The auxiliary basis set of
the type /J does not suffice here.



Additional speedups can be obtained if the Fock operator formation is approximated using the `!RIJCOSX` or `!RIJK`
techniques. In case of `RIJCOSX`, an additional auxiliary basis must be provided for the `AuxJ` auxiliary basis slot.
For more information on the basis set slots see section *Built-in Basis Sets* .

Whereas the `RIJK` requires a single auxiliary basis set ( `AuxJK` slot), that is large enough to fit integrals in the Fockmatrix construction, orbital gradient/Hessian and the correlation part. In contrast to COSX, the calculation can
also be carried out in `conv` mode (storing the AO integrals on disk).



The described methodology allows the computation of systems with up to 2000 basis functions. Even larger
molecules are accessible in the framework of DLPNO-NEVPT2 described in the next subsection. Several ex
amples can be found in the CASSCF tutorial.

**658** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.19.2 Beyond the RI approximation: DLPNO-NEVPT2**

For systems with more than 80 atoms, we recommend the recently developed DLPNO-NEVPT2.[344] It is a successful combination of DLPNO strategy with the FIC-NEVPT2 method. As its single reference counterparts,
DLPNO-NEVPT2 recovers 99.9% of the FIC-NEVPT2 correlation energies even for large system. The input
structure is similar to the parenting FIC-NEVPT2 method. Below you find an input example for the Fe(II)-complex
depicted in Fig. 7.6, where the active space consists of the metal-3d orbitals. The example takes about 9 hour (including 3 hour for one CASSCF iteration) using 8 cores (2.60GHz Intel E5-2670 CPU) for the calculation to finish.
A detailed description of the DLPNO-NEVPT2 methodology can be found in our article.[344].

Just like RI-NEVPT2, the calculations requires an auxiliary basis. The aux-basis should be of /C or /JK type (more
accurate). Aside from the paper of Guo et al,[344] a concise report of the accuracy can be found in the CASSCF
tutorial, where we compute exchange coupling parameters. Note that in the snippet above, we have repeated some
of the default setting in the NEVPT sub-block. This is not mandatory and should be avoided to keep the input as
simple as possible.

As mentioned earlier, the CASSCF step can be accelerated with the RIJK or RIJCOSX approximation. Both
options are equally valid for the DLPNO-NEVPT2. The RIJK variant typically produces more accurate results
than RIJCOSX. The input file is almost the same as before, except for the keyword line:



**7.19. N-Electron Valence State Pertubation Theory** **659**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.6: Structure of the FeC 72 N 2 H 100

**7.19.3 Explicitly correlated NEVPT2: NEVPT2-F12 and DLPNO-NEVPT2-F12**

Like in the single-reference MP2 theory, the NEVPT2 correlation energy converges slowly with the basis set. Aside
from basis set extrapolation, the R12/F12 method are popular methods to reach the basis set limit. For comparison
of F12 and extrapolation techniques, we refer to the study of Liakos et al.[521] ORCA features an F12 correction
for the FIC-NEVPT2 wavefunction using the RI approximation.[345] The RI approximation is mandatory as the
involved integrals are expensive. In complete analogy to the single reference MP2-F12, the input requires an F12
basis, an F12-cabs basis and a sufficiently large RI basis (/JK or /C).




A linear scaling version of NEVPT2-F12, the DLPNO-NEVPT2-F12, allows to tackle systems with several thou
**660** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

sand of basis functions.[338] With the exception of the DLPNO_NEVPT2 keyword, the input structure is otherwise
identical to NEVPT2-F12 method.

Note that the DLPNO-NEVPT2-F12 algorithm is unitary invariant with respect to subspace rotation of inactive and
active orbitals. By tightening the DLPNO truncation thresholds, the canonical NEVPT2-F12 can be reproduced,
even with localized internal and active molecular orbitals.



**7.19. N-Electron Valence State Pertubation Theory** **661**

**ORCA Manual** **,** **Release 6.0.1**

**7.19.4 Tackling large active CASSCF spaces**

Large active spaces (CAS(10,10) and more) require special attention as the standard implementation involves the
fourth order reduced density matrix (4-RDM).[46] The storage of the latter can easily reach several gigabytes and
thus cannot be kept in core memory. ORCA thus by default constructs and contracts the 4-RDM on the fly ( `D4Step`
`fly` ). Note that the program can be forced to keep the 4-RDM on disk ( `D4Step disk` ) or in memory ( `D4Step`
`core` ).

Aside from the storage, the formation of the 4-RDM itself becomes the time dominating step of the NEVPT2 calculation for large active spaces. There are two set of approximations to tackle the challenge. The prescreening (PS)
or the extended prescreening (EPS) approximation and the cumulant expansion.[343]
In addition, a reformulation of the canonical NEVPT2 is available, that avoids the 4-RDM.[458] The basic idea
of the latter is similar to the recent development reported by Sokolov and coworkers.[162] In ORCA the reformulated “efficient” implementation is combined with the PS approximation. Note that the reformulation is presently
restricted to the canonical NEVPT2 ansatz. An extension to the DLPNO variant will be available in the future.

The new code is called setting “ `D4Step efficient` ”. Irrespective of the formulation, ORCA by default truncates
the CASSCF wave function prior computation of the fourth order reduced density matrix using the PS approximation.[342, 343] Only configurations with a weight larger than a given parameter `D4TPre` are taken into account. The
same reduction is available for the third order density matrix using the keyword `D3TPre` . Both of the parameters
can be adjusted within the `PTSettings` sub-block of the CASSCF module.



These approximations naturally affect the “configuration RI” as well. In this context, it should be noted that a
configuration corresponds to a set of configuration state functions (CSF) with identical orbital occupation. For
each state the dimension of the CI and and RI space is printed.



The default values usually produce errors of less than 1 mEh. However, the error introduced by the `D4TPre` is
system dependent and should be double checked. The exact NEVPT2 energy is recovered with the parameters
set to zero. The approximation is available for all variants of NEVPT2 (SC, FIC and DPLNO-FIC). For crude
cut-offs, the approximation may lead to so called *false intruder states* .[342, 343, 913] The behavior shows up as
unreasonably large correlation energy contributions of the 1h (V_i) or 1p (V_a) excitations class e.g. positive or
large correlation energies compared to the 2h-2p (V_ijab) excitation class. This is a system specific issue, which is
avoided with tighter thresholds (D4TPre=1e-14). The default settings is chosen conservative and rarely produces
artifacts. As last resort, an imaginary shift can be added to mitigate intruder states. Note that imaginary shifts
(default=0.0 )are restricted the canonical FIC-NEVPT2 - not DLPNO.

The PS approximation completely neglects CFGs with a small weight. This is contrasted by the EPS approximation,
where the small weights (up to thresh `D4TQuad` ) are still accounted for (first order correction).[343]. The results
are more robust but also more expensive compared to the PS approximation.



(continues on next page)

**662** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Huge computational savings can be achieved with the cumulant expansion, which have been recently reevaluated.[343]. The results should be treated with care as false intruder states can emerge.[913] In these cases,
the imaginary level shift is the only mitigation tool. Note that the imaginary shift is implemented only for FICNEVPT2.



**7.19.5 Selecting or Specific States for NEVPT2**

ORCA by default computes all states defined in the CASSCF block input with the NEVPT2 approach. There are
cases, where this is not desired and the user wants to skip some of these states. The input mask of `SelectedRoots`
is equivalent to the `weights` keyword in the %casscf block: The enumeration `SelectedRoots[0]` refers to the
numbering of the multiplicity blocks and the respective roots defined in CASSCF.



**7.19.6 Unrelaxed Densities and Natural Orbitals**

With the FIC-NEVPT2 ansatz, it is possible to request state-specific unrelaxed densities

*𝛾* ( *𝑝, 𝑞* ) = *<* Ψ *𝐼* *|𝐸* *𝑞* *[𝑝]* *[|]* [Ψ] *[𝐼]* *[>,]*

where Ψ *𝐼* refers to NEVPT2 wave function of the I’th state. The code is implemented using the ORCA AGE
tool-chains.[474] In its present form the code runs serial. Note that the density can be used to generate natural
orbitals.



(continues on next page)

**7.19. N-Electron Valence State Pertubation Theory** **663**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



The density as well the natural orbitals are state-specific. Thus, ORCA repeats the population analysis for each
state. With the added keyword `!KeepDens` the NEVPT2 density is stored in the density container ( **.densities** file
on disk). The latter can be used to create density plots interactively (see Section *orca_plot* ). Natural orbitals are
stored in the gbw file-format as **.nat** file with a prefix corresponding to the jobname, multiplicity and root. The
density can be used to generate natural orbitals.

A typical output takes the following form:



NEVPT2 natural orbital can be used to do natural orbital iterations ( `!MORead NoIter` ). They might also be a
useful tool to find suitable orbital to extend the active space.[443]

**664** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.19.7 State-averaged NEVPT2**

In the definition of the Dyall Hamiltonian [238] the CASSCF orbitals are chosen to diagonalize the Fock operator
(pseudo-canonicalized). Therefore, using a state-averaged CASSCF wave function, the NEVPT2 procedure involves the construction and diagonalization of the “state-specific” Fock operators and is thus resulting in a unique
set of orbitals for each state. This becomes quickly inefficient for large number of states or large molecular systems
since each orbital set implies an integral-transformation. This is the **default** setting for NEVPT2 and is printed in
the output



Other orbital options can be set using the keyword `canonstep` .



The final orbitals of the state-averaged CASSCF diagonalize the state-averaged Fock operator. Large computational
savings can be made if these orbitals are employed for all of the states. `canonstep 0` chooses orbital energies as
diagonal elements of the state-specific Fock operators. In release version ORCA 3.0 and older, this has been
the default setting. These options work best if the averaged states are similar in nature. For SC-NEVPT2, we
have implemented two more `canonsteps`, which trade accuracy for speed and *vice versa* . `canonstep 2` is more
approximate and employs orbital energies from the state-averaged calculation. Thus there is no contribution to
excitation energies from the perturber class *𝑉* *𝑖𝑗* *[𝑎𝑏]* [at this level of approximation.]

If the states under consideration are substantially different, these approximations will be of poor quality and should
be turned off. Better results can be achieved, if the state-averaged orbitals are partially relaxed for each state
before the actual SC-NEVPT2 calculation. [224] Often it is not possible to optimize the excited states separately.
Thus `canonstep 3` will try a single steepest descent step for each state before running the actual SC-NEVPT2
calculation with canonicalized orbitals. Optionally, instead of a steepest descent using an approximate diagonal
Hessian, a single Newton-Raphson step can be made.



Despite a converged state-averaged calculation, the gradient for the individual states can be surprisingly large. As
a consequence, the orbital relaxation might fail as both methods might be outside their convergence radius. ORCA
will retry the relaxation with an increased damping. If the orbital update still fails, the program will stick with the
initial orbitals. Setting an overall damping manually, might help the relaxation procedure.



**7.19. N-Electron Valence State Pertubation Theory** **665**

**ORCA Manual** **,** **Release 6.0.1**

**7.19.8 Quasi-Degenerate SC-NEVPT2**

NEVPT2 as it is presented in the previous subsections follows the recipe of “diagonalize and perturb”. The 0th
order wavefunction is determined by the diagonalization of the CAS-CI matrix. The space spanned by the CAS-CI
vectors is often referred to as “model space”. The subsequent perturbation theory is constructed based on the assumption that the states under consideration are well described within the model space. Consequently, the first order
correction to the wavefunction Ψ [(1)] *𝐼* does not affect the composition of the reference state *|𝐼⟩* . Corrections to the
wavefunction and energy arise from the interaction of the reference state with the functions *|𝑘⟩* of the contributing
first order interacting space

Ψ [(1)] *𝐼* = ∑︁ *𝐶* *𝑘* *|𝑘⟩*

*𝑘*


*𝐸* *𝐼* [(2)] = ∑︁

*𝑘*


*⟨* *𝐼* *|* *𝐻* *|* *𝑘* *⟩⟨* *𝑘* *|* *𝐻* *|* *𝐼* *⟩*

*𝐸* *𝐼* [(0)] *−* *𝐸* *𝑘*


This is problematic, when the interaction/mixing of states are falsely described at the CASSCF level. A typical
example is the dissociation of lithium fluoride.



Here, the ground and first excited state of Σ [+] should not cross. However, at the NEVPT2 level, an erratic double
crossing is observed instead.

**666** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

CAS(2,2) reference

A re-organizing of the reference states can be introduced in the framework of quasi-degenerate perturbation theory.
In practice, an effective Hamiltonian is constructed allowing “off-diagonal” corrections to the second order energy


*𝐻* *𝐼𝐽* = *𝛿* *𝐼𝐽* *𝐸* *𝐼* [(0)] + ∑︁

*𝑘*


*⟨* *𝐼* *|* *𝐻* *|* *𝑘* *⟩⟨* *𝑘* *|* *𝐻* *|* *𝐽* *⟩*

*𝐸* *𝐼* [(0)] *−* *𝐸* *𝑘*


Diagonalization of this eff. Hamiltonian yields improved energies and rotation matrix (right eigenvectors) that
introduces the desired re-mixing of the reference states. The quasi-degenerate extension to SC-NEVPT2 [43] can
be switched on with the keyword `QDType` .



ORCA will print the eff. Hamiltonian matrix and its eigenvectors at the end of the calculation.




(continues on next page)

**7.19. N-Electron Valence State Pertubation Theory** **667**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



By construction the Hamiltonian is non-Hermitian ( `QDType QD_Bloch` ). Hence the computation of properties with
the revised wave function e.g. expectation values require left- and right eigenvectors. A single set of eigenvectors
(“right”) can be constructed using the Des Cloizeaux scheme ( `QDType QD_Cloiszeaux` ) leading to an Hermitian
effective Hamiltonian.[204] The transformation does not change the energies but affects the mixing of states. Note
that actual eff. Hamiltonian is printed with a `PrintLevel` larger 4 in the PTSettings subblock. The diagonalization
of the general matrices appearing in both formulations may occasionally lead to complex eigenpairs - an undesired
artifact. Although, the eigenvalues have typically only a small imaginary component, the results are not reliable
and ORCA prints a warning.



The `QD_VanVleck` option avoids the general eigenvalue decomposition. The equations are derived from second
order Van Vleck perturbation theory, which results in a Hermitian eff. Hamiltonian.[493] The methodology is
equivalent to the symmetrization of the Bloch Hamiltonian. The solution is always real and properties are easily
accessible. Thus, `QD_VanVleck` **is the recommended approach in ORCA** . For a more detailed comparison of
the different eff. Hamiltonian theories, we refer to the literature.[123, 790]
In all three formulations, the energy denominator in the quasi-degenerate NEVPT2 is very sensitive to approximations. The canonicalization options with averaged orbitals and orbitals energies ( `canonstep 0/2` ) have the
tendency to lessen the energy-denominator. To avoid artifacts, the calculation is restricted to `canonstep 1` —
each state has its own orbitals.

If properties are requested within the casscf module i.e. zero-field splitting, there will be an additional printing
with the “improved” CI vectors and energies. For technical reasons, properties that are not computed in CASSCF
such as the Mössbauer parameters do not benefit from the QD-NEVPT2 correction.

**668** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**
### **7.20 Complete Active Space Peturbation Theory : CASPT2 and** **CASPT2-K**

The fully internally contracted CASPT2 (FIC-CASPT2) approach is available with real, imaginary and IPEA
shifts.[40, 270, 732]. The ORCA implementation employs a reformulation of the CASPT2, that completely avoids
the fourth order reduced density matrix, that would appear in the canonical implementation.[458] Some concepts
are shared by a recent development reported by Sokolov and coworkers.[162] The modification allows calculations
with large active spaces without approximating the results e.g. with the cumulant expansion.

It should be noted that the IPEA shift in OpenMOLCAS slightly deviates from ORCA.[253]. Here, the IPEA shift,
*𝜆*, is added to the matrix elements of the internally contracted CSFs Φ *[𝑝𝑟]* *𝑞𝑠* [=] *[ 𝐸]* *𝑞* *[𝑝]* *[𝐸]* *𝑠* *[𝑟]* *[|]* [Ψ] [0] *[ >]* [ with the generalized Fock]
operator


*<* Φ *[𝑝]* *[′][′]* *[𝑟]* *[′][′]*



*[𝑝]* *𝑞* *[′][′]* *𝑠* *[𝑟]* *[′][′]* *[|][𝐹]* [ ˆ] *[|]* [Φ] *[𝑝𝑟]* *𝑞𝑠* *[>]* [ + =] *[<]* [ Φ] *[𝑝]* *𝑞* *[′][′]* *𝑠* *[𝑟]* *[′][′]*



*[𝑝]* *𝑞* *[′][′]* *𝑠* *[𝑟]* *[′][′]* *[|]* [Φ] *[𝑝𝑟]* *𝑞𝑠* *[>][ ·]* *[𝜆]*


*𝑝* *[−]* *[𝛾]* *𝑞* *[𝑞]* [+] *[ 𝛾]* *𝑟* *[𝑟]* *[−]* *[𝛾]* *𝑠* *[𝑠]* [)] *[,]*
2 *[·]* [ (4 +] *[ 𝛾]* *[𝑝]*


where *𝛾* *𝑞* *[𝑝]* [=] *[<]* [ Ψ] [0] *[|][𝐸]* *𝑞* *[𝑝]* *[|]* [Ψ] [0] *[ >]* [ is the expectation value of the spin-traced excitation operator.[][441][] The labels p,q,r,s]
refer to general molecular orbitals (inactive, active and virtual). Irrespective of the ORCA implementation, the
validity of the IPEA shift in general remains questionable and is thus by default disabled.[922] ORCA features
an alternative formulation, named **CASPT2-K**, that revises the zeroth order Hamiltonian itself.[460] Here, two
additional Fock matrices are introduced for excitation classes that add or remove electrons from the active space.
The new Fock matrices are derived from the generalized Koopmans’ matrices corresponding to electron ionization
and attachment processes. The resulting method is less prone to intruder states and the same time more accurate
compared to the canonical CASPT2 approach. For more a detailed discussion, we refer to the paper by Kollmar et
al.[460]

The CASPT2 and CASPT2-K approaches are called in complete analogy to the FIC-NEVPT2 approach. Note that
the methodology can be combined with the RI approximation. A detailed example with comments on the output is
given in Section *Complete Active Space Perturbation Theory: CASPT2 and CASPT2-K* . Below is concise list with
the accessible options.



(continues on next page)

**7.20. Complete Active Space Peturbation Theory : CASPT2 and CASPT2-K** **669**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



CASPT2 can also be set using the simple keywords on top of any valid CASSCF input.


### **7.21 Dynamic Correlation Dressed CAS**

DCD-CAS(2) is a post-CASSCF MRPT method of the perturb-then-diagonalize kind, i.e. it can modify the CAS
wavefunction compared to the previous CASSCF.[653] In cases where CASSCF already provides a good 0th order
wavefunction, DCD-CAS(2) energies are comparable to NEVPT2.

**7.21.1 Theory of Nonrelativistic DCD-CAS(2)**

The DCD-CAS(2) method is based on solving the eigenvalue problem of an effective Hamiltonian of the form


*𝐻* *𝐼𝐽* [DCD] *[,𝑆]* = *⟨* Φ *[𝑆𝑆]* *𝐼* *[|][𝐻][|]* [Φ] *[𝑆𝑆]* *𝐽* *[⟩−]* ∑︁

*𝐾∈* FOIS


*⟨* Φ *[𝑆𝑆]* *𝐼* *[|]* *[𝐻]* *[|]* [˜Φ] *[𝑆𝑆]* *𝐾* *[⟩⟨]* [˜Φ] *[𝑆𝑆]* *𝐾* *[|]* *[𝐻]* *[|]* [Φ] *[𝑆𝑆]* *𝐽* *[⟩]*
*𝐸* *𝐾* *[𝑆]* *[−]* *[𝐸]* 0 *[𝑆]*


for each total spin *𝑆* separately. The 0th order energies *𝐸* *𝐾* *[𝑆]* [of the perturbers] *[ |]* [˜Φ] *[𝑆𝑆]* *𝐾* *[⟩]* [are obtained by diagonalizing]
the Dyall’s Hamiltonian in the first-order interacting space (FOIS). The effective Hamiltonian has the form of a
CASCI Hamiltonian that is dressed with the effect of dynamic correlation (dynamic correlation dressed, DCD),
hence the name for the method. *𝐸* 0 *[𝑆]* [is chosen to be the ground state CASSCF energy for the respective total spin]
*𝑆* . Since this choice is worse for excited states than for the ground state, excitation energies suffer from a “ground
state bias”.

For the contribution coming from perturbers in which electrons are excited from two inactive ( *𝑖𝑗* ) to two virtual
( *𝑎𝑏* ) orbitals, we use (when writing the DCD Hamiltonian in a basis of CASCI states) the alternative expression

*⟨* Ψ *[𝑆𝑆]* *𝐼* *[|][𝐻]* [DCD] [(] *[𝑖𝑗]* *[→]* *[𝑎𝑏]* [)] *[|]* [Ψ] *[𝑆𝑆]* *𝐽* *[⟩]* [=] *[ −][𝛿]* *[𝐼𝐽]* *[𝐸]* [MP2]


*𝐸* MP2 = ∑︁

*𝑖𝑗𝑎𝑏*


( *𝑖𝑏* *|𝑗* *𝑎* ) [2] *−* ( *𝑖𝑏* *|𝑗* *𝑎* )( *𝑖𝑎* *|𝑗* *𝑏* ) + ( *𝑖𝑎* *|𝑗* *𝑏* ) [2]

*𝜖* *𝑎* + *𝜖* *𝑏* *−* *𝜖* *𝑖* *−* *𝜖* *𝑗*


Since in this version the *𝑖𝑗* *→* *𝑎𝑏* perturber class does not contribute at all to excitation energies (like it is assumed
in the difference-dedicated configuration interaction method), we call this the difference-dedicated DCD-CAS(2)
method. Since the *𝑖𝑗* *→* *𝑎𝑏* class contributes the largest part of the dynamic correlation energy, this also removes
the largest part of the ground state bias. This option is used as default in DCD-CAS(2) calculations. In order to
also remove the ground state bias from the other perturber classes, we furthermore apply a perturbative correction
to the final energies. At first order (which is chosen as default), it takes the form


∆ *𝐸* *𝐼* = *−* ∆ *𝐼* ∑︁

*𝐾∈* FOIS


*⟨* Ψ [˜] *𝐼* *|* *𝐻* *|* Φ [˜] *𝐾* *⟩⟨* Φ [˜] *𝐾* *|* *𝐻* *|* Ψ [˜] *𝐼* *⟩*

( *𝐸* *𝐾* *−* *𝐸* 0 ) [2]


∆ *𝐼* = *⟨* Ψ [˜] *𝐼* *|𝐻|* Ψ [˜] *𝐼* *⟩−* *𝐸* 0

for the correction ∆ *𝐸* *𝐼* to the total energy of the *𝐼* th DCD-CAS(2) root *|* Ψ [˜] *𝐼* *⟩* .

**670** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.21.2 Treatment of spin-dependent effects**

The theory so far is valid for a nonrelativistic or scalar-relativistic Hamiltonian *𝐻* . If we modify it to a Hamiltonian
*𝐻* + *𝑉*, where *𝑉* contains effects that are possibly spin-dependent, this leads us to a theory [491] which has a similar
form as QDPT with all CAS roots included. The form of the spin-dependent DCD-CAS(2) effective Hamiltonian

is

*⟨* Φ *[𝑆𝑀]* *𝐼* *|𝐻* [DCD] *|* Φ *[𝑆]* *𝐽* *[′]* *[𝑀]* *[′]* *⟩* = *𝛿* *𝑆𝑆* *′* *𝛿* *𝑀𝑀* *′* *𝐻* *𝐼𝐽* [DCD] *[,𝑆,]* [corr] + *⟨* Φ *[𝑆𝑀]* *𝐼* *|𝑉* *|* Φ *[𝑆]* *𝐽* *[′]* *[𝑀]* *[′]* *⟩.*

**H** [DCD] *[,𝑆,]* [corr] = **C** [DCD] **E** ( **C** [DCD] ) *[𝑇]* *.*

In order to construct it, we first need to solve the scalar-relativistic DCD-CAS(2) problem to construct the matrix
**H** [DCD] *[,𝑆,]* [corr] from the bias corrected energies **E** and DCD-CAS(2) CI coefficients **C** and then calculate the matrix
elements of the operators contributing to V in the basis of CSFs *|* Φ *[𝑆𝑀]* *𝐼* *⟩* .

Zero field splitting D tensors are extracted using the effective Hamiltonian technique, i.e. fitting the model Hamiltonian to a des-Cloiseaux effective Hamiltonian that is constructed from the relativistic states and energies by
projection onto the nonrelativistic multiplet (see section *Zero-Field Splitting* and the reference [566]). There are
limitations to this approach if spin orbit coupling becomes so strong that the relativistic states cannot uniquely be
assigned to a single nonrelativistic spin multiplet.

Hyperfine A-matrices and Zeeman g-matrices for individual Kramers doublets consisting of states *|* Φ *⟩, |* Φ *⟩* are
extracted by comparing the spin Hamiltonians

*𝐻* Zeeman = *𝜇* *𝐵* *𝐵* *[⃗]* *· 𝑔* *·* *𝑆* *[⃗]*

*𝐻* HFC = ∑︁ *⃗𝐼* *[𝐴]* *· 𝐴* *[𝐴]* *· ⃗𝑆*

*𝐴*

to the matrix representation of the many-electron Zeeman and HFC operators in the basis of the Kramers doublet.
This yields [491]

*𝑔* *𝑘* 1 = 2 *ℜ⟨* Φ *|𝐿* *𝑘* + *𝑔* *𝑒* *𝑆* *𝑘* *|* Φ *⟩*

*𝑔* *𝑘* 2 = 2 *ℑ⟨* Φ *|𝐿* *𝑘* + *𝑔* *𝑒* *𝑆* *𝑘* *|* Φ *⟩*

*𝑔* *𝑘* 3 = 2 *⟨* Φ *|𝐿* *𝑘* + *𝑔* *𝑒* *𝑆* *𝑘* *|* Φ *⟩*

*𝐴* *𝑘* 1 = *−* 2 *𝛾* *𝐴* *ℜ⟨* Φ *|𝐵* *𝑘* [HFC] ( *𝑅* *[⃗]* *𝐴* ) *|* Φ *⟩*

*𝐴* *𝑘* 2 = *−* 2 *𝛾* *𝐴* *ℑ⟨* Φ *|𝐵* *𝑘* [HFC] ( *𝑅* *[⃗]* *𝐴* ) *|* Φ *⟩*

*𝐴* *𝑘* 3 = *−* 2 *𝛾* *𝐴* *⟨* Φ *|𝐵* *𝑘* [HFC] ( *𝑅* *[⃗]* *𝐴* ) *|* Φ *⟩*

where *𝐵* *𝑘* [HFC] ( *𝑅* *[⃗]* *𝐴* ) is the *𝑘* th component of the magnetic hyperfine field vector at the position of nucleus *𝐴* and *𝛾* *𝐴*
is the gyromagnetic ratio.

**7.21.3 List of keywords**

The following keywords can be used in conjunction with the DCD-CAS(2) method:

(continues on next page)

**7.21. Dynamic Correlation Dressed CAS** **671**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



Note that the calculation of SSC requires the definition of an auxiliary basis set, since it is only implemented
in conjunction with RI integrals. If `dcd_magnetization` is requested, the values for magnetic flux density
and temperature to be used can be specified via the keywords `MAGTemperatureMIN`, `MAGTemperatureMAX`,
`MAGTemperatureNPoints`, `MAGFieldMIN`, `MAGFieldMAX`, `MAGNpoints` of the `rel` subblock of the `%casscf`
block (see section *Magnetization and Magnetic Susceptibility* ). If the keyword `dcd_domagfield` is set to a number different than 0, the magnetic fields can be entered as a matrix of xyz coordinates (in Gauss), e.g.



Furthermore, there is the keyword `DCD_EDIAG` that when running the DCD-CAS(2) code in CASCI mode works
analogously to the keyword `EDiag` in the `soc` subblock of the `%mrci` block (see section *Zero-Field Splitting* ). The
only difference is that the energies should be entered in atomic units, not in wavenumbers, e.g.



**672** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**
### **7.22 Density Matrix Renormalization Group**

*The* `BLOCK` *code in ORCA is only available on the Linux platform!*

`BLOCK` is an implementation of the density matrix renormalization group (DMRG) algorithm from the Chan group.

[156, 157, 158, 296, 789] The references given should be cited when using this part of the program.

The DMRG is a variational wavefunction method. It can be viewed as (i) an efficient method for strong correlation
in large complete active spaces, (ii) a brute force method to systematically approach FCI for a large number of
electrons and orbitals, (iii) a polynomial cost route to exact correlation in pseudo-one-dimensional molecules, such
as chains and rings.

Although the algorithm is somewhat complicated compared to many quantum chemistry methods, significant effort
has been devoted in `BLOCK` to ensure that it can be run in a simple black-box fashion. In most cases, only a single
keyword needs to be specified.

To provide an idea of how the DMRG can be used, here are some examples. The timings will vary depending on
your computational setup, but the following are calculations that run in a few hours to a day, on a single 12-core
Xeon Westmere cluster node:

  - Complete active space (CAS) CI calculations for active spaces with up to 30 electrons in 30 active orbitals,
targetting up to 1–10 states, e.g. Jacobsen’s catalyst in a 32 electron, 25 orbital active space,

  - One-dimensional chain molecules, with “widths” of up to 4 orbitals, and about 100 orbitals in total, e.g. the
*𝜋* -active space of a 4 *×* 25 graphene nanoribbon,

  - FCI benchmark solutions in molecules with fewer than 20 electrons, and up to 100 orbitals, e.g. C 2 in a
cc-pVTZ basis, D 2h symmetry (12 electrons in 60 orbitals),

  - Accuracies in energy differences or total energies of about 1 kcal/mol.

The following are calculations which are possible with the `BLOCK` code, but which are challenging, and require
large memory (e.g. up to 8 GB per core) and computational time (e.g. from a day to more than a week on up to 6
12-core Xeon Westmere nodes),

  - Complete active space (CAS) CI calculations in active spaces with around 40 electrons in 40 active orbitals,
targetting a few states, for example, an Fe(II)-porphine (40 electrons in 38 orbitals) with an active space of Fe
3d, 4d and all porphine *𝜋* and *𝜎* donor orbitals, or an Fe 3d, S 3p active space calculation for [Fe 4 S 4 (SCH 3 )

4 []] [2] *[−]* [,]

  - One-dimensional chain molecules, with “widths” of up to 6 orbitals, and about 100 total orbitals,

  - Champion FCI benchmark solutions in small molecules, such as butadiene in a cc-pVDZ basis (22 electrons
in 82 orbitals),

  - Accuracies in energy differences or total energies of about 1 kcal/mol.

If any these calculations interest you, then you might want to try a DMRG calculation with `BLOCK` !

**7.22.1 Technical capabilities**

Currently, `BLOCK` implements the following

  - An efficient DMRG algorithm for quantum chemistry Hamiltonians

  - Full spin-adaptation (SU(2) symmetry) and Abelian point-group symmetries

  - State-averaged excited states

Note that the standalone version of `BLOCK` may provide more capabilities than are available through the external
interface. See the `BLOCK` website for details [155].

**7.22. Density Matrix Renormalization Group** **673**

**ORCA Manual** **,** **Release 6.0.1**

**7.22.2 How to cite**

We would appreciate if you cite the following papers in publications resulting from the use of `BLOCK` :

  - G. K.-L. Chan and M. Head-Gordon, *J. Chem. Phys.* **116**, 4462 (2002),

  - G. K.-L. Chan, *J. Chem. Phys.* **120**, 3172 (2004),

  - D. Ghosh, J. Hachmann, T. Yanai, and G. K.-L. Chan, *J. Chem. Phys.*, **128**, 144117 (2008),

  - S. Sharma and G. K-.L. Chan, *J. Chem. Phys.* **136**, 124121 (2012).

In addition, useful DMRG references relevant to quantum chemistry can be found in the review below by Chan and
Sharma.

  - G. K-.L. Chan and S. Sharma, *Ann. Rev. Phys. Chem.* **62**, 465 (2011),

**7.22.3 Overview of BLOCK input and calculations**

Within ORCA, the `BLOCK` program is accessed as part of the CASSCF module. `BLOCK` can be run in two modes:
CASCI mode (no orbital optimization) or CASSCF mode. To enable CASCI mode, set `maxiter 1` .



For small molecule CASCI it may be possible to correlate all orbitals. In general, similar to a standard CASSCF
calculation, it is necessary to select a sensible active space to correlate. (See Section *Orbital optimization* on
CASSCF). This is the responsibility of the user.

**7.22.4 Standard commands**

Once the orbitals to correlate have been chosen, and the wavefunction symmetries and quantum numbers are specified, the accuracy of the DMRG calculation is governed by two parameters: the maximum number of renormalized
states *𝑀* ; and, the order and localization of the orbitals.

The most important parameter in the DMRG calculation is *𝑀*, the number of renormalized states. This defines
the maximum size of the wave-function expansion, which is *𝑂* ( *𝑀* [2] ) in length in the renormalized basis. As *𝑀* is
increased, the DMRG energy converges to the exact (FCI or CASCI) limit.

The DMRG maps orbitals onto a 1D lattice, thus the best results are achieved if strongly interacting orbitals are
placed next to each other. For this reason, the DMRG energy is not generally invariant to orbital rotations within the
active space, and orbital rotation and ordering can improve the DMRG energy for a given *𝑀* . As *𝑀* is increased,
the DMRG energy becomes less and less sensitive to the orbital ordering and localization.

To minimize the number of wavefunction optimization steps, it is often advantageous to perform DMRG calculations at small *𝑀*, then increase *𝑀* to the final maximum value. This sequence of optimizations is governed by the
*sweep schedule*, which specifies how many optimization steps (sweeps) to perform at each intermediate value of
*𝑀* .

The above may seem to make running a DMRG calculation more complicated than a usual quantum chemistry
calculation, however, `BLOCK` provides a set of default settings which eliminate the need to specify the above parameters by hand. We highly recommend that you first learn to use the `BLOCK` program *with these default settings* .
In the default mode, the orbitals are ordered automatically (Fiedler vector method [58, 72, 259, 260]) and a default
sweep schedule is set.

An example of a default CASCI calculation on the C~2~ molecule correlating all electrons in a VTZ basis, is given
here:

**674** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Once you are familiar with the default mode, we recommend exploring the localization of orbitals. In general,
DMRG benefits from the use of localized orbitals, and these should be used unless the high-symmetry of the
molecule (e.g., D 2 *ℎ* symmetry) provides compensating computational benefits. We recommend using “splitlocalized” orbitals, which correspond to localizing the occupied and virtual orbitals separately. An example of
a split-localized default DMRG calculation on the porphine molecule, correlating the full *𝜋* -space (26 electrons in
24 orbitals), in a cc-pVDZ basis is given in Sec. *Appendix: Porphine \pi-active space calculation* .

For a given `maxM`, it can take a long time to tightly converge DMRG calculations (e.g. to the default 1e-9 tolerance).
To decrease computation time, you may wish to loosen the default tight sweep tolerance or control the maximum
number of sweep iterations with the commands `sweeptol` and `maxIter` .

**Orbital optimization**

Orbital optimization (mixing the external/internal space with the active space, not to be confused with orbital
rotation and ordering in the active space) in DMRG calculation can be performed by using the `BLOCK` program
as the “CIStep” within a CASSCF calculation, as described above. For the moment, spin-densities and related
properties are not available for this `CIStep` .

During the optimization iterations it is important that the active orbitals maintain their overlap and ordering with
previous iterations. This is done using `actConstrains` . This flag is set by default.



In general, performing a DMRG calculation with orbital optimization is quite expensive. Therefore, it is often best
to carry out the orbital optimization using a small value of `maxM` (enabled by the default parameters `maxM=25` and
the resulting sweep schedule), and to carry out a final single-point calculation using a larger value of `maxM` .

**7.22. Density Matrix Renormalization Group** **675**

**ORCA Manual** **,** **Release 6.0.1**

**Advanced options**

There may be times when one wants finer control of the DMRG calculation. All keywords are shown in the *complete*
*set of BLOCK options Complete set of BLOCK options* below. The `startM` command allows to change the starting
number of states in DMRG calculations. It is also possible to specify the entire sweep schedule manually. A sweep
schedule example follows:



The commands above are:

   - `MaxIter`, corresponds to the maximum number of sweeps done by DMRG;

   - `NSchedule`, specifies the total number of schedule parameters we will specify;

   - `Sche_iteration`, details the sweep number at which to change the parameters of the calculation. Notice
count begins at 0;

   - `Sche_M`, is the number of renormalized states at each sweep;

   - `Sche_sweeptol`, is the tolerance of the Davidson algorithm;

   - `Sche_noise`, is the amount of perturbative noise we add each sweep;

   - `Twodot_to_onedot`, specifies the sweep at which the switch is made from a twodot to a onedot algorithm.
The recommended choice is to start with twodot algorithm and then switch to onedot algorithm a few sweeps
after the maximum *𝑀* has been reached. To do a calculation entirely with the twodot or the onedot algorithm,
replace the `twodot_to_onedot` line with `twodot 1` or `onedot 1` ;

   - `switch_rst`, defines the switching threshold of orbital gradient below which DMRG turns to onedot algorithm and restarts from previous operators and wavefunction. This is essential to avoid oscillation of energy
values in the orbital optimization.

The default DMRG sweep schedule is selected automatically according to the choice of computational mode. By
default two different sets of predefined schedules are supported for CASCI and CASSCF computations, respectively.

In CASCI mode, the default schedule corresponds to the following: starting from a given `startM` (where the
default is 250 and 8 sweeps), increase to a value of 1000 (8 sweeps) and increment by 1000 every 4 iterations until
`maxM` is reached. The algorithm switches from twodot to onedot two sweeps after the `maxM` has been reached.

In CASSCF mode, the orbital optimization requires much fewer renormalized states to converge the wavefunction
with respect to orbital rotations. The default schedule therefore starts with `startM` (where the default is 25 and 2
sweeps), and increments by a factor of 2 every 2 sweeps util `maxM` is reached. The algorithm continues the sweep
at `maxM` by decreasing the Davison tolerance `sche_sweeptol` and noise level `sche_noise` every 2 cycles by a
factor of 10, until `sche_sweeptol` becomes smaller than `sweeptol` .

For better control of the orbital ordering, we also provide a genetic algorithm minimization method of a weighted
exchange matrix. The genetic algorithm usually provides a superior orbital ordering to the default ordering, but
can itself take some time to run for large numbers of orbitals. The genetic algorithm can be enabled by

**676** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**



within the `%casscf` input.

**Troubleshooting**

The two most common problems with DMRG calculations are that (i) convergence with `maxM` is slower than desired,
or (ii) the DMRG sweeps get stuck in a local minimum. (i) is governed by the orbital ordering / choice of orbitals.
To improve convergence, turn on the genetic algorithm orbital ordering.

If you suspect (ii) is occurring, the simplest thing to do is to increase the starting number of states with the `startM`
(e.g. from 500 to 1000 states). Local minima can also sometimes be avoided by increasing the noise in the DMRG
schedule, e.g. by a factor of 10. To check that you are stuck in a local minimum, you can carry out a DMRG
extrapolation (see extended Manual in the `BLOCK` website).

Note that the present DMRG-SCF establishes the input order of active space orbitals according to their Hartree-Fock
occupancy, even if these orbitals are ultimately canonical or split-localized canonical in nature. This is specified by
`hf_occ` in which the Hartree-Fock occupancy is derived by default from the one-electron integrals. Other options
for obtaining the occupancy are available (see *Complete set of BLOCK options* ).

Somet times the energy values produced from one SCF cycle to another may oscillate. Such a nonlinear numerical
behaviour may occur typically by the last few iterations, most likely caused by the loss of a certain distribution of
quantum numbers (eg, particle number, irrep symmetry and spin) in the blocking and decimation procedure due
to incomplete many-body basis. On the other hand, the loss of quantum numbers is the main source of energy
discontinuities on potential energy curves calculated by DMRG-SCF using a small number of renormalized states.

In the current release of DMRG-SCF implementation, the number of quantum states is locked to avoid these problems. The locking mechanism is turned on when the orbital gradient falls below a certain threshold defined by the
keyword `switch_rst` (default: 0.001). The DMRG calculation then starts from previous operators and wavefunction in which a perturbative noise is not added. Locking quantum states and restaring DMRG wavefunction not
only ensures a smooth convergence towards the final energy but also minimizes the number of iterations. Note that
the locking procedure introduces an arbitrariness to the final energy, when a very small *𝑀* is used, since the final
digits of energy depend on where the locking begins. It is therefore not recommended to start locking too early in
iterations which could trap the orbital solution in a local mimimum. Finally the quality of resulting orbitals can
be checked by carrying out a DMRG calculation with sufficient renormalized states. Using the default value of
`switch_rst` DMRG-SCF usually results in the orbitals that are good enough to reproduce the CASSCF energy.

**Complete set of** `BLOCK` **options**

(continues on next page)

**7.22. Density Matrix Renormalization Group** **677**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



**7.22.5 Appendix: Porphine** *𝜋* **-active space calculation**

We provide a step-by-step basis on localizing the *𝜋* -orbitals of the porphine molecules and running a CASSCFDMRG calculation on this system. It will be important to obtain an initial set of orbitals, rotate the orbitals which
are going to be localized, localize them, and finally run the CASSCF calculation. We will abbreviate the coordinates
as [ *. . .* ] after showing the coordinates in the first input file, but please note they always need to be included.

1. First obtain RHF orbitals:



(continues on next page)

**678** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

2. We then swap orbitals with *𝜋* -character so they are adjacent to each other in the active space. ( *𝜋* orbitals are
identified by looking at the MO coefficients). When they are adjacent in the active space, they can be easily
localized in the next step.



**7.22. Density Matrix Renormalization Group** **679**

**ORCA Manual** **,** **Release 6.0.1**

3. After rotating the orbitals, we localize the 13 occupied *𝜋* -orbitals. This is performed using the `orca_loc`
code. The input file follows.



4. After localizing the occuppied orbitals, we localize the 11 virtual *𝜋* -orbitals using the `orca_loc` code once
again. The input file follows.



5. After these steps are complete, we run a CASSCF-DMRG calculation. The standard input file is shown
below
### **7.23 Relativistic Options**

The relativistic methods in ORCA are implemented in a fairly straightforward way but do require some caution
from the user. The options are controlled through the `%rel` block which features the following variables:



(continues on next page)

**680** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
   # Choice of the model potential for ALL methods
   # --------------------------------------------------   ModelPot VeN, VC, VXa, VLDA, VPC
       # Flags for terms in the model potential
       # =0 not included =1 included
       # WARNING: default is currently 1,1,1,1 for ZORA and IORA and
       # VeN = nuclear attraction term
       # VC = model Coulomb potential (ZORA/IORA only)
       # VXa = model Xalpha potential (ZORA/IORA only)
       # VLDA= VWN-5 local correlation model pot. (ZORA/IORA only)
       # VPC = external point charges (X2C only)
   Xalpha 0.7 # default value for the X-Alpha potential,
        # only has an effect when VXa is part of the model potential
   # -------------------------------------------------   # This variable determines the type of fitted atomic
   # density that enters the Coulomb potential part of the
   # model potential (has no effect when using DKH):
   # -------------------------------------------------   ModelDens rhoDKH # DKH4 model densities (default)
          rhoZORA # ZORA model densities
          rhoHF # Hartree-Fock model densities
   # -------------------------------------------------   # This flag controls whether only one center terms
   # are retained. If this is true an approximate treat   # ment of relativistic effects is the result, but
   # geometry optimizations CAN BE PERFORMED WITH ALL
   # METHODS AND MODEL POTENTIALS
   # In addition one gets NO gauge noninvariance
   # errors in ZORA or IORA
   # -------------------------------------------------   OneCenter false # default value
   # -------------------------------------------------   # Flag for the diagonal approximation to the unitary
   # decoupling matrix (DLU) in X2C. Mutually exclusive
   # with OneCenter. See section "DLU approximation".
   # -------------------------------------------------   DLU false # default value
   # -------------------------------------------------   # Specify the speed of light used in relativistic
   # calculations
   # -------------------------------------------------   C 137.0359895 # speed of light used (137.0359895 is the default value)
             # synonyms for C are VELIT, VELOCITY
   # -------------------------------------------------   # Picture change for properties
   # --------------------------------------------------   PictureChange 0 # (or false): no picturechange (default)
          1 # (or true): include picturechange
          2 # for DKH: use second-order DKH transformation
           # (see section "Picture-Change Effects")
          2 # for X2C: include the response of the unitary
           # decoupling transformation (see section
           # "Exact Two-Component Theory")
   # --------------------------------------------------   # Order of DKH treatment (this has no effect on ZORA calculations)
   # --------------------------------------------------   order 1 # first-order DKH Hamiltonian
      2 # second-order DKH Hamiltonian
   # --------------------------------------------------   # Kind of Foldy-Wouthuysen transformation for picturechange effects
   # in g tensors (see section "Picture-Change Effects")

```
(continues on next page)

**7.23. Relativistic Options** **681**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**Note:** It is important to recognize that in the one-center approximation ( `OneCenter true` ) ALL methods can be
used for geometry optimization. Several papers in the literature show that this approximation is fairly accurate for
the calculation of structural parameters and vibrational frequencies. Since this approximation is associated with
negligible computational effort relative to the nonrelativistic calculation it is a recommended procedure.

**7.23.1 Approximate Relativistic Hamiltonians**

In the relativistic domain, calculations are based on the one-electron, stationary Dirac equation in atomic units (rest
mass subtracted)

*ℎ* *𝐷* Ψ = (︀( *𝛽* *−* 1) *𝑐* [2] + *𝑐* ***𝛼*** *·* ***𝑝*** + *𝑉* )︀ Ψ = *𝐸* Ψ *.* (7.162)

The spinor Ψ can be decomposed in its so-called large and small components


Ψ = Ψ *𝐿*
(︂Ψ *𝑆*


(7.163)
)︂


These are obviously coupled through the Dirac equation. More precisely, upon solving for Ψ *𝑆*, the following
relation is obtained:


*−* 1
***𝜎*** *·* ***𝑝*** Ψ *𝐿* = *𝑅* Ψ *𝐿* (7.164)
)︂


Ψ *𝑆* = [1]

2 *𝑐*


1 + *[𝐸]* *[−]* *[𝑉]*
(︂ 2 *𝑐* [2]


Through the unitary transformation


*𝑈* = Ω + *−𝑅* [+] Ω
(︂ *𝑅* Ω + Ω *−*


with Ω + = ~~*√*~~ 1+ 1
)︂


1 1

1+ *𝑅* [+] *𝑅* *[,]* [ Ω] *[−]* [=] ~~*√*~~ 1+


1+ *𝑅𝑅* [+] [,]


the Hamiltonian can be brought into block-diagonal form

*𝑈* [+] *ℎ* *𝐷* *𝑈* = *ℎ* ˜ ++ ˜ 0
(︂ 0 *ℎ* *−−*


(7.165)
)︂


The (electronic) large component thus has to satisfy the following relation

*ℎ* ++ Ψ *𝐿* = Ω + (︀ *ℎ* ++ + *ℎ* *±* *𝑅* + *𝑅* [+] ( *ℎ* *∓* + *ℎ* *−−* *𝑅* ))︀ Ω + Ψ *𝐿* = *𝐸* + Ψ *𝐿* *.* (7.166)

The approximate relativistic schemes implemented in ORCA use different methods to substitute the exact relation
(7.166) with approximate ones.

Two approximation schemes are available in ORCA: the regular approximation and the Douglas-Kroll-Hess (DKH)
approach.

**682** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.23.2 The Regular Approximation**

In the regular approximation, (7.166) is approximated by

*𝑐*
*𝑅* = 2 *𝑐* [2] *−* *𝑉* ***[𝜎]*** *[·]* ***[ 𝑝]*** *[.]* (7.167)

At the zeroth-order level (ZORA), Ω *±* = 1, so that the ZORA transformation is simply


1 *−𝑅* [+]
*𝑈* ZORA = *𝑅* 1
(︂

and the corresponding Hamiltonian given by


(7.168)
)︂


˜ 1
*ℎ* [ZORA] ++ = *𝑉* + *𝑐* ***𝜎*** *·* ***𝑝*** 2 *𝑐* [2] *−* *𝑉* *[𝑐]* ***[𝜎]*** *[·]* ***[ 𝑝]*** *[.]* (7.169)

At the infinite-order level (IORA), Ω *±* is taken into account, so that


(7.170)
)︂


*𝑈* IORA = *𝑈* ZORA


Ω + 0
0 Ω *−*
(︂


and


*ℎ* ˜ [IORA] ++ = Ω +


1
(︂ *𝑉* + *𝑐* ***𝜎*** *·* ***𝑝*** 2 *𝑐* [2] *−* *𝑉* *[𝑐]* ***[𝜎]*** *[·]* ***[ 𝑝]*** )︂ Ω + (7.171)


is the corresponding Hamiltonian. Note that despite the name – *infinite-order* regular approximation – this is still

*not* exact.

In ORCA, the spin-free (scalar-relativistic) variant of ZORA and IORA are implemented. These are obtained from
those above through the replacement

1 1
***𝜎*** *·* ***𝑝*** 2 *𝑐* [2] *−* *𝑉* ***[𝜎]*** *[·]* ***[ 𝑝]*** *[→]* ***[𝑝]*** 2 *𝑐* [2] *−* *𝑉* ***[𝑝]*** *[.]* (7.172)

The regular Hamiltonians contain only part of the Darwin term and no mass-velocity term. A problem with relations (7.171) and (7.169) is that due to the non-linear dependence of the resulting regular Hamiltonians on *𝑉*,
a constant change of *𝑉*, which in the Dirac and Schrödinger equations will result in a corresponding change of

energy

*𝐸* *→* *𝐸* + const

does not so in the regular approximation. Several attempts have been made to circumvent this problem. The scaled
ZORA variant is one such procedure. Another one is given through the introduction of model potentials replacing
*𝑉* . Both approaches are available in ORCA.

**The scaled ZORA variant**

This variant goes back to van Lenthe et al. [865]. The central observation is that the Hamiltonian

*ℎ* ZORA
*ℎ* scaledZORA = 1 + ⟨Ψ *𝐿* ⃒⃒⃒ *𝑐* ***𝜎*** *·* ***𝑝*** (2 *𝑐* [2] *−* 1 *𝑉* ) [2] *[ 𝑐]* ***[𝜎]*** *[·]* ***[ 𝑝]*** ⃒⃒⃒ Ψ *𝐿* ⟩ (7.173)

produces constant energy-shifts *𝐸* *→* *𝐸* + const when the potential *𝑉* is changed by a constant – *for hydrogenic*
*ions* . For many-electron systems, the scaled-ZORA Hamiltonian still does not yield simple, constant energy shift
for *𝑉* *→* *𝑉* + const. But it produces the exact Dirac energy for hydrogen-like atoms and performs better than the
first-order regular approximation for atomic ionization energies.

**7.23. Relativistic Options** **683**

**ORCA Manual** **,** **Release 6.0.1**

**The regular approximation with model potential**


The idea of this approach goes back to Van Wüllen [867], who suggested the procedure for DFT. However we also
use it for other methods. The scalar relativistic ZORA self-consistent field equation is in our implementation (in
atomic units):

*𝑐* [2]

[︂ **p** 2 *𝑐* [2] *−* *𝑉* **[p]** [ +] *[ 𝑉]* [eff] ]︂ *𝜓* *𝑖* = *𝜀* *𝑖* *𝜓* *𝑖* (7.174)


2 *𝑐* [2] *−* *𝑉* **[p]** [ +] *[ 𝑉]* [eff]


*𝜓* *𝑖* = *𝜀* *𝑖* *𝜓* *𝑖* (7.174)
]︂


where *𝑐* is the speed of light. It looks like the normal nonrelativistic Kohn–Sham equation with the KS potential
*𝑉* eff :


*𝑉* eff ( **r** ) = *−* ∑︁

*𝐴*


*𝑍* *𝐴* *𝜌* ( **r** *[′]* )
(7.175)
*|* **r** *−* **R** *𝐴* *|* [+] ∫︁ *|* **r** *−* **r** *[′]* *|* *[𝑑]* **[r]** *[′]* [ +] *[ 𝑉]* [xc] [ [] *[𝜌]* [] (] **[r]** [)]


( *𝑍* *𝐴* is the charge of nucleus *𝐴* and *𝑅* *𝐴* is its position; *𝜌* ( *𝑟* ) is the total electron density and *𝑉* *𝑥𝑐* [ *𝜌* ] the exchangecorrelation potential – the functional derivative of the exchange-correlation energy with respect to the density).
The kinetic energy operator *𝑇* = *−* 2 [1] *[∇]* [2] [ of the nonrelativistic treatment is simply replaced by the ZORA kinetic]

energy operator:


*𝑐* [2]
*𝑇* [ZORA] = **p** 2 *𝑐* [2] *−* *𝑉* **[p]** (7.176)


Clearly, in the regions where the potential *𝑉* is small compared to *𝑐* [2], this operator reduces to the nonrelativistic
kinetic energy. *𝑉* could be the actual KS potential. However, this would require to solve the ZORA equations
in a special way which demands recalculation of the kinetic energy in every SCF cycle. This becomes expensive
and is also undesirable since the ZORA method is not gauge invariant and one obtains fairly large errors from
such a procedure unless special precaution is taken. Van Wüllen [867] has therefore argued that it is a reasonable
approximation to replace the potential *𝑉* with a model potential *𝑉* [˜] model which is constructed as follows:


˜
*𝑉* model = *−* ∑︁

*𝐴*


*𝑍* *𝐴* *𝜌* model ( **r** *′* )

*𝑑* **r** *[′]* + *𝑉* xc [LDA] [︀ *𝜌* [model] []︀] ( **r** ) (7.177)

*|* **r** *−* **R** *𝐴* *|* [+] ∫︁ *|* **r** *−* **r** *[′]* *|*


The model density is constructed as a sum over spherically symmetric (neutral) atomic densities:

*𝜌* model ( **r** ) = ∑︁ *𝜌* *[𝐴]* ( **r** ) (7.178)

*𝐴*

Thus, this density neither has the correct number of electrons (for charged species) nor any spin polarization. Yet,
in the regions close to the nucleus, where the relativistic effects matter, it is a reasonable approximation. The
atomic density is expanded in a sum of s-type Gaussian functions like:

*𝜌* *[𝐴]* ( **r** ) = ∑︁ *𝑑* *𝑖* exp (︁ *−𝛼* *𝑖* *|* **r** *−* **R** *𝐴* *|* [2] [)︁] (7.179)

*𝑖*

The fit coefficients were determined in three different ways by near basis set limit scalar relativistic atomic HF
calculations and are stored as a library in the program. The fitting densities are available for elements up to Rn,
as well as the actinoids. Through the variable `ModelDens` ( *vide supra* ) the user can choose between these fits
and study the dependence of the results in this choice (it should be fairly small except, perhaps, with the heavier
elements and the HF densities which are not recommended). The individual components of the model potential
(eq. (7.177)) can be turned on or off through the use of the variable `ModelPot` ( *vide supra* ).

Van Wüllen has also shown that the calculation of analytical gradients with this approximation becomes close to
trivial and therefore scalar relativistic all electron geometry optimizations become easily feasible within the ZORA
approach. However, since *𝑇* [ZORA] is constructed by numerical integration it is very important that the user takes
appropriate precaution in the use of a suitable integration grid and also the use of appropriate basis sets! In the
case of `OneCenter true` the numerical integration is done accurately along the radial coordinate and analytically
along the angular variables such that too large grids are not necessary unless your basis set is highly decontracted
and contains very steep functions.

**684** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.23.3 The Douglas-Kroll-Hess Method**

The Douglas-Kroll-Hess (DKH) method expands the exact relation (7.166) in the external potential V. In ORCA
the first- and second-order DKH methods are implemented. The first-order DKH Hamiltonian is given by

*ℎ* ˜ [(1)] ++ [=] *[ 𝐸]* *[𝑝]* [+] *[ 𝐴]* *[𝑝]* *[𝑉𝐴]* *[𝑝]* [+] *[ 𝐵]* *[𝑝]* *[𝑉]* [(] *[𝑝]* [)] *[𝐵]* *[𝑝]* *[,]* (7.180)

with


(7.181)
2 *𝐸* *𝑝* ( *𝐸* *𝑝* + *𝑐* [2] )


*𝐸* *𝑃* = ~~√~~ *𝑐* [4] + *𝑐* [2] *𝑝* [2] *, 𝐴* *𝑝* =


~~√~~


*𝐸* *𝑝* + *𝑐* [2]


*𝑝* *𝑐* = *𝑐*

2 *𝐸* *𝑝* *, 𝐵* *𝑝* √︀2 *𝐸* *𝑝* (


At second order, it reads

where


*ℎ* ˜ [(2)] ++ [= ˜] *[ℎ]* [(1)] ++ [+ 1] 2 [[] *[𝑊]* *[𝑝]* *[, 𝑂]* []] (7.182)


*𝑐𝜎* *𝑝*
*{𝑊* *𝑝* *, 𝐸* *𝑝* *}* = *𝛽𝑂, 𝑂* = *𝐴* *𝑝* [ *𝑅* *𝑝* *, 𝑉* ] *𝐴* *𝑝* *, 𝑅* *𝑝* = (7.183)
*𝐸* *𝑝* + *𝑐* [2]

define the second-order contribution. In ORCA, the spin-free part of *ℎ* [˜] [(2)] ++ [is implemented.]

The occurrence of the relativistic kinetic energy, *𝐸* *𝑃*, which is not well-defined in position space, makes a transformation to the *𝑝* [2] -eigenspace necessary. Thus any DKH calculation will start with a decontraction of the basis
set, to ensure a good resolution of the identity. Then the non-relativistic kinetic energy is diagonalized and the
*𝐸* *𝑃* -dependent operators calculated in that space. The potential *𝑉* and *𝑉* [(] *[𝑝]* [)] are transformed to *𝑝* [2] -eigenspace.
After all contributions are multiplied to yield the (first- or second-order) Hamiltonian, the transformation back to
AO space is carried out and the basis is recontracted.

The (spin-free) DKH-Hamiltonians contain all spin-free, relativistic correction terms, e.g. the mass-velocity and
Darwin terms. As the potential enters linearly, no scaling or model potential is necessary to introduce the correct
behaviour of the energy under a change

*𝑉* *→* *𝑉* + const *.*

In all these respects the DKH Hamiltonians are much cleaner than the regular Hamiltonians.

**7.23.4 Picture-Change Effects**

Irrespective of which Hamiltonian has been used in the determination of the wave function, the calculation of
properties requires some special care. This can be understood in two ways: First of all, we changed from the
ordinary Schrödinger Hamiltonian to a more complicated Hamiltonian. As properties are defined as derivatives of
the energy, it is clear that a new Hamiltonian will yield a new expression for the energy and thus a new and different
expression for the property in question. Another way of seeing this is that through the transformation *𝑈*, we changed
not only the Hamiltonian but also the wave function. To obtain the property at hand as the expectation value of
the property operator with the wave function, we have to make sure that property operator and wave function are
actually given in the same space. This is done through a transformation of either the property operator or the wave
function.

In any case, the difference between the non-relativistic and (quasi) relativistic property operator evaluated between
the (quasi) relativistic wave function is called the picture-change effect. From what was said above, this is clearly
not a physical effect. It describes how consistent the quasi relativistic calculation is carried out. A fully consistent
calculation requires the determination of the wave function on the (quasi) relativistic level as well as the use of the
(quasi) relativistic property operator. This is obtained through the choice
```
%rel PictureChange 1 end # or 2 - see below

```
**7.23. Relativistic Options** **685**

**ORCA Manual** **,** **Release 6.0.1**

in the `%rel` block. It may be that the (quasi) relativistic and non-relativistic property operator do produce similar
results. In this case, a calculation with picture-change turned off ( `PictureChange=0` ) may be a good approximation. This is, however, not the rule and cannot be predicted before carrying out the calculation. It is therefore
highly recommended to turn on picture-change in all (quasi) relativistic property calculations!

For DKH2, the fully consistent picture-change effects are obtained using the same transformation order for the
property operator as for the one-electron Hamiltonian, i.e. setting
```
%rel PictureChange 2 end

```
while with `PictureChange=1` only first-order changes on the property operators are taken into account, which
reduces the computational cost. However, since this is in no way a significant reduction, this choice is not recommended. A similar argument applies to X2C (see *X2C derivatives and properties* ).

For magnetic properties, the DKH transformation and consequently the DKH Hamiltonian and the corresponding property operators are not unique. Depending on whether the magnetic field is included in the free-particle
Foldy–Wouthuysen (fpFW) transformation carried out in the first step of the DKH protocol or not, two different
Hamiltonians result. If the magnetic field is included in the fpFW transformation, the resulting Hamiltonian is a
function of the gauge invariant momentum

***𝜋*** = **p** + **A** *.*

It is therefore gauge invariant under gauge transformations of the magnetic vector potential **A** and thus are the
property operators derived from it. This is referred to as f *𝜋* FW DKH Hamiltonian. If the magnetic field is not
included in the FW transformation, the resulting Hamiltonian is a function of the kinetic momentum **p** only and
thus is not gauge invariant. The latter Hamiltonian is referred to as fpFW DKH Hamiltonian. A comparison of
both Hamiltonians is given in Table Table 7.20.

Table 7.20: Comparison of the properties of the fpFW and fπFW DKH Hamiltonians. For details see Ref. [746].

From this Table, it becomes clear that the f *𝜋* FW DKH Hamiltonian is clearly preferred over the fpFW Hamiltonian.
To obtain the property operators, it is however necessary to take the derivatives of these Hamiltonians. It turns out
that in the case of the hyperfine-coupling tensor, the necessary derivatives produce divergent property operators in
the case of the f *𝜋* FW DKH Hamiltonian. This may be due to the unphysical assumption of a point-dipole as a source
of the magnetic field of the nucleus. As a physical description of the magnetization distribution of the nucleus is not
available due to a lack of experimental data, the magnetization distribution is assumed to be the same as the charge
distribution of the nucleus, see Section *Finite Nucleus Model* . This is unphysical as the magnetization is caused by
the one unpaired nucleon in the nucleus whereas the charge distribution is generated by the protons in the nucleus.
So, physically, the magnetization should occupy a larger volume in space than the charge. This might also be the
reason why the resulting finite-nucleus model is insufficient to remedy the divergences in the f *𝜋* FW hyperfinecoupling tensor. Consequently, the hyperfine-coupling tensor is only implemented in the version resulting from
the fpFW DKH Hamiltonian. In the case of the g-tensor both versions are implemented and accessible via the
keyword
```
%rel fpFWtrafo true/false end

```
By default, this keyword is set to `true` . A detailed form of the property operators used for the g-tensor and
hyperfine-tensors can be found in Ref. [746].

**686** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.23.5 Finite Nucleus Model**

Composite particles like nuclei have, as opposed to elementary particles, a certain spatial extent. While the pointcharge approximation for nuclei is in general very good in nonrelativistic calculations, in relativistic calculations it
might lead to non-negligible errors. A finite-nucleus model is available for all calculations in the ORCA program
package. It is accessible from the `%rel` block via
```
%rel FiniteNuc true/false end

```
By default, this keyword is set to `false` . If the keyword is set to `true`, finite-nucleus effects are considered in the
following integrals:

  - nucleus potential V

  - DKH-integral *𝑉* [(] *[𝑝]* [)]

  - one-electron spin-orbit integrals SOC (also in one-electron part of SOMF)

  - electric-field gradient EFG (and thus, as a consequence in the Fermi-contact and spin-dipole terms of the
HFC tensor)

  - nucleus-orbit integral NUC

  - angular-momentum integral l

The finite-nucleus model implemented in ORCA is the Gaussian nucleus model of Ref. [872].

**7.23.6 Exact Two-Component Theory (X2C)**

The X2C implementation in ORCA closely follows that of Franzke, Weigend, and their coworkers, described in the
references: [659] (energy), [274] (gradient), [276] (EPR hyperfine coupling), [273] (NMR spin–spin coupling),

[272] (NMR shielding). These are also consistent with the work of Gauss and coworkers in refs: [165] (gradient,
electric properties), [166] (Hessian), [167] (NMR shielding). However, despite the name, only a scalar relativistic
(spin-free) version is available at present, resulting effectively in a one-component method (more aptly called “SFX2C-1e”), very similar to the DKH and ZORA approaches described above. The main difference to the latter
two is that the decoupling of the one-electron Dirac Hamiltonian is exact, rather than approximate. SF-X2C-1e
is implemented in ORCA for energies, gradients, and various properties (see below) with both a point- and finite
nucleus model.

We briefly describe the working equations here, using the notation of the aforementioned references, which differs
somewhat from that in the previous sections. The one-electron Dirac equation is solved directly:


DC = MCE *,* C = (︂ **CC** [S] +L+ **CC** [S] *−* [L] *−*

to obtain the unitary transformation matrix:


(7.184)
)︂


**R** **0**

**0** **R** *[′]*
)︂(︂ )︂


**U** ++ **U** + *−*
U =
(︂ **U** *−* + **U** *−−*

*−* 1
**X** = **C** [S] **C** [L]
+ (︀ + )︀


**1** *−* **X** *[†]*
= **X** **1**
)︂ (︂



[1]

2 ( **S** *[−]* 2 [1]


*−* [1]

[1] 2

2
)︁


**R** = **S** *[−]* [1] 2



[1]

2 ˜ **SS** *[−]* 2 [1]


2 1
**S** 2


˜
**S** = **S** + [1]

2 *𝑐* [2] **[ X]** *[†]* **[TX]**


which exactly block-diagonalizes the Hamiltonian:

**h** + **0**
U *[†]* DU =
**0** **h** *[−]*
(︂


(7.185)
)︂


**h** [+] = **R** *[†]* **LR** (7.186)

**7.23. Relativistic Options** **687**

**ORCA Manual** **,** **Release 6.0.1**

1
**L** = **V** + **TX** + **X** *[†]* **T** + **X** *[†]* **X** (7.187)
(︂ 4 *𝑐* [2] **[ W]** *[ −]* **[T]** )︂

where **V**, **T**, **S**, and **W** are the potential, kinetic, overlap, and relativistic potential ( *𝑝* ˆ *𝑉* [ˆ] *𝑝* ˆ) integral matrices. **h** [+] is
thus the matrix form of the relativistically-corrected one-electron Hamiltonian used for the rest of the calculation.

Note that the potential operator *𝑉* [ˆ] used in the above equations only includes the electron–nuclear Coulomb interaction. External point charges may optionally be included via `%rel ModelPot[4]=1` (default 0). This option
affects energy and NMR shielding calculations but it is presently not available for gradients or Hessians.

**DLU approximation**

The diagonal local approximation to the unitary transformation matrix (DLU), as introduced by Peng and Reiher,[660] reduces the computational cost of the X2C transformation by approximating U (i.e., **R** and **X** ) as an
atomic-block-diagonal matrix.


**R** *≈*
⨁︁


**R** *𝐴* **X** *≈* ⨁︁
*𝐴* *𝐴*


**X** *𝐴*

*𝐴*


where [⨁︀] *𝐴* [denotes a direct sum of atomic diagonal blocks. Eqs (][7.184][)–(][7.187][) can then be solved independently]

for diagonal atomic blocks **h** [+] *𝐴𝐴* [. Off-diagonal blocks] **[ h]** [+] *𝐴𝐵* [are obtained as:]


**h** [+] *𝐴𝐵* [=] **[ R]** *[†]* *𝐴* **[L]** *[𝐴𝐵]* **[R]** *[𝐵]*

**L** *𝐴𝐵* = **V** *𝐴𝐵* + **T** *𝐴𝐵* **X** *𝐵* + **X** *[†]* *𝐴* **[T]** *[𝐴𝐵]* [+] **[ X]** *[†]* *𝐴*


1
(︂ 4 *𝑐* [2] **[ W]** *[𝐴𝐵]* *[−]* **[T]** *[𝐴𝐵]*


**X** *𝐵*
)︂


It is also possible to approximate light atoms *𝑎, 𝑏* (below a certain atomic number) as non-relativistic:

**X** *𝑎* = **R** *𝑎* = **I**

**W** *𝑎𝑏* = **W** *𝑎𝐵* = **0**

**h** [+]
*𝑎𝑏* [=] **[ V]** *[𝑎𝑏]* [+] **[ T]** *[𝑎𝑏]*
**h** [+] *𝑎𝐵* [= (] **[V]** *[𝑎𝐵]* [+] **[ T]** *[𝑎𝐵]* **[X]** *[𝐵]* [)] **[ R]** *[𝐵]*

Unlike the one center approximation (which is also available for X2C), all nuclei are included in the potential
operator *𝑉* [ˆ] . Use of the DLU approximation is controlled via:



**X2C derivatives and properties**

As discussed in section *Picture-Change Effects*, when computing properties with relativistic methods, derivatives
need to be taken of the correct Hamiltonian, namely **h** [+] (eq (7.186)) in the X2C case. These include contributions
due to the derivatives of **R** and **X**, which are often small. Therefore, it is possible to neglect them and save some
computational time via the following option:



The same setting is applied to all properties for which the X2C correction is implemented. Currently, these are:
geometric gradients, electric dipoles, quadrupoles, and polarizabilities, electric field gradients, EPR hyperfine couplings, and NMR shieldings and spin–spin couplings. For the Hessian, the X2C correction is implemented in a

**688** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

semi-numeric fashion. The DLU approximation is applied throughout, if requested, and reduces the computational effort dramatically. Note that for magnetic properties, the restricted magnetic balance (RMB) for the small
component basis functions is used whenever GIAOs are requested (e.g. NMR shielding), while the restricted kinetic balance (RKB) is used otherwise (e.g. NMR coupling). The spin–orbit coupling integrals used for various
properties only include a relativistic correction to the one-electron term, as is the case for DKH.

For second derivative properties whose number is proportional to the number of atoms, e.g. the DSO term of NMR
couplings, first derivatives of various intermediate quantities required for the full X2C second derivative are stored
on disk. The storage requirements can be reduced via the `StorageLevel` keyword and the missing intermediates
will be recomputed on-the-fly, which of course increases the computation time.



**7.23.7 Basis Sets in Relativistic Calculations**

For relativistic calculations, special basis sets have been designed, both as DKH and ZORA recontractions of
the non-relativistic Ahlrichs basis sets (in their all-electron versions) for elements up to Kr, and as purpose-built
segmented all-electron relativistically contracted (SARC) basis sets for elements beyond Kr [62, 641, 642, 643, 644,
729]. Their names are “ZORA-” or “DKH-” followed by the conventional basis set name. For X2C calculations, the
“x2c-XVPall” basis sets and their variants are available.[275, 690] See section *Choice of Basis Set* for a complete
list of basis sets.
### **7.24 Approximate Full CI Calculations in Subspace: ICE-CI**

**7.24.1 Introduction**

In many circumstances, one would like to generate a wavefunction that is as close as possible to the full-CI result,
but Full CI itself is out of the question for computational reasons. Situations in which that may be desirable include
a) one wants to generate highly accurate energies for small molecules or b) one wants to sort out a number of lowlying states or c) one wants to run CASSCF calculations with larger active spaces than the about fourteen orbitals
that have been the state of the art for a long time.

ORCA features a method that has been termed Iterative-Configuration Expansion Configuration Interaction (ICECI).[171, 172] It is based on much older ideas brought forward by Jean-Paul Malrieu and his co-workers in the
framework of the CIPSI (an abbreviation for a method with a rather bulky name *Configuration Interaction by Per-*
*turbation with multiconfigurational zeroth-order wave functions Selected by Iterative process* ) in the early 1970s.

The goal of the ICE-CI is to provide compact wavefunction(s) (e.g. one or several states) close to the full-CI limit
at a small fraction of the computational cost. However, ICE-CI itself is not designed to deal with hundreds of atoms
or thousands of basis functions. Thus, unlike, say DLPNO-CCSD(T) which is a high accuracy method for treating
large sytems, ICE-CI is either a highly robust high accuracy method for very small systems or a “building block”
for large systems. By itself it can treat a few dozen electrons and orbitals – e.g. *much* more than full CI – but it
cannot do wonders. Its scope is similar to the density matrix renormalization group (DMRG) or Quantum Monte
Carlo Full CI (QMCFCI) procedures.

ICE-CI should be viewed as a multireference approach. It is self-adaptive and robust, even in the presence of near
or perfect degeneracies. It yields orthogonal states (when applied to several states) and spin eigenfunctions. It also
yields a density and a spin density.

**7.24. Approximate Full CI Calculations in Subspace: ICE-CI** **689**

**ORCA Manual** **,** **Release 6.0.1**

**7.24.2 The ICE-CI and CIPSI Algorithms**

The general idea of ICE-CI is straightforward: Consider a many-particle state that has at least a sizeable contribution
from a given configuration **n** [0] (this is a set of occupation numbers for the active orbitals that are *𝑛* [0] *𝑝* [= 0] *[,]* [ 1] *[ 𝑜𝑟]* [2]

=
( *𝑝* any active orbital). By nature of the non-relativisitic Hamiltonian only configurations that differ by at
most two orbital occupations from **n** [0] will interact with it. We can use perturbation theory to select the subset
of singles and doubles that interact most strongly with **n** [0] and then solve the variational problem. We can then
analyze the CI vector for configurations that make a dominant contribution to the ground state. Say, we single out
the configurations with *𝐶* *𝐼* [2] *[> 𝑇]* [gen] [. This defines the “generator” set of configurations. The other configurations]
are called “variational” configurations. They are treated to infinite order by the variational principle, but are not
important enough to bring in their single and double excitations. In the next iteration, we perform singles and
doubles relative to these general configurations and select according to their interaction with the dominant part
of the previous CI vector (truncated to the generators). This procedure can be repeated until no new important
configurations are found and the total energy converges (See Fig. 7.8).



**ORCA Manual** **,** **Release 6.0.1**

be realized by organizing the calculation around the concept of a configuration. In general, in CFG-ICE all CSFs
that belong to a given configuration are included and all selection quantities are summed over all CSFs of a given
configuration before it is decided whether this CSFs is included or not. In the configuration state functions based
ICE (CSF-ICE) the logic of generation and selection occurs at the level of individual CSFs and therefore we get
rid of the requirement to carry around all the CSFs for a given configuration. This provides substantial gains in
the case of molecules containing a large number of transition metal atoms, where each atom contains a high-spin
center. In such cases only a few CSFs of a the dominant CFG play a dominant role and other show negligible
contribution to the wavefunction. Finally, in some cases the original determinant based CIPSI procedure could be
preferred. Such cases can be handled by the determinant based ICE termed DET-ICE. The three variants of ICE
therefore cover all the possible types of multi-reference systems that one encounters in quantum chemistry.

It should be noted that although the procedure contains a perturbative element, the final energy is strongly dominated by the variational energy and hence, for all intents and purposes, the ICE-CI procedure is variational (but
not rigorously size consistent – size consistency errors are on the same order of magnitude as the error in absolute
energy).

**7.24.3 A Simple Example Calculation**

Let us look at a simple calculation on the water molecule:



Let us look at the output:




(continues on next page)

**7.24. Approximate Full CI Calculations in Subspace: ICE-CI** **691**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



From the output the individual steps in the calculation are readily appreciated. The program keeps cycling between
variational solution of the CI problem, generation of new configurations and perturbative selection until convergence of the energy is achieved. Normally, this occurs rapidly and rarely requires more than five iterations. The
result will be close to the Full CI result.

Let us look at a H 2 O/cc-pVDZ calculation in a bit more detail (See Fig. 7.9). The calculation starts out with a
single Hartree-Fock configuration. The first iteration of ICE-CI creates the singles and doubles and altogether 544
configurations are selected. These singles and doubles bring in about half of the correlation energy. Already the
second iteration, which leads to 73000 selected CSFs provides a result close to the full CI. At this point up to
quadruple excitations from the Hartree-Fock reference have been included. It is well known that such quadruple
excitations are important for the correct behavior of the CI procedure (near size consistency will come from the
part of the quadruple excitations that are products of doubles). However, only a very small fraction of quadruples
will be necessary for achieving the desired accuracy. In the first iteration the procedure is already converged and
provides 99.8% of the correlation energy, using 0.5% of the CSFs in the full CI space and at less than 0.2% the
calculation time required for solving the full CI problem. Hence, it is clear that near exact results can be obtained
while realizing spectacular savings.

**692** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.9: An ICE-CI calculation on the water molecule in the cc-pVDZ basis (1s frozen)

**7.24.4 Accuracy**

The accuracy of the procedure is controlled by two parameters T gen and T var Since we have found that T var =
10 *[−]* [7] T gen always provides converged results, this choice is the default. However, T var can be set manually. It can
be reduced considerably in order to speed up the calculations at the expense of some accuracy. Our default values
are T gen = 10 *[−]* [4] and T var = 10 *[−]* [11] . This provides results within about 1 mEh of the full CI results (roughly
speaking, a bit better than CCSDT for genuine closed-shell systems).

During the development of ICE-CI systematic test calculations have been performed using a reference set of 21
full CI energies on small molecules. The convergence pattern of the mean absolute error is shown in Fig. 7.10.
It is evident from the figure that the convergence of ICE-CI towards the FCI result is very smooth and that high
accuracy can be obtained. In fact, the default settings lead to an accuracy of <1 mEh deviation to the full-CI result.
*𝜇* Eh accuracy can be achieved by further tightening. The achieved accuracy relative to accurate coupled-cluster
results shows that the accuracy of even CCSDTQ can be surpassed by ICE-CI. The achievable accuracy is only
limited by the value of T gen and much less so by the value of T var . Hence, it is advisable to use a value for T var
that is essentially converged and control the accuracy of the procedure by T gen .

**7.24. Approximate Full CI Calculations in Subspace: ICE-CI** **693**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.10: Convergence of the ICE-CI procedure towards the full CI results for a test set of 21 full CI energy. Shown
is the RMS error relative to the Full CI results. The corresponding errors for various coupled-cluster variants is
shown by broken horizontal lines.

**7.24.5 Scaling behavior**

ICE-CI will break the factorial scaling of the full CI problem and scale polynomially. The actual order of the
polynomial scaling is system dependent and accuracy dependent. In order to provide some impression, consider
some calculations on linear polyene chains.

Fig. 7.11: Polyene chains used for scaling calculations.

The results are displayed in the Fig. 7.12. It is evident from Fig. 7.12 that ICE-CI breaks the factorial scaling of the
full CI problem. In fact, for a thresholds of T gen =10 *[−]* [4], 10 *[−]* [3] and 10 *[−]* [2] the observed scalings are approximately
*𝑂* (N [8] ), *𝑂* (N [7] ) and *𝑂* (N [6] ) respectively. These numbers will obviously be very system dependent but should serve
as a rough guide. The calculations become quickly much more expensive if T gen is tightened. A rule of thumb
is that each order of magnitude tightening of T gen increases the computation time by a factor of 10. The above
calculations have been performed on a simple desktop computer and it was already possible to solve a CAS(30,30)
problem in less than one day of elapsed time using the default thresholds. Large active spaces will require either
loosening of the tresholds or large, more powerful machines.

**694** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.12: Scaling behavior of ICE-CI for linear polyene chains (Full *𝜋* -electron active space) as a functions of
system size for different generator thresholds.

**7.24.6 Accuracy of the Wavefunction**


The accuracy of the many particle wavefunction is not straightforward to check. A reasonable measure, however,
is how well it converges towards the exact result for one-electron expectation values. Since every expectation value
can be written in terms of natural orbitals of the one-particle density as:

ˆ ˆ ˜ ˆ
⟨ *𝑂* ⟩ = ⟨Ψ ⃒⃒⃒∑︁ *𝑜* *[𝑜]* [ˆ][(] **[x]** *[𝑖]* [)] ⃒⃒⃒ Ψ⟩ = ∑︁ *𝐷* *𝑝𝑞* *⟨𝜓* *𝑝* *|𝑜|𝜓* *𝑞* *⟩* = ∑︁ *𝑛* *𝑝* ⟨ *𝜓* *𝑝* *|𝑜|𝜓* ˜ *𝑝* ⟩


Ψ =
*𝑜* *[𝑜]* [ˆ][(] **[x]** *[𝑖]* [)] ⃒⃒⃒ ⟩ ∑︁


*𝑛* *𝑝* *𝜓* ˜ *𝑝* *|𝑜* ˆ *|𝜓* ˜ *𝑝*
⟨ ⟩
*𝑝*


ˆ
*𝐷* *𝑝𝑞* *⟨𝜓* *𝑝* *|𝑜|𝜓* *𝑞* *⟩* = ∑︁

*𝑝𝑞* *𝑝*


where ˆ *𝑜* ( **x** *𝑖* ) is an arbitrary one-particle operator, *𝐷* *𝑝𝑞* is the density matrix of the ICE-CI wavefunction, *𝜓* [˜] *𝑝* are
the natural orbitals of the ICE-CI wavefunction and *𝑛* *𝑝* are their occupations numbers. It is reasonable to take the
deviation of the natural orbital occupation numbers as a measure for wavefunction convergence.

For example, we treat the H 2 O/cc-pVDZ problem again. From the results in Fig. 7.13 it becomes evident that
the ICE-CI wavefunction is fairly accurate. At the default threshold the occupation numbers agree to within 10 *[−]* [3]

with the full CI reference numbers, which means that expectation values will be of similar accuracy. Interestingly,
the largest errors occur in the region of the HOMO-LUMO gap, where apparently all approximate wavefunction
approaches tend to depopulate the high lying orbitals too much and put too much electron density in the low lying
empty orbitals. From comparison, it is seen, that the CCSD natural occupation numbers for this problem are
significantly less accurate. Hence, this is evidence that the ICE-CI wavefunction is properly converging to the right
result.

**7.24. Approximate Full CI Calculations in Subspace: ICE-CI** **695**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.13: Convergence of the ICE-CI natural orbital occupation numbers. The upper panel is showing the Full CI
occupation numbers, the lower panel the deviation of the ICE-CI values from these exact values. For comparison,
the CCSD natural orbital occupation numbers are also provided.

**7.24.7 Potential Energy Surfaces**

You can use ICE-CI to scan entire potential energy surfaces. In general, the non-parallelity error along a potential
energy surface is very small. Thus, ICE-CI yields consistent quality throughout the surface.

For example, let us look at the potential energy surface of the N 2 molecule (Fig. 7.14) – a common test case
for quantum chemical methods. There are not too many methods that would disscociate the triple bond of N 2
correctly – ICE-CI is one of them. The potential energy surface is entirely smooth and also correctly behaves in
the dissociation limit. Near the minimum it is very close to high-level coupled-cluster methods that, however, all
fail badly as the bond is stretched.

**696** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.14: Potential energy surface of the N 2 molecule in the SV basis. For comparison higher level coupled-cluster
results are also shown.

It is interesting to observe the variations of the ICE-CI wavefunction along the dissociation potential energy surface.
As an example, we look at the dissociation curve of H 2 O where both O-H bonds are simultaneously stretched (Fig.
7.15). It is seen that the ICE-CI method is extremely parallel to the full CI curve at all distances. Hence, the
description of the bond remains consistent, even when Hartree-Fock becomes a bad approximation. The agreement
is particularly good if MP2 natural orbitals are used in the ICE-CI procedure. With the default value of T gen =
10 *[−]* [4] and MP2 natural orbitals the error is consistently below 0.2 mEh. For tighter thresholds, the error is below
0.05 mEh. By contrast, the CCSD(T) method shows relatively large deviations from the full CI results and also
behaves very non-parallel as a function of O-H distance.

**7.24. Approximate Full CI Calculations in Subspace: ICE-CI** **697**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.15: Non-parallelity error of ICE-CI for the H 2 O molecule in the SV basis. Shown is the deviation from the
full CI value as a function of O-H distance (both bonds stretched). For comparison, the CCSD(T) curve is also
shown

It is instructive to analyze the ICE-CI wavefunction along the dissociation pathway (Fig. 7.16). It becomes apparent
that the wavefunctions stays compact along the entire surface, even in the dissociation limit, where the weight of
the Hartree-Fock wavefunction drops to less than 25%. Even in this drastic limit, the ICE-CI wavefunction consists
of only about 60000 CSFs, which is very similar to the size of the wavefunction at equilibrium geometry. As the
wavefunction becomes more multiconfigurational, the number of generator configurations goes slightly up from
the equilibrium value of 77 to a maximum of 118 and finally 112 at dissociation. It is also interesting to note that
along the entire dissociation pathway no configuration with more than 8 open shells is generated, which means that
no more than quadruple excitations are contained in the ICE-CI wavefucntion. The number of iterations required in
the ICE-CI procedure also stays constant along the surface at 4 iterations, which impressively shows that a dominant
configuration is not necessary for a successful ICE-CI calculation.

**698** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.16: Analysis of the ICE-CI wavefunction along the O-H dissociation pathway.

**7.24.8 Excited States**

ICE-CI can be used to obtain some insight into excited states starting from no knowledge at all. Of course, the best
was to start an excited state calculation is to have some idea which configurations are important for the low-lying
states of the system. If this is not the case, an automated procedure is used. The program will first generate an
“Aufbau” configuration using the orbitals that are provided on input. Starting from this Aufbau configuration, single
excitations at the configuration level are performed an the Hamiltonian is diagonalized for the required number of
roots. These roots are then analyzed for the leading configurations and the regular ICE-CI procedure is started
from those configurations. For example, look at a calculation on the CN radical. In this case, we know the relevant
orbitals and leading configurations for the lowest four roots (a doublet Σ ground state, a doublet Π excited state
and a doublet Σ excited state) and hence can provide them in the input file as shown below.



(continues on next page)

**7.24. Approximate Full CI Calculations in Subspace: ICE-CI** **699**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



The result is shown below. The excitation energies are reasonable but not highly accurate due to the limitations of
the basis set (experimentally the doublet Π state is at 1.32 eV and the doublet Σ state at 3.22 eV). There is a very
slight symmetry breaking In the doublet Π state that arises from the selection procedure. It should be noted that
the state averaged CASSCF excitation energies are 0.25 eV and 3.18 eV.



Below, it is described how to do ICE-CI calculations on excited states if the dominant configurations are not known.

**7.24.9 Tips and Tricks**

ICE-CI can be used very fruitfully together with, say, MP2 natural orbitals. This usually results in results that are
closer to full CI results and at the same lead to more compact wavefunctions (it may be called nICE). The use of
MP2 natural orbitals is requested by choosing `UseMP2nat true` inside the %ice block. Alternatively, improved
virtual orbitals can be used (requested by `UseIVOs true` ). A comparison is shown in Scheme *Comparison of*
*MP2 natural orbitals and improved virtual orbitals for the ICE-CI procedure (H2O molecule, cc-pVDZ basis,*
*equilibrium geometry)* . It is evident that the calculations based on the MP2 natural orbitals show an error relative
to full CI that is almost a factor of two smaller than the corresponding result with canonical orbitals while at the same
time the wavefunction is more compact by more than 30%. Hence, the use of MP2 natural orbitals appears to be a
very good idea in conjunction with the ICE-CI procedure. This also holds when MP2 itself is a bad approximation
(for example in the dissociation limit of the H2O molecule as shown above). On the other hand, the IVOs behave
very similar to canonical orbitals and hence, seem to offer fewer advantages.

**700** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.17: Comparison of MP2 natural orbitals and improved virtual orbitals for the ICE-CI procedure (H2O
molecule, cc-pVDZ basis, equilibrium geometry)

If ICE-CI is used in conjunction with MP2 natural orbitals, there also is the possibility of letting the program
automatically choose the active space (this is called auto-ICE). The general idea is simple – we base the active
space on the MP2 natural orbitals and their occupation numbers. All orbitals between occupation number say 1.98
down to 0.02 will be included in the active space. A relevant input is shown below.



If we scan along the H 2 O dissociation surface one can see that despite changing active spaces, the dissociation
curves are smooth and remain fairly parallel to the full CI dissociation curve. Depending on the tightness of the
thresholds the active space may change from a small 6 electrons in 5 orbitals to a larger 8 electrons in 7 or 8 orbitals
upon dissociation. This is the expected behavior as the *𝜎* -antibonding orbital becomes more stable along the bond
stretching coordinate. Hence, these results are encouraging in as far as in many situations the program will be able
to select a sensible active space without extended input from the user.

**7.24. Approximate Full CI Calculations in Subspace: ICE-CI** **701**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.18: Automatic active space selection along the H 2 O dissociation surface. The reference curve (blue triangles)
is the ICE-CI method for the full orbital space with the default parameters.

Another place, where automatic selection comes in conveniently is in the calculation of excited states. If there are
no user supplied configurations, what happens is that the program will first choose an Aufbau “reference” configuration and then perform all single excitations relative to this configuration. The program will then diagonalize the
Hamiltonian over the this set of configurations to create 0 [th] order approximations for the chosen number of roots
of interest and then initiate the ICE-CI procedure starting from the leading configurations of these states. Here is
an example for the benzene molecule:

(continues on next page)

**702** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

(The %cclib statement is explained below and is not mandatory here). The Auto-ICE procedure comes up with
as many as 24 electrons in 19 orbitals, which already is a fairly heavy calculation. The procedure converges in
five iterations and provides indeed the correct states: the gorund state, the [1] B 2u state at 6.4 eV, the [1] B 1u state at
8.9 eV and a degenerate [1] E 1u state at 10.0 eV. These excitation energies are still in error by about 2 eV relative to
experiment, which is mainly due to missing dynamic correlation. However, the correct states and their sequence
has been found.

The ICE-CI can be used to find the ground state if the actual ground state is not known. To this end, one simply
has to turn off the selection steps. This makes the calculations more expensive, but they will converge to the lowest
state. In the example below (again, the H 2 O molecule) we start from a random quintuply excited configuration –
the ICE-CI still finds the ground state after four iterations:

However, if one wants to converge to an excited state, one should turn on the selection. In the example below (once
more the water molecule) one can converge to the second excitated singlet state by judicious choice of the start
configuration:



(continues on next page)

**7.24. Approximate Full CI Calculations in Subspace: ICE-CI** **703**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**7.24.10 Large-scale approximate CASSCF: ICE-SCF**

ICE-CI can be used as a replacement for the CI step in a CASSCF framework. In this way, much larger CASSCF
calculations than previously possible can be envisioned. In using the ICE-CI in this way, the active orbitals should
be chosen as natural orbitals in order to ensure a proper canonicalization. In general, ICE-CI results will not be
invariant with respect to the choice of orbitals. However, in practice we have not found this to be problematic. We
refer to this as ICE-SCF.

The use is simple: in the %casscf block choose:

The entire remaining input is the one for standard CASSCF calculations. In this way one can do CASSCF calculations with very large active space in reasonable turnaround times. We have not observed convergence problems
that are worse than in the standard CASSCF procedure. The results in Fig. 7.19 show that the deviations from regular CASSCF energies are very small. The largest deviation observed for C 2 H 4 is on the order of 0.2 mEh, which
appears acceptable. Note that the CASSCF tutorial also covers larger examples and excitations energies computed
with the ICE-CI as CI solver. As mentioned in the CASSCF section *The Complete Active Space Self-Consistent*
*Field (CASSCF) Module*, some feature are not supported for ICE-CI e.g. magnetic properties as well NEVPT2
corrections are not yet available.

**704** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.19: Deviations of ICE-SCF from CASSCF energies for a selection of molecules (standard truncation parameters *𝑇* gen = 10 *[−]* [4] and *𝑇* var = 10 *[−]* [11] )

Since CASSCF is fully variational, it is possible to optimize geometries with that procedure. It is our experience so
far, that the ICE-SCF geometries are virtually indistinguishable from CASSCF geometries (an example is shown
in Fig. 7.20).

Fig. 7.20: CASSCF and ICE-SCF optimized geometries for methylene and ozone (cc-pVDZ basis set, default
parameters).

**7.24. Approximate Full CI Calculations in Subspace: ICE-CI** **705**

**ORCA Manual** **,** **Release 6.0.1**

**7.24.11 The entire input block explained**

For completeness, the parameters that can be specified in the input block are summarized below:



**7.24.12 A Technical Note:** `orcacclib`

We should finally mention a technical aspect. The CI procedure in ICE-CI is based around the so-called one particle
coupling coefficients

*𝐴* *[𝐼𝐽]* *𝑝𝑞* [=] ⟨︀ *𝐼|𝐸* *𝑝* *[𝑞]* *[|][𝐽]* ⟩︀

where *𝐴* *[𝐼𝐽]*
*𝑝𝑞* [is a coupling coefficient,] *[ 𝐼]* [and] *[ 𝐽]* [are configuration state functions (CSFs) and] *[ 𝐸]* *𝑝* *[𝑞]* [is the spin-free]
excitation operator that promotes an electron from orbital *𝑝* to orbital *𝑞* . The values of these coupling coefficients
only depend on the logical relationship between the CSFs *𝐼* and *𝐽* but not on the absolute values of *𝐼*, *𝐽*, *𝑝*, *𝑞* . In
fact, they only depend on the number of unpaired electrons in *𝐼* and the total spin *𝑆* that both CSFs refer to. Hence,
prototype coefficients can be pre-tabulated. This is normally done in a CI run at the beginning of the run. However,
in ICE-CI it may have to be repeated several dozen times and for large numbers of open shells (say 14), the process
is time and memory consuming.

**706** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

In order to ease the computational burden, we have provided a small utility program that tabulates the coupling
coefficients for a given total spin *𝑆* (rather the multiplicity *𝑀* = 2 *𝑆* + 1) and maximum number of open shells.
This program is called `orcacclib` . It is called like:
```
orca_cclib Mult MaxNOpen

```
or - if you want to speed up the generation of the cclib:
```
mpirun -np 4 /full_path/orca_cclib_mpi Mult MaxNOpen cclib # using 4 processes

```
It will produce a series of files orcacc.el.mult.nopen (electron density coupling coefficients) and orcacc.sp.mult.nopen (spin-density coupling coefficients) in the current directory. These files are binary files. They
can be copied to an arbitrary directory. You instruct the program to read these coefficients (rather than to recalculate
them all the time) by setting the path to this directory:



The remaining part of the filename will be automatically added by the program. This option can save humongous
amounts of time. The coupling coefficient library needs to be made for the desired multiplicities only once. The
practical limit will be 14-16 open shells. If you are running the calculation on a cluster using some submit script,
you have to ensure that the provided `cclib` path is accessible from the compute node.
### **7.25 CI methods using generated code**

The AUTOCI module is a replacement of the `orca_mdci` for cases, where manual implementation of the method
would be tedious or practically impossible. The module works with all types of reference wave function available in
ORCA, i.e., RHF, ROHF, UHF and CASSCF and offers CI and related methods. All the methods are implemented
in canonical orbital basis and storing all integrals on disk.

**7.25.1 Introduction**

All the theories are obtained by the means of automated programming within the ORCA-AGE (Automated Generator Environment for ORCA).[474, 500] The CI module reads in the SCF wavefunction and optimizes the coefficient
of the CI expansion. Conceptually, the module is similar to `orca_mdci`, therefore the input and output do have a
lot in common.

**7.25.2 Input**

All parameters applicable to the AUTOCI module are shown below.

(continues on next page)

**7.25. CI methods using generated code** **707**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)




N.B. For a ROHF reference, only CISD calculations can be performed in the current version. However, it is possible
to run UHF calculations with an ROHF reference by setting the `RunROHFasUHF` flag to true. Note that this only
makes sense when the reference is indeed ROHF, e.g. (calculating the isotropic part of the HFC at CCSD level,
running AutoCI UHF CCSD module, with orbitals obtained from the ROHF SCF calculation):



(continues on next page)

**708** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

If one wishes to experiment with the module itself and the reference wavefunction stays constant, it is possible to
store the transformed MO integrals on disk ( `keepints` ) and reuse them ( `useoldints` ). The program checks only
whether the dimension of the integrals on disk match the problem actually solved, i.e. the user is responsible for
valid data.

**7.25.3 Available Properties**

The following single-reference methods are currently implemented in the AUTOCI.

continues on next page

**7.25. CI methods using generated code** **709**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.21 – continued from p revious p a g e

Any AUTOCI method can be called from the simple keyword by prepending `AUTOCI-` to the correlation method,
for instance
```
! AUTOCI-CCSD

```
**7.25.4 Analytic Nuclear Gradients with AUTOCI**

Obtaining accurate geometries is crucial to computing molecular properties accurately. In order to perform geometry optimisations, the nuclear gradient is necessary and while this can easily be obtained using numerical finite
difference methods, it is also quite costly. More importantly, perhaps, is the fact that numeric derivatives tend
to become unstable. Therefore, being able to evaluate analytic gradients is of vital importance. Using the AGE,
a general framework has been built that supports arbitrary-order CI, CC and MPn nuclear gradients (and other
derivatives).[500]

An example is shown below how to optimise a geometry using AUTOCI’s gradients at the CCSD level of theory



The analytic gradients can even be used to perform semi-numerical frequency calculations
```
! AUTOCI-CCSD NumFreq

```
Besides nuclear gradients, all other first-order properties available in ORCA are available for the respective methods, such as dipole/quadrupole moments, hyperfine couplings or quadrupole splittings. As discussed above,
(un)relaxed densities can be requested via



For geometry optimisations, both the unrelaxed and relaxed densities are computed automatically and do not need
to be requested explicitly.

**7.25.5 AUTOCI Response Properties via Analytic Derivatives**

For single-reference methods (currently limited to `CCSD` and `MP2` ), some response properties could be calculated
via taking the analytic derivative of the wavefunctions computed by AUTOCI.

The input parameters for the wavefunctions are controlled by the `%autoci` block, while the property-related parameters are controlled by respective property blocks, like `elprop` and `eprnmr` . Some useful options are shown
below.



(continues on next page)

**710** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

N.B. For the response property calculations, the electron density and electron response density needs to be calculated. Currently for the analytic polarizability at CCSD level, only the unrelaxed density version is implemented:




For MP2, both the polarizability and NMR shielding needs the relaxed densities:





Please also note that for AUTOCI NMR calculations, the GIAOs (gauge-including atomic orbitals) are necessary

**7.25. CI methods using generated code** **711**

**ORCA Manual** **,** **Release 6.0.1**

(turned on by default). Also, there is no fronzen core options implemented yet ( `NoFrozenCore` keyword is needed).

**7.25.6 Fully Internally Contracted MRCI**

Starting point for any multireference approach is a reference wavefunction that consists of multiple determinants
or configurations state functions (CSFs). In many instances this is the complete active space SCF (CASSCF)
wavefunction. In the uncontracted MRCI approach, as implemented in the `orca_mrci` module, the wavefunction
is expanded in terms of excited CSFs that are generated by considering excitations with respect to all reference
CSFs. The methodology scales with the number of reference CSFs and hence is restricted to small reference
spaces. Moreover, the configuration driven algorithm used in `orca_mrci` keeps all integrals in memory, which
further limits the overall size of the molecule.

Internal contraction as proposed by Meyer and Siegbahn avoids these bottlenecks [585, 797]. Here, excited CSFs
are generated by applying the excitation operator to the reference wavefunction as whole. The fully internally
contracted MRCI presented here (FIC-MRCI) uses the same internal contraction scheme as the FIC-NEVPT2 (aka
PC-NEVPT2). The entire methodology as well as a comparison with the conventional uncontracted MRCI is
reported in our article [806]. The CEPA0, ACPF and AQCC variants are straight forward adoptions [742]. The
residue of the FIC-MRCI ansatz

*𝑅* *𝐾* = *⟨* Φ *[𝑝𝑟]* *𝑞𝑠* *[|][𝐻]* [ ˆ] *[−]* *[𝐸]* [CAS] *[ −]* *[𝜆𝐸]* *[𝑐]* *[|]* [Ψ] [FIC] *[⟩]* *[,]* (7.188)

is modified by the factor


1 MRCI

0 CEPA0
2 ACPF
*𝑁* *𝑒*
1 *−* ( *𝑁* *𝑒* *−* 3 )( *𝑁* *𝑒* *−* 2 )

*𝑁* *𝑒* *·* ( *𝑁* *𝑒* *−* 1) AQCC


*𝜆* =


⎧⎪⎪⎨⎪⎪⎩


Here, *𝐸* *𝑐* is the correlation energy and Φ *[𝑝𝑟]* *𝑞𝑠* [denote the internally contracted CSF that arise from the action of the]
spin-traced excitation operators on the CAS-CI reference wave function

Φ *[𝑝𝑟]* *𝑞𝑠* [=] *[ 𝐸]* *𝑞* *[𝑝]* *[𝐸]* *𝑠* *[𝑟]* *[|]* [Ψ] [CAS] *[⟩]* *[.]*

In case of ACPF and AQCC the *𝜆* factor explicitly depends on the number of correlated electrons, *𝑁* *𝑒* .

The general input structure is like that of the CASSCF module, e.g., the following example input reads an arbitrary
set of orbitals and starts the FIC-MRCI calculation. The internal contracted formalism requires CAS-CI reduced
densities up to fourth order, which can be expensive to construct. By default, the density construction is speed up
using the prescreening (PS) approximation reported in Section *N-Electron Valence State Pertubation Theory* .



(continues on next page)

**712** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Currently, the program is capable of computing total energies and vertical excitation energies. More features will
be available with future releases.

**7.25.7 Fully Internally Contracted MRCC**

Several approaches have been taken towards extending CC theory to work with genuinely multiconfigurational
reference wave functions [538], yet none of these approaches has found widespread adoption. As of 2011, the
internally contracted MRCC theory has had a revival, with a rigorous theoretical investigation of several approximations that also proved its orbital invariance [249] and a first report of a polynomial-scaling code obtained through
automatic equation generation [357].

Our implementation in ORCA is akin to the previously published formulations in Refs. [249, 357], although everything is formulated rigorously in terms of the spin-free excitation operators *𝐸* [ˆ] *𝑞* *[𝑝]* [= ˆ] *[𝑎]* *[𝑝𝛼]* *[𝑎]* [ˆ] *[𝑞𝛼]* [+ ˆ] *[𝑎]* *[𝑝𝛽]* *[𝑎]* [ˆ] *[𝑞𝛽]* [, using an]
improved version of the ORCA-AGE code generator.[500] To begin with, the *ansatz* for the wave function is

*|* Ψ *⟩* = e *𝑇* ^ *|* 0 *⟩* *,* (7.189)

where *|* 0 *⟩* denotes a zeroth order CASSCF reference wave function and the cluster operator can be written as
(Einstein’s summation convention implied)



[1] 2 *[𝑡]* *𝑎𝑏* *[𝑖𝑗]* *[𝐸]* [ˆ] *𝑖* *[𝑎]* *[𝐸]* [ˆ] *𝑗* *[𝑏]* [+] *[ 𝑡]* *𝑎𝑏* *[𝑖𝑡]* *[𝐸]* [ˆ] *𝑖* *[𝑎]* *[𝐸]* [ˆ] *𝑡* *[𝑏]* [+ 1] 2


*𝑇* ˆ = [1]


2 *[𝑡]* *𝑎𝑏* *[𝑡𝑢]* *[𝐸]* [ˆ] *𝑡* *[𝑎]* *[𝐸]* [ˆ] *𝑢* *[𝑏]* [+] *[ 𝑡]* *𝑎𝑡* *[𝑖𝑗]* *[𝐸]* [ˆ] *𝑖* *[𝑎]* *[𝐸]* [ˆ] *𝑗* *[𝑡]* [+] *[ 𝑡]* *𝑎𝑢* *[𝑖𝑡]* *[𝐸]* [ˆ] *𝑖* *[𝑎]* *[𝐸]* [ˆ] *𝑡* *[𝑢]*


+ *𝑡* *[𝑖𝑡]* *𝑢𝑎* *[𝐸]* [ˆ] *𝑖* *[𝑢]* *[𝐸]* [ˆ] *𝑡* *[𝑎]* [+] *[ 𝑡]* *𝑎𝑣* *[𝑡𝑢]* *[𝐸]* [ˆ] *𝑡* *[𝑎]* *[𝐸]* [ˆ] *𝑢* *[𝑣]* [+ 1] 2 *[𝑡]* *𝑡𝑢* *[𝑖𝑗]* *[𝐸]* [ˆ] *𝑖* *[𝑡]* *[𝐸]* [ˆ] *𝑗* *[𝑢]* [+] *[ 𝑡]* *𝑢𝑣* *[𝑖𝑡]* *[𝐸]* [ˆ] *𝑖* *[𝑢]* *[𝐸]* [ˆ] *𝑡* *[𝑣]* *[.]*


Note that we do not use normal order in the cluster operator.

Inserting the *ansatz* from Eq. (7.189) into the Schrödinger equation and pre-multiplying with the inverse exponential, we obtain the similarity transformed Hamiltonian and the energy expression,

*𝐻* ¯ *|* 0 *⟩* = e *[−][𝑇]* [^] *𝐻* ˆ e *𝑇* ^ *|* 0 *⟩* = *𝐸|* 0 *⟩* *.*

In our code, the similarity-transformed Hamiltonian is truncated after the quadratic terms since that approximation
has been found to only have minor impact on the accuracy of the method [249],

¯ ˆ
*𝐻* *≈* *𝐻* + [ ˆ *𝐻,* ˆ *𝑇* ] + [1]

2 [[[ ˆ] *[𝐻,]* [ ˆ] *[𝑇]* []] *[,]* [ ˆ] *[𝑇]* []] *[ .]*

The residual conditions are subsequently obtained by projecting with contravariant excited functions *⟨* Φ [˜] *𝑃* *|* onto the
Schrödinger equation,

*𝑟* *𝑃* = *⟨* Φ [˜] *𝑃* *|𝐻* [¯] *|* 0 *⟩* *.*

For a definition of the contravariant projection functions, we refer to Ref. [806] since this fic-MRCC implementation
uses the same contravariant functions as the published fic-MRCI implementation. Despite using contravariant
projection functions, this is not sufficient to remove all linear dependencies from the set of projection functions
*{* Φ [˜] *𝑃* *}*, i.e. the metric matrix

*𝑆* *𝑃𝑄* = *⟨* Φ [˜] *𝑃* *|* Φ [˜] *𝑄* *⟩̸* = *𝛿* *𝑃𝑄*

has off-diagonal elements *within* excitation classes and between classes with the same number of inactive and
virtual indices (ITAU and ITUA). Hence, the set of projection functions needs to be orthonormalized, which is
achieved with Löwdin’s canonic orthogonalization in the AUTOCI module. [1]

1 This is similar to scheme A from Ref. [357].

**7.25. CI methods using generated code** **713**

**ORCA Manual** **,** **Release 6.0.1**

**Input Example**

The fic-MRCC module can be started by specifying the `CIType` keyword in the `%autoci` block or by adding
`fic-MRCC` to the simple input line of an ORCA input file. The following example computes the singlet ground
state energy of four hydrogen atoms arranged as a square with a side length of 2 *𝑎* 0, which is commonly known as
the H4 model [418].



In this example, ORCA will first run a state-specific CASSCF calculation, and then immediately continue with the
fic-MRCC calculation on top of the CASSCF solution from the first step. It is, however, not required to always run a
CASSCF calculation before the `autoci` module. Any ORCA `gbw/mp2nat/...` file is accepted through `%moinp`,
although that route requires the user to specify the active space in the `autoci` block. `autoci` will then compute a
CASCI solution with the provided input orbitals and use that information to drive the correlated calculations.

Please be aware that fic-MRCC is a very extensive theory, which leads to long run times. The computational
effort depends mainly on the number of orbitals, the number of total electrons and the size of the active space.
On modestly modern hardware, calculations of *∼* 300 orbitals with a CAS(2,2) should be readily achievable. For
larger active spaces, such as a CAS(6,6), calculations with a total of *∼* 200 orbitals will also complete within a day.
### **7.26 Geometry Optimization**

ORCA is able to calculate equilibrium structures (minima and transition states) using the quasi Newton update
procedure with the well known BFGS update [67, 241, 399, 763, 764, 765], the Powell or the Bofill update. The
optimization can be carried out in either redundant internal (recommended in most cases) or Cartesian displacement
coordinates. As initial Hessian the user can choose between a diagonal initial Hessian, several model Hessians
(Swart, Lindh, Almloef, Schlegel), an exact Hessian and a partially exact Hessian (both recommended for transition
state optimization) for both coordinate types. In redundant internal coordinates several options for the type of step
to be taken exist. The user can define constraints via two different paths. He can either define them directly (as
bond length, angle, dihedral or Cartesian constraints) or he can define several fragments and constrain the fragments
internally and with respect to other fragments. The ORCA optimizer can be used as an external optimizer, i.e.the
energy and gradient calculations done by ORCA.

**714** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


**7.26.1 Input Options and General Considerations**

The use of the geometry optimization module is relatively straightforward. [1]



(continues on next page)

1 But that doesn’t mean that geometry optimization itself is straightforward! Sometimes, even when it is not expected the convergence can
be pretty bad and it may take a better starting structure to come to a stationary point. In particular floppy structures with many possible rotations
around single bonds and soft dihedral angle modes are tricky. It may sometimes be advantageous to compute a Hessian matrix at a “cheap”
level of theory and then do the optimization in Cartesian coordinates starting from the calculated Hessian.

**7.26. Geometry Optimization** **715**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
    # perform constrained optimizations with varying N1-N2    # distance from value1 up to value2 in N steps;
    # works as well for angles (use A N1 N2 N3) and for
    # dihedrals (use D N1 N2 N3 N4)
   Scan B N1 N2 [value1 value2 value3 ... valueN] end
    # perform constrained optimizations with N1-N2-distances
    # as given in the list;
    # works as well for angles (use A N1 N2 N3) and for
    # dihedrals (use D N1 N2 N3 N4)
   # perform a simultaneous multidimensional scan
   # possible for up to 3 different scan parameters. They each must
   # have an identical number of scan steps
   simul_Scan true # default false
   fullScan true # if !ScanTS is requested, fullScan assures
            # that the relaxed surface scan is fully
            # carried out before the TS optimization is
            # started (Default is false)
   # fragment optimization:
   # 1. all atoms have to belong to a fragment
   # 2. you have to connect the fragments
   ConnectFragments
     {1 2 C} # constrain the internal coordinates
            # connecting fragments 1 and 2
     {1 2 C N1 N2}# constrain the internal coordinates
            # connecting fragments 1 and 2, the
            # fragments are connected via atoms
            # N1 and N2
     {1 3 O} # optimize the internal coordinates
            # connecting fragments 1 and 3
     {1 3 O N1 N2}# optimize the internal coordinates
            # connecting fragments 1 and 3, the
            # fragments are connected via atoms
            # N1 and N2
   end
   # 3. you can constrain the fragment internally
   ConstrainFragments # constrain all internal coordinates
     { 1 } # containing only atoms of fragment 1
   end
   # optimize hydrogens
   optimizeHydrogens true
    # in the context of a normal optimization all internal
    # coordinates not involving any hydrogens are constrained
    # in the context of a fragment optimization all internal
    # coordinates involving hydrogens are optimized (also in a
    # constrained fragment)
   # freeze the hydrogen positions with respect to the
   # heteroatoms
   freezeHydrogens true
   # invert the defined constraints, i.e. optimize the
   # constraints and constrain the remaining coordinates
   # this only works for the redundant internal coordinates
   # Cartesian coordinates are not affected by invertConstraints
   invertConstraints true # step type control
   Step qn # quasi-Newton step
        rfo # Rational function step (Default for !Opt)
        prfo # partitioned RFO step (Default for !OptTS)
   # Step size control
   MaxStep 0.3 # maximum step length in internal coordi         # nates. Default is 0.3 au
   Trust -0.3 # Initial trust radius. Default is -0.3 au
         # Trust <0 - use fixed trust radius

```
(continues on next page)

**716** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Keywords for the control of the Hessian (especially important for the TS optimization):

(continues on next page)

**7.26. Geometry Optimization** **717**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

As for parameter scan runs ORCA has some special options that may help to speed up the optimization:



**718** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**Redundant Internal Coordinates**

There are three types of internal coordinates: redundant internals, old redundant internals (redundant_old) and
a new set of redundant internals (redundant_new, with improved internals for nonbonded systems). All three
sets work with the same “primitive” space of internal coordinates (stretches, bends, dihedral angles and improper
torsions). Only the redundant internals works with one more type of bends in cases where a normal bend would
have been approximately 180 *[∘]* . In redundant internal coordinates the full primitive set is kept and the Hessian and
gradient are transformed into this – potentially large – space. A geometry optimization step requires, depending on
the method used for the geometry update, perhaps a diagonalization or inversion of the Hessian of dimension equal
to the number of variables in the optimization. In redundant internal coordinates this space may be 2-4 times larger
than the nonredundant subspace which is of dimension 3 *𝑁* atoms *−* 6(5). Since the diagonalization or inversion
scales cubically the computational overhead over nonredundant spaces may easily reach a factor of 8–64. Thus, in
redundant internal coordinates there are many unnecessary steps which may take some real time if the number of
primitive internals is greater than 2000 or so (which is not so unusual). The timing problem may become acute in
semiempirical calculations where the energy and gradient evaluations are cheap.

We briefly outline the theoretical background which is not difficult to understand:

Suppose, we have a set of *𝑛* *𝐼* (redundant) primitive internal coordinates **q** constructed by some recipe and a set of
*𝑛* *𝐶* = 3 *𝑁* atoms Cartesian coordinates **x** . The B-matrix is defined as:

*𝐵* *𝑖𝑗* = *𝜕𝑥* *[𝜕]* *[𝑞]* *[𝑖]* *𝑗* (7.190)

This matrix is rectangular. In order to compute the internal gradient one needs to compute the “generalized inverse”
of **B** . However, since the set of primitive internals is redundant the matrix is rank-deficient and one has to be careful.
In pratice one first computes the *𝑛* *𝐼* *× 𝑛* *𝐼* matrix **G** :

**G** = **BB** *[𝑇]* (7.191)

The generalized inverse of **G** is denoted **G** *[−]* and is defined in terms of the eigenvalues and eigenvectors of **G** :


*𝑇* **Λ** *−* **1** **0**

**0** **0**
)︂ (︂


(7.192)
)︂


**U**
**G** *[−]* =
**R**
(︂


**U**

**R**
)︂(︂


Here **U** are the eigenvectors belonging to the nonzero eigenvalues **Λ** which span the nonredundant space and **R**
are the eigenvectors of the redundant subspace of the primitive internal space. If the set of primitive internals is
carefully chosen, then there are exactly 3 *𝑁* atoms *−* 6(5) nonzero eigenvalues of **G** . Using this matrix, the gradient
in internal coordinates can be readily computed from the (known) Cartesian gradient:

**g** *𝑞* = **G** *[−]* **Bg** *𝑥* (7.193)

The initial Hessian is formed directly in the redundant internal space and then itself or its inverse is updated during
the geometry optimization.

Before generating the Newton step we have to ensure that the displacements take place only in the nonredundant
part of the internal coordinate space. For this purpose a projector *𝑃* *[′]* :

**P** *[′]* = **GG** *[−]* = **G** *[−]* **G** (7.194)

is applied on both the gradient and the Hessian:

**˜g** **q** = **P** *[′]* **g** **q** (7.195)

**˜H** **q** = **P** *[′]* **H** **q** **P** *[′]* + *𝛼* ( **1** *−* **P** *[′]* ) (7.196)

The second term for *𝐻* [˜] sets the matrix elements of the redundant part of the internal coordinate space to very large
values ( *𝛼* = 1000).

**7.26. Geometry Optimization** **719**

**ORCA Manual** **,** **Release 6.0.1**

**Coordinate steps**

A Quasi-Newton (QN) step is the simplest choice to update the coordinates and is given by:

**Δq** = *−* **H** **[˜]** *[−]* **q** **[1]** **[˜g]** **[q]** (7.197)


A more sophisticated step is the rational function optimization step which proceeds by diagonalizing the augmented
Hessian:

**H** *𝑞* **g** *𝑞* ∆ **q** = *𝑣* ∆ **q** (7.198)
(︂ **g** *𝑞* 0 )︂(︂ 1 )︂ (︂ 1 )︂

The lowest eigenvalue *𝜈* 0 approaches zero as the equilibrium geometry is approached and the nice side effect of
the optimization is a step size control. Towards convergence, the RFO step is approaching the quasi-Newton step
and before it leads to a damped step is taken. In any case, each individual element of ∆ **q** is restricted to magnitude
`MaxStep` and the total length of the step is restricted to `Trust` . In the RFO case, this is achieved by minimizing
the predicted energy on the hypersphere of radius `Trust` which also modifies the direction of the step while in the
quasi-Newton step, the step vector is simply scaled down.

Thus, the new geometry is given by:

**q** new = **q** old + ∆ **q** (7.199)

However, which Cartesian coordinates belong to the new redundant internal set? This is a somewhat complicated
problem since the relation between internals and Cartesians is very nonlinear and the step in internal coordinates
is not infinitesimal. Thus, an iterative procedure is taken to update the Cartesian coordinates. First of all consider
the first (linear) step:

∆ **x** = **A** ∆ **q** (7.200)

with **A** = **B** *[𝑇]* **G** *[−]* . With the new Cartesian coordinates **x** *𝑘* +1 = **x** *𝑘* + ∆ **x** a trial set of internals **q** *𝑘* +1 can be
computed. This new set should ideally coincide with **q** new but in fact it usually will not. Thus, one can refine the
Cartesian step by forming

∆∆ **q** = **q** new *−* **q** *𝑘* +1 (7.201)

which should approach zero. This leads to a new set of Cartesians ∆ **x** *[′]* = **A** ∆∆ **q** which in turn leads to a new
set of internals and the procedure is iterated until the Cartesians do not change and the output internals equal **q** *𝑛𝑒𝑤*
within a given tolerance (10 *[−]* [7] RMS deviation in both quantities is imposed in ORCA).

**Constrained Optimization**

Constraints on the redundant internal coordinates can be imposed by modifying the above projector *𝑃* *[′]* with a
projector for the constraints *𝐶* :

**P** = **P** *[′]* *−* **P** *[′]* **C** ( **CPC** ) *[−]* **[1]** **CP** *[′]* (7.202)

*𝐶* is a diagonal matrix with 1’s for the constraints and 0’s elsewhere. The gradient and the Hessian are projected
with the modified projector:

*𝑔* ˜ *𝑞* = *𝑃𝑔* *𝑞* (7.203)

˜
*𝐻* *𝑞* = *𝑃𝐻* *𝑞* *𝑃* + *𝛼* (1 *−* *𝑃* ) (7.204)

**720** **Chapter 7. Detailed Documentation**


= *𝑣* ∆ **q**
1
)︂ (︂


∆ **q**

1
)︂(︂


(7.198)
)︂

**ORCA Manual** **,** **Release 6.0.1**

**Constrained Fragments Optimization**

The constrained fragments option was implemented in order to provide a convenient way to handle constraints for
systems consisting of several molecules. The difference to a common optimization lies in the coordinate setup. In
a common coordinate setup the internal coordinates are built up as described in the following:

In a first step, bonds are constructed between atom pairs which fulfill certain (atom type specific) distance criteria. If
there are fragments in the system, which are not connected to each other (this is the case when there are two or more
separate molecules), an additional bond is assigned to the nearest atom pair between the nonbonded fragments. All
other internal coordinates are constructed on the basis of this set of bonds. Here, in a second step, bond angles are
constructed between the atoms of directly neighboured bonds. If such an angle reaches more than 175 *[∘]*, a special
type of linear angles is constructed. In a third step, dihedral angles (and improper torsions) are constructed between
the atoms of directly neighbouring angles.

If the constrained fragments option is switched on, the set of bonds is constructed in a different way. The user
defines a number of fragments. For each fragment a full set of bonds (not seeing the atoms of the other fragments)
is constructed as described above. When using this option, the user also has to define which fragments are to be
connected. The connection between these fragments can either be user-defined or automatically chosen. If the user
defines the connecting atoms N1 and N2, then the interfragmental bond is the one between N1 and N2. If the user
does not define the interfragmental bond, it is constructed between the atom pair with nearest distance between
the two fragments. Then the angles and dihedrals are constructed upon this (different) set of bonds in the already
described fashion.

Now let us regard the definition of the fragment constraints: A fragment is constrained internally by constraining
all internal coordinates that contain only atoms of the respective fragment. The connection between two fragments
A and B is constrained by constraining specific internal coordinates that contain atoms of both fragments. For
bonds, one atom has to belong to fragment A and the other atom has to belong to fragment B. Regarding angles,
two atoms have to belong to fragment A and one to fragment B and vice versa. With respect to dihedrals, only
those are constrained where two atoms belong to fragment A and the other two belong to fragment B.

**7.26.2 Transition State Optimization**

As transition state finder we implemented the well-established eigenvector following algorithm using a P-RFO step
as implemented by Baker [67]. This algorithm is a quasi-Newton like algorithm.

The Taylor series of the energy, truncated after the quadratic term, is:

*𝐸* = *𝐸* 0 + *𝑔* *𝑞* + ∆ *𝑞* *𝑞* + 2 [1] [∆] *[𝑞]* [+] [H] *[𝑞]* [∆] *[𝑞]* (7.205)

The Newton-Raphson step to get from the actual point to a stationary point is:

∆ *𝑞* = *−* H *[−]* *𝑞* [1] *[𝑔]* *[𝑞]* [=] ∑︁ *−* *[𝑉]* *𝑖* [+] *𝑏* *[𝑔]* *𝑖* *[𝑞]* *[𝑉]* *[𝑖]* (7.206)

with *𝑉* *𝑖* and *𝑏* *𝑖* as eigenvectors and eigenvalues of the Hessian H *𝑞* . This step leads to the nearest stationary point
on the PES. This stationary point can be a minimum or a saddle point, according to the curvature of the PES at the
actual point.

With a simple shift of the Hessian eigenvalues *𝑏* *𝑖* in this equation one can guide the step to a stationary point with
the required characteristics (Hessian with exactly one negative eigenvalue). The transition state search is separated
into two different optimization problems. The energy is maximized along one Hessian eigenmode and minimized
along the remaining 3 *𝑁* *−* 7(6) eigenmodes. We introduce two different shift parameters *𝜆* *𝑝* and *𝜆* *𝑛*, where *𝜆* *𝑝*
is the shift parameter for the eigenmode being maximized and *𝜆* *𝑛* shifts the Hessian eigenvalues of the modes
being minimized. This method allows us to maximize along any mode, not only the one with smallest eigenvalue.
Starting from two different RFO-matrices for the different optimization problems (see description above) we get
for *𝜆* *𝑝* and *𝜆* *𝑛* :

*̸*


*𝜆* *𝑝* = [1]

*̸*



[1]

2 *[𝑏]* *[𝑘]* [+ 1] 2

*̸*


2

*̸*


*𝜆* *𝑛* *𝐹−* *𝑖* [2] *𝑏* *𝑖* = *𝜆* *𝑛* (7.207)

*̸*


~~√~~ *𝑏* [2] *𝑘* [+ 4] *[𝐹]* *𝑘* [2] and ∑︁

*𝑖* = *̸* *𝑘*


*̸*

**7.26. Geometry Optimization** **721**

**ORCA Manual** **,** **Release 6.0.1**

whereas *𝐹* *𝑖* = *𝑉* *𝑖* [+] *[𝑔]* [is the component of] *[ 𝑔]* [along the Hessian eigenmode] *[ 𝑉]* *[𝑖]* [and] *[ 𝜆]* *[𝑛]* [has to get solved iteratively. The]
solution for *𝜆* *𝑛* has to be negative and lower than *𝑏* 2 (or lower than *𝑏* 1, if not the lowest mode is being followed). If
the Hessian has more than one negative eigenvalue, these properties might not be fulfilled, and the Hessian would
have to be modified. In our implementation the Hessian diagonal elements are either shifted or reversed in such a

case.

Once the shift parameters are known the P-RFO step *ℎ* is calculated as follows:

*𝐹* ¯ *𝑘* *𝑉* *𝑘* *𝐹* ¯ *𝑖* *𝑉* *𝑖*
∆ *𝑞* *𝑘* = *−* *𝑏* *𝑘* *−* *𝜆* *𝑝* and ∆ *𝑞* *𝑖* = *−* *𝑏* *𝑖* *−* *𝜆* *𝑛* with *𝑖* = 1 *. . . 𝑛, 𝑖* = *̸* *𝑘* (7.208)


*̸*

∆ *𝑞* =


*̸*

*𝑛*
∑︁ ∆ *𝑞* *𝑗* (7.209)

*𝑗* =1


*̸*

**ScanTS option**

For TS modes of rather local nature (involving only one bond or an angle; no concerted movements over multiple
atoms) we implemented the ScanTS feature. Here the user can carry out a relaxed surface scan and a TS optimization in one calculation. After the relaxed surface scan the algorithm chooses the optimized structure of the
scan with highest energy as initial guess structure and the two neighbouring structures for the calculation of the
second derivative of the scanned coordinate (e.g., if scan step number 4 gives the structure with highest energy,
then structure `basename.004.xyz` is the initial guess for the TS optimization; the structures `basename.003.xyz`
and `basename.005.xyz` are used for the calculation of the second derivative). Before the first step of the subsequent TS optimization the energies and gradients for all three structures are calculated. The gradients are then
transformed to internal coordinates. The diagonal Hessian value of the scanned coordinate is then calculated via
finite difference of the internal gradients of the two given structures (003 and 005 in our example).

For the construction of the initial Hessian a model force field Hessian is built up (this Hessian has got only diagonal
entries and zeros as off-diagonal elements). The exactly calculated diagonal Hessian value replaces the model force
field Hessian entry for the respective internal coordinate.

If the user already performed a regular relaxed surface scan without the subsequent TS optimization, then he can
nevertheless use these structures for the same procedure. A relaxed surface scan always gives you the xyz-files and
gbw-files of the optimized structures of each scan step. A separate TS optimization can be carried out where the
structure with highest energy is the starting structure. Additionally the two files with the two adjacent structures
(as explained above) have to be provided (via the Hess_Internal keyword, see below). Furthermore, the internal
coordinate, for which the diagonal Hessian value has to be calculated, has to be given (the previously scanned
coordinate). This exact Hessian calculation is only possible for one internal coordinate:


*̸*


*̸*


*̸*

Additionally the manipulation of the diagonal Hessian values of the internal Hessian is possible for further internal
coordinates, but without an extra calculation. Here the user can just define a value (in Eh/Bohr [2] ).


*̸*


*̸*


*̸*

**722** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

The definition of such Hessian (diagonal) elements is possible for multiple internal coordinates. These just replace
the values of the force field model Hessian.

**Hybrid Hessian**

We implemented the calculation of a “Hybrid Hessian” as an alternative to the full Hessian calculation for TS
optimization. Here only those parts of the Hessian, that are important for the TS optimization, are calculated
exactly. For this calculation we define two kinds of atoms: atoms whose couplings with the other atoms are treated
exactly (E) and atoms whose couplings are treated approximately (A).

In a first step an Almloef model Hessian is built up in redundant internal coordinates and transformed to Cartesian
coordinates. This Hessian gives the second derivative elements for atom pairs A/A. In a second step the second
derivative elements between pairs E/E and E/A are calculated numerically as in a numerical frequency calculation:

**ΔE** = **ΔE** = *𝑔* *𝑗,* *[𝑖,𝐵]* *𝐶* *[−]* *[𝑔]* *𝑗,* *[𝑒𝑞.]* *𝐶* (7.210)
∆ *𝑖* *𝐵* ∆ *𝑗* *𝐶* ∆ *𝑗* *𝐶* ∆ *𝑖* *𝐵* *𝑑𝑖𝑠𝑝𝑙.*

with:

︂


**Partial Hessian Vibrational Analysis**

We implemented the Partial Hessian Vibrational Analysis (PHVA), as published by Li, Jensen in [513], for the
analysis of the nature of stationary points of structures obtained with QM/MM optimizations.

︂


︂


︂


NOTE

  - This procedure should be used for QM/MM optimized structures only to verify the nature of the stationary
point and have an estimate of the ZPE.

Here we shortly describe the procedure: In PHVA we divide the system into two parts *𝐵* (of size *𝑛* atoms) and *𝐶*
(size *𝑁* *−* *𝑛* ). Let the atom set *𝐵* belong to the region where the chemical change is localized. The Partial Hessian
matrix is built up as follows:

︂ *𝐾* *𝐵𝐵* 0 (7.211)
( 0 *𝐾* *𝐶𝐶* *[𝜀]* )

**7.26. Geometry Optimization** **723**

**ORCA Manual** **,** **Release 6.0.1**

With:


*𝐾* *𝐵𝐵* : *𝑥, 𝑦, 𝑧* direction


⎞


*𝜀* 0 0


*𝐾* *𝐶𝐶* *[𝜀]* [=]


⎛

⎜
⎝


0 ... 0

0 0 *𝜀*


⎟⎠ *, 𝜀* = 10 *[−]* [8] au *,* (7.212)


this corresponds to using near-infinite masses for the atoms in *𝐶* .

With this procedure we get the following eigenvalue structure:

  - Six zero eigenvalues with modes corresponding to translational and rotational motion of the entire molecule.

  - 3( *𝑁* *−* *𝑛* ) *−* 6 small (less than 1 cm *[−]* [1] ) eigenvalues with modes corresponding mainly to internal motion
within region *𝐶* .

  - Three eigenvalues (typically less than 10 cm *[−]* [1] ) with modes corresponding mainly to motion of region *𝐶*
relative to region *𝐵* .

  - (3 *𝑛* *−* 3) eigenvalues with modes corresponding mainly to relative motion of *𝐵* and *𝐶* as well as internal
motion within region *𝐵* .

**7.26.3 Minimum Energy Crossing Points**

The MECP optimization allows the user to optimize to structures where two different potential energy surfaces
(PES1 and PES2) cross each other. In this optimization two conditions apply: the energy *𝐸* 1 of PES1 is minimized
while at the same time the energy difference ( *𝐸* 1 *−* *𝐸* 2 ) [2] of both surfaces is minimized. For the implementation
we follow in principle the suggestions of Harvey et al. in [365].

For the minimization two different gradients are constructed:

The first gradient chosen for the minimization is

**f** = *[𝜕]* (7.213)

*𝜕𝑞* [(] *[𝐸]* [1] *[ −]* *[𝐸]* [2] [)] [2] [ = 2 (] *[𝐸]* [1] *[ −]* *[𝐸]* [2] [)] *[ ·][ 𝑥]* [1]

where *𝑥* 1 is the gradient difference vector


*𝜕𝐸* 1
*𝑥* 1 =

[︂(︂ *𝜕𝑞*


)︂ *−* (︂ *𝜕𝐸𝜕𝑞* 2


(7.214)
)︂]︂


which is orthogonal to the crossing hyperline near the MECP.

The gradient


*𝜕𝐸* 1
**g** =
(︂ *𝜕𝑞*


*−* *[𝑥]* [1]
)︂ *|𝑥* 1 *|*


*−* *[𝑥]* [1]
)︂ *|𝑥* 1


*𝜕𝐸* 1

[︂(︂ *𝜕𝑞*



*·* *[𝑥]* [1]
)︂ *|𝑥* 1 *|*


(7.215)
]︂


is orthogonal to *𝑥* 1 .

Both gradients are combined to yield the effective surface crossing gradient

**g** **SC** = **g** + **f** (7.216)

The crossing hyperline is defined as the 3 *𝑁* *−* 7 dimensional subspace of PES1, which is orthogonal to *𝑥* 1 . In the
MECP optimization we want to find the point of lowest energy within this subspace.

Our calculation of normal modes and force constants for movements along the crossing hyperline differ from the
one proposed by Harvey et al. A standard frequency analysis can not be performed, but a similar procedure is
applied:

Let us regard the second-order Taylor expansion for the energy of both surfaces near the MECP for a displacement
along the crossing hyperline (orthogonal to *𝑥* 1 ):

**E** *𝐴* = *𝐸* MECP + [1] (7.217)

2 [∆] *[𝑞]* *[𝑇]* *[𝐻]* [eff] *[,𝐴]* [∆] *[𝑞]*

**724** **Chapter 7. Detailed Documentation**

with:


**ORCA Manual** **,** **Release 6.0.1**


Diagonalization of this effective Hessian gives us the normal modes of the crossing hyperline and thus allows us
to decide whether the MECP optimization converged to a minimum in the 3 *𝑁* *−* 7 dimensional subspace of the
crossing hyperline.

The procedure for the calculation of the effective Hessian is now as follows: For each of both surfaces the second
derivative matrix is calculated. Then the 6 rotations and translations and additionally the direction of the gradient
difference vector *𝑥* 1 (this ensures that movement orthogonal to the crossing hyperline, for which we do NOT satisfy
the conditions of a stationary point, is excluded) are projected out from the Hessian matrix.

For MECP optimizations the following options exist:



**7.26.4 Conical Intersections**

The minima in the conical intersection seam-space between two states (named here I and J) can be found by using
regular geometry optimization algorithms, except that the gradient to be optimized is [545]:

**g** = **g** *[′]* *𝑑𝑖𝑓𝑓* [+] **[ Pg]** *𝑚𝑒𝑎𝑛*

where **g** *[′]* *𝑑𝑖𝑓𝑓* [= 2(] *[𝐸]* *[𝐼]* *[−]* *[𝐸]* *[𝐽]* [)(] *[𝜕𝐸]* *[𝐼]* *[/𝜕𝑞]* *[−]* *[𝜕𝐸]* *[𝐽]* *[/𝜕𝑞]* [)][ is parallel to the gradient difference vector;] **[ g]** *[𝑚𝑒𝑎𝑛]* [is the]
gradient mean and **P** is a projection matrix that projects out the gradient difference ( **x** ) and non-adiabatic coupling
( **y** ) direction components:

**P** = **1** *−* **xx** **[T]** *−* **yy** **[T]**

Now we have three approaches to solve this problem in ORCA, that will be explained next.

**Gradient Projection** : This is exactly what has been described above, and will be chosen as default whenever
NACMEs between I and J are available. It is in principle the faster and most accurate method. It can be invoked
by setting:

**7.26. Geometry Optimization** **725**

**ORCA Manual** **,** **Release 6.0.1**



OBS.: Turning on the ETF (see Sec. *NACMEs with built-in electron-translation factor* ) can improve the optimization when using the full Gradient Projection method.

**Gradient Projection (without NACME)** : It is an approximation to the method above, that one gets by completely
neglecting the NACMEs. It is essentially equivalent to finding a surface crossing point, and will not necessarily
find minima inside the CI seam-space, although the final ∆ *𝐸* *𝐼𝐽* should be zero.



**Updated Branching Plane** : Here the idea is to start from a guess NACME, which is any unit vector perpendicular
to **x**, and do an progressive update on it, similar to the BFGS update on the Hessian [545]. The “Branching Plane”
defined by **x** and **y** gets then iteratively more accurate until covergence is achieved. It has been shown to be quite
accurate and is the default whenever NACMEs are not available. Can be used with:



Finally, the ∆ *𝐸* *𝐼𝐽* energy threshold for the optimization can be altered with:



**7.26.5 Numerical Gradients**

If you want to use numerical instead of analytic gradients you have to use
```
! NumGrad

```
in your input file. Additionally the settings for the numerical differentiation can be changed:



**7.26.6 ORCA as External Optimizer**

If you want to make use of ORCA’s routines for optimization, TS optimization, NEB, IRC, GOAT, etc., but not use
ORCA’s built-in electronic structure methods, you can use the keyword:
```
! ExtOpt

```
in your input file. All information that you give on the electronic structure is discarded. In each optimization/NEB/IRC step ORCA writes an input file called `basename_EXT.extinp.tmp` with the following info:



(continues on next page)

**726** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Comments from `#` until the end of the line should be ignored. The file `basename_EXT.xyz` will also be present in
the working directory. ORCA always requests the energy, but a gradient only if needed for the chosen calculation

type.

ORCA then calls:
```
scriptname basename_EXT.extinp.tmp [args]

```
where `args` are optional command line arguments, which can be provided in the ORCA input file (see below) and
are directly passed to the command line for the external program.

`scriptname` is the name of the external program or wrapper script, which is not distributed with the ORCA binaries
and must be supplied by the user in one of the following ways:

1. as a file or link named `otool_external` in the same directory as the ORCA executables;

2. by assigning the `EXTOPTEXE` environment variable to the *full path* to the external program;

3. via the ORCA input:



Regardless of which option is used, the keyword `Ext_Params` can be used to specify the additional command line
arguments as a single string.

The external script starts the energy (and gradient) calculation and finally provides the results in a file called
`basename_EXT.engrad` using the same `basename` as the XYZ file. This file must have the following format:



Comments from `#` until the end of the line are ignored, as are any comment-only lines.

The script may also print relevant output to `STDOUT` and/or `STDERR` . `STDOUT` will either be printed in the ORCA
standard output, or redirected to a temporary file and removed afterwards, depending on the type of job (e.g., for
`NumFreq` the output for the displaced geometries is always redirected) and ORCA output settings:

**7.26. Geometry Optimization** **727**

**ORCA Manual** **,** **Release 6.0.1**



**7.26.7 Gaussian as External Optimizer**

To use the external optimizer from Gaussian in ORCA, the following keywords were provided in the past:



Since the ORCA team got banned by Gaussian in January 2007 we can no longer support these option flags. They
have not been removed from the code and may or may not work. If there is trouble with it we can – unfortunately
– not offer any help since we do not have access to the Gaussian code any longer.
### **7.27 Frequency calculations - numerical and analytical**

In the ORCA program package, the calculation of frequencies through the numerical or analytical Hessian is done
via the `orca_numfreq` module and the combination of the `orca_propint`, `orca_scfresp`, and `orca_prop`
modules, respectively.

The parameters to control these frequency calculations can be specified in the %freq-block.



(continues on next page)

**728** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



At present, analytical Hessians can be calculated for SCF only. However, there are some additional restrictions.
Analytical Hessians cannot be performed for

Here is what you would do, if you ran a frequency calculation and have a .hess file on disk and want to try different
scaling factors for the frequencies


```
orca_vib myjob_scaled_freq.hess

```
The program will then read the Hessian, diagonalize it and apply your scaling factor. Whatever scaling factor was
used in the actual input that generated the Hessian is irrelevant since the Hessian is re-diagonalized. To avoid
confusion, we recommend that if the goal is to play with the scaling factor, then to leave the scaling factor in the
input at 1.0. Nothing bad happens if you don’t though.

**7.27. Frequency calculations - numerical and analytical** **729**

**ORCA Manual** **,** **Release 6.0.1**

**7.27.1 Restarting Numerical Frequency calculations**

To restart a numerical frequencies calculation, use:



and ORCA will look for basename.res.{} files in the same folder where the calculation is being run, check for what
already has been done and restart where it is needed.
### **7.28 Intrinsic Reaction Coordinate**

The Intrinsic Reaction Coordinate (IRC) method finds a path connecting a transition state (TS) with its downhillnearest intermediates. The implementation in ORCA follows the method suggested by Morokuma and coworkers.[412]

The IRC method follows the gradient of the nuclear coordinates. As the gradient is negligible at a TS, first an initial
displacement from the TS structure has to be carried out, based on the eigenmodes of the Hessian, in order to get
to a region with nonnegligible gradient. For the initial displacement the eigenvector of the eigenmode with lowest
frequency (hessMode=0) is normalized and then scaled by Scale_Displ_SD (which by default is chosen such that
an energy change of Init_Displ_DE can be expected). Two initial displacements, forward and backward, are taken
by adding the resulting displacement vector (multiplied with +1 and -1, respectively) to the initial structure. If the
user requests the downhill direction (e.g. from a previous unconverged IRC run), it is assumed that the gradient is
nonzero and thus no initial displacement is carried out.

After the initial displacement the iterations of the IRC method begin. Each iteration consists of two main steps,
which each consist again of multiple SP and gradient runs:

1. Initial steepest descent (SD) step:

1. The gradient (grad0) of the starting geometry (G0) is normalized, scaled by Scale_Displ_SD, and the
resulting displacement vector (SD1) is applied to G0.

2. Optional (if SD_ParabolicFit is true): If SD1 increases the energy, a linear search is taken along the
direction of the displacement vector:

1. The displacement vector SD1 is scaled by 0.5 (SD2 = 0.5 x SD1) and again added to G0.

2. A parabolic fit for finding the displacement vector (SD3) which leads to minimal energy is carried
out using the three SP energies (G0, geometry after SD1 and after SD2 step). SD3 has the same
direction as SD1 and SD2, but can have a different length.

3. The keyword Interpolate_only controls whether the length of SD3 has to be in between 0 and and
the length of SD1. If that is the case, the maximum length is determined by SD1, the minimum
length is zero.

3. At the resulting geometry G1 (G0+SD1 or G0+SD3) the gradient is calculated (grad1).

2. Optional (if Do_SD_Corr is true): Correction to the steepest descent step:

1. Based on grad0 and grad1 a vector is computed which represents a correction to the first SD (SD1 or
SD3) step. This correction brings the geometry closer to the IRC.

2. This vector is normalized, scaled by Scale_Displ_SD_Corr times the length of SD1 or SD3, and the
resulting displacement vector (SDC1) is applied to G1.

3. Optional (if SD_Corr_ParabolicFit is true):

1. If the energy increases after applying step SDC1, SDC1 is scaled by 0.5 (SDC2 = 0.5 x SD1), if
the energy decreases, SDC1 is scaled by 2 (SDC2 = 2 x SD1). SDC2 is then added to G1.

**730** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

2. A parabolic fit for finding the displacement vector (SDC3) which leads to minimal energy is carried
out using the three SP energies (G1, geometry after SDC1 and after SDC2 step). SDC3 has the
same direction as SDC1 and SDC2, but can have a different length.

3. The keyword Interpolate_only controls whether the length of SDC3 has to be in between 0 and and
the length of SDC1. If that is the case, the maximum length is determined by SDC1, the minimum
length is zero.

4. At the resulting geometry G2 (G1+SDC1 or G1+SDC3) the gradient is calculated (grad2).

3. The gradient at the new geometry is checked for convergence.

4. Optional (if Adapt_Scale_Displ is true):

1. If the resulting overall step size is smaller than 0.5 times Scale_Displ_SD, Scale_Displ_SD is multiplied
by 0.5.

2. If the resulting overall step size is larger than 2 times Scale_Displ_SD, Scale_Displ_SD is multiplied
by 2.

3. Scale_Displ_SD may not become smaller than 1/16 times the initial Scale_Displ_SD and not larger
than 4 times the initial Scale_Displ_SD.

The following keywords are available:



(continues on next page)

**7.28. Intrinsic Reaction Coordinate** **731**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

NOTE

  - For direction=down (downhill) no initial displacement is necessary, and thus no Hessian is needed.
### **7.29 Nudged Elastic Band Method**

The Nudged Elastic Band (NEB)[384, 416, 586] method is used to find a minimum energy path (MEP) connecting
two local energy minima on the potential energy surface (PES) and thereby an estimate of the activation energy for
the transition. The two minima are referred to as the reactant and product in the following discussion. The path can
have one or more maxima, each one corresponding to a first order saddle point on the energy surface. The NEB
method offers an advantage over eigenvector-following methods in that it is guaranteed to find saddle points that
connect the given reactant and product states. The minimum energy path is often used to represent the reaction
coordinate of the transition between the two states. The methods and implementation outlined below are discussed
further in Ref. [4].

The user needs to specify the reactant and product configurations. The reactant energy minimum is inserted into
the regular ORCA input file while the product should be in a separate .xyz file (keyword: *neb_end_xyzfile* ). The
reactant and product configurations should be optimized *a priori* by relaxing to energy minima on the PES, see
section *Geometry Optimizations* . This can also be achieved via the ‘preopt_ends’ keyword. It is important to
carefully prepare the reactant and product such that the position (or index) of the atoms is the same in the two
configuration files, i.e. there should be one-to-one mapping between the reactant and product configurations.

The discretized path between the two minima is represented by a set of *𝑀* system configurations that are referred
to as images, i.e. **R** = [ *𝑟* 0 *, 𝑟* 1 *, ..., 𝑟* *𝑀* *−* 1 ]. The number of intermediate images between the end points (i.e. reactant and product) is specified by the user. The general rule of thumb is to include *𝑀* = 7 *−* 12, or 5 *−* 10
intermediate images per energy maximum in order to obtain a high enough resolution of the path and the saddle
point. However, calculations can often converge and give accurate results with fewer images but complex paths
with multiple maxima or long tails may require more images. During an NEB calculation the intermediate images
are iteratively shifted towards the MEP using the component of the atomic force that is perpendicular to the current
path as estimated from the tangent to the path at each image. While, the end point images are typically kept fixed.
In each step of the iterative process, the energy and atomic forces of each intermediate image need to be computed.
One of the main advantages of the NEB method is that the calculations of the images are carried out in parallel,
where the electronic structure computations can be distributed over multiple processors (see discussion below for
more details on the parallelization). While the CPU time is proportional to the number of images, the number of
iterations needed for convergence to the MEP can become smaller when more images are included in the discrete
representation of the path.

The tangent to the path at each image, ˆ *𝜏* *𝑖*, can be estimated in two ways (keyword: *tangent* ), either by the original
method [416] or by the more numerically stable improved [384] estimate (default option). In the former, the tangent
at an image is taken to be a linear combination of the two line segments that connect to image *𝑖*,


*𝜏* *𝑖* = *[𝑟]* *[𝑖]* [+1] *[ −]* *[𝑟]* *[𝑖]*


*|𝑟* *𝑖* *−* *𝑟* *𝑖−* 1 *|*



*[𝑟]* *[𝑖]* [+1] *[ −]* *[𝑟]* *[𝑖]* *[𝑟]* *[𝑖]* *[−]* *[𝑟]* *[𝑖][−]* [1]

*|𝑟* *𝑖* +1 *−* *𝑟* *𝑖* *|* [+] *|𝑟* *𝑖* *−* *𝑟* *𝑖−* 1


In the improved tangent estimate, the line segment from the current image to the adjacent image with higher energy
is used, i.e.


*𝜏* *𝑖* =


*𝜏* [+] if E *𝑖* +1 *>* E *𝑖* *>* E *𝑖−* 1
{︃ *𝜏* *[−]* if E *𝑖* +1 *<* E *𝑖* *<* E *𝑖−* 1


**732** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

where *𝜏* [+] = *𝑟* *𝑖* +1 *−* *𝑟* *𝑖* and *𝜏* *[−]* = *𝑟* *𝑖* *−* *𝑟* *𝑖−* 1 . With the exception of image *𝑖* being at an energy extremum along the
path, then an energy-weighted average of the two line segments to adjacent images is used,


*𝜏* *𝑖* =


*𝜏* [+] ∆ *𝑉* *𝑖* [max] + *𝜏* *[−]* ∆ *𝑉* *𝑖* [min] if E *𝑖* +1 *>* E *𝑖−* 1
{︃ *𝜏* [+] ∆ *𝑉* *𝑖* [min] + *𝜏* *[−]* ∆ *𝑉* *𝑖* [max] if E *𝑖* +1 *<* E *𝑖−* 1


where

∆ *𝑉* *𝑖* [max] = max( *|𝐸* *𝑖* +1 *−* *𝐸* *𝑖* *|, |𝐸* *𝑖−* 1 *−* *𝐸* *𝑖* *|* )

∆ *𝑉* *𝑖* [max] = min( *|𝐸* *𝑖* +1 *−* *𝐸* *𝑖* *|, |𝐸* *𝑖−* 1 *−* *𝐸* *𝑖* *|* )

Then the tangent is normalized, ˆ *𝜏* *𝑖* = *𝜏* *𝑖* */|𝜏* *𝑖* *|* . With an accurate estimate of the tangent, the perpendicular component
of the atom force is computed by,

*𝐹* *𝑖* *[⊥]* = *𝐹* *𝑖* *−* ( *𝐹* *𝑖* *·* ˆ *𝜏* *𝑖* ) ˆ *𝜏* *𝑖*

In the free-end NEB method, the endpoint images are optimized simultaneously along with the intermediate images, i.e. *𝑀* movable images are used. Three different variants of the free-end NEB method (keywords: *free_end*,
*free_end_type* ) are included in ORCA: where (i) the endpoints are restrained to move along the same (or separate) energy isocontour[5, 921], (ii) according to the atomic force acting perpendicular to the path and (iii) the full
atomic force. For the first variant, the ‘reactant’ and ‘product’ endpont images, can be restrained to move along
two different energy contours, *𝐸* 0 (given by keyword: *free_end_ec* ) and *𝐸* 1 (given by keyword: *free_end_ec_end* ),
to keep the path bounded. Then, if the images drift away from the isocontour because of curvature of the energy
surface, an harmonic restraint term is used to pull the image back to the contour.[5] The stiffness of the harmonic
restraint is given by a user-supplied parameter (keyword: *free_end_kappa* ). It is important to carefully select the
energy values and the strength of the harmonic restraint, otherwise the path may become kinked. For the second
variant, the endpoint images are unbounded but displaced directly towards the MEP. This is typically acceptable if
the endpoint images are already in vicinity to the MEP and is less prone to kinks developing along the path. For
the third variant, the endpoint images become optimized to the reactant and product energy minimum.

**7.29.1 Spring forces**

In order to control the distribution of the images along the path, spring forces are included to act between adjacent
images, tangential to the path[416],

ˆ
*𝐹* *𝑖* [sp] *[,][‖]* = (︀ *𝑘* *𝑖* [sp] *[|][𝑟]* *[𝑖]* [+1] *[ −]* *[𝑟]* *[𝑖]* *[| −]* *[𝑘]* *𝑖* [sp] *−* 1 *[|][𝑟]* *[𝑖]* *[−]* *[𝑟]* *[𝑖][−]* [1] *[|]* )︀ *𝜏* *𝑖*

The magnitude of the spring forces (i.e. stiffness) is controlled by spring constants, *𝑘* [sp] . The typical values of the
spring constant (keyword: *springconst* ) can be taken to be within the range of 0.01 Eh/Bohr [2] to 1.0 Eh/Bohr [2] .
If the spring constants are choosen to be the same for all pairs of adjacent images, the images will be equally
distributed along the path. However, it is also possible to choose energy-weighted spring constants (keyword:
*energy_weighted* ) so as to increase the density of images in the higher energy regions[4, 385]. In an energyweighted NEB calculation the spring constants are scaled according to the relative energy of the images, from a
lower-bound value (keyword: *springconst* ) to an upper-bound value (keyword: *springconst2* ), by

(1 *−* *𝛼* *𝑖* ) *𝑘* u + *𝛼* *𝑖* *𝑘* l *,* if *𝐸* *𝑖* *> 𝐸* ref
*𝑘* *𝑖* [sp] [=] { *𝑘* *𝑙* *,* otherwise

*𝛼* *𝑖* = *[𝐸]* [max] *[ −]* *[𝐸]* *[𝑖]*

*𝐸* max *−* *𝐸* ref

where *𝑘* u and *𝑘* l are the upper- and lower-bound values for the spring constant. *𝐸* max is the current estimate of the
maximum energy along the path, *𝐸* *𝑖* is the higher energy image of the pair of images connected by line segment *𝑖*
and *𝐸* ref is the energy of the higher energy minimum. The energy-weighted springs will typically serve to improve
the tangent estimate in the barrier region and hence stabilize the calculations. The inclusion of energy-weighted
springs can be important in reactions where the energy barrier is narrow and/or the pathway is characterized by a
long ‘energy tail’, e.g., in rearrangements or dissociation reactions. The choice of spring constants will affect the
behavior of a calculation, especially the number of iterations needed to reach convergence. Other formulations for
spring forces are also available since ORCA 4.2 (keyword: *springtype* ). These are referred to as the original[416]
and ideal[554] spring forces. The original spring forces are estimated by a spring acting on each degree of freedom

**7.29. Nudged Elastic Band Method** **733**

**ORCA Manual** **,** **Release 6.0.1**

between a pair of adjacent images. For ideal springs each image is assigned an ideal position along the path based
on a linear interpolation of the current location of the images and the individual images interact with the ideal
locations via spring forces. The ideal springs are currently not implemented to work with energy weighted spring

constants.

While only the component of the spring force parallel to the path is included in an NEB calculation (by default) the
user can choose to include a fraction of the spring force acting perpendicular to the path to stabilize calculations
(keyword: *perpspring* . Since, the perpendicular component of the spring force can serve to straighten out the path
and is useful for complex pathways with multiple energy extrema and low resolution of the path. The inclusion
of the perpendicular component of the spring force is always accompanied by a switching function that is used to
scale it according to (i) convergence to the MEP (the ‘tan’ function)[792] (ii) the angle between adjacent images
(the ‘cos’ function)[416] or a combination of both. The inclusion of the perpendicular spring force can help to
reduce the number of iterations and eliminate kinks on the path. However, it is important to stress that by inclusion
of the perpendicular spring forces, the images may not converge on the MEP. Alternatively, the user can choose to
use the modified DNEB method[792, 854].

**7.29.2 Optimization and convergence of the NEB method**

The effective force used in a standard NEB calculations is the sum of the atomic force component perpendicular
to the path and the spring force component parallel to the path,

*𝐹* *𝑖* [NEB] = *𝐹* *𝑖* *[⊥]* [+] *[ 𝐹]* *𝑖* [sp] *[,][‖]*

The path can be brought to the MEP by moving according to the effective force, as is shown in Fig. 7.21.

Fig. 7.21: Visualization of the effective force, *𝐹* [NEB] and its two components: *𝐹* *𝑖* *[⊥]* [and] *[ 𝐹]* *𝑖* [sp] *[,][‖]* for three images along
an intermediate path in a NEB optimization. The figure is taken from Ref. [3]

This can be achieved by using any of the three optimization methods implemented (keyword: *opt_method* ): velocity
projection optimization (VPO)[416], fast inertial relxation engine (FIRE)[108] and L-BFGS[636]. VPO and FIRE
are more robust for regions that are far from the MEP, while L-BFGS converges faster when the images are close
to the MEP. FIRE and VPO both have a local and global implementation (keyword: *local* ). In the local variant,
all of the images are treated individually when taking an optimization step, while in the latter the whole band is
treated as a single point. A constant ‘trust-radius’ is used for all optimization methods, where if the magnitude of

**734** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

the maximum Cartesian component of an optimization step exceeds a user-supplied threshold (keyword: *maxmove* ),
the whole displacement is scaled down accordingly. The number of steps stored in the L-BFGS optimization for
the construction of the approximate Hessian matrix can be adjusted by the user (keyword: *lbfgs_memory* ). For a
more conservative optimization with L-BFGS, the memory can also be erased if a large step is attempted (keyword: *lbfgs_restart_on_maxmove* ).

The convergence of the intermediate images is gauged from the maximum Cartesian component of the perpendicular atom force as well as the root-mean-square, i.e. max( *|* **F** *[⊥]* *|* ) *,* RMS( **F** *[⊥]* ). The atomic force on the images
perpendicular to the path vanishes as the images are located on the MEP. A typical value of the tolerance for the
maximum component of the atomic force perpendicular to the path is 1 *·* 10 *[−]* [3] Eh/Bohr. Typically the tolerance
for the root-mean-square value is chosen to be smaller by a factor of 1/2 or 1/3. Sometimes a tighter tolerance for
the maximum component of the force is needed, for example 5 *·* 10 *[−]* [4] Eh/Bohr or even 2 *·* 10 *[−]* [4] Eh/Bohr. The
maximum number of optimization steps allowed is set by the keyword ‘maxiter’.

The configuration of each image after each iteration is written to a ‘_trj.xyz’ file (see file:
basename_MEP_ALL_trj.xyz). This file is useful for troubleshooting non-convergent calculations.

**7.29.3 Climbing image NEB**

In order make the highest energy image converge more accurately to the (highest) energy maximum along the MEP,
the climbing image variant of the NEB method (CI-NEB) can be used. [385] In the CI-NEB method, the effective
force *𝐹* [NEB] acting on the climbing image (i.e. *𝑖* = ci) is transformed to:

*𝐹* ci [NEB] = *𝐹* ci *−* 2 ( *𝐹* ci *·* ˆ *𝜏* ci ) ˆ *𝜏* ci

where the climbing image is pushed up-hill along the path and relaxed down-hill perpendicular to the path. That is,
the energy is maximized with respect to one degree of freedom corresponding to the direction of the tangent while
the energy is minimized with respect to all other degrees of freedom. The effective force on the climbing image
does not include any spring force and the density of images then becomes different on either side of the climbing
image. As long as the tangent estimate is accurate enough the climbing image will converge rigorously to the point
of highest energy along the path. An illustration of how the climbing image NEB method works is shown in Fig.
7.22 for a simple two-dimensional energy function.

**7.29. Nudged Elastic Band Method** **735**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.22: Illustration of how the CI-NEB method works on a two-dimensional Müller-Brown energy surface,
*𝐸* ( *𝑥, 𝑦* ).[539] The calculation is started from a linear interpolation between the reactant ( **R** ) and product ( **P** ) energy
minima, using *𝑀* = 10. The images are displaced in the orthogonal direction to the path (red curves), until they
converge to the minimum energy path (white dashed curve). The climbing image accurately locates the higher
energy first order saddle point along the path (denoted by **SP** ). The optimization profile is shown as an inset. In
such a plot the interpolated energy along the path is plotted as a function of displacement, for each (or selected)
optimization step. The figure is taken from Ref. [3]

It can be useful to start the climbing image after the magnitude of the atomic forces perpendicular to the path
drops below a given user supplied threshold (keyword: *tol_turn_on_ci* ). Then, the highest energy image along
the current path is converted to a climbing image. It is usually most efficient to initiate the climbing image early
on or even from the start of the NEB calculation. This applies when using the VPO optimization method. For LBFGS it is recommended to start CI-NEB when the path has partially converged to the MEP, e.g., around 0.01-0.02
Eh/Bohr. If there are two or more maxima in the energy along the MEP it is possible that the image near the highest
maximum is not chosen as the climbing image at an early stage of the NEB calculation. Then, later on the choice
of the climbing image can be switched automatically. Also, for barrierless reactions, the climbing image is not
turned on. The atom coordinates of the climbing image (in a CI-NEB calculation) or the highest energy image (in
an NEB calculation) are written to files ‘_NEB-CI_converged.xyz’ and ‘_NEB-HEI_converged.xyz’, respectively,
when a calculation has successfully completed.

The convergence of a CI-NEB calculation can either be gauged by monitoring the forces on all images or only on
the climbing image, (keyword: *convtype* ). The latter option may be used when the objective of the calculation
is to locate the highest energy saddle point connecting the reactant and product states and can save significant
computational effort. To gauge for convergence on the climbing image, both the root-mean-square and magnitude
of the maximum (Cartesian) component of the atom force are monitored, i.e. max( *|* **F** ci *|* ) *,* RMS( **F** ci ). When gauging
the convergence of all images in a CI-NEB calculation it is typically acceptable to converge the regular images more
loosely than the climbing image. By default, the tolerance for the regular images is a factor of 10 larger than that of
the climbing image. This scaling of the tolerances is a parameter that can be set by the user (keyword: *tol_scale* ).
Typically for an acceptable convergence to the saddle point, the tolerance threshold for the maximum magnitude

**736** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

of an atomic force component of the climbing image can be set to 5 *·* 10 *[−]* [4] Eh/Bohr.

**7.29.4 Generation of the initial path**

One of the most important aspects of any NEB or CI-NEB calculation is the generation of the initial path
between the reactant and product energy minima (keyword: *interpolation* . The recommended method is
the image-dependent pair potential (IDPP) method [808]. An alternative and simpler method is linear interpolation in Cartesian coordinates. In either case, the user should always inspect the initial path (see file:
basename_initial_path_trj.xyz) to make certain that it is acceptable.

By default, the endpoint structures are scanned for covalently linked fragments. If two fragments are detected
in either of the endpoint structures, the structure is automatically prepared such that the distance between the
fragments is no larger than a maximum distance defaulted to 3.5 Angstrom.

The linear interpolation in Cartesian coordinates may result in overlap of atoms leading to large, initial, atomic
forces and even divergence in the SCF cycles. The IDPP method solves these problems by interpolating pairwise
distances between neighboring atoms in the reactant and product energy minimum. Then, a path is generated to
match those distances as closely as possible. Since there are many more pairwise distances than atom coordinates,
the initial path is found by minimizing the objective function,


*𝑀*
∑︁ *𝑤* ( *𝑑* *𝐴𝐵* ) ( *𝑑* *[𝜅]* *𝐴𝐵* *[−]* *[𝑑]* *[𝐴𝐵]* [)] [2] (7.218)

*𝐵>𝐴*


*𝑆* *𝜅* [IDPP] ( *𝑟* *𝑖* ) =


*𝑀*
∑︁

*𝐴*


where *𝑑* *𝐴𝐵* is the pairwise distance between atoms *𝐴* and *𝐵* for intermediate image *𝑖* . *𝑑* *[𝜅]* *𝐴𝐵* [is the ideal interpolated]
distance between atoms *𝐴* and *𝐵* of the same image. *𝑤* is a weight-function to give shorter bond distances more
weight and make unnecessary bond-breaking unfavorable. The weight function is given as *𝑤* = ( *𝑑* AB ) *[−]* [4] . The IDPP
path avoids the overlap of atoms and can also generate a path that is closer to the MEP than the linear interpolation
in Cartesian coordinates[808]. The IDPP path is obtained from an NEB calculation using the IDPP objective
function starting from a linear interpolation of the Cartesian coordinates between the endpoint structures, but this
calculation requires little computational effort since it does not require any electronic structure computations. Note
that it is possible that the initial path breaks covalent bonds and that it can be far from the optimal MEP, so the user
should always inspect the initial path before starting an NEB calculation. The user can adjust the settings of the
IDPP calculations using the ‘idpp’ related keywords, but the default values should suffice for most applications.
Note that the units of the IDPP are in Ångströms instead of atomic units. The matrix of ideal interpolated distance
between the atoms *𝐴* and *𝐵* at image *𝑖*, *𝑑* *[𝜅]* *𝐴𝐵, 𝑖* [, is most simply obtained by linear interpolation as]

*𝑑* *[𝜅]* *𝐴𝐵, 𝑖* [=] *[ 𝑑]* *𝐴𝐵* *[𝑖𝑛𝑖𝑡𝑖𝑎𝑙]* + *𝑃* *𝑖* *** (︁ *𝑑* *[𝑓𝑖𝑛𝑎𝑙]* *𝐴𝐵* *−* *𝑑* *[𝑖𝑛𝑖𝑡𝑖𝑎𝑙]* *𝐴𝐵* )︁ *,*

where *𝑃* *𝑖* = *𝑛* *𝑖𝑚* *𝑖* *−* 1 [is the position of image] *[ 𝑖]* [on the path between 0, corresponding to the initial image, and 1,]
corresponding to the final image, and *𝑛* *𝑖𝑚* is the total number of images.

As this linear distance interpolation may not be ideal, one can alternatively choose a bilinear distance interpolation
scheme that takes atomic bonds into account. Bonds between the atoms *𝐴* and *𝐵* in the initial and final images
are identified if their distance *𝑑* *𝐴𝐵* *< 𝑡* *𝑏𝑜𝑛𝑑* = *𝑡* *𝑐* ( *𝑅* *𝐴* *[𝑐𝑜𝑣]* + *𝑅* *𝐵* *[𝑐𝑜𝑣]* [)] *[,]* [ where] *[ 𝑡]* *[𝑐]* [is an input factor impacting at what]
distances a bond is detected by default taken to be 1.2, and *𝑅* *𝑋* *[𝑐𝑜𝑣]* is the covalent radius of atom *𝑋* . If a bond is
detected in one of the endpoint structures but not the other, two linear distance interpolations are performed to
obtain *𝑑* *[𝜅]*
*𝐴𝐵,𝑖* [. The first interpolates the distance between the endpoint structure in which the atoms are bonded and]
*𝑡* *𝑏𝑜𝑛𝑑*, the second interpolates the distance between *𝑡* *𝑏𝑜𝑛𝑑* and the endpoint structure in which the bond is broken.
The two linear distance interpolations are joined at the path position *𝑃* *𝑗𝑜𝑖𝑛* defaulted to 0.5, corresponding to the
midpoint on the path between the endpoint images. If the atoms are bonded in the initial structure but not in the
final structure, the interpolation is


*𝑑* *[𝜅]*
*𝐴𝐵, 𝑖* [=]


⎧ *𝑃* *𝑖* ( *𝑡* *𝑏𝑜𝑛𝑑* *−𝑑* *[𝑖𝑛𝑖𝑡𝑖𝑎𝑙]* *𝐴𝐵* )

*𝑑* *[𝑖𝑛𝑖𝑡𝑖𝑎𝑙]* *𝐴𝐵* + *𝑃* *𝑗𝑜𝑖𝑛* *,* if *𝑃* *𝑖* *< 𝑃* *𝑗𝑜𝑖𝑛*

⎨⎩ *𝑑* *[𝑓𝑖𝑛𝑎𝑙]* *𝐴𝐵* *−* (1 *−𝑃* (1 *𝑖* ) ( *.* 0 *𝑑−* *[𝑓𝑖𝑛𝑎𝑙]* *𝐴𝐵* *𝑃* *𝑗𝑜𝑖𝑛* *−𝑡* ) *𝑏𝑜𝑛𝑑* ) *,* if *𝑃* *𝑖* *≥* *𝑃* *𝑗𝑜𝑖𝑛* *.*


⎧
⎨


*𝑑* *[𝑓𝑖𝑛𝑎𝑙]* *𝐴𝐵* *−* (1 *−𝑃* (1 *𝑖* ) ( *.* 0 *𝑑−* *[𝑓𝑖𝑛𝑎𝑙]* *𝐴𝐵* *𝑃* *𝑗𝑜𝑖𝑛* *−𝑡* ) *𝑏𝑜𝑛𝑑* ) *,* if *𝑃* *𝑖* *≥* *𝑃* *𝑗𝑜𝑖𝑛* *.*


If the atoms are bonded in the final structure but not in the initial structure, the interpolation is


*𝑑* *[𝜅]*
*𝐴𝐵, 𝑖* [=]


⎧ *𝑑* *[𝑖𝑛𝑖𝑡𝑖𝑎𝑙]* *𝐴𝐵* *−* *𝑃* *𝑖* ( *𝑑* *[𝑖𝑛𝑖𝑡𝑖𝑎𝑙]* *𝐴𝐵* 1 *−𝑃* *𝑗𝑜𝑖𝑛* *−𝑡* *𝑏𝑜𝑛𝑑* ) *,* if *𝑃* *𝑖* *<* 1 *−* *𝑃* *𝑗𝑜𝑖𝑛*
⎨ (1 *−𝑃* *𝑖* ) ( *𝑡* *𝑏𝑜𝑛𝑑* *−𝑑* *[𝑓𝑖𝑛𝑎𝑙]* *𝐴𝐵* [)]

⎩ *𝑑* *[𝑓𝑖𝑛𝑎𝑙]* *𝐴𝐵* + *𝑃* *𝑗𝑜𝑖𝑛* *,* if *𝑃* *𝑖* *≥* 1 *−* *𝑃* *𝑗𝑜𝑖𝑛* *.*


⎧
⎨


(1 *−𝑃* *𝑖* ) ( *𝑡* *𝑏𝑜𝑛𝑑* *−𝑑* *[𝑓𝑖𝑛𝑎𝑙]* *𝐴𝐵* [)]
*𝑑* *[𝑓𝑖𝑛𝑎𝑙]* *𝐴𝐵* + *𝑃* *𝑗𝑜𝑖𝑛* *,* if *𝑃* *𝑖* *≥* 1 *−* *𝑃* *𝑗𝑜𝑖𝑛* *.*


**7.29. Nudged Elastic Band Method** **737**

**ORCA Manual** **,** **Release 6.0.1**

This bilinear interpolation leads to a slower increase of the atom distance in the bonded region compared to the
non-bonded region in most cases, emphesizing the bond breaking process and thus the region where the energy is
changed most by a change in the bond distance. If the change in the bond distance in the non-bonded region is slower
than the change in the bonded region, the implementation falls back to the regular linear distance interpolation.

In challenging cases, even the IDPP NEB calculation starting from a linear interpolation of the Cartesian coordinates between the endpoint structures may not provide a reasonable initial path. This may happen when the linear
interpolation path has atoms come very close to each other in intermediate images, which leads to bond breaking
even after NEB optimization using the IDPP objective function. In such cases, a reasonable initial path can often be obtained by avoiding the linear interpolation by sequentially adding images to the path starting from both
endpoint structures instead. This method is referred to as sequential IDPP (S-IDPP).[766] The two sets of images
close to each endpoint structure are separated by a larger distance than the images in each set by choosing a smaller
spring constant than between the images in each set where equal spring constants are used. The images closest to
the center are converged in an NEB calculation and an image added at an appropriate distance from the converged
image between the two images closest to the center. This process is repeated until the requested amount of images
has been added. The tangent of the images closest to the center follows the improved tangent definition and always
treats them as extrema on the path, i.e. an average of the normalized distance vectors to the adjacent images is
used. The number of images used to form the S-IDPP initial path can be different from the number of images used
in the subsequent NEB calculation involving electronic structure calculations. It can be benficial to use an even
number of images in the S-IDPP computation since no image is placed at the center of the initial path then and
moving to the requested odd number of images in an additional IDPP NEB calculation afterwards. This option is
used by default, but can be deactivated. For systems involving very heavy rotations of large groups, the method
becomes more robust when twice the amount of images is used in the S-IDPP calculation. Half the images are then
removed automatically for the subsequent NEB calculation involving electronic structure calculations. This option
is available, but not used by default.

The user may have a preconceived notion of the saddle point configuration or have an estimate of the path from
a calculation carried out at a lower level of theory. The initial path can be generated in such a way as to include
an intermediate configuration as one of the images using the ‘NEB_TS_XYZFile’ keyword. Since this image will
be optimized along with the other intermediate images during the NEB calculation the guess does not have to be

accurate.

If inspection of the initial path reveals problems, e.g., unnecessary bond breaking, it is often a good idea to insert
a reasonable configuration into the initial interpolation to avoid such problems. Moreover, if an NEB calculation
is unable to converge to the MEP (or saddle point) with the given maximum number of iterations, the user can
restart the calculation from the ‘allxyz’ file (see file: basename_MEP.allxyz) which is written to the disk after each
iteration during the optimization. Note, when starting an NEB calculation from an output from a previous CI-NEB
calculation and vice-versa the band may require a few iterations to adjust the distribution of images to achieve the
desired distribution, depending on the selected spring type and the choice of NEB method.

If the system can be modeled reasonably well using the GFN-xTB method, another possible choice is the generation
of an initial path on XTB level (keywords ‘XTB0’, ‘XTB1’ or ‘XTB2’ for GFN0-xTB[699] GFN-xTB[332] or
GFN2-xTB[70]). In this case the initial path on IDPP level is refined using an NEB calculation on the chosen XTB
level. If this NEB run is successful, the entire MEP on XTB level is used as the initial path. If the NEB run on
XTB level is not successful, the initial path on IDPP level is used instead.

Another keyword that makes use of the XTB method is the ‘XTBTS’ keyword (‘XTB0TS’, ‘XTB1TS’ or
‘XTB2TS’). In this case the initial path on IDPP level is refined using an NEB-CI calculation on XTB level.
If the NEB-CI run is successful, the resulting CI structure is chosen as TS guess structure, and the final initial path
is generated using an IDPP path from reactant to TS guess and from TS guess to product. If the NEB-CI run on
XTB level is not successful, the initial path on IDPP level is used instead.

**738** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.29.5 Removal of translational and rotational degrees of freedom**

For NEB and CI-NEB calculations of molecular systems it is important to project out the six (or five in the case
of linear molecules) degrees of freedom corresponding to the global rotation and translation of the system. This
can be done either at the start of a calculation or for each optimization step (keyword: *quatern* ). For the latter, the
center-of-geometry of each image is translated to origin and a rotational matrix is constructed using the quaternion approach[577] to minimize the root-mean-square deviation between any two adjacent images. Depending on
whether a fixed center is used (keyword: *fix_center* ), the images are either kept in that place or transferred back to
their original position. This procedure is repeated for any pair of adjacent images in each step of the optimization.
Also, the net effective NEB force is set to zero (keyword: *remove_extern_force* ).[434]

**7.29.6 Reparametrization of the path**

In some cases it may be beneficial to enable redistribution of the images along the path every *𝑁* iterations (i.e.
analogous to the string method[240]) (keyword: *reparam* ). The path is then interpolated using either a linear
or cubic polynomial fitted to both the coordinates and the tangent to the path, and the images are redistributed
evenly along the interpolated path. Both *𝑁* and the type of interpolation are specified by the user (keyword:
*reparam_type* ). The cubic interpolation method should be better in calculations where the resolution of the path
and hence the estimate of the tangent is good, while the linear interpolation is generally more robust as it does not
as dependent on the tangent as much.

**7.29.7 Useful output**

After each iteration, the energy profile along the path is obtained by making a piecewise cubic polynomial interpolation using both the energy and the component of the atom force tangentinal to the path[384]. The interpolation
can reveal important information about the MEP in locations between the intermediate images. The interpolation
is written to the file ‘interp’ (see file: basename.interp) in each step of the optimization. Moreover, as NEB and
CI-NEB calculations can be quite computationally demanding and in order to properly analyze what may have
gone wrong in such a calculation, the user can inspect the ‘.log’ file, which includes information about the type of
calculation, energy, length of the path, spring forces, atomic forces etc.

**7.29.8 Important warning messages**

Some tests are carried out during the optimization in order to detect problems on the fly. The angle between the
two straight lines going through an image and its neighbors on each side is calculated. If the angle becomes large
e.g. exceeding 90 *[∘]* the estimate of the tangent has likely become inaccurate and a better resolution of the path is
required. If the angle is close to 180 *[∘]* the ordering of the images may have become incorrect. Especially in the latter
case, it may be a good choice of action to terminate the calculation and include a larger number of intermediate
images in the subsequent calculation. Some information from the calculation, e.g, a guess for the saddle point,
could be incorporated in the new calculation.

Another issue is the identification of an intermediate minimum along the path. If an intermediate minimum is
observed in *𝑀* subsequent iterations ( *𝑀* is supplied by the user) a warning is issued to the user that a possible
intermediate minimum may exist along the path. It is a good idea to check the status of the calculation, the path and
the convergence behaviour. If the calculation appears to be proceeding normally and heading for convergence, the
best course of action is to allow the calculation to finish. However, it is in general better to carry out separate NEB
calculations for segments of the MEP on either side of the intermediate minimum. Especially, if the intermediate
minimum is deep w.r.t to the reactant and product state energy minima.

In such cases, the image closest to the apparent intermediate minimum is selected and a structural minimization
carried out. The resulting configuration is then used as the initial state or final state in the subsequent CI-NEB
calculations.

**7.29. Nudged Elastic Band Method** **739**

**ORCA Manual** **,** **Release 6.0.1**

**7.29.9 Parallel execution**

If the number of processes (NProcs) specified in the input is larger than 1, NEB will automatically start up in
multi-processes mode:

**NProcs <= NImages**

NProcs processes will handle NProcs images independently with 1 process per image. Choose NProcs =
X*NImages (e.g. X = 1 or 0.5)

**NProcs > NImages**

NProcs processes will handle NImage images, each image being treated by (NProcs/ NImages) processes.
If you want to dedicate more than 1 process to each single image-calculation, choose NProcs = X*NImages
(e.g. X = 2, 3, 4, ...).

Note: If in the second case multiple compute-nodes are involved, the user will need to define the ORCA specific
environment variable RSH_COMMAND, which tells the NEB driver how to connect to the individual nodes (set
it to either ‘rsh’ or ‘ssh’). However, this may not work with all queueing systems.

If the energy and force calculations are fast (e.g. with semiempirical methods), there is no gain in using multiple
processes per image. Starting up and finalizing MPI may consume more time than the gain from parallel processing.

**7.29.10 zoomNEB**

A preliminary version of the Zoom-NEB (Z-NEB) method has been included this implementation, where the objective of the method is to locate a saddle point more accurately with a better resolution compared to CI-NEB
calculations. The Z-NEB method is an automatic two step procedure, where in the first step a CI-NEB calculation
is carried out to obtain a rough convergence towards the MEP. Then, the region surrounding the highest energy
maximum along the path is identified and a new set of images distributed along this region. In the second step, a
free-end CI-NEB calculation is started from this new path. In this calculation, the endpoints are optimized according to the atom force acting perpendicular to the path. This will ensure that the endpoints of the second CI-NEB
calculation will converge to the MEP, as well. Furthermore, to maintain the parallelization of the CI-NEB method,
same number of movable images are used in the first and second CI-NEB calculations.

**7.29.11 NEB-TS**

Probably the most efficient saddle point search methods are obtained when double ended methods (e.g. NEB)
are combined with single ended methods (e.g., eigenvector-following). In the current implementation, a combination of EW-CI-NEB and EF P-RFO (eigenvector-following partitioned rational function optimization) methods is
presented and referred to as the NEB-TS method [4].

In NEB-TS, the EW-CI-NEB method is used to partially converge to the MEP and hence saddle point, i.e., the
optimization of the images along the MEP is halted once the climbing image is converged to a prescribed tolerance.
Then, the climbing image is used to provide a subsequent eigenvector-following calculation with an accurate initial
guess configuration, as is shown in Fig. 7.23 and the tangent at the CI is used to select the eigenvector to be followed.
The tangent estimate should already provide an accurate approximation to the unstable mode at the saddle point.
The initial Hessian matrix needed for the eigenvector-following calculation can either be computed analytically
(if available) or taken as the Almlöf empirical Hessian matrix [264]. If the Almlöf Hessian matrix is used, the
curvature at the CI is estimated by using a finite difference approximation (i.e. using the atom force acting on the
neighboring images to CI) and used to scale the corresponding eigenvalue of the selected eigenvector, allowing the
eigenvector-following calculation to be started from a Hessian matrix of correct form. The typical ‘%geom’ block
can be used to modify the settings of the eigenvector-following calculation.

**740** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.23: Illustration of how the NEB-TS method works on a two-dimensional Müller-Brown energy surface,
*𝐸* ( *𝑥, 𝑦* ) [539]. The calculation is started from a linear interpolation between the reactant and product energy
minima, using *𝑀* = 10. The images are displaced in the orthogonal direction to the path (red curves) using the
CI-NEB algorithm, until a rough convergence to the minimum energy path (white dashed curve) is obtained. The
climbing image then provides an approximate saddle point configuration that can be used to start eigenvectorfollowing partitioned rational function optimization to accurately (and swiftly) identify the (higher energy) first
order saddle point. The figure is taken from Ref. [4]

**7.29.12 FAST-NEB-TS and LOOSE-NEB-TS**

Since our first NEB-TS implementation, we investigated a lot more settings and variants, see [4]. Based on those
findings, two new algorithms and convergence threshold settings have been implemented into ORCA. FAST-NEBTS corresponds to the IDPP-TS in the paper, and LOOSE-NEB-TS corresponds to the actual NEB-TS defaults,
which are defined in the paper. Both features, FAST- and LOOSE-NEB-TS, show slightly lower robustness, but
need significantly less NEB cycles.

**7.29.13 NEB / NEB-TS and TD-DFT**

The NEB and NEB-TS algorithm now also works in combination with TD-DFT. The input:



not only computes the MEP and TS of the first excited state, but it also prints out (after NEB convergence) the
excited state as well as ground state energies over the MEP:



(continues on next page)

**7.29. Nudged Elastic Band Method** **741**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

You can even request an NEB-TS calculation on the ground state PES, and at the same time gain information on
the excited PES via the input:



During this NEB calculation, only ground state energies and gradients are computed. Only after NEB convergence,
the additional excited state energies are computed on each image, in order to yield the ordering of the states on the
MEP:



**7.29.14 Summary of Keywords**

The following keywords are available:



(continues on next page)

**742** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
%neb
  Product "product.xyz" # product structure. Input is mandatory.
  NImages 8 # default 8. Number of images without fixed endpoints,
            # for free_end total number of images
  PrintLevel 1 # default 1. Normal printout. Use 0 for no printout, higher
            # numbers (<=4) for more detailed printout.
  TS "TSGuess.xyz" # Provide guess for the TS structure. Images
                  # are interpolated between reactant and TS guess
                  # and between TS guess and product.
  NEB_TS_Image 3 # default -1. Number of the image the TS guess is used for.
            # If not defined (=-1), the image which gives lowest RMSD
            # for all image distances is used.
 # Restart option: After each iteration the NEB method stores all image
 # structures in an .allxyz file. In case of an abort this file can be used
 # for a restart. File should contain the structures for all images.
  Restart_ALLXYZFile "NEB1.allxyz"# use the trajectory from file if filename is
                  # provided
 # Alternatively NEB can be started on user prepared wavefunctions for each image.
 # The names of of these wavefunction files should consist of a user-chosen basename
 # and the extension '_imN.gbw', where N is the image number.
 # The basename should be provided in the input, ORCA will add extension '_imN.gbw'
  Restart_GBW_BaseName "NEB2" # use the wavefunctions from file NEB2_imN.gbw
 # Check SCF convergence: If true, SCF convergence is checked for and
 # calculation aborts if:
 # -any of the images does not show SCF convergence in four subsequent cycles.
 # -any of the images does not show SCF convergence in two subsequent cycles
 # after the gradient is converged.
  CheckSCFConv true # default true
 # PDB file input format:
  Product_PDBFile "product.pdb" # Product structure in pdb format. If this is
                  # given, xyz does not need to be given.
  TS_PDBFile "TSGuess.pdb" # TS guess structure in pdb format. If this is
                  # given, xyz does not need to be given.
  Free_End false # Use free-end NEB. In this case the NImages
                  # corresponds to the total number of images.
  PreOpt false # do optimization of reactant and product in
                  # internal coordinates before NEB starts
  NSteps_FoundIntermediate 30 # Number of steps the intermediate has to be
                  # present
  AbortIf_FoundIntermediate false # If an intermediate is found abort the run.
  NPTS_Interpol 10 # Number of abscissa in cubic polynomial
                  # interpolation
  Interpolation IDPP # Method to generate the images based on the
                  # reactant, product (and potentially TS guess)
                  # linear
                  # IDPP
                  # XTB0TS - TS on GFN0-xTB level
                  # XTB0 - entire path on GFN0-xTB level
                  # XTB1TS - TS on GFN1-xTB level
                  # XTB1 - entire path on GFN1-xTB level
                  # XTB2TS - TS on GFN2-xTB level
                  # XTB2 - entire path on GFN2-xTB level
  Prepare_Frags true # Analyze endpoint structures for fragments.
                  # If two fragments are detected in an
                  # endpoint structure, reduce distance to
                  # maximum distance given by Max_Frag_Dist

```
(continues on next page)

**7.29. Nudged Elastic Band Method** **743**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
  Max_Frag_Dist 3.5 # Maximum allowed fragment distance. If they
                  # are farther apart, reduce the distance to
                  # this value (Ang.)
  Bond_Cutoff 1.2 # Factor to multiply sum of covalent radii of
                  # two atoms by. If the distance is smaller
                  # than the result, the atoms are considered
                  # bonded.
 # The formulation used to estimate the tangent to the path
  Tangent improved # improved (default)
                  # original
 # The type of the spring interaction parallel to the path. Original springs apply
 # spring interaction between each degree of freedom of adjacent images, while
 # 'image' springs apply a spring interaction between the images
 # Spring type
  SpringType image # image / distance (default)
                  # dof / original
                  # ideal
  SpringConst 0.01 # The spring constant used to scale the spring
                  # forces parallel to the path. If energy-weighted
                  # springs are used. This parameter gives the
                  # lower bound value of the spring constant
  SpringConst2 0.1 # If energy-weighted spring forces are used.
                  # This parameters give the value for the upper
                  # bound value of the spring constant.
  Energy_Weighted true # Employ energy-weighted springs. When
                  # energy-weighted springs are used, the
                  # images tend to accumlate in higher energy
                  # regions of the path.
 # The type of the spring interaction perpendicular to the path. The perpendicular
 # spring is introduced via a scaling function: cos, tan, costan, which all use
 # the spring component perpendicular to the path.
 # DNEB is the doubly nudged elastic band method.
  PerpSpring no # no (default)
                  # cos
                  # tan
                  # cosTan
                  # DNEB
  LLT_Cos true # Enables the cos-type spring force
                  # acting perpendicular to the band.
 # Translational and rotational degrees of freedom
 Quatern always # no,
                # startonly
                # always (default)
 # Fix_center specifies whether the centroid of each image should be
 # constrained to the origin of the coordinate system or to the center
 # of each image individually.
 Fix_center True
 # Fix_center specifies whether the centroid of each image should be
 # constrained to the origin of the coordinate system or to the center
 # of each image individually.
 Remove_extern_Force True # Removes the net effective NEB force before
                # translation of the path
 # Options for Free-End NEB
  Free_End_Type Perp # Type of optimization of endpoints in free-end

```
(continues on next page)

**744** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
                # NEB.
                # contour - constrain end points to a fixed
                # contour with energy EC, see below
                # perp - allow end points to move according to
                # perp. spring force
                # full - allow to move according to full force,
                # i.e. relax to energy minimum
  Free_End_EC # Energy contour value for image 0 - needed for
                # free_end_type = contour
  Free_End_EC_End # Energy contour value for image N - needed for
                # free_end_type = contour
  Free_End_Kappa # harmonic restraint term - needed for
                # free_end_type = contour
 # Monitor convergence for all images or only the CI.
 # Convergence type
  ConvType all # all (default)
                  # CIOnly
  CI false # Do Climbing image NEB
  NEB_TS false # Do CI NEB and subsequent TS opt.
 # Convergence tolerance. In Eh / Bohr (except Tol_Scale ).
  Tol_MaxFP_I 1.e-3 # Default. The convergence tolerance for the
              # maximum component of the atomic force
              # perpendicular to the path.
  Tol_RMSFP_I 5.e-4 # Default. The convergence tolerance for the rms
              # atomic force perpendicular to the path. Only
              # applies to regular images.
  Tol_MaxF_CI 2.e-3 # The convergence tolerance for the maxmimum
              # component of the atomic force acting on the CI.
              # Only applies to (ZOOM-)NEB-CI/-TS calculations.
              # Default is 5.e-4 (-CI) and 2.e-3 (-TS)
  Tol_RMSF_CI 1.e-3 # The convergence tolerance for the rms atomic
              # force acting on the CI. Only applies to (ZOOM-)NEB-CI.
              # Default is 2.5e-4 (-CI) and 1.e-3 (-TS)
  Tol_Turn_On_CI 2.e-2 # Thresholds for max. atomic force for switching on
              # CI in (ZOOM-)NEB-CI and (ZOOM-)NEB-TS.
              # Defaults: 0.02 for LBFGS, 0.2 for VPO and FIRE
  Tol_Scale 10.0 # For convergence type 'all' the user can scale
              # the convergence tolerance of the regular images
              # relative to the CI values using this
              # multiplicative factor. Only applies to (ZOOM-)NEB-CI
              # and (ZOOM-)NEB-TS calculations.
 # Interpolation and redistribution of the path is performed every 'reparam'
 # iterations. The type of interpolation is set by reparam_type.
  Reparam_type linear # Cubic
             # Linear (default)
  Reparam 0 # No. of iterations after which the path should be
             # reparametrized
             # 0 (default) means: reparametrization is off
  Tol_Reparam 0.0 # User-defined threshold at which the path should be
             # reparametrized
             # 0.0 (default) means: reparametrization is off
 # The optimization method used to converge the band on the MEP / saddle point.
 # The L-BFGS is more aggressive and efficient, but also more error-prone.
 # VPO is conservative and robust.
  Opt_Method LBFGS # LBFGS (default)

```
(continues on next page)

**7.29. Nudged Elastic Band Method** **745**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
             # VPO
             # FIRE
             # BFGS - TODO Villi correct?
 # Options Optim. Method
  Maxmove 0.1 # maximum component allowed per step. Default is 0.1 (LBFGS)
          # and 0.2 (VPO / FIRE)
  Stepsize 1.0 # multiplicative factor to scale the size of the step in each
          # optimization cycle.
          # Default is 1.0 (LBFGS) and 0.5 (VPO / FIRE)
  MaxIter 500 # Maximum number of iterations. 500 for LBFGS, 1000 for VPO / FIRE.
  Local false # Use local optimization.
          # Default is false for NEB, but true for (ZOOM-)NEB-CI/-TS.
 # Options LBFGS
  LBFGS_Mem 20 # the number of previous steps to be kept in memory and used
             # to construct the approximate Hessian matrix.
  LBFGS_DR 1.e-3 # Size of the finite difference step taken at the
             # initialization of L-BFGS
  LBFGS_Restart_On_Maxmove true # Re-initialize L-BFGS for the next step when
                  # the 'max-move' limit is reached.
  LBFGS_Reparam_On_Restart false # Re-parametrize when L-BFGS is re-initialized
  LBFGS_Precondition true # If true, then after initialization, the curvature
                  # along direction of the force is estimated and
                  # used to determine the first step
 # FIRE parameters
  FIRE_INITIAL_DAMP 0.1 # Initial value for the damping factor
  FIRE_DAMP_DECR" 0.99 # Decrease of the damping factor
  FIRE_STEP_INCR" 1.1 # Factor to increase the stepsize
  FIRE_STEP_DECR" 0.5 # Factor to decrease the stepsize
  FIRE_MAX_STEP" 5.0 # Default is 10 x Stepsize
  FIRE_RETENTION" 5 # Retention before starting acceleration
 # Options Zoom
  Tol_Turn_On_Zoom 0.1 # use ZOOM-NEB(-CI/TS)
  Zoom_Offset 1 # if manual selection is chosen, how many
              # images away from CI should be chosen
  Zoom_Auto true # automatically select zoom region
  Zoom_Alpha 0.5 # determines how much of the barrier
              # zoom-auto should select
  Zoom_Interpolation # linear (default)
              # cubic
  Zoom_PrintFullTrj # print full trajectory including fixed region during Zoom
 # Set of parameters to adjust the IDPP pre-optimization when generating the initial
 # path.
 # Options IDPP
  IDPP_NMax 7000 # maximum number of cycles allowed in IDPP
  IDPP_Tol_MaxF 0.01 # tolerance on the maximum component of the
                    # atomic force perpendicular to the path.
                    # For S-IDPP, this setting is used in the
                    # final IDPP optimization after all images
                    # have been added to the path
  IDPP_ksp 1.0 # spring constant used to scale the spring
                    # force parallel to the path.
  IDPP_Alpha 0.01 # multiplicative factor to scale the size
                    # of the step in each opt. cycle
  IDPP_MaxMove 0.05 # maximum component allowed per step
  IDPP_Debug false # will print out the convergence of IDPP
                    # and also the optimization trajectory and

```
(continues on next page)

**746** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



Output files:

  - Configuration and trajectory files:

**7.29. Nudged Elastic Band Method** **747**

**ORCA Manual** **,** **Release 6.0.1**

**–**
basename_initial_path_trj.xyz: The initial path generated at the start of the NEB run and after minimization of RMSD between the reactant and product states.

**–**
basename_MEP_trj.xyz: The final converged MEP trajectory.

**–**
basename_MEP_ALL_trj.xyz: The configurations of each image is appended to this file for each step
of the NEB optimization.

**–**
basename_trj.xyz: The trajectory of TS optimization.

**–**
basename_MEP.allxyz: Restart file that includes the configuration of each image from the last iteration
of an NEB or NEB-CI iteration.

**–**
basename_NEB-CI_converged.xyz: The configuration of the climbing image after a successful NEBCI calculation.

**–**
basename_NEB-HEI_converged.xyz: The configuration of the highest energy image after a successful
NEB calculation.

**–**
basename.xyz: The configuration of the optimized saddle point using the TS optimization.

  - Log files:

**–**
basename.interp: The interpolated energy profile of the path for each iteration during the NEB/NEB-CI
optimization.

**–**
basename.interp.final: The energy profile for the converged path of an NEB/NEB-CI optimization.

**–**
basename.log: A general log file containing essential information regarding the run e.g., energy, forces
and step size.
### **7.30 Excited States via RPA, CIS, TD-DFT and SF-TDA**

ORCA features a relatively efficient single-excitation CI (CIS), “random-phase approximation” (RPA) and timedependent DFT module that can be used to calculate excitation energies, absorption intensities and CD intensities.
Especially TD-DFT became very popular for excited state calculations as it offers significantly better results than
HF-CIS at about the same cost. However, there are also many pitfalls of TD-DFT, some of which are discussed in
reviews[613][615]. TD-DFT methods are available for closed-shell and spin-unrestricted reference states, together
with its collinear spin-flip variant. Analytic gradients are available for all these cases. There also is a doubles
correction implemented that improves the results (but also the computational cost). It is often used together with
double-hybrid functionals as explained below. The TD-DFT module of ORCA is also extensively used for the
calculation of X-ray absorption spectra at the K-edge of a given element.

Starting from version 6.0.0, the output format of the absorption wavelength, oscillator strength etc. has changed
compared to the 5.0.x version. For more details on the interpretation of the output, please refer to *One Photon*
*Spectroscopy* .

**7.30.1 General Features**

The module is invoked with the block:



There are a variety of options. The most important one is the number of excited states that you want to have
calculated:
```
%cis NRoots 10 end

```
**748** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


The convergence tolerances are given by:



The variable `ETol` gives the required convergence of the energies of the excited states (in Eh) and `RTol` is the
required convergence on the norm of the residual vectors. Under normal ciorcumstances the calculations need
about 5-10 iterations to converge to the default convergence tolerances.

Once converged, the program prints the wave function composition. To keep the printing concise, coefficients
smaller than 0.01 are omitted. The threshold can be adjusted with the keyword `TPrint` .



If closed-shell references are used the program can calculate the singlet and spin-adapted triplet excited states at
the same time by using:



This is available for all combinations of methods, including analytic gradients, and for double-hybrids.

In order to control the orbitals that should be taken into account in the calculation two mechanisms are available.
The first mechanism is the default mechanism and consists of specifying and orbital energy window within which
all single excitations will be considered:



Thus, the default is to keep core orbitals frozen and to neglect very high lying virtual orbitals which is a sensible
approximation. However, you may want to consider to include all virtual orbitals by choosing for example `EWin`
`-3,10000` . The second mechanism is to explicitly give an orbital energy window for each operator, i.e.



The “-1“‘s in the above example mean that the HOMO and LUMO for the spin-.up and spin-down orbitals will be
automatically determined by the program. In other words, in the above example, only the following excitations are
included in the TDDFT calculation:

  - Excitations from any occupied alpha orbital whose index is between 2 (inclusive) and that of the alpha
HOMO (inclusive), to any virtual alpha orbital whose index is between that of alpha LUMO (inclusive) and
14 (inclusive)

  - Excitations from any occupied beta orbital whose index is between 2 (inclusive) and that of the beta HOMO
(inclusive), to any virtual beta orbital whose index is between that of beta LUMO (inclusive) and 16 (inclusive)

For calculations based on a restricted reference, `OrbWin[1]` will be ignored.

In using the CIS/TD-DFT module five different types of calculations should be distinguished:

**7.30. Excited States via RPA, CIS, TD-DFT and SF-TDA** **749**

**ORCA Manual** **,** **Release 6.0.1**

  - Semiempirical methods

  - Hartree-Fock calculations

  - DFT calculations without HF exchange (non-hybrid functionals)

  - DFT calculations with HF exchange (hybrid functionals)

  - DFT calculations with HF exchange and MP2 correlation (double-hybrid functionals)

**7.30.2 Semiempirical Methods**

The semiempirical INDO/S method is very suitable to calculate absorption spectra of medium sized to large organic
and inorganic molecules. It has been parameterized by the late M. C. Zerner for optical spectroscopy and in my
experience at least, it tends to work nicely for many systems. With the semiempirical approach it is easy to calculate
many states of large molecules. For example, consider the following calculation on a bis-histidine ligated ironporphyrin model (in the Fe(II) state) that includes 92 atoms and *≈* 16,500 CSFs in the single excitation space. Yet
the calculation requires only a few minutes on an ordinary computer for the prediction of the first 40 excited states.

The calculated spectrum is in essentially reasonable agreement with experiment in showing a huge band around
400 nm (the famous Soret band) and a smaller but still intense band between 500 and 550 nm (the Q-band). There
are no predicted absorptions below *≈* 10,000 cm *[−]* [1] .

The input for the job is shown below:

(continues on next page)

**750** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
C -2.28137 5.66820 -0.00321
C -2.73691 -4.14249 -0.43699
C -2.42579 -4.72805 -1.83259
C 2.45978 -4.31073 -0.64869
C 2.19678 -4.82182 -2.08201
C 1.60835 -6.22722 -2.10748
C -1.90102 -6.15737 -1.82447
O -1.96736 -6.92519 -2.75599
O 1.60982 -7.01844 -1.19330
O -1.15355 -6.41323 -0.74427
O 0.89871 -6.41433 -3.22828
H 4.17823 5.62170 -0.05623
H 2.86221 7.53117 0.17503
H 1.26303 6.57673 0.17212
H 0.21799 5.11603 -0.03468
H -1.78003 6.14426 -0.87498
H -3.32281 6.05139 0.01906
H -1.78374 6.03115 0.92347
H -4.89690 4.71221 -0.07358
H -6.82566 3.40843 -0.18007
H -5.88239 1.80643 -0.28628
H -4.44893 0.70720 -0.28575
H -5.32107 -2.89387 -0.54251
H -5.45075 -1.49552 0.57400
H -5.46788 -1.24144 -1.20929
H -2.05997 -4.55939 0.34045
H -3.76430 -4.43895 -0.12880
H -3.33638 -4.66246 -2.47119
H -1.65517 -4.10119 -2.33605
H -0.56422 -7.14866 -1.00437
H 0.26056 -7.12181 -3.00953
H 1.48118 -4.13253 -2.58671
H 3.13949 -4.79028 -2.67491
H 3.46153 -4.65168 -0.30336
H 1.73023 -4.75206 0.06633
H 5.26172 -1.51540 -1.48550
H 5.31767 -1.84036 0.28550
H 5.06416 -3.18438 -0.87628
H -0.07991 -3.70928 -0.48866
H 4.39835 0.46775 -0.47078
H 5.39550 2.59422 -1.24309
H 5.47197 4.04179 -0.19892
H 5.44914 2.41988 0.54738
N 0.01831 0.60829 1.68951
C 0.02054 1.64472 2.54371
C 0.04593 -0.50152 2.45186
N 0.04934 1.20474 3.84418
C 0.06582 -0.16578 3.80848
H 0.00322 2.72212 2.31829
N -0.05051 0.81937 -2.30431
H 0.05251 -1.53704 2.08183
C 0.11803 1.92670 -3.04495
H 0.05712 1.81091 4.70485
H 0.08982 -0.83278 4.68627
C -0.24302 -0.18840 -3.17641
C -0.19749 0.28568 -4.49059
N 0.03407 1.63309 -4.38373
H 0.30109 2.95786 -2.70479
H -0.41432 -1.24242 -2.91290
H -0.31761 -0.27403 -5.43315
H 0.12975 2.31943 -5.17616

```
(continues on next page)

**7.30. Excited States via RPA, CIS, TD-DFT and SF-TDA** **751**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
*

```
Fig. 7.24: Structure of the iron-porphyrin used for the prediction of its absorption spectrum (the structure was
obtained from a molecular mechanics calculation and the iron-imidazole bondlength was set to 2.0 Å).

**752** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.25: The ZINDO/S predicted absorption spectrum of the model iron porphyrin shown above. The spectrum
has been plotted using the `orca_mapspc` tool.

Note that ORCA slightly departs from standard ZINDO/S in using dipole integrals in the intensity calculations that
include all one- and two-center terms which are calculated via a STO-3G expansion of the Slater basis orbitals.
The calculated intensities are not highly accurate anyways. In the present case they are overestimated by a factor
of *≈* 2.

**7.30.3 Hartree-Fock Wavefunctions**

When applying the procedures outlined above to pure Hartree-Fock, one obtains the “random-phase approximation”
(RPA) or the CI singles (CIS) model (when effectively using the Tamm-Dancoff Approximation, TDA). In general,
RPA and CIS calculations do not lead to good agreement with experimental excitation energies and errors of 1-5
eV are common. Therefore HF/CIS is mostly a qualitative tool or can be used with caution for larger molecules if
more extensive and more well balanced CI calculations are not computationally tractable.

**7.30.4 Non-Hybrid and Hybrid DFT**


For DFT functionals there is the choice between the full TD-DFT (eq. (7.219)) treatment and the so-called TammDancoff approximation (TDA).

**A** **B** **X** *𝜔* 0 **X**

=

**B*** **A*** **Y** 0 *−𝜔* **Y** (7.219)
(︂ )︂(︂ )︂ (︂ )︂(︂ )︂


**X**

**Y**
)︂(︂


*𝜔* 0

=
0 *−𝜔*
)︂ (︂


**X**

**Y**
)︂(︂


(7.219)
)︂


The TDA is the same approximation that leads from RPA to CIS (i.e. neglect of the so-called “B” matrix, see eq.
(7.220)). The results for vertical excitation energies are usually very similar between the two approaches.

**AX** TDA = *𝜔* TDA **X** TDA (7.220)

**7.30. Excited States via RPA, CIS, TD-DFT and SF-TDA** **753**

**ORCA Manual** **,** **Release 6.0.1**

In general, the elements of matrix “A” and “B” for singlet-singlet excitations in the spin-restricted case are given
by eqs. (7.221) and (7.222).


and


*𝐴* *𝑖𝑎,𝑗𝑏* = *𝛿* *𝑖𝑗* *𝛿* *𝑎𝑏* ( *𝜖* *𝑎* *−* *𝜖* *𝑖* ) + 2( *𝑖𝑎|𝑗𝑏* ) *−* *𝑎* X ( *𝑖𝑗|𝑎𝑏* )

(7.221)
+ (1 *−* *𝑎* X )( *𝑖𝑎|𝑓* XC *|𝑗𝑏* )

*𝐵* *𝑖𝑎,𝑗𝑏* = 2( *𝑖𝑎|𝑏𝑗* ) *−* *𝑎* X ( *𝑖𝑏|𝑎𝑗* ) + (1 *−* *𝑎* *𝑥* )( *𝑖𝑎|𝑓* XC *|𝑏𝑗* ). (7.222)


Here, *𝑖, 𝑗* denote occupied and *𝑎, 𝑏* virtual orbitals. *𝑎* X is the amount of non-local Fock exchange in the density
functional. If *𝑎* X is equal to one, eqs. (7.219) and (7.220) correspond to the RPA and CIS case, based on a HartreeFock ground state determinant.

The TDA is actually the default method for TD-DFT, and can be turned off by:



There are situations where hybrid functionals give significantly better results than pure functionals since they suffer
less from the self-interaction error. In those cases, the RIJCOSX procedure[624] [415][383] leads to very large
speedups in such calculations at virtually no loss in accuracy[676], and is turned on by default whenever the SCF
uses that too.

**7.30.5 Collinear Spin-Flip TDA (SF-TD-DFT)**

Another approach to obtain excited states via CIS/TD-DFT are the so called spin-flip methods (for a good review,
please check ref [144]). The idea is to start from an UHF state, and then “flip” one of the alpha electrons to generate
states with *𝑀𝑆* *𝑆𝐹* = *𝑀𝑆* *𝑈𝐻𝐹* *−* 1. In order to do that, we look for excitations from alpha-to-beta orbitals only,
and that makes the A matrix from TDA even simpler:

*𝐴* *[𝑆𝐹]* *𝑖𝑎,𝑗* ¯ [¯] *𝑏* [=] *[ 𝛿]* *[𝑖𝑗]* *[𝛿]* *[𝑎]* [¯][¯] *[𝑏]* [(] *[𝜖]* *[𝑎]* [¯] *[−]* *[𝜖]* *[𝑖]* [)] *[ −]* *[𝑎]* [X] [(] *[𝑖𝑗][|][𝑎]* [¯][¯] *[𝑏]* [)] (7.223)

where the overbar represent beta orbitals, and no-overbars alpha orbitals.

OBS.: Please note that for pure DFT (with *𝑎* *𝑋* = 0, and no HF contribution), the A matrix is based simply in the
orbital energies, and thus it is always good to have a good amount of HF on the functional!

In order to facilitate the discussion on the results one gets from the SF-TDA, let’s take a closer look at the picture
representing some possible excitations:

Fig. 7.26: Effect of the spin-flip operator on a UHF ( *𝑀𝑆* = 3) wavefunction. The “spin-complete” states are
eigenvectors of the *𝑆* [2] operator, while the “spin-incomplete” are not. Alpha and beta orbitals here are represented
with the same energy, just to simplify the image. Adapted from the previously mentioned review.

**754** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

It is important to note that no all SF-excitations lead to determinants that are eigenvalues of the *𝑆* [2] operator. That
means, depending on how much of these “spin incomplete” excitations are present in the final SF-state, the spincontamination could be high, and in this case, states with *⟨𝑆* [2] *⟩≃* 1 would be predicted. These are undefined states
within the SF theory and should be treated carefully.

OBS.: Any SF method can only be used starting from a UHF wavefunction, with a multiplicity of at least 3!

**First example: methylene and SF-CIS**

One simple example is the calculation of the vertical singlet-triplet splitting of the methylene radical within CIS,
using the following input with symmetry included:



The geometry was taken from a high-level CCSD(T)/cc-pVQZ ( *𝑋* [3] *𝐵* 1 ) optimized geometry, and after the regular
UHF SCF, the SF-CIS result is:



Now, **it is very important to consider that the SF ground state is not the UHF ground state anymore**, the
“new” ground state within the SF scheme is actually STATE 1. You can think of the UHF as being only an initial
model, on the basis of which the SF states are built. The final energy of the new ground state is actually the SCF
energy + energy of the STATE 1 (which is the one given as the FINAL SINGLE POINT ENERGY is no IROOT
is given). This last contribution can be either positive or negative, depending on the case.

Anyway, the ground state is predicted to be a triplet state (here with *𝑀* *𝑆* = 0), as expected for this carbene, and the
S-T spiting energy is 1 *.* 774 *−* 0 *.* 135 eV = 1 *.* 639 eV. The full CI results for that is 1.50 eV, so it is already almost
there! Of course, in this case computing the RHF singlet - UHF triplet makes no sense, since the RHF singlet
would not have the necessary open-shell singlet character.

**7.30. Excited States via RPA, CIS, TD-DFT and SF-TDA** **755**

**ORCA Manual** **,** **Release 6.0.1**

**Benzyne and SF-TDA**

Benzyne is a classic diradical that can be generated from benzene by hydrogen abstraction (Fig. 7.27). It is known
to have an open-shell singlet ground state, and has its adiabatic sinlget-triplet splitting measured experimentally.
Let’s try to compute this value using SF-TDA with ORCA.

Fig. 7.27: Lewis representation of the benzene and benzyne molecules, indicating the diradical character of the
later.

First, we optimize the open-shell singlet by using SF, and the input that follows. Here we use now DFT, in particular
the BHANDHLYP functional, which uses 50% of HF correlation, and is recommended for this kind of application.
By default, the IROOT to be optimized is 1, which in this case corresponds to the SF ground state.



And after the optimization of IROOT 1, the final SF-TDA result is:



(continues on next page)

**756** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

confirming the singlet ground state, with an upper triplet excited state.

Now to optimize the triplet state using SF-TDA, one has to use a similar input, except that now IROOT 2 has to be
chosen as the one to be optimized:



After the optimization, the final predicted adiabatic singlet-triplet gap is 0 *.* 163 eV, very close to the experimental
value of 0 *.* 165 eV [178], and even better than what the Broken-Symmetry (BS) result would be (0 *.* 074 eV).

**7.30.6 Including solvation effects via LR-CPCM theory**

The LR-CPCM theory, as developed by Cammi and Tomasi [134], is implemented for both energies and gradients
of excited states. It is turned on by default, whenever CPCM is also requested for the ground state.

The major change is that now there is a *𝐺* *𝑖𝑎,𝑗𝑏* term in the **A** part of Eq. (7.219), related to solvation effects.

*𝐴* *𝑖𝑎,𝑗𝑏* = *𝛿* *𝑖𝑗* *𝛿* *𝑎𝑏* ( *𝜖* *𝑎* *−* *𝜖* *𝑖* ) + 2( *𝑖𝑎|𝑗𝑏* ) + 2 *𝐺* *𝑖𝑎,𝑗𝑏*
(7.224)
*−* *𝑎* X ( *𝑖𝑗|𝑎𝑏* ) + (1 *−* *𝑎* X )( *𝑖𝑎|𝑓* XC *|𝑗𝑏* )

where *𝐺* *𝑖𝑎,𝑏𝑗* is defined as:

*𝐺* *𝑖𝑎,𝑗𝑏* = ( **V** *𝑖𝑎* ) *[𝑇]* **q** *𝑗𝑏* (7.225)

**7.30. Excited States via RPA, CIS, TD-DFT and SF-TDA** **757**

**ORCA Manual** **,** **Release 6.0.1**

**Equilibrium and non-equilibrium conditions**

These charges *𝑞* *𝑗𝑏* are calculated in the same way as described in *The Conductor-like Polarizable Continuum Model*
*(C-PCM)*, but for excited states, two different values of *𝜀* can be used, depending on the dynamics of the system:

   - **Non-equilibrium** : If the calculation assumes that the electronic excitation is so fast, that there is no time
for the solvent to reorganize around the solute, then the *𝜀* inf of the solvent is used, which is equivalent to the
square of the refractive index. That is the case if one wants to compute the vertical excitation energy, and it
is the default in that case.

   - **Equilibrium** : If the excited state is assumed to be completely solvated, then the true dielectric constant *𝜀* of
the solvent should be used. That is the case for geometry optimizations, frequencies or inside ORCA_ESD.
This is turned on by default whenever analytic gradients are requested.

In any case, these conditions can be controlled by the flag CPCMEQ, that can be set to TRUE or FALSE by the
user, and will then override the defaults.

These are available to all CIS/TD-DFT options: singlets, spin-adapted triplets, UHF and spin-flip variants. It works
inclusive for double-hybrids and whenever SOC is requested.

**Population Analysis of Excited States**

If you want to print a population analysis for the excited state using CIS/TD-DFT, there are two options available:
using **unrelaxed** or **relaxed** densities. For the unrelaxed densities, simply use UPOP TRUE:



and the atomic changes and bond orders will be printed for the chosen IROOT (default 1):



(continues on next page)

**758** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



To get the analysis from the relaxed density, simply use !ENGRAD to a run a gradient calculation:



and the printout is:




In order to print the analysis for multiple states, simply use IROOTLIST and TROOTLIST:

**7.30. Excited States via RPA, CIS, TD-DFT and SF-TDA** **759**

**ORCA Manual** **,** **Release 6.0.1**

︂


︂


︂


**7.30.7 Simplified TDA and TD-DFT**

ORCA also supports calculations of excited states using the simplified Tamm-Dancoff approach (sTDA) by S.
Grimme[323]. The sTDA is particularly suited to calculate absorption spectra of very large systems. sTDA as well
as the simplified time-dependent density functional theory (sTD-DFT)[69] approach require a (hybrid) DFT ground
state calculation. For large systems, using range-separated hybrid functionals (e.g. *𝜔* B97X) is recommended.[725]
The sTD-DFT approach in particular yields much better electronic circular dichroism (ECD) spectra and should
be used for this purpose.

**Theoretical Background**

A brief outline of the theory will be given in the following. For more details, please refer to the original papers[69,
323]. In the sTDA, the TDA eigenvalue problem from eq. (7.220) is solved using a truncated and semi-empirically
simplified *𝐴* *[′]* matrix. The trunctation negelects all excitations that are beyond the energy range of interest, except
a few strongly coupled ones. The matrix elements from eq. (7.221) are simplified by neglecting the response of
the density functional and by approximating the remaining two-electron integrals as damped Coulomb interactions
between transition/charge density monopoles. In the following, the indices *𝑖, 𝑗* denote occupied, *𝑎, 𝑏* virtual and
*𝑝, 𝑞* either kind of orbitals.

︂


*𝐴* *[′]*
*𝑖𝑎,𝑗𝑏* [=] *[ 𝛿]* *[𝑖𝑗]* *[𝛿]* *[𝑎𝑏]* [(] *[𝜖]* *[𝑎]* *[−]* *[𝜖]* *[𝑖]* [) +]

︂


*𝑁* atoms
∑︁ (2 *𝑞* *𝑖𝑎* *[𝐴]* *[𝛾]* *𝐴𝐵* *[𝐾]* *[𝑞]* *𝑗𝑏* *[𝐵]* *[−]* *[𝑞]* *𝑖𝑗* *[𝐴]* *[𝛾]* *𝐴𝐵* *[𝐽]* *[𝑞]* *𝑎𝑏* *[𝐵]* [)] (7.226)

*𝐴,𝐵*

︂


*𝑞* *𝑝𝑞* *[𝐴]* [and] *[ 𝑞]* *𝑝𝑞* *[𝐵]* [are the transition/charge density monopoles located on atom] *[ 𝐴]* [and] *[ 𝐵]* [, respectively. These are obtained]
from Löwdin population analysis (see Sec. *Löwdin Population Analysis* ). *𝜖* *𝑝* is the Kohn-Sham orbital energy of
orbital *𝑝* . *𝛾* *𝐴𝐵* *[𝐾]* [and] *[ 𝛾]* *𝐴𝐵* *[𝐽]* [are the Mataga-Nishimoto-Ohno-Klopman damped Coulomb operators for exchange-type]
( *𝐾* ) and Coulomb-type ( *𝐽* ) integrals, respectively.

︂


1 ︂
*𝛾* *𝐴𝐵* *[𝐽]* [=]
(︂ ( *𝑅* *𝐴𝐵* ) *[𝛽]* + ( *𝑎* X *𝜂* ) *[−][𝛽]*


︂ *𝛽* [1]

(7.227)

)


︂

1
*𝛾* *𝐴𝐵* *[𝐾]* [=]
(︂ ( *𝑅* *𝐴𝐵* ) *[𝛼]* + *𝜂* *[−][𝛼]*


︂

*𝛼*
(7.228)

)︂ [1]


︂

Here, *𝜂* is the arithmetic mean of the chemical hardness of atom *𝐴* and *𝐵* . *𝛼* and *𝛽* are the parameters of the method
and are given by:

*𝛼* = *𝛼* 1 + *𝑎* *𝑥* *𝛼* 2 (7.229)

*𝛽* = *𝛽* 1 + *𝑎* *𝑥* *𝛽* 2 (7.230)

For any global hybrid functional, *𝛼* 1, *𝛼* 2, *𝛽* 1 and *𝛽* 2 are identical. *𝛼* and *𝛽* then depend on the amount of Fock
exchange ( *𝑎* X ) only. This is different for range-separated hybrid functionals where *𝛼* 2 and *𝛽* 2 are set to zero.
*𝛼* 1 and *𝛽* 1 along with a value *𝑎* *𝑥* for the sTDA treatment are individually fitted for each range-separated hybrid
functional.[725] It can bee seen from eq. (7.226) that the method is asymptotically correct which is crucial for
excitations of charge transfer type.

**760** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

In sTD-DFT, eq. (7.219) is solved using the simplified matrices *𝐴* *[′]* (see above) and *𝐵* *[′]* .


*𝐵* *[′]*
*𝑖𝑎,𝑗𝑏* [=]


*𝑁* atoms
∑︁ (2 *𝑞* *𝑖𝑎* *[𝐴]* *[𝛾]* *𝐴𝐵* *[𝐾]* *[𝑞]* *𝑏𝑗* *[𝐵]* *[−]* *[𝑎]* [X] *[𝑞]* *𝑖𝑏* *[𝐴]* *[𝛾]* *𝐴𝐵* *[𝐾]* *[𝑞]* *𝑎𝑗* *[𝐵]* [)] (7.231)

*𝐴,𝐵*


This approach yields better transition dipole moments and therefore spectra but the method is more costly than
sTDA (a factor of 2–5 for typical systems). The parameters used in sTDA and sTD-DFT are identical. There are
**no** additional parameters fitted for this method.

**Calculation Set-up**

sTDA and sTD-DFT can be combined with any (restricted or unrestricted) hybrid DFT singlepoint calculation.
Gradients and frequencies are **not** implemented! The methods can be invoked via the `%tddft` block. Table *Keyword*
*list for sTDA and sTD-DFT.* gives a list of the possible keywords.

Table 7.22: Keyword list for sTDA and sTD-DFT.

The following example shows how to run such a sTDA calculation using the BHLYP functional if one is interested
in all excitations up to 10 eV.

Replacing `Mode sTDA` by `Mode sTDDFT` will invoke a sTD-DFT calculation instead. This is shown in the next
example in combination with the *𝜔* B97X functional and user specified parameters:



(continues on next page)

**7.30. Excited States via RPA, CIS, TD-DFT and SF-TDA** **761**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



For the range-separated hybrid functionals LC-BLYP, CAM-B3LYP, *𝜔* B97, *𝜔* B97X, *𝜔* B97X-D3 and *𝜔* B97XD3BJ, parameters are available and will be used by default if one of these functionals is used. The way of specifying
parameters as shown above is useful if there is a range-separated hybrid functional that has not been parametrized
for sTDA yet. For very large systems (e.g. *>* 500 atoms), it may be useful to define an upper boundary `PTLimit` for
the selection of configurations that are beyond `EThresh` (otherwise the whole configuration space will be scanned).
This can be done as shown below:



In this case, all excitations up to 7 eV are considered from the very beginning. Configurations between 7 and 14
eV are included if their coupling to the configurations below 7 eV is strong enough (in total larger than `PThresh` ).
All configurations beyond 14 eV are neglected. Since the sTDA/sTD-DFT calculations run in serial mode, it is
recommended to reset the maxcore within the `%tddft` block (as done in the above examples). In the latter sample
input, the ground state procedure runs in parallel mode on 4 cores with a maxcore of 5000 MB set for each node.
The subsequent sTD-DFT calculation then runs on a single core, but in order to use all the available memory, the
maxcore is reset to a larger value (i.e., 20000 MB). If the maxcore statement within the `%tddft` block was missing,
only 5000 MB of memory would be available in the sTD-DFT calculation. Note furthermore that for very large
systems, using a functional with the correct asymptotic behaviour is very important (due to the fixed amount of
GGA exchange, CAM-B3LYP does **not** provide this property).

The ORCA output will summarize the important properties of your calculation which allows you to check your
input:



(continues on next page)

**762** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

The spectroscopic data is also printed out after the calculation has finished:




`fL`, `fV`, `RL` and `RV` are the length and velocity expressions of the oscillator and rotatory strengths, respectively. They
may be convoluted by a spectrum processing program to yield the UV/Vis absorption and ECD spectra.

**7.30. Excited States via RPA, CIS, TD-DFT and SF-TDA** **763**

**ORCA Manual** **,** **Release 6.0.1**

**7.30.8 Double-hybrid functionals and Doubles Correction**

The program can compute a doubles correction to the CIS excitation energies. The theory is due to Head-Gordon
and co-workers.[371] The basic idea is to compute a perturbative estimate (inspired by EOM-CCSD theory) to
the CIS excited states that is compatible with the MP2 ground state energy. In many cases this is a significant
improvement over CIS itself and comes at a reasonable cost since the correction is computed *a posteriori* . Of
course, if the CIS prediction of the excited state is poor, the (D) correction – being perturbative in nature – cannot
compensate for qualitatively wrong excited state wavefunctions.

In addition – and perhaps more importantly – the (D) correction is compatible with the philosophy of the doublehybrid functionals and should be used if excited states are to be computed with these functionals. The results are
usually much better than those from TD-DFT since due to the large fraction HF exchange, the self-interaction error
is much smaller than for other functionals and after the (D) correction the results do not suffer from the overestimation of transition energies that usually comes with increased amounts of HF exchange in TD-DFT calculations.

Since the calculations would require a fairly substantial integral transformation that would limit it to fairly small
molecules if no approximation are introduced we have decided to only implement a RI version of it. With this
approximation systems with more than 1000 basis functions are readily within the reach of the implementation.

Since one always has a triad of computational steps: MP2-CIS solution-(D) correction, we have implemented
several algorithms that may each become the method of choice under certain circumstances. The choice depends
on the size of the system, the number of roots, the available main memory and the available disk space together
with the I/O rate of the system. The formal cost of the (D) correction is *𝑂* ( *𝑁* [5] ) and its prefactor is higher than that
of RI-MP2. In the best case scenario, the rate limiting step would be the calculation of the pair-contribution in the
“U-term” which requires (for a closed-shell system) twice the effort of a RI-MP2 calculation *per state* .

The use of the (D)-correction is simple. Simply write:



Table 7.23: Integral handling in various implementations of the (D) correction (i,j=occupied MOs, a,b=virtual
MOs, Q=aux function; NumInt=numerical integration).

NOTE:

  - In all three involved code sections (MP2, CIS, (D)) the storage format FLOAT is respected. It cuts down
use of disk and main memory by a factor of two compared the default double precision version. The loss of

**764** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

accuracy should be negligible; however it is – as always in science – better to double check.

  - The (ab|Q) list of integrals may be the largest for many systems and easily occupies several GB of disk
space (hence algorithms 2 and 3). However, that disk-space is often well invested unless you run into I/O
bottlenecks.

  - The (ia|jb) and (ij|ab) lists of integrals is also quite large but is relatively efficiently handled. Nevertheless,
I/O may be a problem.

  - Making the exchange contribution to the CIS residual vector in an RI-AO direct fashion becomes quite
expensive for a larger number of states. It may be a good choice if only one or two excited states are to be
calculated for a larger system.

  - Calculations are possible with the full TD-DFT and the TDA-DFT versions.

  - Usage of time-dependent double-hybrids should be cited as follows: For TD or TDA with any double
hybrid,[328] TD-B2GPLYP,[310] TDA-PBE0-DH or TDA-PBE0-2,[579] TD-PBE0-DH, TD-PBE0-2, or
TDA-B2GP-PLYP [772], TD- *𝜔* B2PLYP or TD- *𝜔* B2GPPLYP [146], TDA- *𝜔* B2PLYP or TDA- *𝜔* B2GPPLYP

[145], TD(A)-RSX-QIDH or TD(A)-RSX-0DH [145], TDA-PBE-QIDH [119], TD-PBE-QIDH [386],
TD(A)-DSD-BLYP or TD(A)-DSD-PBEP86 or many other spin-component-scaled double-hybrid functionals with TD(A)-DFT from 2017 [772], TD(A) *𝜔* B88PP86 or TD(A) *𝜔* PBEPP86 or many other spincomponent and opposite scaled double hybrids with TD(A)-DFT from 2021 [147].

  - For instructions on how to employ spin-component-scaling, spin-opposite-scaling, and the calculation of
singlet-triplet excitation energies with double hybrids, see Sec. *Doubles Correction* . Note that SCS/SOSCIS(D) is only automatically used when a TD(A)-DFT calculation is requested for the functionals from 2021
by Casanova-Páez and Goerigk. [147] In those instances, “doscs” has not to be set. SCS/SOS-CIS(D) is not
automatically used for PWPB95, *𝜔* wB97X-2, or the DSD functionals.

  - Cite Ref. [145] when singlet-triplet excitations are calculated with double hybrids.

**7.30.9 Natural Transition Orbitals**

Results of TD-DFT or CIS calculations can be tedious to interprete as many individual MO pairs may contribute
to a given excited state. In order to facilitate the analysis while keeping the familiar picture of an excited state
originating from essentially an electron being promoted from a donor orbital to an acceptor orbital, the concept of
“natural transition orbitals” can be used.

The procedure is quite straightforward. For example, consider the following job on the pyridine molecule:



**7.30. Excited States via RPA, CIS, TD-DFT and SF-TDA** **765**

**ORCA Manual** **,** **Release 6.0.1**

which results in:



(continues on next page)

**766** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



We see that there is a weakly allowed transition (S1) that is essentially totally composed of a single NTO pair
(20a *→* 21a : n= 0.99825296), while the third excited state (S3) is strongly allowed and requires two NTO pairs for
its description (20a *→* 21a : n= 0.64493520 and 19a *→* 22a : n= 0.34962356).

These orbitals are shown below. It is evident that the S1 state donor orbital (NTO20) is a nitrogen lone pair and
the acceptor orbital is a *𝜋** orbital of the ring. For the S3 state the two NTO donor orbitals are comprised of a
nearly degenerate set of *𝜋* orbitals (they would be degenerate in the parent benzene) and the acceptor orbitals are
a pair of nearly degenerate *𝜋** orbitals. It is evident from this example that by looking at the NTOs one can obtain
a nicely pictorial view of the transition process, even if many orbital pairs contribute to a given excited state in the
canonical basis.

**7.30. Excited States via RPA, CIS, TD-DFT and SF-TDA** **767**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.28: Natural transition orbitals for the pyridine molecule in the S1 and S3 states.

Similar analysis can be performed in the case of ROCIS and DFT/ROCIS calculations as it will be described in
section *Natural Transition Orbitals/ Natural Difference Orbitals* .

**7.30.10 Computational Aspects**

**RI Approximation (AO-Basis)**

If the SCF calculation used the RI approximation it will also be used in the TD-DFT calculation. The RI approximation saves a large amount of time while giving close to identical results (the errors will usually be *<* 0.1 eV) and
is generally recommended. If the functional is a hybrid functional the RI-approximation will only be applied to the
Coulomb term while the exchange will be treated as before. In the SCF you can use this feature with the keyword
( `! RIJONX` ). It will then also be used in the TD-DFT calculation. Again, the RIJCOSX approximation can be used
in TD-DFT and CIS calculations and leads to very large speedups at virtually no loss in accuracy.

**768** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**RI Approximation (MO-Basis)**

As an alternative to the direct AO-basis computation ORCA allows to use RI-integrals transformed to the MO basis
to generate the CI matrix. This algorithm is more disk-intensive. However, for medium sized molecules we have
observed speedups on the order of 15 or more with this method. It is particularly benefitial together with hybrid
functionals.

In order to use this method you have to specify `mode riints` in the `%tddft` block and you also have to assign
an auxiliary basis set (for example `def2-TZVP/C` ). There is a second algorithm of this kind that is labelled `mode`
```
riints_disk

```
Note that the auxiliary basis set has to be valid for correlation treatments in case that you have a hybrid functional.
Thus the basis sets developed for RI-MP2 are suitable ( `def2-SVP/C`, `def2-TZVP/C` and `def2-TZVPP/C` ). If you
have a non-hybrid functional the normal RI-J auxiliary basis sets are fine.

An example that uses the B3LYP functional is given below:



**Note:**

  - Do not forget to assign a suitable auxiliary basis set! If Hartree-Fock exchange is present (HF or hybridDFT) these are the auxiliary bases optimized for correlation while for non-hybrid functionals the standard
RI-J bases are suitable.

  - The standard auxiliary basis sets may not be suitable if you have diffuse functions present and want to study
Rydberg states. You have to augment the axuliary basis with diffuse functions yourself in this case.

  - Be prepared that the transformed integrals take up significant amounts of disk space.

**Integral Handling**

If the SCF calculation is carried out in an integral direct fashion this will also be done in the CIS/TD-DFT calculation. Thus, no bottlenecks arising from large integral transformations or large disk space requirement arise in the
calculations. An exception is the MO based RI approximations described in the previous section.

**Valence versus Rydberg States**

For valence excited states the usual orbital basis sets are reasonable. Thus, with polarized double-zeta basis sets
sensible results are obtained. Especially DFT calculations have the nice feature of not being overly basis set dependent.

If Rydberg states are desired, you should make sure that diffuse functions are present in your basis set. You could
always use the augmented-specific basis, e.g. DEF2-TZVPD, ma-DEF2-TZVP, or aug-cc-pVTZ, or add some
extra diffuse basis to your regular basis. These can be added to any “normal” basis set. For example, the following
example provides a rather high quality basis for excited state calculations that is based on the Ahlrichs basis set:

**7.30. Excited States via RPA, CIS, TD-DFT and SF-TDA** **769**

**ORCA Manual** **,** **Release 6.0.1**



**Tip:** If you want to augment a given basis set it is sensible to run a preliminary SCF calculation and use `%output`
`print[p_basis] 2 end` . This will provide you with a detailed listing of basis functions and their exponents.
You can then add additional s, p and perhaps d-functions with the `AddGTO` command as in the example above. It
is sensible to decrease the exponent of the diffuse functions by roughly a factor of 3 from the smallest exponent in
the original basis.

**Restrictions for Range-Separated Density Functionals**

Several restrictions apply for range-separated (hybrid as well as double-hybrid) density functionals. They are currently only implemented to work with the AO-based algorithm within the RIJONX, RIJCOSX, and NORI integral
schemes. Additionally, the asymptotic correction has been disabled. However, the nuclear gradient for the excited
states is now available, including for the triplets. Please no that the IROOTMULT flag must be set to TRIPLET
under %CIS or %TDDFT in order to obtain that.

**Potential Energy Surface Scans**

ORCA allows the combination the scan feature with CIS or TD-DFT. This can be used to map out the excited
state potential energy surfaces as a function of one- two- or three parameters. The output of the “trajectory” run
automatically contains the excited state energies in addition to the ground state energy. For example consider the
following simple job.



The output file from this job contains the *total* energies (i.e. the ground state energy plus the excitation energy) for
each excited state as a function of C-O bondlength as shown below. Howerver, the assignment of the individual
states will change with geometry due to curve crossings. Thus, the state-to-state correlation must be worked out
“by hand”. These calculations are nevertheless very helpful in obtaining at least a rough idea about excited state
energy surfaces.

**770** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.29: Result of a potential energy surface scan for the excited states of the CO molecule using the `orca_cis`
module.

**7.30. Excited States via RPA, CIS, TD-DFT and SF-TDA** **771**

**ORCA Manual** **,** **Release 6.0.1**

**Potential Energy Surface Scans along Normal Coordinates**

The ground and excited state potential energy surfaces can also be mapped as a function of normal coordinates. The
normal mode trajectory run is invoked by the keyword `!MTR` . In addition several parameters have to be specified in
the block `%mtr` . The following example illustrates the use:

First you run a frequency job:

and then:




The `HessName` parameter specifies the name of the file which contains nuclear Hessian matrix calculated in the
frequency run. The Hessian matrix is used to construct normal mode trajectories. The keyword `MList` provides
the list of the normal modes to be scanned. The parameters `RSteps` and `LSteps` specify the number of steps in
positive and negative direction along each mode in the list. In general, for a given set of parameters



the total number of the displaced geometries for which single point calculations will be performed is equal to
∏︀ ( *𝑟* *𝑚* *𝑖* + *𝑙* *𝑚* *𝑖* + 1). Thus, in the present case this number is equal to (4 + 4 + 1) (5 + 5 + 1) = 99.

*𝑚* *𝑖*

The `ddnc` parameter specifies increments *𝛿𝑞* *𝛼* for respective normal modes in the list in terms of dimensionless
normal coordinates (DNC’s). The trajectories are constructed so that corresponding normal coordinates are varied
in the range from *−𝑙* *𝛼* *𝛿𝑞* *𝛼* to *𝑟* *𝛼* *𝛿𝑞* *𝛼* . The measure of normal mode displacements in terms DNC’s is appropriate

**772** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

choice since in spectroscopical applications the potential energy function *𝑈* is usually expressed in terms of the
DNC’s. In particular, in the harmonic approximation *𝑈* ( *𝑞* *𝛼* ) has a very simple form around equilibrium geometry:


*𝑈* = *𝑈* 0 +

where *𝜔* *𝛼* is the vibrational frequency of the *𝛼* -th mode.


3 *𝑁* *−* 6
∑︁

*𝛼*


ℏ *𝜔* 2 *𝛼* *[𝑞]* *𝛼* [2] (7.232)


Dimensionless normal coordinate *𝑞* *𝛼* can be related to the vector of atomic Cartesian displacements *𝛿* **X** as follows:


∑︁ *𝐿* *𝑘𝛼* *𝛿𝑋* *𝑘* √︀

*𝑘* =1


*𝜔* *𝛼*
*𝑞* *𝛼* =
(︁ ℏ


)︁ [1] 2


3 *𝑁*

[1] 2 ∑︁


*𝑀* *𝑘* (7.233)


where *{𝐿* *𝑘𝛼* *}* is the orthogonal matrix obtained upon numerical diagonalization of the mass-weighted Hessian
matrix, and **M** is the vector of atomic masses. Accordingly, the atomic Cartesian displacements corresponding to
a given dimensionless normal coordinate *𝑞* *𝛼* are given by:


ℏ
*𝛿𝑋* *𝑘* =
(︂ *𝜔* *𝛼*


ℏ
*𝛿𝑋* *𝑘* =
(︂ *𝜔*


)︂ [1] 2


2
*𝐿* *𝑘𝛼* *𝑞* *𝛼* ( *𝑀* *𝑘* ) *[−]* 2 [1]


2 (7.234)


Alternatively, it is possible to specify in the input the Cartesian increment for each normal mode. In such a case,
instead of the `ddnc` parameter one should use the `dxyz` keyword followed by the values of Cartesian displacements,
for example:



For a given Cartesian increment *𝑑* *𝑋,𝛼* along the *𝛼* –th normal mode the atomic displacements are calculated as
follows:


*𝛿𝑋* *𝑘* = *[𝑑]* *[𝑋]* *[,]* *[𝛼]*


2 (7.235)



*[𝑋]* *[,]* *[𝛼]* 2

*‖* **T** *𝛼* *‖* *[𝐿]* *[𝑘𝛼]* [(] *[𝑀]* *[𝑘]* [)] *[−]* [1]


The vector **T** *𝛼* in the Cartesian basis has components *𝑇* *𝑖𝛼* = *𝐿* *𝑘𝛼* ( *𝑀* *𝑘* ) *[−]* [1] 2 and length (norm) *‖* **T** *𝑘* *‖* .

The increment length can also be selected on the basis of an estimate for the expected change in the total energy
∆ *𝐸* due to the displacement according to eq.(7.118). The value of ∆ *𝐸* can be specified via the `EnStep` parameter:



All quantum chemical methods have to tolerate a certain amount of numerical noise that results from finite convergence tolerances or other cutoffs that are introduced into the theoretical procedures. Hence, it is reasonable to
choose ∆ *𝐸* such that it is above the characteristic numerical noise level for the given method of calculation.

At the beginning of the program run the following trajectory files which can be visualized in gOpenMol will be
created:

   - `BaseName.m9.xyz` and `BaseName.m13.xyz` contain trajectories along normal modes 9 and 13, respectively.

**7.30. Excited States via RPA, CIS, TD-DFT and SF-TDA** **773**

**ORCA Manual** **,** **Release 6.0.1**

   - `BaseName.m13s1.m9.xyz - BaseName.m13s5.m9.xyz` contain trajectories along normal mode 9 for different fixed displacements along mode 13, so that the file `BaseName.m13sn.m9.xyz` corresponds to the
*𝑛* -th step in the positive direction along mode 13.

   - `BaseName.m13s-1.m9.xyz - BaseName.m13s-5.m9.xyz` contain trajectories along normal mode 9 for
different fixed displacements along mode 13, so that the file `BaseName.m13s-n.m9.xyz` corresponds to
the *𝑛* -th step in the negative direction along mode 13.

   - `BaseName.m9s1.m13.xyz - BaseName.m9s4.m13.xyz` contain trajectories along normal mode 13 for
different fixed displacements along mode 9, so that the file `BaseName.m9sn.m13.xyz` corresponds to the
*𝑛* -th step in the positive direction along mode 9.

   - `BaseName.m9s-1.m13.xyz - BaseName.m9s-4.m13.xyz` contain trajectories along normal mode 13 for
different fixed displacements along mode 9, so that the file `BaseName.m9s-n.m13.xyz` corresponds to the
*𝑛* -th step in the negative direction along mode 9.

The results of energy single point calculations along the trajectories will be collected in files `BaseName.mtr.`
`escf.S.dat` (for the SCF total energies) and files `BaseName.mtr.ecis.S.dat` (for the CIS/TDDFT total energies), where “S” in the suffix of `*.S.dat` filenames provides specification of the corresponding trajectory in the
same way as it was done for the case of trajectory files `*.xyz` (e.g. `S=”m9s-1.m13”` ). Likewise, the calculated total
energies along the trajectories will be collected in files `BaseName.mtr.emp2.S.dat` in the case of MP2 calculations, `BaseName.mtr.emdci.S.dat` (MDCI), `BaseName.mtr.ecasscf.S.dat` (CASSCF), `BaseName.mtr.`
`emrci.S.dat` (MRCI).

Note, that in principle normal coordinate trajectories can be performed for an arbitrary number normal modes.
This implies that in general trajectories will contain geometries which involve simultataneous displacement along
several (>2) modes. However, trajectory files `*.xyz` and corresponding `*.dat` files will be generated only for the
structures which are simultaneously displaced along not more than 2 normal coordinates.

**774** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.30: Result of a potential energy surface scan along C-C stretching normal coordinate (mode 13 in the present
example) for the excited states of the ethene molecule using the `orca_cis` module.

**7.30. Excited States via RPA, CIS, TD-DFT and SF-TDA** **775**

**ORCA Manual** **,** **Release 6.0.1**

**Normal Mode Scan Calculations Between Different Structures**

This type of job allows to map PES between two different structures as a function of normal coordinates. The
H 2 O molecule represent a trivial case which has formally 2 equivalent equilibrium structures which differ by angle
H 1 —O—H 2 ( 103.5 *[∘]* and 256.5 *[∘]*, respectively, as follows from the BP86/SV(P) calculations). In such a case
the input for the nomal mode trajectory run would require the calculation of geometry difference between both
structures in terms of the dimensionless normal coordinates. This can be done in `orca_vib` run as follows :
```
> orca_vib water.hess ddnc geom.xyz

```
The second parameter ddnc in the command line invokes the calculation of geometry difference in terms of the
DNC’s. Both structures are specified in the file `geom.xyz` which has a strict format:



The first line of the input specifies the number of the structures and total number of atoms (2 and 3, respectively).
Specification of each structure in sequence starts with a new line containing the number of the structure. The
number 0 in the second line is used to denote the reference structure. Note that atomic coordinates should be given
in units of Å and in the same order as in the ORCA input for the frequency run from which the file `water.hess`
was calculated.

At the end of the `orca_vib` run the file `geom.ddnc` is generated. It contains the geometry difference in terms
of the dimensionless normal coordinates between the structures with nonzero numbers and the reference one in

`geom.xyz` :



The output file indicates that the structural difference occurs along 2 normal coordinates: 6 (bending mode) and 7
(totally symmetric O—H stretching mode). On the basis of the calculated displacement pattern the following input
for the normal mode trajectory run between two structures can be designed:



(continues on next page)

**776** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Here the parameters `RSteps`, `LSteps` and `ddnc` are chosen in such a way that in the scan along modes 6 and
7 the corresponding dimensionless normal coordinates will be varied in the range 0 *−* 9.091932 and -9.723073
*−* 0, respectively, in accordance with the projection pattern indicated in the file `geom.ddnc` . Note that normal
modes are only defined up to an arbitrary choice of sign. Consequently, the absolute sign of the dimensionless
displacements is ambiguous and in principle can vary in different `orca_vib` runs. It is important that the normal
mode scan between different structures exemplified above is performed using the same sign of normal modes as
in the calculation of normal mode displacements. This condition is fulfilled if the same normal modes are used in
`orca_vib` run and trajectory calculation. Thus, since in `orca_vib` calculation normal modes are stored in `.hess`
file it is necessary to use the same Hessian file in the trajectory calculation.

**Printing Extra Gradients Sequentially**

If you want to print extra gradients for external applications or any other reason, you can use the keywords
SGRADLIST and TGRADLIST, for singlets and triplets. This will print the gradients sequentially after the
CIS/TDDFT run. If you put 0 on the singlet list, the ground state gradient will also be added, always at the end.



In order to save this gradients in a text file, please use:
```
%METHOD STORECISGRAD TRUE END

```
**7.30.11 Keyword List**



(continues on next page)

**7.30. Excited States via RPA, CIS, TD-DFT and SF-TDA** **777**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)


### **7.31 Excited States via ROCIS and DFT/ROCIS**

The ORCA program package includes the `orca_rocis` module to perform configuration interaction with single
excitations (CIS) calculations using a restricted open-shell Hartee-Fock (ROHF) reference function. It produces
excitation energies, absorption energies and CD intensities. It was designed with the aim to reproduce and - even
more importantly - reliably predict transition metal L-edges as observed in X-ray absorption spectroscopy (XAS).

**7.31.1 General Use**

In the present implementation the `orca_rocis` module is only able to perform CIS calculations on top of a highspin ROHF reference function. All spins of the unpaired electrons have to be coupled ferrmoagnetically to give
a total spin of *𝑆* = [1] 2 *[𝑁]* [, where] *[ 𝑁]* [is the number of unpaired electrons. Other ROHF functions such as Zerner’s]

configuration averaged or spin averaged ROHF cannot be used as reference. The input for a high spin ROHF
calculation is done in the `%scf` block.



In our experience ROHF calculations suffer a lot from convergence problems. UHF calculations generally exhibit
better convergence properties. In most cases the quasi-restricted orbitals (qro’s) of a UHF calculation resemble the
ROHF orbitals. Thus the program features the ability to start a ROCIS calculation on top of a UHF calculation. It
will automatically create the qro’s and build the reference determinant with them. If one wants to avoid the (small)
errors that are introduced by this procedure, one may take the qro’s of a UHF calculation as starting orbitals for
a subsequent ROHF calculation. Furthermore it is possible to invoke the `orca_rocis` module for closed-shell
molecules. The program will then perform a CI calculation with the provided RHF reference function. In this case
it will yield the same result as the `orca_cis` program.

A number of basic variables in the `%rocis` block control the settings of the Davidson procedure that is used to
solve the CI problem:



The dimension of the iterative subspace is given by MaxDim *·* NRoots. The lowest possible choice for MaxDim is
a value of 2. In general, by choosing `MaxDim` *≈* 5-10 times `NRoots` you will achieve a more favorable convergence
by the cost of an increased disk space requirement. Increasing the `NGuessMat` variable will improve the convergence of the iterative CI procedure. The amount of output produced during the calculation is controlled via the
`PrintLevel` variable



**778** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Note, that this does not influence which spectra are calculated or printed. The absorption spectrum calculated on
the basis of the pure dipole approximation for your calculation is always printed. In addition, it is possible to allow
for electric quadrupole and magnetic dipole contributions to the absorption spectrum as well as to calculate the
CD spectrum check section ( *One Photon Spectroscopy* ) for details. By defining in the %rocis block:



The printed spectra look like this:


(continues on next page)

**7.31. Excited States via ROCIS and DFT/ROCIS** **779**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



Furthermore like in TD-DFT (section *Use of TD-DFT for the Calculation of X-ray Absorption Spectra* ) or CASSCF
one may obtain intensities by evaluating the 2nd order oscillation strengths, or the full semi-classical oscillation
strengths.

  - The exact oscillation strengths behave like the multipole expansion in the velocity representation.

  - They are by definition origin independent they do not suffer from artificial negative values like the multipole
moments beyond 1st order.

  - They are used with the multipole moments up to 2nd order to regenerate the electric dipole, electric
quadrupole and magnetic dipole contributions in either length or the velocity representation.

For the Fe K-edge XAS spectrum of [FeCl 4 ] [2] *[−]* . This will result in addition to the following tables for the velocity
representation:



(continues on next page)

**780** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



These spectra are plotted by calling:



In particular ABSOI and ABSVOI will plot the exact transition moments spectra at the Length and Velocity representations (For the multiple expansion contributions).

If calculations on large molecules are conducted, the integral transformation will be the most time-consuming
part. Therefore it is strongly recommended to use the resolution of the identity (RI) approximation in those cases.

**7.31. Excited States via ROCIS and DFT/ROCIS** **781**

**ORCA Manual** **,** **Release 6.0.1**

It effectively reduces the computational costs of the transformation step by only introducing minor errors to the
calculation. It has to be kept in mind that in order to keep the introduced errors small, one has to provide a
reasonable auxiliary basis sets along with your normal basis set input.

Starting from ORCA 4.0 the basis set definition on ORCA has changed. This also affects the definition of the
auxiliary basis set when the DoRI keyword is set. ROCIS will then only allow in the mainline `/C` auxiliary basis
sets to be set (i.e. def2-TZVP `/C` ). As these basis are usually optimised on the presence of effective core potentials
(ECPs) they are generally not recommended for core-electron calculations. The `/J` auxiliary basis set need to be
used and they are specified in the following way.





The `orca_rocis` module provides two ways of choosing the orbital excitation space: by orbital energy or orbital
number. In the former case an energy window has to be specified and the program will then take all orbitals, whose
orbital energies lie within this window, into account. Note, that one actually has to define two orbital windows:
One for the donor and the second for the acceptor orbital. The input of the windows is done as an array: The first
two numbers define the donor space while the last two numbers define the acceptor space.



The default is to keep core orbitals and very high lying virtual orbitals out of their respective orbital excitation
spaces. Since these orbitals span a space that is usually not reachable with regular UV/Vis spectroscopy, this is a
reasonable approximation. One has to keep in mind that an orbital energy window makes only sense if the orbitals
used in the calculation have a well-defined orbital energy. As a consequence one cannot use an orbital energy
window for a calculation with localized orbitals. The second way to specify the excitation space is by orbital
numbering.



In restricted calculations only one set of spatial orbitals is created. Hence it is not necessary to provide orbital
windows for *𝛼* and *𝛽* electrons separately. Of course, only doubly or singly occupied orbitals can act as donor
orbitals and only singly and nonoccupied orbitals can act as acceptor orbitals. The program recognises nonoccupied
orbitals in the donor space and doubly occupied orbitals in the acceptor space and removes both.

The many-electron expansion space of a ROCIS calculation in ORCA is divided into five classes. Using second

**782** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

quantised replacement operators *𝐸* *𝑝* *[𝑞]* [= ˆ] *[𝑎]* *[↑]* *𝑞𝛼* *[𝑎]* [ˆ] *[𝑝𝛼]* [+ ˆ] *[𝑎]* *[↑]* *𝑞𝛽* *[𝑎]* [ˆ] *[𝑝𝛽]* [they take the form[][727][].]


*|* Φ *[𝑠]* *𝑖* *[⟩]* [=] *[ 𝐸]* *𝑖* *[𝑠]* *[|]* [0] *[⟩]*
*|* Φ *[𝑎]* *𝑠* *[⟩]* [=] *[ 𝐸]* *𝑠* *[𝑎]* *[|]* [0] *[⟩]*
*|* Φ *[𝑎]* *𝑖* *[⟩]* [=] ~~*√*~~ 1 2 *[𝐸]* *𝑖* *[𝑎]*


*|* Φ *[𝑎]* *𝑖* *[⟩]* [=] ~~*√*~~ 2 *[𝐸]* *𝑖* *[𝑎]* *[|]* [0] *[⟩]*

*|* Φ *[𝑎𝑠]* *𝑡𝑖* *[⟩]* [=] *[ 𝐸]* *𝑡* *[𝑎]* *[𝐸]* *𝑖* *[𝑠]* *[|]* [0] *[⟩]*
*|* Φ *[𝑎𝑠]* *𝑡𝑖* *[⟩]* [=] ~~*√*~~ 1 6 [(] *[𝐸]* *𝑖* *[𝑎]*


(7.236)


6 [(] *[𝐸]* *𝑖* *[𝑎]* *[−]* [2] *[𝐸]* *𝑠* *[𝑎]* *[𝐸]* *𝑖* *[𝑠]* [)] *[ |]* [0] *[⟩]*


The orbital label *𝑖* denotes a doubly occupied orbital, *𝑠* and *𝑡* refer to singly occupied orbitals and orbital label *𝑎*
corresponds to a virtual orbital. The form of the excitation classes ensures that all excited states are eigenfunctions
of the *𝑆* [ˆ] [2] -operator and have the same total spin *𝑆* as the electronic ground state. Each of the five excitation classes
can be switched on or off manually.



Formally, the *|* Φ *[𝑎𝑠]* *𝑡𝑖* *[⟩]* [and] *[ |]* [Φ] *[𝑎𝑡]* *𝑡𝑖* *[⟩]* [excitation classes can be regarded as double excitations. When the program finishes]
the ROCIS calculation it gives the excitation energy together with the composition for each root. According to the
number of labels of the respective functions *|* Φ *⟩*, contributions from excited configuration state functions belonging
to the different excitation classes are given by two, three or four numbers.



Furthermore the `orca_rocis` module is able to calculate the effect of spin-orbit coupling (SOC) on the calculated
ground and excited states. It introduces SOC in the framework of quasi-degenerate perturbation theory (QDPT).
The SOC Hamiltonian is diagonalized in the basis of the calculated ROCIS states ⃒⃒Ψ *𝑆𝑀𝐼* ⟩︀, where *𝐼* is the root label
and *𝑆* and *𝑀* are the spin and magnetic spin quantum numbers, respectively[622], [727].



After the SOC calculation the program will produce additional spectra for the SOC corrected results. The spectra
contain transitions from the 2 *𝑆* + 1 lowest lying states into all excited states, where S is the spin quantum number

**7.31. Excited States via ROCIS and DFT/ROCIS** **783**

**ORCA Manual** **,** **Release 6.0.1**

of the electronic ground state. These 2 *𝑆* + 1 lowest states may be split up in the order of 1-100 cm *[−]* [1] . Due to the
small magnitude of the splitting, all of the 2 *𝑆* + 1 states can be significantly populated even at low temperatures.
Experimentally, the intensity of a given transition is dependent on the population of the corresponding initial state.
With the `TEMPERATURE` keyword the population of the theoretically calculated states can be manipulated by the
varying the fictive temperature of the system. It has to be mentioned that the electric quadrupole transitions between
spin-orbit coupled states are not well defined and are likely to give unreasonable results. Hence it is recommended
to use the `DoHigherMoments` keyword only for calculations that do not include SOC.


If the `PrintLevel` value is set to 3 or higher, the program will print out the composition of the SOC corrected
states in the basis of states ⃒⃒Ψ *𝑆𝑀𝐼* ⟩︀.



(continues on next page)

**784** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

*̸*

*̸*

*̸*


*̸*

*̸*

*̸*


*̸*

*̸*

*̸*


Further details of the SOC calculation such as the procedure of SOC integral calculation can be controlled via the
`%rel` block (section *Relativistic Options* .

**7.31.2 Transition Metal L-Edges with ROCIS or DFT/ROCIS**

The `orca_rocis` program was designed to calculate transition metal L-edge spectra of large molecules as they are
observed in X-ray absorption spectroscopy (XAS). An L-edge results when an electron is promoted from the 2p
shell of a transition metal ion into the valence d shell by an X-ray photon. Strong spin-orbit coupling in the 2p shell
and p-d coupling phenomena complicate the interpretation and even more so the prediction of these spectra. It has
to be kept in mind that the present program applies a variety of approximations which might lead to observable
deviations from experimentally determined spectra. However, we believe that the results obtained from the program
are in general qualitatively correct and in most cases accurate close to the experimental uncertainty. In cases where
quantitative accuracy is not met, the provided results might still give some insight into the mechanisms of intensity
distribution in the spectra.

The special input structure for orbital windows described in *General Use* allows the user to restrict the donor orbital
space to the transition metal 2p shell. The acceptor orbital space is the same as in regular UV/Vis spectroscopy. It
should include all singly occupied molecular orbitals and as many virtual orbitals as one can afford in the calculation. The number of roots should be chosen large enough so that at least all 2p-3d single excitations are calculated.
In many cases even more roots are required since doubly excited or charge transfer states may become important.
Moreover the strong SOC apparent in the 2p shell of transition metal ions necessitates the additional calculation
of excited states with a total spin of *𝑆* *[′]* = *𝑆* + 1 and *𝑆* *[′]* = *𝑆* *−* 1 where *𝑆* is the total spin of the electronic ground
state. Accordingly four additional excitation classes introduce excited configuration state functions with a lower
*𝑆* and higher spin multiplicity. They feature the second quantized spin raising and lowering operatorsˆ *[−]* *𝑆* [ˆ] *𝑝𝑞* [+] [= ˆ] *[𝑎]* *[↑]* *𝑞𝛼* *[𝑎]* [ˆ] *[𝑝𝛽]* [,]
*𝑝𝑞* [= ˆ] *[𝑎]* *[↑]* *𝑞𝛽* *[𝑎]* [ˆ] *[𝑝𝛼]* [.]

*̸*

*̸*

*̸*


SOMO
2 2 *𝑆* *𝑆* *[′][′]* +1 +2 *[𝑆]* *𝑡𝑖* *[−]* *[|]* [0] *[⟩−]* ∑︀

*𝑢* = *̸* *𝑡*

SOMO
2 2 *𝑆* *𝑆* *[′][′]* +1 +2 *[𝑆]* *𝑡𝑖* *[−]* *[|]* [0] *[⟩−]* ∑︀

*𝑢* = *̸* *𝑡*

SOMO
2 2 *𝑆* *𝑆* *[′][′]* +1 +3 *[𝑆]* *𝑎𝑖* *[−]* *[|]* [0] *[⟩−]* ∑︀

*𝑡*

*̸*


Φ ( *𝑖𝑡−* ) =
⃒⃒⃒ ⟩ √︁

*̸*

Φ ( *𝑖𝑡−* ) =
⃒⃒⃒ ⟩ √︁

*̸*

Φ *𝑖* ( *𝑎−* ) =
⃒⃒⃒ ⟩ ~~√~~

*̸*


*̸*

*̸*

( *𝑆* *[′]* + 1 ) [2] *−𝑆* *[′]* [2] 1
( *𝑆* *[′]* +1)(2 *𝑆* *[′]* +3) *√* 2(2 *𝑆* *[′]* +2) *[𝑆]* *𝑡𝑡* *[−]* *[𝐸]* *𝑖* *[𝑎]* *[|]* [0] *[⟩]*

*̸*


*̸*

*̸*

( *𝑆* *[′]* + 1 ) [2] *−𝑆* *[′]* [2] 1
( *𝑆* *[′]* +1)(2 *𝑆* *[′]* +3) *√* 2(2

*̸*


~~*√*~~ 2 *𝑆* 1 *′* +1 ~~*√*~~ 2 *𝑆* 1 *′* +2 *𝑆* *𝑢𝑢* *[−]* *[𝐸]* *𝑖* *[𝑡]* *[|]* [0] *[⟩]*

*̸*

~~*√*~~ 2 *𝑆* 1 *′* +1 ~~*√*~~ 2 *𝑆* 1 *′* +2 *𝑆* *𝑢𝑢* *[−]* *[𝐸]* *𝑖* *[𝑡]* *[|]* [0] *[⟩]*

*̸*

*̸*


*̸*

*̸* *𝑆* *[′]* = *𝑆* *−* 1

*̸*


*̸*

*̸*

√

*̸*


*̸* ⎫⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪

*̸* *̸* ⎬⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎭


*̸*

*̸*

(7.237)

*̸*


*̸*

*̸*

SOMO
+ ∑︀

*𝑡,𝑢* = *̸* *𝑡*


*̸*

*̸*

√︁

*̸*


*̸*

*̸*

2
(2 *𝑆* *[′]* +2)(2 *𝑆* *[′]* +3) √︁

*̸*


*̸*

*̸*

1
(2 *𝑆* *[′]* +2)2(2 *𝑆* *[′]* +1) *[𝑆]* *𝑡𝑡* *[−]* *[𝑆]* *𝑢𝑢* *[−]* *[𝑆]* *𝑎𝑖* [+] *[|]* [0] *[⟩]*

*̸*


*̸*

*̸*

*̸*

Φ *𝑎𝑖* + = *𝑆* *𝑎𝑖* [+] *[|]* [0] *[⟩]* *𝑆* *[′]* = *𝑆* + 1
⃒⃒⃒ ⟩ }︁

Inclusion of configuration state functions with higher or lower multiplicity is invoked with the keywords
`DoLowerMult` and `DoHigherMult`, respectively.


*̸*

*̸*

*̸*


*̸*

*̸*

*̸*


*̸*

*̸*

*̸*

(continues on next page)

**7.31. Excited States via ROCIS and DFT/ROCIS** **785**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

The program will conduct a separate Davidson procedure for each multiplicity. Subsequently it gives the excitation
energies and compositions of the calculated excited states for all included multiplicities. After all CI calculations
are finished, the program gives a list of all calculated roots with their excitation energies and their multiplicities. It is
this number that will be referred to as label *𝐼* in the decomposition of spin-orbit coupled states in the basis ⃒⃒Ψ *𝑆𝑀𝐼* ⟩︀.
It is very important to note, that when states with different multiplicities are calculated this number might deviate
from the number that appears in the respective CI part of the output. If one gets confused about the numbering of
the states, the state energies might act as a guideline through the output of the program.

Without SOC the spin exclusion rule applies which means that only excited states with a total spin equal to the
ground state spin ( *𝑆* *[′]* = *𝑆* ) give rise to non-vanishing intensities. Hence, only these transitions are listed in the
spectra before SOC.



(continues on next page)

**786** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

After calculation of SOC in the basis of all calculated ROCIS roots, the program prints out the composition of the
spin-orbit coupled states (if `PrintLevel` >2) and the corresponding absorption spectrum.




(continues on next page)

**7.31. Excited States via ROCIS and DFT/ROCIS** **787**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

With the aid of the `orca_mapspc` program it is possible to extract a `.plt` file from the printed spectra, which
then can be used to generate a plot of the intensity vs the excitation energy. The `orca_mapspc` program applies
Gaussian type lineshape functions to the calculated transitions with a user-defined FWHM. One has to provide
some information for the program such as the name of the output file, the type of spectrum you wish to plot, the
energy range and the like. It is invoked in the command line and the parameters are given as arguments:
```
orca_mapspc FeIICl4.out socabs -eV -w1 -n3000 -x0710 -x1740

```
The first argument has to be the output file of your calculation followed by the type of spectrum that should be
plotted. In the case of transition metal L-edges it is an absorption spectrum after the SOC correction. The arguments
“-eV” (use electron Volt as energy unit), “-w1” (FWHM = 1eV), “-n3000” (use 3000 grid points), “-x0710” and
“-x1740” (energy range: 710 to 740 eV) have to be adapted to the specific calculation. As a result, one obtains a
`.plt` and a `.stk` file. The `.plt` file contains five columns. In the first column one finds the energy and in the
second the total intensity. Columns three to five contain the x-,y- and z-components of the transition moment.
Note, that the distribution of the transition moment among its spatial components depends on the orientation of
your molecular axis system. The `.stk` file contains a list of all transitions with their respective transition energy

Fig. 7.31: Comparison of the experimentally observed (black) and calculated ROCIS (red) Fe L-edge of [FeCl 4 ] [2] *[−]* .
The red bars highlight the contribution of individual states to the total spectrum. The calculation was performed
using the TZVP basis set.

For many transition metal compounds the description of the electronic ground and excited states by Hartree-Fock
theory and CIS is of rather poor quality. Especially covalency and relative spin state energetics are not reproduced

**788** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

correctly. This in turn might lead to wrong intensity distributions in the calculated L-edge spectra. In the majority
of these cases the quality of the description and hence the predicted L-edge spectra can be significantly improved
with the DFT/ROCIS method[727]. It features the usage of a restricted open-shell Kohn-Sham matrix as reference
and also uses the DFT orbitals for setting up the excited configuration state functions in the CI expansion. The
two electron integrals that include the DFT orbitals are scaled according to their nature and their position in the CI
matrix by the parameters *𝑐* 1, *𝑐* 2 and *𝑐* 3 . They all lie in the interval [0;1]. Parameters *𝑐* 1 and *𝑐* 2 scale coulomb- and
exchange- like terms in the diagonal part of the CI matrix, whereas *𝑐* 3 reduces the size of all off-diagonal elements
of the CI matrix. For example:

*𝐻* *𝑖𝑎,𝑖𝑎* [DFT/ROCIS] = *𝐹* *𝑎𝑎* *[𝐶]* [(][KS][)] *−* *𝐹* *𝑖𝑖* *[𝐶]* [(][KS][)] *−* *𝑐* 1 ( *𝑖𝑖|𝑎𝑎* ) + 2 *𝑐* 2 ( *𝑖𝑎|𝑖𝑎* )

(7.238)
*𝐻* *𝑖𝑎,𝑗𝑏* [DFT/ROCIS] = *𝑐* 3 {︁ *𝛿* *𝑖𝑗* *𝐹* *𝑎𝑏* *[𝐶]* [(][KS][)] *−* *𝛿* *𝑎𝑏* *𝐹* *𝑗𝑖* *[𝐶]* [(][KS][)] *−* ( *𝑖𝑗|𝑎𝑏* ) + 2 ( *𝑖𝑎|𝑗𝑏* )}︁

The three default parameters *𝑐* 1 = 0 *.* 18, *𝑐* 2 = 0 *.* 20 and *𝑐* 3 = 0 *.* 40 have been optimized for a test set of molecules
and their excited states on a B3LYP/def2-TZVP(-f) level of theory but can be freely chosen[727]. It is most likely
that for a different combination of test molecules, functional and basis set, a different set of parameters gives better
results. Since the parameters are chosen with regard of a good “balance” between orbital energies, Coulomb and
exchange integrals, a new set of parameters should at least crudely resemble their relative proportions.




Fig. 7.32: Comparison of the experimentally observed (black) and calculated (red) Ti L-edge of [Cp 2 TiCl 2 ]. The
red bars highlight the contribution of the individual states to the total spectrum. The pure ROCIS method (left)
predicts a wrong L 3 -L 2 intensity ratio and strongly overestimates the splitting of the satellite features to the main
bands. Better results are obtained with the DFT/ROCIS method (right).

**7.31. Excited States via ROCIS and DFT/ROCIS** **789**

**ORCA Manual** **,** **Release 6.0.1**

**7.31.3 Natural Transition Orbitals/ Natural Difference Orbitals**

Likewise to CIS and TD-DFT (section *Natural Transition Orbitals* ) The nature of the calculated excited states in
ROCIS and DFT/ROCIS can be analyzed by using the Natural Transition Orbitals (NTO) or Natural Difference
Orbitals (NDO) machineries.[688] Note that:

  - The NTO analysis is based on the transition density between ground and excited states. Hence is valid for
singly excited states and for states of the same multiplicity.

  - The NDO analysis on the otherhand is somewhat more flexible in this respect as it is based on the difference
density between ground and excited states.

  - Presently, only one analysis (NTO or NDO) can be performed at a time while when both flags are on the
NTO analysis switches off.

An example is given below for [FeCl 4 ] [2] *[−]* :



Then the respective NTO and NDO analysis for state 15 is given below:




(continues on next page)

**790** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



For closed shell cases the orbitals are save in similar way to TDDFT and CIS (section *Natural Transition Orbitals* ).
In the case of open shell cases for convenience donor orbitals are saved with orbital operator 0 while acceptor
orbitals with orbital operator 1. This needs to be specified in the `orca_plot` program and should not be confused
with the `spin-up` and `spin-down` orbitals in the UHF and UKS cases.

In practice one can use this machinery to analyze for example the relativistically corrected states located at 705.5
eV (when shifted with respect to experiment). It can be seen that these states contain for example significant
contributions from state 14. NTO or NDO analysis then shows that this state is dominated by the spin conserving
DOMO-SOMO 2 *𝑝* *𝑧* *−* 3 *𝑑* *𝑦𝑧* single electron excitation.

**7.31. Excited States via ROCIS and DFT/ROCIS** **791**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.33: DFT/ROCIS calculated L3 XAS spectrum of [Fe(Cl) 4 ] [2] *[−]* together with NDO analysis for state 14.
Constant broadening 0 *.* 5 eV and isovalue for the orbital plots 0 *.* 03 a.u. is used throughout

**7.31.4 Resonant Inelastic Scattering Spectroscopy**

**General**

Starting from ORCA version 4.0 ROCIS module can be used to calculate RIXS spectra

The present implementation is directly based on the Kramers Heisenerg Dirac (KDH) expression formula for near
resonant and resonant conditions


}︃


2 [{︃]
Γ *𝐹*
( *𝐸* *𝐹𝑉* *−* *𝐸* *𝑒𝑥* + *𝐸* *𝑠𝑐* ) [2] + 4 [1] [Γ] *[𝐹]* 2


⃒⃒⃒⃒⃒


*|𝛼* *𝜌𝜆* ( *𝐸* *𝑒𝑥* *, 𝐸* *𝑠𝑐* ) *|* [2] *𝑇𝑜𝑡𝑎𝑙* [=] ∑︁

*𝐹*


⃒⃒⃒⃒⃒


∑︁

*𝑉*


*⟨* *𝐹* *|* *𝑚* *𝜌* *|* *𝑉* *⟩⟨* *𝑉* *|* *𝑚* *𝜆* *|* *𝐼* *⟩*

*𝐸* *𝑉𝐼* *−* *𝐸* *𝑒𝑥* *−* *𝑖* [1] 2 [Γ] *[𝑉]*


*|𝛼* *𝜌𝜆* ( *𝐸* *𝑒𝑥* *, 𝐸* *𝑠𝑐* *, 𝑉* ) *|* [2] *𝑟𝑒𝑠𝑜𝑛𝑎𝑛𝑡* [=] ∑︁ *|⟨𝐹* *| 𝑚* *𝜌* *|𝑉* *⟩|* [2] *|⟨𝑉* *| 𝑚* *𝜆* *|𝐼⟩|* [2] *𝑓* ( *𝐸* *𝑉𝐼* *, 𝐸* *𝐹𝑉* *, 𝐸* *𝑒𝑥* *, 𝐸* *𝑠𝑐* *,* Γ *𝑉* *,* Γ *𝐹* )

*𝐹*


*|𝛼* *𝜌𝜆* ( *𝐸* *𝑉𝐼* *, 𝐸* *𝑠𝑐* ) *|* [2] *𝐷𝑖𝑟𝑒𝑐𝑡* [=] ∑︁ *|𝛼* *𝜌𝜆* ( *𝐸* *𝑉𝐼* *, 𝐸* *𝑠𝑐* *, 𝑉* ) *|* [2] *𝑟𝑒𝑠𝑜𝑛𝑎𝑛𝑡*

*𝑉*


The resonance scattering cross section for total and direct cases, averaged over all orientations of the molecule and
integrated over all directions and polarizations of scattered radiation is given in equations:


*𝑠𝑐* *[𝐸]* *[𝑒𝑥]*

*[𝑇𝑜𝑡𝑎𝑙]* [8] *[𝜋𝐸]* [3]

*𝑅𝑋𝐸𝑆* [(] *[𝐸]* *[𝑒𝑥]* *[, 𝐸]* *[𝑠𝑐]* [) =] 9 *𝑐* [4] ∑︁


*𝜎* *[𝑇𝑜𝑡𝑎𝑙]*


∑︁ *|𝛼* *𝜌𝜆* ( *𝐸* *𝑒𝑥* *, 𝐸* *𝑠𝑐* ) *|* [2] *𝑇𝑜𝑡𝑎𝑙*

*𝜌,𝜆* = *𝑥,𝑦,𝑧*



*[𝐷𝑖𝑟𝑒𝑐𝑡]* *𝑠𝑐* *[𝐸]* *[𝑒𝑥]*

*𝑅𝑋𝐸𝑆* [(] *[𝐸]* *[𝑒𝑥]* *[, 𝐸]* *[𝑠𝑐]* [) = 8] *[𝜋𝐸]* 9 [3] *𝑐* [4] ∑︁


*𝜎* *[𝐷𝑖𝑟𝑒𝑐𝑡]*


∑︁ *|𝛼* *𝜌𝜆* ( *𝐸* *𝑒𝑥* *, 𝐸* *𝑠𝑐* ) *|* [2] *𝐷𝑖𝑟𝑒𝑐𝑡*

*𝜌,𝜆* = *𝑥,𝑦,𝑧*


**792** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Interference effects can be then derived in a straightforward way from equation:

*𝜎* *𝑅𝑋𝐸𝑆* *[𝑖𝑛𝑡𝑒𝑟𝑓𝑒𝑟𝑒𝑛𝑐𝑒]* ( *𝐸* *𝑒𝑥* *, 𝐸* *𝑠𝑐* ) = *𝜎* *𝑅𝑋𝐸𝑆* *[𝑇𝑜𝑡𝑎𝑙]* [(] *[𝐸]* *𝑒𝑥* *[, 𝐸]* *𝑠𝑐* [)] *[ −]* *[𝜎]* *𝑅𝑋𝐸𝑆* *[𝐷𝑖𝑟𝑒𝑐𝑡]* [(] *[𝐸]* *𝑒𝑥* *[, 𝐸]* *𝑠𝑐* [)]

In order to access RIXS spectroscopy in the ROCIS module one needs in addition to specify a 2nd donor space.
This is specified by defining an OrbWin array with 6 elements: The first four elements define the ranges of the two
donor spaces while the last two elements the respective acceptor space range.
```
OrbWin = 0,0,2,4,45,60

```
An important difference with respect to the conventional ROCIS or DFT/ROCIS calculations is the fact that two
donor spaces of very different energy ranges are involved (e.g. K-edge, L-edge) which requires to restrict somewhat
the acceptor space and saturate it with as many states as possible.

The main calling commands in order to perform a RIXS calculation within both ROCIS and CASSCF blocks are
the following:

  - RIXS true. Similar to absorption spectroscopy, this requests the RIXS calculation to be performed based on
the calculated non-relativistic ground state multiplicity States

  - RIXSSOC true. By turning-on this flag the RIXS is calculated by taking in account the relativistically
corrected Ms States.

  - Elastic true. This flag indicates whether the resonant condition in which the initial and Final states coincide
should be taken into account. Note that the intensity of this spectral feature might be overestimated as
presently the non resonant terms are not treated

The respective ROCIS input reads then as follows:

When running the calculation one can monitor if the requested NRoots were sufficient enough to select the states
dominated by both the donor orbital spaces



(continues on next page)

**7.31. Excited States via ROCIS and DFT/ROCIS** **793**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

If that is not the case the respective RIXS calculations will not be performed and a Warning Message will be
generated:



A successful run on the other hand will generate the following messages for RIXS and RIXSSOC calculations.




(continues on next page)

**794** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



In both cases the number of involved Initial, Final and Intermediate states is specified explicitly.

For example in the case of RIXSSOC 2 Ms Ground states, 78 Intermediate states and 214 Final states are involved.
Then the RIXS cross section for elastic and inelastic scattering will be generated by 432 (2*(2+214)) Ground-Final
State-Pairs and 78 Intermediate States per Ground-Final state pair.

**Processing the spectra with** `orca_mapspc`

By calling `orca_mapspc` with the following keywords:



The program will process the `test.el_inel.rocis.rixssoc` file with the following parameters:

Energy range along x : 871-876 eV

Energy range along y: -1-34 eV

-l indicates Lorentzian broadening

Width along x (gamma): 0.4 eV

Width along y (gamma): 0.4 eV

Points along x: 125

Points along y:125

Shift to be applied along Incident energy/Emission axis: 20 eV

The y axis will be Energy Transfer axis. If -eaxis2 is the y axis will be then Emission Energy axis

All this information is printed during the data processing:



(continues on next page)

**7.31. Excited States via ROCIS and DFT/ROCIS** **795**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Successful run will generate the following files: The RIXS planes of the Total, Direct and Interference RIXS
intensity as indicated in the above equations:



In addition one obtains the integrated spectra at constant Incident energies (CIE):
```
test.el_inel.rocis.rixssoc.dw.dat

```
as well as at constant Emission/Energy Transfer energies (CEE/CET):
```
test.el_inel.rocis.rixssoc.wex.dat

```
**796** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.34: DFT/ROCIS calculated RIXS planes for [ *𝐶𝑢* ( *𝑁𝐻* 3 ) 4 ] [2] *[−]* . Left: Total RIXS Intensity, Middle: Direct
RIXS intensity and Right: Interference RIXS intensity. Lorentzian lineshape broadening with constant widths
along Incident and Energy Transfer axis (0.5 and 0.2 eV respectively) were used throughout.

**Generating Cuts**

Cuts along x and y axis can be generated with two ways:

1) At first, this action can be performed by adding the following keywords: `uex` and `udw` accounting for generating
cuts at constant Incident Energies (CIE) and at constant Emission (CEE)/or at constant Energy Transfer (CET)
respectively, together with the desired number of cuts.

2) Alternatively, the energies of the desired cuts can be specified as lists in the files udex.inp (user defined excitations) udem.inp (user defined emissions)

For example if in udex.inp one specifies:



and for the cuts along Energy Transfer axis one just specify -udw3



Then at the end one gets:



(continues on next page)

**7.31. Excited States via ROCIS and DFT/ROCIS** **797**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



The files `*_rxes_fs.dat` are RXES spectra containing all individual contributions from all Final states together
with the Direct, the Total and the Interference contributions at the given constant Incident Energy.

Similarly, the `*_rxes_vs.dat` are RXES spectra containing individual contributions of the Intermediate states,
together with the Direct the Total and the Interference contributions at the given constant Incident Energy

Likewise, the respective `*_xas_fs.dat` and `*_xas_vs.dat` are XAS type spectra with individual contributions
at a given constant Emission or Energy transfer Energy

These files are Energy vs Intensity files and read like:

1) for `*fs.dat`
```
X S- 1( 0- 0) S- 2( 0- 1) DIRECT TOT INTERFERENCE

```
2) for `*vs.dat`
```
X S- 1( 45) S- 2( 47) DIRECT TOT INTERFERENCE

```
In the first case S -1(0-0) represents the individual contribution of a given Ground-Final state pair. The numbering
follows the numbering of the output file e.g.:



Hence, in this case S -1 represents the elastic scattering intensity.

In the second case S -1(45) represents the individual contribution of a given Intermediate state.



In this case S -1 represents the intensity contribution of the first Intermediate state.

Starting from ORCA 4.2 in every RIXS requested calculation the Off resonant XES spectrum is automatically
generated in every RIXS requested calculation.

(continues on next page)

**798** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)


Hence also the myfile-rixs.out file can also be processed with the `orca_mapspc` to generate the respective XES

spectra:
```
orca_mapspc myfile_rixs.out XES/XESSOC -x06000 -x16500 -w2.0 -eV -n10000

```
**7.31.5 Core PNO-ROCIS, PNO-ROCIS/DFT**

It has been shown recently[546] that it is possible to combine the powerful machinery of the PNOs with the ROCIS
and ROCIS/DFT methods to formulate the core PNO-ROCIS and PNO-ROCIS/DFT methods. The usage of PNOs
here is somewhat unconventional since they are not used to treat electron correlation effects in a state specific
manner. Rather, the PNOs are used to identify the relevant part of the virtual space that can be reached by excitation
out of local core orbitals. This subspace of the virtual space is local, thus leading to a linear scaling, state universal
method.

The PNO-ROCIS calculations can be requested with the following keywords:



As has been shown in reference[546] a universal TCutPNO 1e-11 threshhold can be defined for all edges provided
that the PNOs are constructed by taking into account all the availiable core orbitals in the systems. For example in

**7.31. Excited States via ROCIS and DFT/ROCIS** **799**

**ORCA Manual** **,** **Release 6.0.1**

the case of a 1st row transition metal this will be the 9 1s, 2s, 2p, 3s and 3p MOs. These orbitals will be identified
automatically by the program provided that the element or the elements for which the XAS calculation will be
performed are specified within the XASElems keyword. In the following example these correspond to Core MOs
36-44. Note that the CoreMOs list should not be confused with the OrbWin which is used to specify the excitation
space that will be actually used in the actual calculation.



Alternativelly one can also use the CoreMOs keyword to individual select the respective CoreMOs



A complete list of CoreMOs of the different atoms can be found in reference[546] The program will then proceed
and generate the Core PNOs and use the TCutPNO threshold to reduce the Virtual MO space. In the following
example only virtual orbitals are selected out of the total 1445 virtual MOs



From this point and on the programm will proceed the usual way. This will result in extraordinary computation
speeding ups without loss in accuracy.

**800** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.31.6 ROCIS Magnetic Properties**

Several magnetic properies are availiable in the ROCIS method Including g-tensors (G-Matrix), zero field splittings
(ZFS), hyperfine couplings (HFCs) and electric field gradients (EFGs).

The g-tensors as well as the zfs are calculated on the basis of the Effective Hamiltonian as well in the sum over
states (SOS) framework. HFCs are calculated in the SOS framework while EFGs are calculated as expectation
values. Please consult also the respective discussion in the MRCI chapter (section *The Multireference Correlation*
*Module* )



This will enter the calculation in the ROCIS Spin Hamiltonian section



**7.31.7 Keyword List**



(continues on next page)

**7.31. Excited States via ROCIS and DFT/ROCIS** **801**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



**802** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**
### **7.32 Excited States via MC-RPA**

MC-RPA excitation energies and transition moments are computed from the poles and residues of the linear response function of CASSCF a wave function.[380, 417, 902] By following similar lines, it is in principle possible
to compute any kind of static and dynamic molecular property that is based on analytic derivatives of the CASSCF
energy, which may be available in future releases of ORCA.

**7.32.1 General Description**

The starting point of response theory for variational wave functions like CASSCF is the time-dependent (TD)
Schrödinger equation in its phase-isolated form[174]

ˆ
*𝐻* *−* *𝑖* *[𝜕]* *|* 0 [˜] *⟩* = 0
(︁ *𝜕𝑡* *[−]* *[𝑄]* )︁

with the TD quasi energy

︂ ︂


ˆ
*𝑄* ( *𝑡* ) = *⟨* 0 [˜] *|* *𝐻* *−* *𝑖* *[𝜕]*
(︁ *𝜕𝑡*

︂ ︂


*|* 0 [˜] *⟩* .
)︁

︂ ︂


The Hamiltonian *𝐻* [ˆ] = *𝐻* [ˆ] 0 + *𝑉* [ˆ] *[𝑡]* consists of the unperturbed time-independent Hamiltonian *𝐻* [ˆ] 0 and a TD perturbation

︂ ︂


*𝑒* *[−][𝑖𝜔]* *[𝑘]* *[𝑡]* [∑︁]

*𝑘* *𝑥*

︂ ︂


ˆ
*𝑉* *[𝑡]* = ∑︁

︂ ︂


*𝜀* *𝑥* ( *𝜔* *𝑘* ) *𝑋* [ˆ]

*𝑥*

︂ ︂


which is described as a sum of periodic perturbations, i.e. a Fourier series. TD molecular properties are obtained
by applying the TD variational principal

*𝛿{𝑄* ( *𝑡* ) *}* *𝑇* = 0

up to a certain order in the time-averaged quasi energy

︂ ︂


*{𝑄* ( *𝑡* ) *}* *𝑇* = [1]

*𝑇*

︂ ︂


*𝑇/* 2

*𝑄* ( *𝑡* ) *𝑑𝑡*

∫︁ *−𝑇/* 2

︂ ︂


while *{𝑄* ( *𝑡* ) *}* *𝑇* is expanded by the perturbation strengths *𝜀* *𝑋* at vanishing frequencies *𝜔* *𝑘* = 0. Applying the TD
variational principle for the second-order quasi energy leads to

0 = *𝛿{𝑄* ( *𝑡* ) *}* [(2)] *𝑇* = *⇒* *[𝜕]* *[𝑄]* *𝜕* *[𝑋𝑌]* ***𝜆*** *𝑋* [(] *[−]* ( *−* *[𝜔]* *𝜔* *[𝑌]* *𝑌* *[,]* *[ 𝜔]* ) *[𝑌]* [)] = (︁ **E** [(2)] *−* *𝜔* *𝑌* **S** [(2)] [)︁] ***𝜆*** *[𝑌]* *−* **V** *[𝑌]* = 0. (7.239)

The first-order response equations *(7.239)* become singular if the perturbation frequency *𝜔* *𝑌* approaches any eigenvalue

**E** [(2)] ***𝜆*** = **S** [(2)] ***𝜆*** *𝜔*,

︂ ︂


of second-derivative matrices **E** [(2)] and **S** [(2)] . The eigenvalues *𝜔* correspond to the electronic excitation energies.
The second-derivative matrices **E** [(2)] and **S** [(2)] have a paired structure as both kind of operators that express orbital
excitation and de-excitations are involved:

**A** **B** **Σ** **Δ** **X** **0**

*−* *𝜔* =

**B** *[*]* **A** *[*]* *−* **Δ** *[*]* *−* **Σ** *[*]* **Y** *[*]* **0**

[︂(︂ )︂ (︂ )︂]︂(︂ )︂ (︂ )︂

The eigenvalue equations above are valid for all variational wave functions methods, e.g. DFT, HF, CASSCF etc.
The only difference is the operator manifold and the unperturbed Hamiltonian *𝐻* [ˆ] 0 that is used. For the CASSCF
linear response and eigen value equations, the super matrices **A**, **B**, **Σ**, and **Δ** have the following structure:

︂ ︂


**Σ** **Δ**
*−* *𝜔*
*−* **Δ** *[*]* *−* **Σ** *[*]*
)︂ (︂

︂ ︂


**X**

**Y** *[*]*
)︂]︂(︂

︂ ︂


**0**

=
**0**
)︂ (︂

︂ ︂


)︂

︂ ︂


)︃

︂ ︂


)︃

︂ ︂ )


**A** =

︂ ︂


*⟨* 0 *|* [ *𝑞* *𝑖* *,* [ *𝐻* [ˆ] 0 *, 𝑞* *𝑗* *[†]* []]] *[ |]* [0] *[⟩]* *⟨* 0 *|* [[ *𝑞* *𝑖* *,* *𝐻* [ˆ] 0 ] *, 𝑅* *𝑗* *[†]* []] *[ |]* [0] *[⟩]*
(︃ *⟨* 0 *|* [ *𝑅* *𝑖* *,* [ *𝐻* [ˆ] 0 *, 𝑞* *𝑗* *[†]* []]] *[ |]* [0] *[⟩]* *⟨* 0 *|* [ *𝑅* *𝑖* *,* [ *𝐻* [ˆ] 0 *, 𝑅* *𝑗* *[†]* []]] *[ |]* [0] *[⟩]*

︂ ︂


**Σ** =

︂ ︂


*⟨* 0 *|* [ *𝑞* *𝑖* *, 𝑞* *𝑗* *[†]* []] *[ |]* [0] *[⟩]* *⟨* 0 *|* [ *𝑞* *𝑖* *, 𝑅* *𝑗* *[†]* []] *[ |]* [0] *[⟩]*
(︃ *⟨* 0 *|* [ *𝑅* *𝑖* *, 𝑞* *𝑗* *[†]* []] *[ |]* [0] *[⟩]* *⟨* 0 *|* [ *𝑅* *𝑖* *, 𝑅* *𝑗* *[†]* []] *[ |]* [0] *[⟩]*

︂ ︂


**B** = ︂ *⟨* 0 *|* [ *𝑞* *𝑖* *,* [ ˆ *𝐻* 0 *, 𝑞* *𝑗* ]] *|* 0 *⟩* *⟨* 0 *|* [[ *𝑞* *𝑖* *,* *𝐻* [ˆ] 0 ] *, 𝑅* *𝑗* ] *|* 0 *⟩* ︂
( *⟨* 0 *|* [ *𝑅* *𝑖* *,* [ *𝐻* [ˆ] 0 *, 𝑞* *𝑗* ]] *|* 0 *⟩* *⟨* 0 *|* [ *𝑅* *𝑖* *,* [ *𝐻* [ˆ] 0 *, 𝑅* *𝑗* ]] *|* 0 *⟩*


︂ ) **Δ** = ( ︂ *⟨⟨* 00 *||* [ [ *𝑅𝑞* *𝑖𝑖* *, 𝑞, 𝑞* *𝑗𝑗* ]] *| |* 00 *⟩⟩* *⟨⟨* 00 *||* [ [ *𝑅𝑞* *𝑖𝑖* *, 𝑅, 𝑅* *𝑗𝑗* ]] *| |* 00 *⟩⟩*


︂ ︂

**7.32. Excited States via MC-RPA** **803**

**ORCA Manual** **,** **Release 6.0.1**

The TD CASSCF wave function is expressed in terms of orbital excitation *𝑞* *𝑖* *[†]* [and de-excitation operators] *[ 𝑞]* *[𝑖]* [,]

*𝑞* *𝑖* *[†]* [=] *[ 𝐸]* *[𝑝𝑞]* [=] *[ 𝑎]* *[†]* *𝑝𝛼* *[𝑎]* *[𝑞𝛼]* [+] *[ 𝑎]* *[†]* *𝑝𝛽* *[𝑎]* *[𝑞𝛽]* [,] *𝑞* *𝑖* = *𝐸* *𝑞𝑝*, with *𝑝> 𝑞*

as well as so called state transfer operators

*𝑅* *𝑖* *[†]* [=] *[ |][𝑖][⟩⟨]* [0] *[|]* [,] *𝑅* *𝑖* = *|* 0 *⟩⟨𝑖|*, with *𝑖* = 0 *̸*

that account for relaxation of orbitals and CI coefficients when perturbed by an electromagnetic field, respectively.

The eigenvalue (and response) equations are solved iteratively by a customized version of the Davidson algorithm
that simultaneously determines the N lowest lying roots. The most time-consuming step is the transformation
of the trial vectors that contain an orbital and CI coefficient part with the electronic Hessian matrix **E** [(2)] . The
working equations are very similar to those of the CASSCF electronic gradient that is computed when minimizing
the CASSCF ground state energy.

As a show case example the UV/Vis spectrum of a Nickel dimethylglyoximato complex (Ni(dmg) 2 ) was simulated
with both SA-CASSCF and MC-RPA. A CAS (12/9) with the 3d electrons on Ni and 4 *𝜋* orbitals and electrons
from the ligands was selected; the def2-SVP basis set was used. For SA-CASSCF we have averaged over 21 states
while for MC-RPA the 20 lowest roots were determined. Though both UV/Vis spectra have two intense peaks,
their excitation energies and oscillator strengths differ quite substantially. This can be attributed to the lack of
state-specific orbital relaxation that is only available in MC-RPA. In subsection *Natural Transition Orbitals* the
most important natural transition orbitals[380, 562] and active natural orbitals of MC-RPA and SA-CASSCF are
shown, respectively.

*̸*

*̸*

*̸*

*̸*


Fig. 7.35: Calculated UV/Vis spectra of Ni(dmg) 2 .

**7.32.2 Detecting CASSCF Instabilities**

*̸*


Selecting the right orbitals for the active space is not always an easy task. A wrong selection may lead to convergence to excited states or saddle points when minimizing the CASSCF energy. Such an instability in the wave
function can be detected by computing the lowest excitation energy, i.e. the lowest root of the electronic Hessian
with MC-RPA.

Instabilities may occur even for the simplest cases if the starting orbitals for CASSCF energy calculation were
inappropriate. Let us look at a benzene CAS(6/6) calculation where we started from the `model potential` initial
guess for the MOs.


*̸*


*̸*


*̸*

(continues on next page)

**804** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



The energy converges smoothly



as the gradient norm does



(continues on next page)

**7.32. Excited States via MC-RPA** **805**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Though we have reached convergence for a CASSCF ground state energy calculation, the MC-RPA calculation
however detects an instability



by finding positive-indefiniteness by a Cholesky decomposition of the reduced space Hessians.

Instabilities in the CASSCF wavefunction can usually be avoided by carefully monitoring the active space orbitals
in the



section of the CASSCF output.



(continues on next page)

**806** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

In this particular example, MOs 18 and 23 are not part of the *𝜋* system and have to be rotated with orbitals 16 and
31, respectively. After rotating all *𝜋* orbitals into the active space, the CASSCF converges to a lower energy.

The electronic CASSCF Hessian is now positive definite and the lowest MC-RPA excitation energy becomes
```
STATE 1: E= 0.171023 au 4.654 eV 37535.3 cm**-1

```
**7.32.3 Natural Transition Orbitals**

Natural transition orbitals[380, 562] (NTO) are obtained from a singular value decomposition of the MC-RPA
ground-to-excited state (f) transition density matrices *𝜌* [0] *𝑝𝑞* *[→][𝑓]* . As for TD-DFT and ROCIS one obtains two sets of
orbitals for each state that describe the donation (occupied and active) and acceptance (active and virtual) of an
electron in the electronic transition. The orbital structure of *𝜌* [0] *𝑝𝑞* *[→][𝑓]* for CASSCF wave functions is illustrated in Fig.
7.36.

**7.32. Excited States via MC-RPA** **807**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.36: Structure of MC-RPA transition density matrix *𝜌* [0] *𝑝𝑞* *[→][𝑓]*

The compute NTOS only the following flag in the input has to switched ON:



This will compute all NTOs with a singular value larger then the `NTOThresh` threshold for ALL roots.

(continues on next page)

**808** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

For the above example, the most important (controlled by `NTOThresh` ) donating and accepting NTOs of state 13
are written to the `gbw` -type files



and can be plotted with the `orca_plot` program (see Sec. *orca_plot* )
```
orca_plot ni-dmg-2-svp-cas-12-9-mcrpa.s12.nto-donor -i

```
Please be aware of the different indices for states in the in and output!

To compute less or more NTOs the threshold `NTOThresh` can be adapted accordingly.

Let us come back to the UV/Vis spectra of Ni(dmg) 2 . For the two most intense peaks the natural orbitals and NTOs
of MC-RPA and SA-CASSCF, respectively, are shown in Fig. 7.37. While the most intense peak in each spectrum
(b and A) correspond to the same *𝜋* *→* *𝜋* *[*]* excitation, transition a and B are complete different, i.e. *𝑑* *→* *𝜋* *[*]* and
*𝜋* *→* *𝜋* *[*]* .

**7.32. Excited States via MC-RPA** **809**

**ORCA Manual** **,** **Release 6.0.1**

(a) (a) SA natural orbitals (b) (b) NTOs

Fig. 7.37: Calculated UV/Vis spectra of Ni(dmg) 2 .

**7.32.4 Computational Aspects**

The code is intended to be used for medium-sized and larger open-shell molecules. It has the same scaling as
ORCA’s first-order CASSCF energy implementation though a larger pre-factor as the computational cost grow “in
principle” linearly with the number of roots.

The implementation is AO-driven meaning that the computational bottleneck is the Fock matrix construction for
the several state-specific pseudo AO densities. Note that there are up to 6 pseudo AO densities for each state.
The computational costs can be reduced significantly if the `RIJCOSX` approximation is employed, which is highly
recommended.

The second most expensive part of the MC-RPA computation are the two-electron integrals with 3 active indices
*𝑔* *𝑝𝑡𝑢𝑣* . As we aim for running calculations on larger systems, there is only an implementation of the integral
transformation that uses the resolution-of-the-identity (RI) approximation.

The restrictions on the auxiliary basis sets are the same as for the CASSCF code (Sec. *General Description* ). That

is

  - If the Fock matrices are constructed in `Direct` or `Conventional` mode, the /C bases are used for the RI
approximation of the *𝑔* *𝑝𝑡𝑢𝑣* integrals.

  - If the `RIJCOSX` approximation for the Fock matrices is employed, the /JK bases are used for both the Fock
matrices and the *𝑔* *𝑝𝑡𝑢𝑣* integrals.

Note that MC-RPA implementation can be run in parallel with MPI which allows for computing UV/Vis and ECD
spectra large open-shell molecules in a limited amount of time.

Before starting running MC-RPA, it is recommended to converge the state specific CASSCF energy calculation
until you hit the point of stagnating convergence. Note that property calculations in general assume vanishing
electronic gradients otherwise numerical issues in the eigenvalue / response equations may occur.

**810** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


**7.32.5 Keyword List**




### **7.33 Excited States via EOM-CCSD**

The EOM-CCSD routine is part of the `orca_mdci` module of the ORCA program package. It is called after
a successful coupled-cluster calculation, if the appropriate flags and the number of roots have been set. In the
following chapter the general program flow and all input parameters of the EOM routine will be described in
detail (for typical use, see *Excited States with EOM-CCSD* ). For an RHF or UHF reference, the EE-, IP- and EAEOM-CCSD approaches are available for the computation of excitation energies, ionization potentials and electron
affinities, respectively. Currently, the following simple input keywords are available:



**7.33.1 General Description**

The EOM wave function is parametrized in the following manner

*ℛ|* Ψ *𝐶𝐶* *⟩,*

i.e. via the action of a linear excitation operator *ℛ* on the coupled-cluster ground state wave function Ψ *𝐶𝐶* . Here,
*ℛ* is a particle conserving operator, in the case of the excitation energy problem. However, this is not true for the
ionization or electron attachment problems, where *ℛ* is a net annihilation or net creation operator, respectively.
The ground state coupled-cluster T-amplitudes are obtained from a CCSD calculation, and our task is to obtain *ℛ* .
Note that since the CC Hamiltonian is nonsymmetric, a left hand solution ( *ℒ* ) would also be needed to evaluate
properties. For the calculation of excitation, ionization or electron attachment energies, however, it is enough to

**7.33. Excited States via EOM-CCSD** **811**

**ORCA Manual** **,** **Release 6.0.1**

obtain the right hand solutions ( *ℛ* ). In principle, this is done by building the Hamiltonian and diagonalizing it in
order to obtain energy expectation values.

In practice, the size of the CCSD Hamiltonian matrix is prohibitively large and thus, various methods have been
devised to obtain its lowest few eigenvalues and eigenstates. One of the most popular of these approaches is the
Davidson method, which can be summarized as follows:

  - Construct an initial guess of orthogonal trial vectors, *𝐶* .

  - Evaluate the sigma vectors *𝜎* = *𝐻𝐶* .

  - Build model Hamiltonian *ℋ* = *𝐶* *[𝑇]* *𝜎* .

  - Diagonalize *ℋ* : *ℰ* = *𝒰* *[𝑇]* *ℋ𝒰* .

  - Compute Ritz vectors *𝑋* = *𝐶𝒰* .

  - Compute residuals *𝑅* = *𝑋ℰ−* *𝜎𝒰*, check convergence: if yes, pass *𝑋, ℰ* as solutions.

  - Preconditioning: *𝑇* = *𝑀𝑅* (many possible choices for the preconditioner *𝑀* ).

  - Check if adding new trial vectors would exceed the maximum number of trial vectors:

**–** if no, add *𝑇* to *𝐶*, and orthonormalize the united set

**–** if yes, then set *𝑋* as *𝐶* (orthonormalize if *𝐻* is nonsymmetric); then add *𝑇* and orthonormalize

The advantage of the above method is that, instead of the full Hamiltonian, only the sigma vectors have to be
explicitly evaluated and stored.

It is also possible to use a lower scaling version of the EOM-CCSD methods, which relies on the perturbative
truncation of the coupled-cluster similarity transformed Hamiltonian. Presently, only the second order truncated
version (CCSD(2) approximation) is available for closed-shell molecules (RHF). However, it is better to use the
PNO based implementation, as it has the cost of EOM-CCSD(2), but its accuracy is comparable to canonical
EOM-CCSD.

Below are all the parameters that influence the RHF EOM routine. In the following sections, these parameters will
be explained following the solver algorithm described above.

(continues on next page)

**812** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



In the case of the UHF EOM-CCSD implementation, the parameters that influence a given calculation are provided
below.



**7.33.2 Memory Management**

The most important data coming from the coupled-cluster routine are the ground state energy and wave function,
and the molecular integrals. The integrals are then used to create “dressed” integral containers, which allows for an
efficient factorization of the EOM equations, since these dressed quantities do not change during the calculation.
Most of these are written on disk, with the possible exception of the integral container which has three external
labels. This, and the solver files may remain in core if enough memory is available. The program sequentially tries
to allocate memory for the files in the order of their importance, and what cannot be kept in core, goes on disk. The
order of allocation is as follows: 1. residual vectors, 2. Ritz vectors, 3. three external integrals, 4. sigma vectors
and 5. state (trial) vectors, as seen in the example below:



(continues on next page)

**7.33. Excited States via EOM-CCSD** **813**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Half of the memory specified with the keyword `MaxCore` is distributed among the five candidates. In the above
case, everything fits in memory. Note that these are only the largest contributors to memory consumption, and
there should ideally be a safety margin when allocating memory.

In order to estimate the amount of necessary memory, it should be kept in mind that, in the closed shell case, the
memory requirements of the residual and Ritz vectors are proportional to *𝑁* *𝑅* *𝑁* *𝑃* *𝑁* *𝑉* [2] [, the three external integrals]
to *𝑁* *𝑅* *𝑁* *𝑂* *𝑁* *𝑉* [3] [and the sigma and trial vectors to] *[ 𝑁]* *[𝐷]* *[𝑁]* *[𝑅]* *[𝑁]* *[𝑃]* *[𝑁]* *𝑉* [2] [, where] *[ 𝑁]* *[𝑂]* [and] *[ 𝑁]* *[𝑉]* [are the number of occupied]
and virtual orbitals, *𝑁* *𝑃* = *[𝑁]* *[𝑂]* [(] *[𝑁]* 2 *[𝑂]* [+] [1] [)] is the number of occupied pairs, *𝑁* *𝑅* is the number of roots, and *𝑁* *𝐷* is

the maximum size of the reduced space. The keyword `NRoots` sets *𝑁* *𝑅*, while `NDav` determines *𝑁* *𝐷* . Luckily, the
contributions that, in our experience, are the most important to keep in memory, are also the ones that require the
smallest amount of it. It is advisable to use `KCOpt AOBLAS`, as it has the lowest memory requirements.

Note that in the UHF EE-EOM-CCSD implementation, the memory requirements of the residual and Ritz vectors
are proportional to *𝑁* *𝑅* ( *𝑁* *𝑃* *𝛼* *𝑁* *𝑉* [2] *𝛼* [+] *[𝑁]* *[𝑃]* *𝛽* *[𝑁]* *𝑉* [2] *𝛽* [+] *[𝑁]* *[𝑂]* *𝛼* *[𝑁]* *[𝑂]* *𝛽* *[𝑁]* *[𝑉]* *𝛼* *[𝑁]* *[𝑉]* *𝛽* [)][, the three external integrals to] *[ 𝑁]* *[𝑅]* [(] *[𝑁]* *[𝑂]* *𝛼* *[𝑁]* *𝑉* [2] *𝛼* [+]
*𝑁* *𝑂* *𝛽* *𝑁* *𝑉* [2] *𝛽* [+] *[𝑁]* *[𝑂]* *𝛼* *[𝑁]* *[𝑉]* *𝛼* *[𝑁]* *𝑉* [2] *𝛽* [+] *[𝑁]* *[𝑂]* *𝛽* *[𝑁]* *[𝑉]* *𝛽* *[𝑁]* *𝑉* [2] *𝛼* [)][ and the sigma and trial vectors memory requirements are proportional]
to *𝑁* *𝐷* *𝑁* *𝑅* ( *𝑁* *𝑃* *𝛼* *𝑁* *𝑉* [2] *𝛼* [+] *[ 𝑁]* *[𝑃]* *𝛽* *[𝑁]* *𝑉* [2] *𝛽* [+] *[ 𝑁]* *[𝑂]* *𝛼* *[𝑁]* *[𝑂]* *𝛽* *[𝑁]* *[𝑉]* *𝛼* *[𝑁]* *[𝑉]* *𝛽* [)][, where] *[ 𝑁]* *[𝑂]* *𝛼* [,] *[ 𝑁]* *[𝑂]* *𝛽* [,] *[ 𝑁]* *[𝑉]* *𝛼* [and] *[ 𝑁]* *[𝑉]* *𝛽* [are respectively, the]

number of occupied alpha, occupied beta, virtual alpha and virtual beta orbitals and *𝑁* *𝑃* *𝛼* = *𝑁* *𝑂* *𝛼* ( *𝑁* 2 *𝑂* *𝛼* *−* 1 ) and

*𝑁* *𝑃* *𝛽* = *𝑁* *𝑂* *𝛽* ( *𝑁* 2 *𝑂* *𝛽* *−* 1) are the number of alpha and beta occupied pairs, respectively.

**7.33.3 Initial Guess**

The present initial guess in the RHF EOM implementation consists of constructing a CIS Hamiltonian of a certain
dimension, and diagonalizing it. The roots are preselected based on the energetic ordering of the diagonal elements
of the Hamiltonian. In the UHF case, the guess is constructed from the solutions of a UHF CIS calculation. The
number of roots in the initial guess is determined as 20 times the number of roots desired in EOM ( `NRoots` ) if
`NDav` is 20 or smaller, otherwise it is set to `NDav` times the number of EOM roots. If the parameter `NInits` is
larger than zero, then the number of initial guess roots will be set to this parameter times `NRoots` . The maximum
possible number of roots is the full CIS dimension, ( *𝑁* *𝑂* *𝑁* *𝑉* (RHF) or *𝑁* *𝑂* *𝛼* *𝑁* *𝑉* *𝛼* + *𝑁* *𝑂* *𝛽* *𝑁* *𝑉* *𝛽* (UHF)) . One should
keep in mind, while increasing the number of initial guess vectors, that this corresponds to diagonalizing a matrix
of increasing dimension. If, for example `NRoots` is 10, then by default 200 roots are considered in the initial guess
(unless it exceeds the size of the CIS space), or if `NInits` is set to 100, then there will be 1000 roots in the guess.
In some cases, the roots calculated using EOM may not be the lowest ones, but a few of these may be replaced by
some higher roots which are “easier” to find. In such cases, it may help to increase `NRoots` or `NInits` to converge
to the proper roots. The program can be made to follow the initial CIS guess by setting `FollowCIS` to true and
is necessary if we wish to ionize or excite from inner-valence or core orbitals. In the RHF implementation, the
core orbital, from which the ionization or excitation originates, can be specified using the keyword `CoreHole`,
in addition to setting `DoCore` and `FollowCIS` to true. The `CoreHole` keyword is quite general and in principle,
ionization or excitation processes from any occupied orbital can be specified using this keyword.

**814** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.33.4 Hamiltonian Construction**

The Hamiltonian construction begins by calling the sigma routines. In the case of the closed-shell code, the logical
variables `UseEOMOptS` and `UseEOMOptD` choose the routines to be used in the evaluation of the singles and doubles
sigma vectors, respectively. If true, the optimized sigma routine, using dressed integrals, will be used. This should
not be changed, the option is there mainly for debugging purposes. If set to false, an automatically generated, and
much slower serial code will be used instead. In the case of the open-shell UHF implementation, optimized sigma
routines have been generated using the ORCA Automated Generator Environment (AGE) [474]. In each early
iteration, *𝑁* *𝑅* sigma vectors will be determined, except in the case of a restart, where the number of sigma vectors
is 2 *𝑁* *𝑅* . For further details on convergence, see *Convergence, Restart, Preconditioning and Subspace Expansion*
below.

The most time consuming part of the sigma vector construction is the formation of the external exchange contribution, which can be influenced via the CC keyword `KCOpt` . Currently, there are three options that are compatible
with the RHF EOM implementation: `KC_MO`, `KC_AOX` and `KC_AOBLAS` (see the MDCI documentation) and `KC_AOX`
is the only option available in the UHF EOM code. The external exchange term can be treated most efficiently
using COSX, which in the closed-shell case, leads to average speed ups of 10x for the external exchange term
and an overall speedup of 3x for the EOM calculation. This is accompanied by a drastic reduction of the storage
cost[233]. The error introduced is below 1 meV, which is 200-fold less than the error bar of the method[233] itself.
It is the default for `KCOpt KC_AOX` and `KC_AOBLAS` and can be controlled by the keyword `DOCOSXEOM` . The default
grid settings for EOM are `GridX 1` and `IntAccX 2.68` .

Once the sigma vectors are available, they are multiplied with the trial vectors to yield the reduced space Hamiltonian. The Hamiltonian is built in a way that, in each iteration, only the new vector products are added to the “edge”
of the old Hamiltonian, so that a full build is avoided. It should be clear that the parameter `NDav` plays an important
role here, since it determines the maximum size of the Hamiltonian ( *𝑁* *𝐷* *𝑁* *𝑅* ), and also controls how much memory
is needed for the trial and sigma vectors, as seen above. Since the choice of this parameter influences convergence
properties, it will be discussed further in *Convergence, Restart, Preconditioning and Subspace Expansion* .

**7.33.5 Solution of the (Nonsymmetric) Eigenproblem**

Following the construction of the Hamiltonian, a nonsymmetric eigensolver is called. In this case, it is possible to
have complex eigenvalues. In practice, this is rarely the case, and indicates a problem of some kind. A warning
will be given if this happens, however, one may get away with this if it only happens in an isolated iteration step.

Once the eigenvectors are available, they are compared with those of the previous iteration, if root homing is turned
on, i.e. if the `RootHoming` keyword is set to true. This means evaluating the overlap of the old and new eigenvectors,
in order to keep track of the possible movement of the eigenvectors if root flipping occurs. If converged roots are
removed from further iterations (see next section), it is important to keep track of changes in ordering, especially
if a converged and a non-converged root is swapped. After diagonalization, the Ritz vectors and residuals can be
evaluated.

**7.33.6 Convergence, Restart, Preconditioning and Subspace Expansion**

Convergence is signaled once a residual square norm based criteria is fulfilled. This criteria is determined by the
`CheckEachRoot` keyword. If it is true (default), the convergence of the residual square norm of each root is checked
separately. This is due to the fact that different roots converge at a different rate. Once a root is converged, no new
trial vectors will be generated, belonging to that vector. This means that the EOM iterations will progressively
become faster (until restart). Turning off the rootwise convergence check is possible, but not recommended. In this
case, the maximum of all residual square norms is checked for convergence, and all iterations will take roughly the
same amount of time since no vectors are removed in any iteration. However, this procedure can be numerically
unstable, since the residuals of some roots might become very close to zero, and trying to generate new vectors,
which are orthogonal to these, may lead to numerical disaster. In short, the recommended default is having both
`CheckEachRoot` and `RootHoming` set to true. If `CheckEachRoot` is false, then `RootHoming` should also be set
to false, as it may cause problems if `NDav` is too small. The convergence threshold of the residual in Davidson’s
method can be larger than that for the ground state CC residual threshold in order to obtain converged results.
Namely, a value of `DTol` of 1e-5 is almost always enough to get well converged energies.

**7.33. Excited States via EOM-CCSD** **815**

**ORCA Manual** **,** **Release 6.0.1**

At this point it is worth discussing the role of the keyword `NDav` . This keyword determines at what point the Davidson algorithm should be restarted. If it is chosen too small, it may cause slow convergence. If this value is too large,
this may result in overwhelming demands on memory/disk space requirements. The default value (20) is chosen
with the hope that no, or maybe one restart will be required. It should only be changed if computational resources
demand it. However, the treatment of core ionization or core excitation processes often requires a large value of
`NDav` . At restart, Ritz vectors are copied as new trial vectors for all roots, which will then be orthonormalized,
while new vectors will only be generated for the non-converged roots. This means that the step after the rebuilding
of the expansion space will be 1-2 times as expensive as one of the initial steps.

New directions (trial vectors) are generated from the preconditioned residual vectors. If no preconditioning is
applied (the preconditioner is taken to be a unit matrix), one falls back to the Lanczos algorithm, which is inferior
to the Davidson algorithm. This happens if the keyword `DoLanczos` is true. This is not recommended, as the
Lanczos algorithm converges several times slower than Davidson’s, and is there for debugging mainly. The original
Davidson preconditioner is the inverse of a diagonal matrix which contains the difference of the diagonal elements
of the Hamiltonian and the current approximation to the eigenvalue belonging to the given root. Let us consider
the closed-shell RHF implementation for simplicity. If *𝑅* *𝑖𝑎* and *𝑅* *𝑖𝑗𝑎𝑏* are elements of the singles and doubles
amplitudes, respectively, then the updated vectors ( *𝑇* *𝑖𝑎*, *𝑇* *𝑖𝑗𝑎𝑏* ) have the form

*𝑅* *𝑖𝑎*
*𝑇* *𝑖𝑎* =
*𝐷* *𝑖𝑎* + *ℰ* *𝑅*

for singles, and

*𝑅* *𝑖𝑎*
*𝑇* *𝑖𝑗𝑎𝑏* =
*𝐷* *𝑖𝑗𝑎𝑏* + *ℰ* *𝑅*

for doubles. Here, *𝐷* *𝑖𝑎* and *𝐷* *𝑖𝑗𝑎𝑏* are related to, and possibly approximations of, the respective diagonal Hamiltonian elements. The simplest approximation is just to construct these from diagonal Fock matrix elements (i.e.
orbital energies) as *𝐷* *𝑖𝑎* = *𝜀* *𝑎* *−* *𝜀* *𝑖* and *𝐷* *𝑖𝑗𝑎𝑏* = *𝜀* *𝑎* + *𝜀* *𝑏* *−* *𝜀* *𝑖* *−* *𝜀* *𝑗* . A slightly better preconditioning can be obtained
as follows. For singles, take the exact CIS diagonal elements, *𝐷* *𝑖𝑎* = *𝜀* *𝑎* *−* *𝜀* *𝑖* + *𝑔* *𝑖𝑖𝑎𝑎*, where the last term is the
respective antisymmetrized integral; and construct the doubles as *𝐷* *𝑖𝑗𝑎𝑏* = *𝐷* *𝑖𝑎* + *𝐷* *𝑗𝑏* . This is the default, and can
be changed back to the simple Fock matrix guess by setting `UseCISUpdate` to false.

Following the preconditioning step, the resulting vectors are orthogonalized to the previous set of trial vectors,
and orthonormalized among themselves. Since, the trial vectors do not change once they are generated (unless a
restart occurs), only the new elements of the overlap matrix need to be generated for the orthonormalization. The
numerical threshold for the inversion (and other division steps) is controlled by the parameter `OTol` . Finally, the
amount of printed information can be controlled via the `PrintLevel` keyword. If not given or equal to 2, only basic
iteration information will be printed. If set to 3, detailed iteration information will be printed (recommended if
timing results for individual steps are required), while 4 or higher triggers additional (and very verbose) information
from other subroutines as well.

The default solver is a multi-root Davidson procedure. The single-root solver can be initiated by setting
`DoRootwise` and `FollowCIS` to true. The latter is more stable when a large number of roots are requested.

**7.33.7 Properties in the RHF EOM implementation**

The only property that can be calculated with the current RHF EOM implementation is the transition moment. It is
calculated as a CI-like expectation value, as proposed by Stanton and Bartlett. The right and left transition density
are defined as

*𝜌* *[𝐺𝑟]* *𝑝𝑞* *[→][𝐸𝑥]* = *⟨𝜑* 0 *|* (1 + Λ)[ *𝑒* *[−][𝑇]* *{𝑝* [+] *𝑞* *[−]* *}𝑒* *[𝑇]* *, 𝑅* ] *|𝜑* 0 *⟩*

*𝜌* *[𝐸𝑥]* *𝑝𝑞* *[→][𝐺𝑟]* = *⟨𝜑* 0 *|𝐿𝑒* *[−][𝑇]* *{𝑝* [+] *𝑞* *[−]* *}𝑒* *[𝑇]* *|𝜑* 0 *⟩*

In the above equation, Λ corresponds to the ground state left vector, which needs to solved once and *𝐿* is the left
vector, which needs to be solved separately for each root. Once the right and left vectors have been obtained, the
left and right transition densities are constructed and the oscillator strength is calculated using following formula

*𝑓* = [2] 3 *[𝜀][|][𝜇]* *[𝑝𝑞]* *[𝜌]* *𝑝𝑞* *[𝐸𝑥][→][𝐺𝑟]* *||𝜇* *𝑝𝑞* *𝜌* *𝑝𝑞* *[𝐺𝑟][→][𝐸𝑥]* *|*

**816** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

The oscillator strength, calculated by default, employs a linear approximation for Λ. The *𝐿* vectors are, on the other
hand, calculated as a general inverse of the corresponding *𝑅* vectors. This approximation requires no additional
effort over the energy calculation and gives similar accuracy as that of the exact oscillator strength calculation,
which is at least twice the cost of the energy calculation. Exact EOM-CC transition moments can, however, be
calculated by setting `DoLeft` and `DoTDM` to true. Please note that transition moments have not yet been implemented
for the UHF EOM-CCSD approach.

**7.33.8 Some tips and tricks for EOM-CC calculation**

  - The COSX approximation gives significant savings in terms of memory use, disk space use and computational timings without almost no loss of accuracy[233]. Therefore, the preferred setting for large scale
calculations should include `DoCOSXEOM true`, `DoAOX3e true` and `KCOpt KC_AOBLAS` (Note that `KC_AOX`
is the only option available for `KCOpt` in the UHF implementation).

  - The EOM-CC code in ORCA has three version of the Davidson’s solver. The default one is multi-root

solver which does optimization of all the roots together. It gives the fastest convergence and is more suitable
when one is interested only in a few roots of a big molecule. However, the multi-root solver can land into
numerical issues, if more than 10 root are desired. In that case, one can invoke the root-wise solver by setting
`DoRootwise true` . The single root solver is very stable and should be used when large number of roots are
desired. However, the convergence of the single root solver is slower than the multi-root one. In the RHF
implementation, there is also a batchwise solver, where a subset of the total number of roots is optimized
together. This can be invoked by setting `NRootsPerBatch` to true and is intermediate between the multi-root
and single-root solver in terms of stability and convergence.

  - If the EOM iterations do not converge within 50 cycles, one can try to increase the number of iterations
by setting `MaxIter` in the `%mdci` block to a larger value. One can also try to increase the dimension of
the Davidson’s space by increasing the `NDav` value and this generally helps in convergence acceleration.
However, setting `NDav` to a value larger than 200 can make the calculation prohibitively costly .

  - Convergence thresholds of `DTol 1e-5` (Davidson convergence) and `STol 1e-7` (ground state CCSD convergence ) generally yield sufficiently converged energies, and are suitable for most purposes.

  - The normal Davidson solver generally leads to the lowest energy solutions. This procedure can also yield
roots dominated by double excitations (the so-called satellite states) for the IP and EA variants of EOM-CC,
when one asks for a large number of roots. If one interested in the low lying Koopman’s type of IP and EA
states, they can be obtained by setting `FollowCIS` to true. This will follow the initial guess provided by the
Fock operators.
### **7.34 Excited States via STEOM-CCSD**

The EOM-CCSD approach for excitation energies becomes prohibitively costly for large systems because of its
O( *𝑁* [6] ) scaling. Therefore, one needs a more compact form of the wave-function ansatz. A second similarity
transformation can compress the final matrix diagonalization step to the CIS space only. The resulting STEOMCCSD method of Marcel Nooijen and co-workers [639] is an efficient way for accurate calculations of excitation
energies.

**7.34.1 General Description**

In the standard EOM-CC method, the transformed Hamiltonian is diagonalized over a singles and doubles space to
obtain ionized, attached, or excited states of the reference state. In STEOM-CC, one performs a second similarity
transformation

*𝐺* ˆ = *{𝑒* *𝑆* ^ *}* *−* 1 ˆ¯ *𝐻{𝑒* *𝑆* ^ *}*

The transformation operator *𝑆* [ˆ], including singles and doubles, is defined as

*𝑆* ˆ = ˆ *𝑆* *[𝐼𝑃]* + ˆ *𝑆* *[𝐸𝐴]* *,*

**7.34. Excited States via STEOM-CCSD** **817**

**ORCA Manual** **,** **Release 6.0.1**


ˆ
*𝑆* *[𝐼𝑃]* = *𝑆* *𝑖* *[𝑚]* *[′]* [ ˆ] *[𝐸]* *𝑖* *[𝑚]* *[′]* [ + 1] 2 *[𝑆]* *𝑖𝑗* *[𝑚𝑏]* *[𝐸]* [ˆ] *𝑖𝑗* *[𝑚𝑏]* *[,]*


ˆ
*𝑆* *[𝐸𝐴]* = *𝑆* *𝑒* *[𝑎]* *[′]* *[𝐸]* [ˆ] *𝑒* *[𝑎]* *[′]* [+] 2 [1] *[𝑆]* *𝑒𝑗* *[𝑎𝑏]* *[𝐸]* [ˆ] *𝑒𝑗* *[𝑎𝑏]* *[.]*


In the above equations, *𝑚* and *𝑒* denote active indices of the hole and particle type respectively, while a prime
denotes a restriction to orbitals that are not active. The amplitudes of the operator *𝑆* [ˆ] are defined in such a way that
matrix elements of the transformed Hamiltonian, in second quantized notation, become equal to zero.

*𝑔* *𝑖* *[𝑚]* *[′]* [ =] *[ 𝑔]* *𝑖𝑗* *[𝑚𝑏]* = *𝑔* *𝑒* *[𝑎]* *[′]* [=] *[ 𝑔]* *𝑒𝑗* *[𝑎𝑏]* [= 0]

In addition, the zeros which pre-existed in *𝐻* [¯], after solving the CCSD equations, remain preserved. The above
equations are linear in *𝑆* [ˆ] and are equivalent to the Fock space multireference coupled cluster equations for the one
valence problem. However, to ensure numerical stability, the equations are re-casted as matrix diagonalization
problem and solved as IP-EOM-CCSD and EA-EOM-CCSD problems. The *𝑆* [ˆ] *[𝐼𝑃]* and *𝑆* [ˆ] *[𝐸𝐴]* are then extracted from
the converged previous calculations, respectively, by invoking intermediate normalization on the suitably chosen
eigenvectors corresponding to active holes and active particles. The total process can be described as following

  - Solution of the ground state coupled cluster equations

  - Construct the first similarity transformed Hamiltonian as *𝐻* [ˆ¯] = *𝑒* *[−][𝑇]* [^] *𝐻𝑒* [ˆ] *[𝑇]* [^]

  - Solution of the IP-EOM and EA-EOM equations

  - Extraction of the *𝑆* [ˆ] amplitudes

  - Construct the second similarity transformed Hamiltonian as *𝐺* [ˆ¯] = *𝑒* *[−][𝑆]* [^] *𝐻𝑒* [ˆ¯] *[𝑆]* [^]

  - Diagonalization of *𝐺* [ˆ¯] in CIS space

The advantage of the above method is that, instead of one iterative O( *𝑁* [6] ) scaling diagonalization step, it requires
two iterative O( *𝑁* [5] ) scaling steps, one non-iterative O( *𝑁* [5] ) scaling step and one iterative O( *𝑁* [4] ) scaling matrix
diagonalization step. The presence of so-called ‘implicit triples excitation’ term ensures the charge transfer separability of the excited states, which is absent in EOM-CCSD. In addition, since the final diagonalization step
is performed in a CIS space, the spin adaption is trivial and excited states of triplet multiplicity can be obtained
without going through the complications of a spin orbital based implementation.

The STEOMCC approach has also recently been extended for applications to open-shell systems within the UHF
formalism [403]. In this case, the expressions for the operators *𝑆* [ˆ] *[𝐼𝑃]* and *𝑆* [ˆ] *[𝐸𝐴]* take the form,


ˆ
*𝑆* *[𝐼𝑃]* = [1]

2

+ [1]

2

*𝑆* ̂︀ *−* = [1]

2

+ [1]

2


*𝑖,𝑗,𝑎,𝑚* ∑︁ *𝑠* *[𝑎𝑚]* *𝑖𝑗* {︀ *𝑎* ˆ *[†]* *𝑚* ˆ *[†]* [ ˆ] *𝑗* [ˆ] *𝑖* }︀ + ¯ *𝑖,𝑗,* ∑︁ ¯

¯ *𝑖,* ¯ *𝑗,* ∑︁ *𝑎,* ¯ ¯ *𝑚* *𝑠* ¯ *[𝑎]* *𝑖* [¯] ¯ *𝑗* *[𝑚]* [¯] {︀ *𝑎* ˆ¯ *†* ˆ¯ *𝑚* *†* ˆ¯ *𝑗* ˆ¯ *𝑖* }︀ + *𝑖,* [¯] *𝑗,𝑎,* ∑︁


*𝑖,𝑒,𝑎,𝑏* ∑︁ *𝑠* *[𝑎𝑏]* *𝑖𝑒* {︀ *𝑎* ˆ *[†]* [ ˆ] *𝑏* *[†]* *𝑒* ˆ [ˆ] *𝑖* }︀ + ¯ *𝑖,𝑒,* ∑︁ ¯

¯ *𝑖,* ∑︁ *𝑒,* ¯ *𝑎,* ¯ ¯ *𝑏* *𝑠* ¯ *[𝑎]* *𝑖* [¯] *𝑒* ¯ [¯] *[𝑏]* {︀ *𝑎* ˆ¯ *†* ˆ¯ *𝑏* *†* ˆ¯ *𝑒* ˆ¯ *𝑖* }︀ + *𝑖,* ∑︁ *𝑒,𝑎,* ¯


∑︁


¯ *𝑖,𝑒,* ∑︁ *𝑎,𝑏* ¯ *𝑠* ¯ *[𝑎𝑏]* *𝑖𝑒* [¯] {︀ *𝑎* ˆ¯ *†* ˆ *𝑏* *†* ˆ *𝑒* ˆ¯ *𝑖* }︀

ˆ ¯

∑︁ *𝑠* *[𝑎]* *𝑖𝑒* ¯ [¯] *[𝑏]* {︀ *𝑎* *[†]* [ ˆ¯] *𝑏* *[†]* [ ˆ] *𝑒* [ˆ] *𝑖* }︀ *,*

*𝑖,𝑒,𝑎,* ¯ [¯] *𝑏*


∑︁


∑︁


∑︁


¯ *𝑖,𝑗,* ∑︁ *𝑎,𝑚* ¯ *𝑠* ¯ *[𝑎𝑚]* *𝑖𝑗* [¯] {︀ *𝑎* ˆ¯ *†* ˆ *𝑚* *†* ˆ *𝑗* ˆ¯ *𝑖* }︀

ˆ ¯

∑︁ *𝑠* *𝑖* *[𝑎]* [¯] *𝑗* *[𝑚]* [¯] {︀ *𝑎* *[†]* [ ˆ] *𝑚* *[†]* [ ˆ¯] *𝑗* [ˆ] *𝑖* }︀ *.*

*𝑖,* [¯] *𝑗,𝑎,𝑚* ¯


where we use overbars to distinguish the *𝛽* orbitals from the *𝛼* orbitals. The amplitudes {︀ *𝑠* *[𝑎𝑏]* *𝑖𝑒* *[, 𝑠]* ¯ *[𝑎𝑏]* *𝑖𝑒* [¯] }︀ are determined
by solving the UHF EA-EOM-CCSD equations for the attachment of an *𝛼* electron, while the {︀ *𝑠* ¯ *[𝑎]* *𝑖* [¯] *𝑒* ¯ [¯] *[𝑏]* *[, 𝑠]* *𝑖* *[𝑎]* *𝑒* ¯ [¯] *[𝑏]* }︀ amplitudes
are extracted from a UHF EA-EOM-CCSD calculation for the attachment of a *𝛽* electron. Similarly, the sets of
amplitudes {︀ *𝑠* *[𝑎𝑚]* *𝑖𝑗* *[, 𝑠]* ¯ *[𝑎𝑚]* *𝑖𝑗* [¯] *[}]* [ and] {︀ *𝑠* ¯ *[𝑎]* *𝑖* [¯] ¯ *𝑗* [¯] *[𝑏]* *[, 𝑠]* *𝑖* *[𝑎]* [¯] *𝑗* *[𝑚]* [¯] }︀ are determined by solving the decoupled UHF IP-EOM-CCSD problems
for the ionization of an *𝛼* electron and the ionization of a *𝛽* electron, respectively. Hence, an UHF STEOMCC
calculation involves two separate IP calculations (O( *𝑁* [5] ) scaling) and two separate EA calculations (O( *𝑁* [5] ) scaling
steps).

All the speed up options, including CCSD(2) (only available in RHF implementation) and COSX, which are available for EOM-CCSD are also available for STEOMCC. The most important steps in a STEOMCC calculation are
the IP-EOM and EA-EOM calculations. These steps are performed using the EOM-CCSD module and the relevant
keywords are the same as that described in *Excited States via EOM-CCSD* . The keywords which are exclusive to
the RHF STEOM module are:

**818** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**



The keywords pertaining to the UHF STEOM module are:



**7.34.2 Selection of Active space**

The results of a STEOM-CC calculation depend upon the number of roots selected as active in the EOMIP and
EOMEA calculations. In ORCA, they are chosen automatically, by using state-averaged CIS natural transition
orbitals (NTO). By default, the number of roots included in this initial CIS computation is equal to the number of
roots requested in STEOM ( `NRoots` ). However, this can be modified setting `NRootsCISNAT` to higher values. The
orbitals up to a predefined occupation are then chosen to be active in the EOMIP and EOMEA calculations, and this
is controlled by the keywords `OThresh` and `VThresh` respectively. Now, there are two possible ways to chose active
space. One is to use the criteria of percentage occupation of NTO’s as described in ref [236]. However, a newer and
more robust approach is to use the criteria of absolute occupation, which is default in the current implementation.
One can switch on the old percentage occupation based active space selection by setting `DoNewActSch` to false
(not recommended).

One can also select the active spaces manually by turning the `DoCISNat` to false and setting the `NActIP` and `NActEA`
(RHF STEOM calculation) or the `NActIP_a`, `NActIP_b`, `NActEA_a` and `NActEA_b` (UHF STEOM calculation) to
desired values. However, this is not recommended for general uses. The following snippet shows the output of the
active orbital selection procedure on a closed-shell molecule:



(continues on next page)

**7.34. Excited States via STEOM-CCSD** **819**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



**820** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.34.3 Active space selection using TD-DFT densities**

Instead of using a CIS calculation for selected the Active Space roots, a TD-DFT based one can also be considered.
Be aware that using DFT Kohn-Sham orbitals for computing the CCSD GS energy can lead to some instabilities
and give incorrect results.

The main interest of this approach is to start the STEOM-CCSD calculation with TD-DFT electronic densities
which are in general better than the CIS one, especially for some specific compounds (metallic complexes for
example). The computed TD-DFT densities are also often more stable than the CIS one. It will however slow
down the calculation.

The input has to be written like this:



Any DFT functional can be used but we recommend one with a decent amount of HF exchange. On top of this, the
keyword `TDDFTGuess` has to be set to true in mdci block and the tddft has to be added together with the `NRoots`
keyword. In both input blocks ( `%mdci` and `%tddft` ) the same number of roots has to be given. Starting from ORCA
6, using TD-DFT guess with an UHF reference is also possible.

**7.34.4 The reliability of the calculated excitation energy**

The excitation energy for any states calculated in STEOM-CC are only reliable when the dominant excitation for
that states are confined within the active space. This can be verified from the percentage active character of the
calculated states, an *a posteriori* diagnostic which is defined as


∑


% *𝑎𝑐𝑡𝑖𝑣𝑒𝑐ℎ𝑎𝑟𝑎𝑐𝑡𝑒𝑟* =

for closed-shell systems and takes the form,


∑ *𝐶* ( *𝑚, 𝑒* ) ** 𝐶* ( *𝑚, 𝑒* )

*𝑚,𝑒*
∑︀ *𝐶* ( *𝑖, 𝑎* ) ** 𝐶* ( *𝑖, 𝑎* )


*** 100

∑︀ *𝐶* ( *𝑖, 𝑎* ) ** 𝐶* ( *𝑖, 𝑎* )

*𝑖,𝑎*


∑


% *𝑎𝑐𝑡𝑖𝑣𝑒𝑐ℎ𝑎𝑟𝑎𝑐𝑡𝑒𝑟* =


*𝑚,𝑒* ∑ *𝐶* ( *𝑚, 𝑒* ) ** 𝐶* ( *𝑚, 𝑒* ) + *𝑚,* [∑] ¯


*𝐶* ( *𝑚, 𝑒* ) ** 𝐶* ( *𝑚, 𝑒* ) + *𝑚,* [∑] ¯ *𝑒* ¯ *𝐶* ( ¯ *𝑚,* ¯ *𝑒* ) ** 𝐶* ( ¯ *𝑚,* ¯ *𝑒* )

∑︀ *𝐶* ( *𝑖, 𝑎* ) ** 𝐶* ( *𝑖, 𝑎* ) + [∑︀] *𝐶* ( [¯] *𝑖,* ¯ *𝑎* ) ** 𝐶* ( [¯] *𝑖,* ¯ *𝑎* )


∑︀ *𝑖,𝑎* *𝐶* ( *𝑖, 𝑎* ) ** 𝐶* ( *𝑖, 𝑎* ) + ¯ [∑︀] *𝑖,𝑎* ¯


*** 100 *.*
¯ [∑︀] *𝑖,𝑎* ¯ *𝐶* ( [¯] *𝑖,* ¯ *𝑎* ) ** 𝐶* ( [¯] *𝑖,* ¯ *𝑎* )


within the UHF formalism. The roots which have % *𝑎𝑐𝑡𝑖𝑣𝑒𝑐ℎ𝑎𝑟𝑎𝑐𝑡𝑒𝑟* higher than 98.0 are considered to be converged with respect to the active space.




(continues on next page)

**7.34. Excited States via STEOM-CCSD** **821**

**ORCA Manual** **,** **Release 6.0.1**
```
 Amplitude Excitation in Canonical Basis
 -0.166580 4 -> 8
 -0.975432 7 -> 8
 -0.124356 7 -> 13
IROOT= 2: 0.309409 au 8.419 eV 67907.5 cm**-1
 Amplitude Excitation
  0.994141 7 -> 9
Percentage Active Character 99.78
 Amplitude Excitation in Canonical Basis
 -0.990029 7 -> 9
IROOT= 3: 0.336993 au 9.170 eV 73961.4 cm**-1
 Amplitude Excitation
 -0.994078 5 -> 8
Percentage Active Character 99.10
 Amplitude Excitation in Canonical Basis
 -0.984116 5 -> 8
 -0.136769 5 -> 13
IROOT= 4: 0.357473 au 9.727 eV 78456.2 cm**-1
 Amplitude Excitation
  0.181761 4 -> 10
  0.728209 6 -> 8
  0.611668 7 -> 10
 -0.191540 7 -> 12
Percentage Active Character 94.10
Warning:: the state may have not converged with respect to active space
-------------------- Handle with Care ------------------- Amplitude Excitation in Canonical Basis
 -0.184144 4 -> 10
 -0.725183 6 -> 8
 -0.633718 7 -> 10
IROOT= 5: 0.386654 au 10.521 eV 84860.8 cm**-1
 Amplitude Excitation
  0.980406 4 -> 8
 -0.178551 7 -> 8
Percentage Active Character 99.79
 Amplitude Excitation in Canonical Basis
  0.971678 4 -> 8
  0.122877 4 -> 13
 -0.179242 7 -> 8
IROOT= 6: 0.444881 au 12.106 eV 97640.1 cm**-1
 Amplitude Excitation
 -0.995150 6 -> 9
Percentage Active Character 99.69
 Amplitude Excitation in Canonical Basis

```

(continued from previous page)

(continues on next page)


**822** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
 -0.989966 6 -> 9

```
If the % *𝑎𝑐𝑡𝑖𝑣𝑒𝑐ℎ𝑎𝑟𝑎𝑐𝑡𝑒𝑟* for any calculated state is less than 98, that state may have not converged with respect
to active space and the excitation energy for that particular state is less reliable. The user should request a larger
number of roots under those conditions.

**7.34.5 Removal of IP and EA states with double excitation character**

To obtain accurate results with STEOM-CCSD, only the *𝑆* [ˆ] amplitudes corresponding to the states dominated by
single excitations should be included in the second similarity transformation. This is ensured in ORCA in two
ways. First, the root following ( `FollowCIS` ) is activated by default so that it converges to the states dominated by
singly excited guess vectors. This avoids the calculation of so called ‘satellite states’, which are of double excitation
character with respect to the ground state. Secondly, among the converged IP and EA roots, the states which have
%singles character below a certain predefined threshold (i.e. controlled by the keywords `IPThresh` and `EAThresh` )
are automatically excluded from the second similarity transformation.



Note that the use of CIS natural transition orbitals can lead to convergence issues for the IP and EA states which
are dominated by double excitation character. This can be remedied by setting `DoDbFilter` to true.

**7.34. Excited States via STEOM-CCSD** **823**

**ORCA Manual** **,** **Release 6.0.1**

**7.34.6 Transition and difference densities**

At the end of a STEOM computation, it is possible to store the final eigenvectors in a file “ *job.cis* ”, in analogy with
what is done for CIS and TD-DFT computations. This file can be obtained by setting `DoStoreSTEOM true` in the
input. This file can then be processed by `orca_plot` to obtain the difference and / or the transition densities.

An Natural Transition Orbitals analysis can also be performed within the STEOM-CCSD scheme, as described in
*Natural Transition Orbitals* . It can be performed by setting the keyword `DoSTEOMNatTransOrb` to true.

**7.34.7 Properties**

The dipolar and transition moments (as well as the oscillator strength) can be computed within the STEOM module
using different kinds of approximations. Please cite our paper on these corrected STEOM transition densities [297]!
Starting from ORCA 5, new defaults ( `DoSimpleDens false` ) are used that are much better than the previous CISlike approximation, and the full option is of CC3-like quality.



By default, the STEOM-CCSD densities with `AddL2term true` should be used for all calculation as discussed in
ref. [297].

**7.34.8 Solvation (Experimental)**

In STEOM-CCSD, the excitation energies and densities can be corrected using the CPCM solvation scheme in
ORCA.

To use it, the keyword `DoSolv` has to be set to true in the `%mdci` block and the simple keyword `CPCM` (or `SMD` ) +
name of the solvent has to be given.



**824** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.34.9 Spin-Orbit Coupling (Experimental)**

You can compute the spin-orbit coupling between singlet and triplets states in STEOM-CCSD using the keyword
`STEOMSOC true` . Please note that all SOC matrix elements and properties are currently computed from the **right**
**vector only** !

**7.34.10 Core excitation**

The STEOM-CCSD (and bt-PNO-STEOM-CCSD) method can also be used to compute the K-edge core-excitation
energy of molecules. See *Core-Excitation* for more details.

**7.34.11 Transient absorption**

Transient absorption spectra can be computed using the keyword `DoTrans true` . The `IRoot` keyword will select
the targeted excited state.
### **7.35 Excited States via IH-FSMR-CCSD**

An alternative approach for decoupling the singles excitation space from the space of double and higher excitations
is to use the so called Fock space multi-reference coupled cluster (FSMRCC) method. The method is similar to
STEOM-CCSD, but much more flexible in terms of formulation.

**7.35.1 General Description**

FSMRCC is originally based on an effective Hamiltonian (EH). The basic idea of EH theory is to obtain some
selective eigenvalues of the Hamiltonian operator from the total eigenvalue spectrum. For this purpose, the entire
configuration space is divided into a model and an outer space with projection operators *𝑃* *𝑀* and *𝑄* *𝑀*, respectively (see Fig. 7.38). The diagonalization of the EH takes care of the non-dynamic correlation coming from the
interactions between the model space configurations. On the other hand, the dynamic correlation arises due to the
interactions of the model space configurations with the outer space configurations. This interaction is introduced
through a universal wave operator Ω, which is parametrized such that it generates the exact wave function when
acting on the model space. The valence universal wave operator Ω has the form

*𝑆* ˜ [(] *[𝑝,ℎ]* [)]
Ω= *𝑒*

where the braces indicate normal ordering of the cluster operators and *𝑆* [˜] [(] *[𝑝,ℎ]* [)] is defined as


*ℎ*
∑︁ *𝑆* ˜ [(] *[𝑘,𝑙]* [)]

*𝑙* =0


˜
*𝑆* [(] *[𝑝,ℎ]* [)] =


*𝑝*
∑︁

*𝑘* =0


The cluster operator *𝑆* [˜] [(] *[𝑘,𝑙]* [)] is capable of destroying exactly k active particles and l active holes, in addition to
creation of holes and particles. The *𝑆* [˜] [(] *[𝑝,ℎ]* [)] subsumes all lower sector Fock space *𝑆* [˜] [(] *[𝑘,𝑙]* [)] operators. The *𝑆* [˜] [(0] *[,]* [0)] is
equivalent to standard single-reference coupled cluster *𝑇* [ˆ] operator. The EH for (p,h) valence system can be defined

as

ˆ
*𝐻* *𝑒𝑓𝑓* = *𝑃* *𝑀* [(] *[𝑝,ℎ]* [)] Ω *[−]* [1] [ ˆ] *𝐻* Ω *𝑃* *𝑀* [(] *[𝑝,ℎ]* [)]

However, Ω *[−]* [1] may not be well defined in all the cases. Therefore, the above definition for the EH is seldom used.
Instead, the Block-Lindgren approach is generally used for solving the equations, which is defined by

ˆ
*𝑃* *𝑀* [(] *[𝑝,ℎ]* [)] *𝐻* Ω *−* Ωˆ *𝐻* *𝑒𝑓𝑓* *𝑃* *𝑀* [(] *[𝑝,ℎ]* [)] = 0

[︁ ]︁

ˆ
*𝑄* [(] *𝑀* *[𝑝,ℎ]* [)] *𝐻* Ω *−* Ωˆ *𝐻* *𝑒𝑓𝑓* *𝑃* *𝑀* [(] *[𝑝,ℎ]* [)] = 0

[ ]

**7.35. Excited States via IH-FSMR-CCSD** **825**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.38: Division of the configuration space into model and outer space in effective Hamiltonian (EH) theory and
into model, intermediate, and outer space in intermediate Hamiltonian (IH) theory. *𝑃* and *𝑄* denote the respective
projection operators.

When the model space is not energetically well separated from the outer space, this method faces convergence problems. This is commonly termed as the intruder state problem. In the intermediate Hamiltonian (IH) formulation,
configuration space is divided into three subspaces, namely, the main(M), the intermediate(I), and the outer(O)
space (see Fig. 7.38) with projection operators *𝑃* *𝑀*, *𝑃* *𝐼* and *𝑄* *𝑂*, respectively. The intermediate space acts as a
buffer between the model and the outer space. When diagonalization the IH, a subset of the eigenvalues correspond to the main space obtained through EH theory. The IH is for the singly excited state sector (1,1) is defined

as

¯ ¯
*𝐻* *𝐼* [(1] *[,]* [1)] = *𝑃* *𝑂* [(1] *[,]* [1)] *𝐻𝑃* *𝑂* [(1] *[,]* [1)] + *𝑃* *𝑂* [(1] *[,]* [1)] *𝐻𝑌* [(1] *[,]* [1)] *𝑃* *𝑀* [(1] *[,]* [1)]

where

*𝑌* [(1] *[,]* [1)] = *𝑄* [(1] *𝑂* *[,]* [1)] *𝑆* 2 [(0] *[,]* [1)] + *𝑆* 2 [(1] *[,]* [0)] + *𝑆* 2 [(0] *[,]* [1)] *𝑆* 1 [(1] *[,]* [0)] + *𝑆* 2 [(1] *[,]* [0)] *𝑆* 1 [(0] *[,]* [1)] + *𝑆* 2 [(1] *[,]* [0)] *𝑆* 2 [(0] *[,]* [1)] *𝑃* *𝑀* [(1] *[,]* [1)]
{︁ }︁

The *𝑆* [(1] *[,]* [0)] and *𝑆* [(0] *[,]* [1)] are extracted from converged EOMIP-CCSD and EOMEA-CCSD calculations, respectively,
by invoking intermediate normalization on the suitably chosen eigenvectors corresponding to active holes and
active particles. The total procedure can be described as following

  - solve the ground state coupled cluster equations

  - construct *𝐻* [ˆ¯] = *𝑒* *[−][𝑇]* [^] *𝐻𝑒* [ˆ] *[𝑇]* [^]

  - solve the EOMIP and EOMEA equations

  - extract the *𝑆* [ˆ] amplitudes

**826** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

  - construct the second similarity transformed Hamiltonian as *𝐻* *𝐼* [(1] *[,]* [1)]

  - diagonalize the *𝐻* *𝐼* [(1] *[,]* [1)] in CIS space

The automatic active space selection scheme and all the speed up options which are available for STEOM-CCSD,
including bt-PNO and COSX, are also available for IH-FSMR-CCSD. All the keywords controlling the IH-FSMRCCSD are similar to STEOM-CCSD as described in *Excited States via STEOM-CCSD* .

No UHF variant of IH-FSMR-CCSD is currently available.

**7.35.2 Properties**

The transition properties can be calculated using a simple CIS-like formulation, employing the converged IHFSMR-CC eigenvectors. The transition moments are computed by default in an IH-FSMR-CCSD calculation.

**7.35.3 Solvation Correction**

Solvent effects can be approximated by a simple perturbative correction to the IH-FSMR-CCSD via


where


¯ ¯

*𝜔* *𝑘* = *𝜔* *𝑘* [0] [+] [1] *𝑉* [Δ] *𝑄* [Δ]

2

*𝜔* *𝑘* [0] [= ˆ] *𝐿* *𝐾* *𝐻* *𝐼* [(1] *[,]* [1)] *𝑅* ˆ *𝐾*


The CPCM correction directly enters the *𝐻* *𝐼* [(1] *[,]* [1)], the modified Hatree-Fock orbitals. In the non-equilibrium regime,
one can simply write the perturbative correction as


where

A typical input file looks like


¯

*𝜔* *𝑘* *[𝑛𝑒𝑞]* = *𝜔* *𝑘* [0] *[,𝑛𝑒𝑞]* + [1] 2 *𝑉* ( *𝑃* Δ *[𝑛𝑒𝑞]* [) ¯] *[𝑄]* [(] *[𝑃]* Δ *[𝑛𝑒𝑞]* [)]

*𝑃* Δ *[𝑛𝑒𝑞]* = *𝐿* *𝑘* *𝑅* *𝑘*



For the above input, the following output is obtained:



(continues on next page)

**7.35. Excited States via IH-FSMR-CCSD** **827**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



Thee perturbative correction only changes the transition energies and neither the wave function nor the transition

moment.
### **7.36 Excited States using PNO-based coupled cluster**

Despite the successes of the DLPNO-CC approximation for ground states, the use of PNOs for excited states has
been less fruitful. It is not straightforward to define a PNO-based scheme for excited states, which will maintain the
balance between speed and accuracy, as observed for the ground state. As an intermediate solution, the basis for
ground state DLPNO quantities is transformed back to the canonical basis and are used within the canonical EOM
routine. This procedure is justified, as the main bottle neck of the EOM-CCSD or STEOM-CCSD methods comes
from the ground state calculation. Approximating the ground state CCSD amplitudes with MP2 amplitudes is also
possible, as done in the EOM-CCSD(2) approach. However, it is not reliable and can lead to large errors, when
the reference HF wave function does not provide a reasonable zeroth order approximation to the ground state wave
function. Note that the back-transformed PNO scheme (bt-PNO) described here is available for both open-shell
(UHF (QROs) or ROHF reference) and closed-shell (RHF reference) systems.

**7.36.1 General Description**

The back transformation of the ground state DLPNO-CCSD amplitudes to the virtual space involves three steps.
The *𝑇* amplitudes in the PNO basis are first converted into the PAO basis, then subsequently to the atomic orbital
(AO) basis, and finally to the canonical MO basis[234]. For example, in the closed-shell case, we have

*𝑑* *[𝑖𝑗]* *𝜇* ˜ *𝑎* ˜ *𝑖𝑗* *[𝑇]* *𝑎* ˜ *[𝑖𝑗]* *𝑖𝑗* [˜] *𝑏* *𝑖𝑗* *[𝑑]* ˜ *𝑏* *[𝑖𝑗]* *𝑖𝑗* *𝜇* ˜ *[⇒]* *[𝐿]* *𝜇* *[𝑖𝑗]* *𝜇* ˜ *[𝑇]* *𝜇* ˜ *[𝑖𝑗]* *𝜈* ˜ *[𝐿]* *[𝑖𝑗]* *𝜈𝜈* ˜ *[⇒]* *[𝐶]* *𝑎𝜇* *[𝑖𝑗]* *[𝑇]* *𝜇𝜈* *[𝑖𝑗]* *[𝐶]* *𝜈𝑏* *[𝑖𝑗]* *[⇒]* *[𝑇]* *𝑎𝑏* *[𝑖𝑗]* *[,]*

*𝑑* *[𝑖]* *𝜇* ˜ *𝑎* ˜ *𝑖𝑖* *[𝑇]* *𝑎* ˜ *[𝑖]* *𝑖𝑖* *[⇒]* *[𝐿]* *[𝑖]* *𝜇𝜇* ˜ *[𝑇]* *𝜇* ˜ *[𝑖]* *[⇒]* *[𝐶]* *𝑎𝜇* *[𝑖]* *[𝑇]* *𝜇* *[𝑖]* *[⇒]* *[𝑇]* *𝑎* *[𝑖]* *[,]*

The AO basis functions are denoted as *𝜇, 𝜈, . . .*, while ˜ *𝜇,* ˜ *𝜈, . . .* refers to PAOs. The missing pairs are treated using
MP2 amplitudes. If all the thresholds are set to zero, the back-transformed amplitudes match exactly with the
canonical RI-EOM-CCSD ones. On the other hand, when all the thresholds are made infinitely tight, one obtains
the EOM-CCSD(2) results. This PNO-based excited state approach is available for all the flavors of EOM-CCSD
and for STEOM-CCSD in both open- and closed-shell systems.

Below, we list all the parameters that influence the DLPNO-CCSD-based excited state calculations



**828** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.36.2 Reference State Energy**

Here, it should be noted that the reference energy for PNO-based EOM-CCSD or STEOM-CCSD is slightly different from that printed for a converged ground state DLPNO-CCSD calculation, as it includes the perturbative
correction for different truncated quantities.

In the bt-PNO-EOM-CCSD scheme, the CI-like excited state treatment of the reference state is defined by backtransformed DLPNO amplitudes (or MP2 amplitudes for the weak pairs). The energy corresponding to this set of
amplitude is printed at the beginning of the EOM calculations.



Therefore, to calculate the total energy of an excited (ionized or electron attached) state, one needs to add the
excitation energy to the reference state energy in bt-PNO-EOM-CCSD.

**7.36.3 Use of Local Orbitals**

The use of local orbitals makes it difficult to follow a particular guess vector in the Davidson digonalization process
in EOM-CC and STEOM-CC. Therefore, it is advisable to recanonicalize the occupied orbitals after the ground
state DLPNO-CCSD calculation by setting DoRECAN to true (i.e. only relevant for the closed-shell RHF implementation). It should be noted that the recanonicalization does not change the EOM-CCSD energies. However,
the STEOM-CC energies are not invariant to orbital rotations and differ slightly for local and canonical orbitals.
In the open-shell bt-PNO implementation, we follow a different procedure in that all quantities are transformed to
the delocalized basis before proceeding with the back transformation and the excited state calculation.

**7.36.4 Some tips and tricks for bt-PNO calculations**

  - The bt-PNO scheme with tightPNO settings gives results, which are within 0.01 eV of the canonical EOMCCSD numbers, at a fraction of the computational cost[234]. So, use of bt-PNO scheme is always preferable
over canonical calculations.

  - In the case of an RHF reference, one should set ‘DLPNOLINEAR true’ and ‘NEWDOMAINS true’ in the
mdci block input to use the 2015 fully linear scaling implementation, which is more robust than the 2013
implementation used as default in bt-PNO scheme.

  - The transition moment in bt-PNO-EOM (RHF only) and bt-PNO-STEOM (RHF, UHF (QROs) or ROHF)
is only available using the linear approximation.

**7.36. Excited States using PNO-based coupled cluster** **829**

**ORCA Manual** **,** **Release 6.0.1**
### **7.37 Excited States via DLPNO-STEOM-CCSD**

**7.37.1 PNO dressing (experimental keyword)**

In STEOM-DLPNO-CCSD method most of the steps are done using the powerful PNO approximation except the
last one corresponding to the STEOM-CCSD calculation itself. In the canonical version of the dressing (default in
ORCA) all the amplitudes previously computed at the PNO level are recanonicalized which increases the calculation
cost.PNO dressing uses some of the PNO intermediates to reduce the dressing time. It has however no effect on
the storage size.

Using this PNO dressing will reduce the calculation timing but at a reduce accuracy for the excitation energies. We
thus recommend this option only for specific large systems (>2500 basis functions).

The keyword **DirectDressSTEOM** set to true enable this option.

**7.37.2 Keywords from STEOM-CCSD**

Most of the keywords from STEOM-CCSD can be used within the DLPNO version, except for core excitation.
More information on the *Excited States via STEOM-CCSD* section.

**7.37.3 Tips and Tricks**

As written in the typical calculation section of the manual we would recommend this input for standard organic
molecules.

As a general guideline we will discuss some of the keywords used there:




  - TIGHTSCF is a must for any CCSD calculation.

  - We will recommend using TIGHTPNO for all molecules as it is not a lot more expensive and helps achieving
a better convergence.

  - The OTHRESH, VTHRESH and TCutPNOSingles keywords help with converging the calculations, increasing the percentage active of each root. In contrary to standard STEOM-CCSD, we would acknowledge that
the roots are converged when the percentage active character is at least 96%. Of course you have to check
that the amplitude and orbitals associated with the excitation are correct (and what you expect). Tightening the 3 keywords mentioned will increase this percentage active character. The most important being the
TCutPNOSingles one. Be careful, the computational cost increases exponentially when tightened. In more

**830** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

case 10 *[−]* [12] or 5 *×* 10 *[−]* [12] should be enough. For OTHRESH and VTHRESH you should not go below 10 *[−]* [3],
as the benefits are not so obvious.A trick to achieve a better convergence is to play with the number of roots.
It is often not necessary to compute a lot of roots if you are only interested in the first 3 for example. If some
high energy roots have some low percentage active character, removing them can help for the convergence
of other roots.

  - As shown in the related paper[298], the STEOM density with the L2term is now the default for computing
the excited state properties.

  - The choice of the basis set can also speed up the calculation without a significant loss of accuracy. For most
organic molecules def2-TZVP(-f) is enough. Trying def2-SVP is also a good idea for preliminary tests.

  - The STEOM-CCSD excitation energies are very dependent from the starting geometry. Geometries optimised with several DFT functional can yield significant differences for the excitation energies (about 0.1
eV).

  - It has happened that some roots were missing with the keyword **Dorootwise** set to true. Turning it off solved
the issue but this keyword should be on by default.
### **7.38 Core-level spectroscopy with coupled cluster methods**

The equation of motion coupled cluster method and its similarity transformed version provides an easy way to
directly calculate core-ionization and core-excitation energies. Currently, the core-level spectroscopy with EOMCCSD and STEOM-CCSD is only available for closed shell systems.

**7.38.1 Core-ionization**

One can obtain core-ionized states if one calculates a large no of roots. The ORCA implementation of IP-EOMCCSD, however, allows one to directly target the ionization from the core-orbitals. A typical IP-EOM-CCSD input
file for the acetic acid will look like



The output of it will be

**7.38. Core-level spectroscopy with coupled cluster methods** **831**

**ORCA Manual** **,** **Release 6.0.1**



The option ‘DoCore true’ starts the counting of the roots from ‘corehole’ upwards. The default is ‘DoCore false’
and it counts the root from the HOMO downwards. The ‘corehole 0’ starts the counting from the first occupied
orbital which is the oxygen K-edge in this case. One can directly target the carbon K-edge in this case by putting
‘corehole 2’.




The output of it will be



(continues on next page)

**832** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



Now, the core-ionized states remains embedded in the high density of doubly ionized valence states that form the
continuum. This leads to severe convergence problems. One easy way to overcome this is to use the core-valence
separation approximation which is turned on by the two keywords ‘CVSEP true’ and ‘DoCVS true’. The orbitals
from which the contributions are not neglected for the core-valence separation are set by ‘CVSORB initial,final’.
It is generally a good idea to include all the core orbitals corresponding to a particular element if one is interested
in the ionization from any of the core orbitals for the particular element. In the second example both the carbon
core-orbitals are included in the ‘CVSORB 2,3’. A ‘bt-PNO-IP-EOM-CCSD’ input file for the same example will
look like



The output of it will be




(continues on next page)

**7.38. Core-level spectroscopy with coupled cluster methods** **833**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



The results are in excellent agreement with the canonical one. A DLPNO variant for the same example will look
like



The output of it will be




(continues on next page)

**834** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Although the error in the absolute IP values are as large as 1 eV, the so-called ‘chemical shift’ i.e. the difference
between the IP value of two different atoms of the same elements are reasonably correct.

**7.38.2 Core-Excitation**

The STEOM-CCSD approach provides an efficient and accurate way to do the K-edge core-excitation spectroscopy.
A typical input file for the STEOM-CCSD will look like



The output will be




(continues on next page)

**7.38. Core-level spectroscopy with coupled cluster methods** **835**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
 -0.146649 0 -> 20
  0.169124 0 -> 21
 -0.192930 0 -> 24
IROOT= 2: 19.686174 au 535.688 eV 4320615.8 cm**-1
 Amplitude Excitation
  0.211332 6 -> 7
 -0.215317 6 -> 8
  0.330607 6 -> 11
  0.442546 6 -> 12
 -0.506486 6 -> 15
 -0.568497 6 -> 16
 Ground state amplitude: 0.000000
Percentage Active Character 97.59
Warning:: the state may have not converged with respect to active space
-------------------- Handle with Care ------------------- Amplitude Excitation in Canonical Basis
  0.346366 0 -> 8
  0.177019 0 -> 9
  0.464534 0 -> 11
 -0.590044 0 -> 12
  0.338336 0 -> 14
  0.214399 0 -> 15
  0.169124 0 -> 20
  0.146649 0 -> 21
 -0.192930 0 -> 23
IROOT= 3: 19.865373 au 540.564 eV 4359945.5 cm**-1
 Amplitude Excitation
 -0.571289 6 -> 9
  0.792679 6 -> 10
  0.137627 6 -> 13
 -0.112257 6 -> 17
 Ground state amplitude: -0.000591
Percentage Active Character 97.37
Warning:: the state may have not converged with respect to active space
-------------------- Handle with Care ------------------- Amplitude Excitation in Canonical Basis
 -0.900242 0 -> 7
 -0.116863 0 -> 13
 -0.375672 0 -> 18
  0.128317 0 -> 19
IROOT= 4: 19.909335 au 541.761 eV 4369594.0 cm**-1
 Amplitude Excitation
  0.340300 6 -> 7
  0.704671 6 -> 8
 -0.338179 6 -> 11
  0.511324 6 -> 12
 Ground state amplitude: 0.000000
Percentage Active Character 99.71
 Amplitude Excitation in Canonical Basis
  0.101796 0 -> 8

```
(continues on next page)

**836** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
 -0.793309 0 -> 9
  0.482364 0 -> 11
  0.160972 0 -> 12
 -0.209491 0 -> 15
 -0.128207 0 -> 23
 -0.188543 0 -> 24
IROOT= 5: 19.909335 au 541.761 eV 4369594.0 cm**-1
 Amplitude Excitation
 -0.704671 6 -> 7
  0.340300 6 -> 8
  0.511324 6 -> 11
  0.338179 6 -> 12
 Ground state amplitude: 0.000000
Percentage Active Character 99.71
 Amplitude Excitation in Canonical Basis
 -0.793309 0 -> 8
 -0.101796 0 -> 9
  0.160972 0 -> 11
 -0.482364 0 -> 12
 -0.209491 0 -> 14
 -0.188543 0 -> 23
  0.128207 0 -> 24
IROOT= 6: 19.914772 au 541.909 eV 4370787.3 cm**-1
 Amplitude Excitation
 -0.804799 6 -> 9
 -0.557108 6 -> 10
 -0.125228 6 -> 13
  0.119745 6 -> 17
 Ground state amplitude: 0.000364
Percentage Active Character 97.38
Warning:: the state may have not converged with respect to active space
-------------------- Handle with Care ------------------- Amplitude Excitation in Canonical Basis
  0.934227 0 -> 10
 -0.273222 0 -> 13
  0.144269 0 -> 18
 -0.159846 0 -> 22
IROOT= 7: 19.966983 au 543.329 eV 4382246.2 cm**-1
 Amplitude Excitation
  0.190413 6 -> 10
 -0.954987 6 -> 13
  0.113662 6 -> 22
 Ground state amplitude: 0.000138
Percentage Active Character 94.88
Warning:: the state may have not converged with respect to active space
-------------------- Handle with Care ------------------- Amplitude Excitation in Canonical Basis
 -0.190758 0 -> 7
  0.246282 0 -> 10
  0.890287 0 -> 13

```
(continues on next page)

**7.38. Core-level spectroscopy with coupled cluster methods** **837**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



Excitation from a particular core orbital can be considered currently. In the present case it is the 1S orbital of oxygen.
The required orbital can be specified using the keyword ‘corehole’. For the oxygen 1S it should be ‘corehole 0’.
The carbon 1S can be specified with ‘corehole 1’



(continues on next page)

**838** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



It will give the carbon K-edge spectra as follows



(continues on next page)

**7.38. Core-level spectroscopy with coupled cluster methods** **839**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
 -0.275744 1 -> 23
  0.134711 1 -> 24
  0.140527 1 -> 28
IROOT= 3: 10.807563 au 294.089 eV 2371985.9 cm**-1
 Amplitude Excitation
 -0.759965 6 -> 9
 -0.366007 6 -> 10
  0.514219 6 -> 13
 Ground state amplitude: 0.000746
Percentage Active Character 97.59
Warning:: the state may have not converged with respect to active space
-------------------- Handle with Care ------------------- Amplitude Excitation in Canonical Basis
  0.865305 1 -> 7
 -0.246321 1 -> 10
 -0.230712 1 -> 13
  0.312193 1 -> 18
  0.113059 1 -> 25
IROOT= 4: 10.840510 au 294.985 eV 2379217.0 cm**-1
 Amplitude Excitation
 -0.813493 6 -> 7
  0.345752 6 -> 12
  0.449353 6 -> 15
 Ground state amplitude: 0.000000
Percentage Active Character 98.33
 Amplitude Excitation in Canonical Basis
  0.803886 1 -> 8
 -0.349815 1 -> 9
  0.318183 1 -> 11
 -0.124975 1 -> 12
  0.186068 1 -> 14
 -0.239028 1 -> 23
IROOT= 5: 10.840510 au 294.985 eV 2379217.0 cm**-1
 Amplitude Excitation
  0.813492 6 -> 8
  0.345726 6 -> 11
 -0.449377 6 -> 16
 Ground state amplitude: 0.000000
Percentage Active Character 98.33
 Amplitude Excitation in Canonical Basis
  0.349809 1 -> 8
  0.803873 1 -> 9
  0.124977 1 -> 11
  0.318188 1 -> 12
  0.186103 1 -> 15
 -0.239038 1 -> 24
IROOT= 6: 10.845730 au 295.127 eV 2380362.5 cm**-1
 Amplitude Excitation
  0.116483 2 -> 136
  0.438618 6 -> 9

```
(continues on next page)

**840** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
 -0.879925 6 -> 10
  0.106779 6 -> 19
 Ground state amplitude: 0.000706
Percentage Active Character 96.67
Warning:: the state may have not converged with respect to active space
-------------------- Handle with Care ------------------- Amplitude Excitation in Canonical Basis
 -0.244947 1 -> 7
 -0.900149 1 -> 10
 -0.170451 1 -> 13
 -0.205137 1 -> 18
 -0.192328 1 -> 22
  0.116486 3 -> 136
IROOT= 7: 10.906409 au 296.778 eV 2393680.2 cm**-1
 Amplitude Excitation
  0.113733 2 -> 136
 -0.397156 6 -> 9
 -0.234927 6 -> 10
 -0.815420 6 -> 13
 -0.293892 6 -> 17
  0.126290 6 -> 30
 Ground state amplitude: -0.000417
Percentage Active Character 87.78
Warning:: the state may have not converged with respect to active space
-------------------- Handle with Care ------------------- Amplitude Excitation in Canonical Basis
  0.219961 1 -> 7
 -0.178103 1 -> 10
  0.883509 1 -> 13
 -0.239553 1 -> 18
 -0.188730 1 -> 19
 -0.161616 1 -> 25
  0.113733 3 -> 136
IROOT= 8: 10.926332 au 297.321 eV 2398052.6 cm**-1
 Amplitude Excitation
 -0.365429 6 -> 8
  0.927126 6 -> 11
 Ground state amplitude: 0.000000
Percentage Active Character 99.66
 Amplitude Excitation in Canonical Basis
 -0.129108 1 -> 8
 -0.295033 1 -> 9
  0.119506 1 -> 11
  0.302428 1 -> 12
  0.353687 1 -> 14
  0.777349 1 -> 15
  0.200807 1 -> 21
IROOT= 9: 10.926332 au 297.321 eV 2398052.8 cm**-1
 Amplitude Excitation
  0.365449 6 -> 7

```
(continues on next page)

**7.38. Core-level spectroscopy with coupled cluster methods** **841**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



The core-valence separation should be used similar to that in the core-ionization. The only difference is that the
natural orbital based active space selection scheme in STEOM-CCSD always rotate the particular core orbital to
the HOMO. Therefore, CVSORB should always be HOMO in STEOM-CCSD irrespective of the core-hole. One
should use the exact STEOM-CCSD transition moment by using DoSimpleDens False. Fig. 7.40 presents the
STEOM-CCSD oxygen K-edge spectra in thymine.

Fig. 7.39: Comparison of theoretical and experimental X-ray absorption spectra of oxygen K-edge in thymine. The
simulated spectrum is shifted by -3.7 eV to align with the experimental spectrum.

**842** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

One can interpret the results in terms of NTOs caculated from STEOM-CC eigen vectors

Fig. 7.40: Natural transition orbitals (ntos) for the oxygen K edge spectrum of thymine. All the core EE values
mentioned are in eV and provided in the format (EE,Oscillator Strength).
### **7.39 The Multireference Correlation Module**

**7.39.1 General Description**

A number of **uncontracted** multireference approaches are implemented in ORCA and reside in the `orca_mrci`
module. All of these approaches start with a reference wavefunction that consists of multiple configurations (orbital
occupation patterns). The reference wavefunction defined in the `ref` subblock can be a complete active space
(CAS), restricted active space (RAS) or an arbitrary list of configurations. The total wavefunction is constructed
by considering single and double excitations out of the reference configurations. These excited configurations
are then used to generate configuration state functions (CSF) that have the proper spin and spatial symmetry.
The number of wavefunction parameters rapidly grows with the number of reference functions. The orca_mrci
module features a set of truncation criteria ( `TSel, TPre, TNat` ) that help to reduce the number of wavefunction
parameters. Furthermore, by default, the program only considers reference configurations that already have the
target spin and spatial symmetry. There are situations, where this is undesired and the restrictions can be lifted
with the keyword `rejectinvalidrefs false` . For more information on the theory, the program module as well
as its usage we recommend the review article by Neese et al.[629]. A tutorial type introduction to the subject is
presented in chapter *The Multireference Correlation Module* of the manual and more examples in the CASSCF
tutorial. The detailed documentation of all features of the MR-CI and MR-PT module is somewhat premature and
at this point only a summary of keywords is given below. A thorough description of all technical and theoretical
subtleties must wait for a later version of the manual.

The overall scaling of uncontracted approaches is steep. Hence, the methodology is restricted to small reference
spaces and small molecules in general. **Note that all integrals must be kept in memory!** Internally contracted
multireference approaches such as NEVPT2 do not share these bottlenecks. Aside from NEVPT2, ORCA features

**7.39. The Multireference Correlation Module** **843**

**ORCA Manual** **,** **Release 6.0.1**

a fully internally contracted MRCI (FIC-MRCI) that resides in the `orca_autoci` module. For more details on the
FIC-MRCI we refer to section *CI methods using generated code* .





(continues on next page)

**844** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
            # space only configurations with a weight large>Tpre
            # to any root are included
    AllSingles false
            # include ALL SINGLES in the CI. Default is now TRUE!!!
    # perturbative estimate of the effect of the rejected configurations
    EunselOpt 0 # no correction
         1 # based on the overlap with the 0th order wavefunction
         2 # calculation with the relaxed reference space
            # coefficients. This is the most accurate and only
            # slightly more expensive
    # For CIType=MRCI,MRDDCI and SORCI the approximate correction for
    # higher excitations
    DavidsonOpt Davidson1 # default
          Davidson2 # modified version

```
`Siegbahn` `# Siegbahn` *'* `s approximation`
`Pople` `# Pople` *'* `s approximation`
```
    # For MRACPF,MRACPF2,MRAQCC and SORCP
    NelCorr 0
     # Number of electrons used for computing the average coupled     # pair correction.
     # =0 : set equal to ALL electrons in the CI
     # =-1: set equal to all ACTIVE SPACE electrons
     # =-2: set equal to ACTIVE SPACE electrons IF inactive doubles
     # are excluded (as in MRDDCI)
     # >0 : set equal to user defined input value
    LinearResponse false
     # Use ground state correlation energy to compute the shift for
     # higher roots (not recommended)
    # --------------------------------    # Natural Orbital Iterations
    # --------------------------------    NatOrbIters 0 # default
     # number of average natural orbital iterations
    Tnat 1e-4
     # cutoff of natural orbitals. NOs with an occupation number less
     # then Tnat will not be included in the next iteration
     # Also, orbitals with occupation number closer than Tnat to 2.0
     # will be frozen in the next iteration
    Tnat2 -1
     # if chosen >0 then Tnat2 is the threshold for freezing the
     # almost doubly occupied orbitals. Otherwise it is set equal
     # to Tnat
    # ---------------------------------    # Additional flags and algorithmic
    # details
    # ---------------------------------    PrintLevel 2 # default. Values between 1 and 4 are possible
    DoDDCIMP2 false
     # for DDCI calculations: if set to true the program computes
     # a MP2 like correction for the effect of inactive double
     # excitations which are not explicitly included in the CI. This
     # is necessary if you compare molecules at different geometries
     # or compute potential energy surfaces.
    # ---------------------------------    # The SORCP model

```
(continues on next page)

**7.39. The Multireference Correlation Module** **845**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
    # ---------------------------------    CIType_in # First step CIType
    CIType_fi # Second step CIType
    Exc_in # First step excitation scheme
    Exc_fi # Second step excitation scheme
    Tsel_in # First step Tsel
    Tsel_fi # Second step Tsel
    Tpre_in # First step Tsel
    Tpre_fi # Second step Tpre
     # Thus, the SORCI model corresponds to CIType=SORCP with
     # CIType_in MRCI CIType_fi MRCI
     # Exc_in DDCI2 Cexc_fi DDCI3
     # Tsel_in 1e-5 Tsel_fi 1e-5
     # Tpre_in 1e-2 Tpre_fi 1e-2
    # ---------------------------------    # Multirerence perturbation theory
    # ---------------------------------    MRPT_b 0.02 # Intruder state avoidance PT after Hirao (default 0.0)
            # with this flag individual intruders are shifted away to
            # to some extent from the reference space
    MRPT_shift 0.3 # Level shift introduced by Roos which shifts the entire
            # excited manifold away in order to avoid intruder states.
            # A correction is applied afterwards but results do depend
            # on this (arbitrary) value to some extent.
    H0Opt projected # use an off-diagonal definition of H0
       Diagonal # use a diagonal definition of H0 (much faster but maybe
             # a little less reliable
    Partitioning MP # Moeller plesset partitioning
          EN # Epstein-Nesbet partitioning (not recommended)
    Fopt Standard # Standard definition of MR Fock operators

```
`G3` `# uses Anderson` *'* `s g3 correction also used in CASPT2`
```
    #--------------------------------------    # restrict reference configurations
    #--------------------------------------    RejectInvalidRefs true # by default reference CSFs are restricted
                # to target spin and spatial symmetry
    # ======================================
    # Definitions of blocks of the CI Matrix
    # ======================================
    NewBlock 2 * # generate a Block with doublet(=2) multiplicity
     Nroots 1 # number of roots to be generated
     Excitations cis # CI with single excitations
           cid # CI with double excitations
           cisd # CI with single and double excitations
           ddci1 # DDCI list with one degree of freedom
           ddci2 # DDCI list with two degrees of freedom
           ddci3 # DDCI list with three degrees of freedom
     Flags[_class_] 0 or 1
         # Turn excitation classes on or off individually

```
`#` *``* `s` *''* `stands for any SOMO,` *``* `i` *''* `,` *``* `j` *''* `for internal orbitals and`
`#` *``* `a` *''* `,` *``* `b` *''* `for external orbitals`
```
         # Singles _class_ = ss, sa, is, ia
         # Doubles _class_ = ijss, ijsa, ijab,
         # isss, issa, isab,
         # ssss, sssa, ssab

```
`#` *``* `Flags` *''* `takes priority over` *``* `Excitations` *''* `. In fact` *``* `Excitations` *''*

(continues on next page)

**846** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

`# does nothing but to set` *``* `Flags` *''* `. So, you can use` *``* `Excitations` *''*
`# to provide initial values for` *``* `Flags` *''* `and then modify them`
`# with subsequent` *``* `Flags` *''* `assignments`
```
     refs
        #
        # First choice - complete active space
        #
        CAS(nel,norb) # CAS-CI reference with nel electrons in
                # Norb orbitals
        #
        # Second choice - restricted active space
        #
        RAS(nel: m1 h/ m2 / m3 p)
                # RAS-reference with nel electrons
           # m1= number orbitals in RAS-1
           # h = max. number of holes in RAS-1
           # m2= number of orbitals in RAS-2 (any number of
           # electrons or holes)
           # m3= number of orbitals in RAS-3
           # p = max. number of particles in RAS-3
        #
        # Third choice - individually defined configurations
        #
        \{ 2 0 1 0\}
        \{ 1 1 1 0\}
         etc.
         # define as many configurations as you want. Doubly occupied MOs
         # singly occupied MOs and empty MOs. Important notes:
         # a) the number of electrons must be the same in all references
         # b) the number of orbitals is determined from the number of
         # definitions. Thus, in the example above we have three active
         # electrons and four active orbitals despite the fact that the
         # highest orbital is not occupied in any reference.
         # The program determines the internal, active and external spaces
         # automatically from the number of active electrons and orbitals
        end
     end
     # there can be as many blocks as you want!!!
    # ---------------------------------    # Density matrix generation flags
    # First Key= State densities <I|D|I>
    # =0: none
    # =1: Ground state only (lowest root of all blocks; Electron only)
    # =2: Ground state only (Electron and spin density)
    # =3: Lowest root from each block (Electron density)
    # =4: Lowest root from each block (Electron and spin density)
    # =5: All states (Electron density)
    # =6: All states (Electron and spin density)
    # Second Key= Transition densities <I|D|J>
    # needed for all transition intensities, g-tensor etc
    # =0: none
    # =1: from the ground state into all excited states (el)
    # =2: from the ground state into all excited states (el+spin)
    # =3: from all lowest states into all excited states (el)
    # =4: from all lowest states into all excited states (el+spin)
    # =5: all state pairs (el)
    # =6: all state pairs (el+spin)
    # Note that for perturbation theory the density is computed as
    # an expectation value over the first (second) order wavefunction.
    # which is renormalized for this purpose

```
(continues on next page)

**7.39. The Multireference Correlation Module** **847**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
    # ---------------------------------    Densities 1,1
    # ---------------------------------    # Complete printing of the wavefunction
    # ---------------------------------    PrintWF 1 # CFG based printing (default)
         det # Determinant based wavefunction printing
    TPrintWF 3e-3 # Threshold for the printing of the CFGs/Dets
    # ---------------------------------    # Algorithm for the solver
    # ---------------------------------    Solver Diag # Davidson like solver
        DIIS # DIIS like solver
     # both solvers have their pros and cons. The DIIS may converge
     # better or use less time since it only recomputes the vectors that
     # have not yet converged; The DIIS may be less sensitive to root flipping
     # effects but occasionally it converges poorly and states of the same
     # symmetry are occasionally a little problematic
     # For perturbation theory DIIS is always used.
    # For both solvers
    MaxIter 100 # the maximum number of iterations
    Etol 1e-6 # convergence tolerance for energies in Eh
    Rtol 1e-6 # convergence tolerance for residual
    # For Solver=Diag (Davidson solver)
    Otol 1e-16 # Orthogonality threshold for Schmidt process
    NGuessMat 512 # Dimension of the guess matrix 512x512
            # be used to compute the initial guess of the actual MRCI calculation
    NGuessMatRefCI 512 # Dimension of the guess matrix
              # for the reference CI
    MaxDim 3 # Davidson expansion space = MaxDim * NRoots
    # For the Solver=DIIS. Particularly recommended for anything else but
    # straightforward CI and also for calculations in direct2 mode!
    MaxDIIS 5 # Maximum number of old vectors to be used in DIIS
    RelaxRefs true # Relax reference space coefficients in the CI or
            # freeze them to their zeroth order values
    LevelShift 0.4 # Level Shift for stabilizing the DIIS procedure
    # ---------------------------------    # RI Approximation
    # ---------------------------------    IntMode RITrafo #Use RI integrals
        FullTrafo #No RI (default)
    # ---------------------------------    # Integral storage, memory and files
    # ---------------------------------    IntStorage FloatVals
           DoubleVals (default)
     # store integrals with float (4 byte) or double (8 byte)
     # accuracy in main memory
    FourIndexInts false (default)
           True
     # Store ALL four index integrals over Mos in main memory
     # only possible for relatively small systems, perhaps up
     # to 150-200 MOs included in the CI
    MaxMemInt 256
     # Maximum amount of core memory devoted to the storage of

```
(continues on next page)

**848** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**7.39.2 Properties Calculation Using the SOC Submodule**

**Zero-Field Splitting**

The spin-orbit coupling (SOC) and spin-spin coupling (SSC) contributions to the zero-field splitting (ZFS) can
be calculated very accurately using a wavefunction obtained from a multiconfigurational calculation of a multireference type such as CASSCF, MRCI, or MRPT as is described in QDPT Magnetic Properties Section *Magnetic*
*properties through Quasi Degenerate Perturbation Theory* .


Those transition energies can be substituted by a more accurate energies provided in the input file as follows:



Accurate diagonal energies generally improve the accuracy of the SOC and SSC splittings.

**7.39. The Multireference Correlation Module** **849**

**ORCA Manual** **,** **Release 6.0.1**

**Local Zero-Field Splitting**

The submodule can also be used to calculate the local ZFS splitting parameters of atomic centers. The method,
referred to as local complete active space configuration interaction (L-CASCI), can be used to separate into atomic
contributions the SOC part of the total ZFS tensor. The rational behind it and additional details are described in
the original publication [717]; below are listed only the steps required to reproduce the calculation for the dimer
complex presented there.

1. The first step consists in obtaining the molecular orbitals that are going to be used in the configuration interaction
(CI) procedure. A good set of orbitals can be obtained from a restricted open-shell spin-averaged Hartree-Fock
(SAHF) calculation. The relevant part of the input is listed below:

For the present Mn(II)Mn(III) dimer there are a total of 9 electrons distributed into 10 d-orbitals.

2. Next, the molecular orbitals are localized using one of the implemented localization schemes. Below is the
`orca_loc` input used in this case:



3. Following this, the localized orbitals are made locally canonical by block diagonalizing the Fock matrix using
the `orca_blockf` utility.
```
orca_blockf sahf.fsv sahf.loc 200 204 205 209

```
The first two numbers define the range of molecular orbitals localized on one center; the last two are for the second

center.

4. The recanonicalized orbitals stored in the `sahf.loc` file can be then used to calculate the SOC contribution to
the local ZFS of the Mn(III) center using the following MRCI input:



(continues on next page)

**850** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

5. The three second order ZFS components printed at the end of the calculation ( `Second order D-tensor:`
`component 0`, etc.) are scaled using the *S* value for the complex, which in this case is 4.5 (9 electrons *×* 0.5).
In order to obtain the correct local value of the ZFS, the three matrices have to be rescaled using the *S* value for
Mn(III), which is to 2. Note that the three matrices have different scaling prefactors, and the dependence on *S* is

**7.39. The Multireference Correlation Module** **851**

**ORCA Manual** **,** **Release 6.0.1**

not the same:

**D** *[𝑆𝑂𝐶][−]* [(0)] *∝* *𝑆* 1 [2]

**D** *[𝑆𝑂𝐶][−]* [(] *[−]* [1)] *∝* *𝑆* (2 *𝑆* 1 *−* 1)

**D** *[𝑆𝑂𝐶][−]* [(+1)] *∝* ( *𝑆* +1)(2 1 *𝑆* +1)

These equations can be used to calculate the required prefactors. For example in the case of the *SOC* -(0) the
prefactor is equal to:

**D** *[𝑆𝑂𝐶]* Mn(III) *[−]* [(0)] = [4] 2 *[.]* [5] [2][2] *[ ·]* **[ D]** dimer *[𝑆𝑂𝐶][−]* [(0)] = 5 *.* 0625 *·* **D** *[𝑆𝑂𝐶]* dimer *[−]* [(0)]

The final step is to scale the two remaining matrices using the appropriate prefactors, sum all three of them up,
diagonalize the resulting the matrix, and use its eigenvalues to calculate the *D* and *E* parameters. These represent
the local ZFS parameters of the Mn(III) center.

**Zero-Field Splitting from an excited Multiplet**

For an excited state Multiplet the Calculationof ZFS can be requested by






(continues on next page)

**852** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)




**g-Tensor**

The `orca_mrci` program contains an option to calculate g-tensors using MRCI wavefunctions. For a system with an
odd number of electrons, the doubly degenerate eigenvalues obtained from the QDPT procedure represent Kramers
pairs, which are used to build the matrix elements of the total spin operator and the total angular momentum operator
from the Zeeman Hamiltonian. Denoting Ψ as a solution and Ψ [¯] as its Kramers partner and using matrix element

notations

Φ *[𝑘]* 11 [=] *[ ⟨]* [Ψ] *[|]* [ ˆ] *[𝐿]* *[𝑘]* [+] *[ 𝑔]* *[𝑒]* *[𝑆]* [ˆ] *[𝑘]* *[|]* [Ψ] *[⟩]* *[,]* [ Φ] *[𝑘]* 12 [=] *[ ⟨]* [Ψ] *[|]* [ ˆ] *[𝐿]* *[𝑘]* [+] *[ 𝑔]* *[𝑒]* *[𝑆]* [ˆ] *[𝑘]* ⃒⃒¯Ψ⟩︀ *, 𝑘* = *𝑥, 𝑦, 𝑧* (7.240)

The elements of g-matrix are obtained as:

*𝑔* *𝑘𝑧* = 2Φ *[𝑘]* 11 *[, 𝑔]* *[𝑘𝑦]* [=] *[ −]* [2] *[ℑ]* (︀Φ *[𝑘]* 12 )︀ *, 𝑔* *𝑘𝑥* = 2 *ℜ* (︀Φ *[𝑘]* 12 )︀ (7.241)

Then, the true tensor G is built from g-matrices:

*𝐺* = *𝑔𝑔* *[𝑇]* (7.242)

G is subjected further to diagonalization yielding positive eigenvalues, the square roots of which give the principal
values of g-matrix.


*𝑔* *𝑥𝑥* = √︀


*𝐺* *𝑥𝑥* *, 𝑔* *𝑦𝑦* = √︀


*𝐺* *𝑦𝑦* *, 𝑔* *𝑧𝑧* = √︀


*𝐺* *𝑧𝑧* (7.243)


A typical mrci block of the input file for a g-tensor calculation should (e.g. for a S=3/2 problem) look as the
following:



**7.39. The Multireference Correlation Module** **853**

**ORCA Manual** **,** **Release 6.0.1**

The result for the first Kramers pair is printed as follows:



Here for the *𝐿* and *𝑆* matrix elements indices 1 and 2 are assumed to denote Kramers partners, and three numbers
in the first row stand for *𝑥, 𝑦, 𝑧* contributions.

In addition the g-tensor is calculated within the Effective Hamiltonian formalism.




Finally and only within the MRCI module the g-tensor is evaluated by using the Sum Over States formalism[610]:

**854** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**



(continues on next page)

**7.39. The Multireference Correlation Module** **855**

**ORCA Manual** **,** **Release 6.0.1**


(continued from previous page)



Note that within the SOS formalism in addition to the second order (SOC) contributions the bilinear to the field
terms: Relativistic mass correction and diamagnetic spin-orbit term (Gauge) are evaluated. As can be seen these
corrections are rather negligible in comparison to the second order SOC contributions and most of the time can be
safely omitted. Moreover further insight is obtained by printing the individual contribution of each excited state
to the g-tensor. In the example above the first excited state contributes to the *𝑔* *𝑧* component while the next two to
both the *𝑔* *𝑥* and *𝑔* *𝑦* components, respectively.

So to summarize the g-tensor calculations in the framework of wavefunction based methods like MRCI and/or
CASSCF can be evaluated:

  - via the QDPT approach within an individual Kramers doublet. This is valid analysis only for non-integer
spin cases. In particular for systems with well isolated Kramers doublets where the EPR spectrum originates
only from one Kramers doublet defined within the pseudo spin 1/2 formalism. This analysis has been proven
useful in determining the sign of the ZFS and the electronic structure of the system under investigation.[548]

  - within the effective Hamiltonian approach. This is a valid analysis for all spin cases as it provides the principal
g-values of the system under investigation evaluated in the molecular axis frame. These g-values can be
directly compared with the experimentally determined ones.[421]

  - within the sum over states formalism (SOS). As above this analysis is valid for all spin cases and is only
available via the MRCI module.

**856** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**Magnetization and Magnetic Susceptibility**

The MRCI and CASSCF modules of ORCA allow for the calculation of magnetization and magnetic susceptibility
curves at different fields and temperatures by differentiation of the QDPT Hamiltonian with respect to the magnetic
field. For magnetic susceptibility, calculations are performed in two ways when a static field different from zero
is defined: (i) as the second derivative of energy with respect to the magnetic field and (ii) as the magnetization
divided by the magnetic field. Although the first method corresponds to the definition of magnetic susceptibility,
the second approach is widely used in the experimental determination of *𝜒* ** 𝑇* curves. If the static field is low,
both formulas tend to provide similar values.

The full list of keywords is presented below.



The same keywords apply for CASSCF calculations in rel block (instead of soc in MRCI). Although different
aspects of integration and grid precision can be modified through keywords, default values should provide an
accurate description of both properties. Calculated magnetization and susceptibility are printed in .sus and .mag
files, respectively and also in the output file.

(continues on next page)

**7.39. The Multireference Correlation Module** **857**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



Note that the CASSCF module also supports the calculation of susceptibility tensors at non-zero user-defined
magnetic fields. This is not yet possible with the MRCI module.

**MCD and Absorption Spectra**

The MRCI module of the ORCA program allows calculating MCD spectra and the SOC effects on absorption
spectra. The formalism is described in detail by Ganyushin and Neese[283]. The approach is based on the direct
calculation of the transition energies and transition probabilities between the magnetic levels. Namely, the differential absorption of LCP- and RCP photons for transitions from a manifold of initial states *𝐴* to a manifold of final
states *𝐽* . Using Fermi’s golden rule, the Franck-Condon approximation, assuming a pure electronic dipole mechanism and accounting for the Boltzmann populations of the energy levels, the basic equation of MCD spectroscopy
may be written as (atomic units are used throughout):


∆ *𝜀*


∑︁ ( *𝑁* *𝑎* *−* *𝑁* *𝑗* ) (︁ *|⟨* Ψ *𝑎* *|𝑚* LCP *|* Ψ *𝑗* *⟩|* [2] *−|⟨* Ψ *𝑎* *|𝑚* RCP *|* Ψ *𝑗* *⟩|* [2] [)︁] *𝑓* ( *𝐸* ) (7.244)

*𝑎,𝑗*


*𝐸* [=] *[ 𝛾]* ∑︁


Here *𝑎* and *𝑗* label members of the initial and state manifold probed in the experiments.

ex p ( *−𝐸* *𝑎* */* *𝑘𝑇* )
*𝑁* *𝑎* ( *𝐵, 𝑇* ) = ∑︀ exp ( *−𝐸* *𝑖* */𝑘𝑇* ) (7.245)

*𝑖*

**858** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

denotes the Boltzmann population and if the *𝑎* -th ground state sublevel at energy *𝐸* *𝑎*, *𝑓* ( *𝐸* ) stands for a line shape
function, and *𝛾* denotes a collection of constants. The electric dipole operators are given by:

*𝑚* LCP *≡* *𝑚* *𝑥* *−* *𝑖𝑚* *𝑦* (7.246)

*𝑚* RCP *≡* *𝑚* *𝑥* + *𝑖𝑚* *𝑦* (7.247)

They represent linear combinations of the dipole moment operator:


*𝑍* *𝑁* *𝑅* *[⃗]* *𝑁* *−* ∑︁

*𝑁* *𝑖*


*⃗𝑚* = ∑︁


*⃗𝑟* *𝑖* (7.248)
*𝑖*


where *𝑁* and *𝑖* denotes summations of nuclei (at positions *𝑅* *[⃗]* *𝑁* with charges *𝑍* *𝑁* ) and electrons (at positions *⃗𝑟* *𝑖* )
respectively. The calculated transition dipole moment are subjected to the space averaging over the Euler angles
which is performed by a simple summation over three angular grids.


2 *𝜋*
∫︁

*𝜑* =0


∆ *𝜀*
(︂ *𝐸*


)︂


1

=
*𝑒𝑣* 8 *𝜋* [2]


sin *𝜃𝑑𝜃𝑑𝜑𝑑𝜓* *≈* ∑︁
)︂

*𝜇𝜂𝜏*


∆ *𝜀*
(︂ *𝐸*


)︂


sin *𝜃* *𝜏* (7.249)

*𝜇𝜂𝜏*


2 *𝜋*
∫︁

*𝜓* =0


*𝜋*
∫︁

*𝜃* =0


∆ *𝜀*
(︂ *𝐸*


Finally, every transition is approximated by a Gaussian curve with a definite Gaussian shape width parameter.
Hence, the final calculated MCD spectrum arises from the superposition of these curves.

As an illustration, consider calculation of a classical example of MCD spectrum of [Fe(CN) 6 ] [3] *[−]* . The mrci block
of the input file is presented below.



The parameters B and Temperature can be assigned in pairs, i.e. B = 1000, 2000, 3000..., Temperature = 4,
10, 300.... The program calculates the MCD and absorption spectra for every pair. Now for every point of the
integration grid the program prints out the Euler angles, the orientation of the magnetic field in the coordinate
system of a molecule, and the energy levels.

**7.39. The Multireference Correlation Module** **859**

**ORCA Manual** **,** **Release 6.0.1**



In the next lines, ORCA calculates the strength of LCP and RCP transitions and prints the transition energies, the
difference between LCP and RCP transitions (denoted as C), and sum of LCP and RCP transitions (denoted as D),
and C by D ratio.



**860** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

All C and D values are copied additionally into the text files input.1.mcd, input.2.mcd..., for every pair of Temperature and B parameters. These files contain the energies and C and D values for every calculated transition. These
files are used by the program `orca_mapspc` to calculate the spectra lines. The `orca_mapspc` program generates
from the raw transitions data into spectra lines. The main parameters of the `orca_mapspc` program are described in
section 7.18.1. A typical usage of the `orca_mapspc` program for MCD spectra calculation for the current example
may look as the following:
```
orca_mapspc input.1.mcd MCD -x020000 -x150000 -w2000

```
Here the interval for the spectra generation is set from 20000 cm *[−]* [1] to 50000 cm *[−]* [1], and the line shape parameter
is set to 2000 cm *[−]* [1] .

Very often, it is desirable to assign different line width parameters to different peaks of the spectra to obtain a
better fitting to experiment. `orca_mapspc` can read the line shape parameters from a simple text file named as
input.1.mcd.inp. This file should contain the energy intervals (in cm *[−]* [1] ) and the line shape parameters for this
energy interval in the form of:



This file should not be specified in the executing command; `orca_mapspc` checks for its presence automatically:



Finally, the `orca_mapspc` program generates the output text file input.1.mcd.dat which contains seven columns
of numbers: transition energies, intensities of MCD transitions (the MCD spectrum), intensities of absorption
transitions (the absorption spectrum), the ratio between the MCD and absorption intensities, and the last three
columns represent the “sticks” of the corresponding transitions.



Now the MCD and the absorption spectra can be plotted with a suitable graphical program, for instance with the
Origin program.

**7.39. The Multireference Correlation Module** **861**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.41: Calculated MCD and absorption spectra of [Fe(CN) 6 ] [3] *[−]* (dash lines) compared to experimental spectra
(solid lines).

**Addition of Magnetic Fields**

The inclusion of the Zeeman contribution into the QDPT procedure allows to obtain the splittings of the magnetic levels in an external magnetic field. The switch for this calculation and the magnetic field strength are
defined in the soc subblock of the mrci block. Optionally the wave function decomposition can be printed for
`MagneticField_PrintLevel` larger 0. The latter employs the thresh `TPrint` to omit small contributions from
the printing:



(continues on next page)

**862** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



Then, the output contains three sets of data of splittings of the magnetic levels with the magnetic field applied
parallel to x, y, and z directions:



Here the number in a row represents the strength of the magnetic field (in Gauss), and the following pairs of numbers
denote the energy of the magnetic level (in cm *[−]* [1] ) with its occupation number. This table can be readily plotted
with any suitable graphical program.

**Relativistic Picture Change in Douglas-Kroll-Hess SOC and Zeeman Operators**

The DKH correction to the SOC operator is implemented in ORCA as a correction to the one-electron part of the
SOMF operator. The DKH transformation is performed up to the second order, and the two-electron part in our
implementation is left untransformed. However, the electronic density employed for evaluating the SOMF matrix
elements is obtained from a scalar relativistic calculation. The inclusion of the DKH correction is controlled by
the picturechange key in the rel block:



The “picturechange” key can be set to 0, 1, and 2 for no picture change, the first order, and the second order DKH
transformations of the SOC operator.

With “picturechange” set to 1 or 2 the DKH correction are applied in the first order to the Zeeman operator. This
correction has a visible effect on calculated g-tensors for molecules containing third-row and heavier atoms.

**7.39. The Multireference Correlation Module** **863**

**ORCA Manual** **,** **Release 6.0.1**

**X-ray Spectroscopy**

Likewise to the CASCI/NEVPT2 computational protocol presented in section *Core excited states with*
*(C/R)ASCI/NEVPT2* starting from ORCA 4.2 the MRCI module can be used to compute core excited spectra,
namely X-ray absorption (XAS) and resonant inelastic scattering (RIXS) spectra.

As discussed in the case of CASCI/NEVPT2 protocol *Core excited states with (C/R)ASCI/NEVPT2* a similar strategy is followed to compute XAS/RIXS spectra within the MRCI module. In principle the XAS/RIXS spectra
calculations require two steps:

  - In a first step one needs to optimize the valence active space orbitals in the framework of SA-CASSCF
calculations, e.g. including valence excited states in the range between 6 to 15 eV.

  - In a second step the relevant core orbitals are rotated into the active space and the MRCI problem is solved
by saturating the excitation space with singly core-excited electronic configurations using the previously
optimized sets of orbitals.

  - The core orbitals are also included in the XASMOs definition. The use of this keyword is two fold. At
first it effecteively reduces the number of the generated configuration state functions (CSFs) to those that
exclusively contain contributions from the defined core orbitals. In the case of RIXS also XES (see below)
the specified XASMOs are used to define intermediate or core ionized states.

A representative input for the case of Fe(Cl) 4 is provided bellow:

  - In the first step one performs a SA-CASSCF calculation for the 5 and 15 quintet and triplet states (FeIICl4.casscf.inp).




- In a second step the core orbitals are rotated in the active space and the MRCI problem is solved by saturating
the excitation space with all the quintet and triplet states that involve single excitations from the core orbitals
(FeIICl4-mrci.inp)



(continues on next page)

**864** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)




In a similar fashion Multireference Equation of Motopn Couple Cluster MR-EOM-CC (see next section) can also
be used to compute X-ray spectra. Further information can be found in reference[550]

**7.39. The Multireference Correlation Module** **865**

**ORCA Manual** **,** **Release 6.0.1**

As it is explicitly described in the respective ROCIS section RIXS spectra can be requested by the following keywords:



Please consult section *Resonant Inelastic Scattering Spectroscopy* for processing and analyzing the generated spec
tra

Likewise to TDDFT ( *Use of TD-DFT for the Calculation of X-ray Absorption Spectra* ) ROCIS ( *General Use* ) and
CASSCF ( *Core excited states with (C/R)ASCI/NEVPT2* ) the computed transition densities also in the presence of
SOC can be taken beyond the dipole approximation by using the *OPS tool* for details.

1. by performing a multiple expantion up to second order

2. by computing the exact transition moments

The whole set of spectroscopy tables can be requested with the following commands:



More details can be found in TDDFT ( *Use of TD-DFT for the Calculation of X-ray Absorption Spectra* ) ROCIS
( *General Use* ) and CASSCF ( *Core excited states with (C/R)ASCI/NEVPT2* ) sections.

Starting from ORCA 4.2 the previously reported RASCI-XES protocol reference[691], which can compute K *𝛽*
Mainline XES spectra, can be processed entirely within the ORCA modules. In ORCA 5.0 a similar protocol
(CASCI-XES) exist in the CASSCF module ( *Core excited states with (C/R)ASCI/NEVPT2* )

  - Like above or in the CASCI/NEVPT2 case in a first step one needs to optimize the valence active space
orbitals in the framework of SA-CASSCF calculations, e.g. including valence excited states in the range
between 6 to 15 eV for the N electron system.

  - In a second step the metal 1s and 3p orbitals are rotated in the active space and the 1s MO is defined in the
XASMOs list

  - Computes the XES spectrum in the RASCI framework for the N-1 electron system in the presence of SOC
if the XESSOC keyword for all the states that are dominated by 3p-1s electron decays.

A representative input sequence for the case of Fe(Cl) 6 is provided bellow:

As described in reference[691] at first for a CAS(5,5) the excitation space is saturated by the sextet as well as the
24 quartet and the 75 doublet states which are optimized in the SA-CASSCF fashion.



(continues on next page)

**866** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



In following the 1s and 3p Fe based MOs are rotated in the active space and the XES spectra are computed for the

[Fe(Cl) 6 ] [+] system for the 4 septet and 81 quintet states.



(continues on next page)

**7.39. The Multireference Correlation Module** **867**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

As a result the X-ray emission spectrum is calculated and the intensities are computed on the basis of the transition
electric dipole moments



The resulted XES spectrum can be visualized by processing the above output file with the `orca_mapspc`
```
orca_mapspc fecl6_xes.out XESSOC -x07140 -x17190 -w4.0 -eV -n10000

```
This will result in Fig. 7.42.

**868** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.42: Calculated RASCI K *𝛽* XES spectrum of [Fe(Cl) 6 ] [+] .
### **7.40 Multireference Equation of Motion Coupled-Cluster (MR-EOM-** **CC) Theory**

In analogy with single reference EOM-CC (see sections *Excited States with EOM-CCSD* and *Excited States via*
*EOM-CCSD* ) and STEOM-CC (see sections *Excited States with STEOM-CCSD* and *Excited States via STEOM-*
*CCSD* ), Multireference Equation of Motion Coupled-Cluster (MR-EOM-CC) theory [193, 194, 203, 406, 407,
640] can be viewed a transform and diagonalize approach to molecular electronic structure theory. An MR-EOM
calculation involves a single state-averaged CASSCF calculation, incorporating a few low-lying states and the
solution of a single set of cluster amplitudes, which define a sequence of similarity-transformed Hamiltonians. The
ultimate goal of these many-body transformations is to effectively decouple the CAS configurations from important
excited configurations (e.g., 2p2h, 2p1h, 1p1h, etc.) which comprise the first-order interacting space. Through the
definition of suitable cluster operators, in each of the transformations, most of these excitations can be included
in an internally contracted fashion. Hence, the resulting final transformed Hamiltonian can be diagonalized over a
small subspace of the original first-order interacting space to gain access to many electronic states. As discussed
in section *MR-EOM-CC: Multireference Equation of Motion Coupled-Cluster*, the MR-EOM implementation in
ORCA therefore makes use of the CASSCF module (to obtain the state-averaged CASSCF reference), the MDCI
module for the solution of the amplitude equations and the calculation of the elements of the various similarity
transformed Hamiltonians and the MRCI module for the diagonalization of the final transformed Hamiltonian.
Some desirable features of this methodology are:

  - Many states can be obtained through the diagonalization of a similarity transformed Hamiltonian over a compact diagonalization manifold (e.g. the final diagonalization space in MR-EOM-T|T *[†]* |SXD|U only includes
the CAS configurations and 1h and 1p configurations).

  - Only a single state-averaged CASSCF calculation and the solution of a single set of amplitudes is required
to define the final similarity transformed Hamiltonian and the results are typically quite insensitive to the
precise definition of the CAS (only a few low-lying multiplets need to be included in the state-averaging)

  - The MR-EOM approach is rigorously invariant to rotations of the orbitals in the inactive, active and virtual
subspaces, and it preserves both spin and spatial symmetry.

**7.40. Multireference Equation of Motion Coupled-Cluster (MR-EOM-CC) Theory** **869**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.24: The details of the various MR-EOM transformations that are considered in the ORCA implementation
of MR-EOM. The equations for the operator components and the residual equations which determine the corresponding amplitudes also appear in the Table. Note that we use the usual (Einstein) convention that repeated indices
are summed over.

[︀]

[︀]

︀

[︀]


︀

[︀]



[︀]

[︀]

︀

[︀]



[︀]

[︀]

︀

[︀]



[︀]

︀

[︀]



[︀]

︀

[︀]



[︀]

[︀]

︀

[︀]



[︀]

[︀]

︀

[︀]



[︀]

[︀]

︀

[︀]



[︀]

[︀]

︀

[︀]



[︀]

[︀]

︀

[︀]



[︀]

[︀]

︀

[︀]



[︀]

[︀]

︀

[︀]



[︀]

[︀]

︀

[︀]



[︀]

︀

[︀]



[︀]

[︀]

As the details concerning the MR-EOM methodology are rather involved, we refer the interested reader to
Refs. [193, 194, 203, 406, 407, 640] for a more detailed discussion. Note that the details concerning the implementation of MR-EOM in ORCA can be found in Refs. [406] and [407]. In the following discussion, we note
that general spatial orbitals *𝑝, 𝑞, 𝑟, 𝑠*, which comprise the molecular orbital basis, are partitioned into (doubly occupied) inactive core orbitals *𝑖* *[′]* *, 𝑗* *[′]* *, 𝑘* *[′]* *, 𝑙* *[′]*, occupied orbitals *𝑖, 𝑗, 𝑘, 𝑙* (i.e. the union of the inactive core and active
orbital subspaces), active orbitals *𝑤, 𝑥, 𝑦, 𝑧* and virtual orbitals *𝑎, 𝑏, 𝑐, 𝑑* . In general, the many-body similarity
transformations assume the general form

︀

[︀]



[︀]

[︀]

~~̂~~
*𝐺* ̂︀ = {︀ *𝑒* *𝑌* ̂︀ [}︀] *−* 1 *𝐻* ︀ 2 {︀ *𝑒* *𝑌* ̂︀ [}︀] = *𝑔* 0 + ∑︁

[︀]



[︀]

[︀]

︀ ∑︁ *𝑔* *𝑟𝑠* *[𝑝𝑞]* {︀̂︀ *𝐸* *𝑟𝑠𝑝𝑞* }︀ + *. . .,*

*𝑝,𝑞,𝑟,𝑠*

[︀]



[︀]

[︀]

︀ ∑︁ *𝑔* *𝑞* *[𝑝]* {︀̂︀ *𝐸* *𝑞𝑝* }︀ + ∑︁

*𝑝,𝑞* *𝑝,𝑞,𝑟,𝑠*

[︀]



[︀]

[︀]

︀

in which *𝑌* [̂︀] is a cluster operator and *𝐻* ~~[̂]~~ [︀] 2 is the bare Hamiltonian or a similarity transformed Hamiltonian truncated
up to two-body operators. The braces indicate Kutzelnigg-Mukherjee normal ordering [485, 597], which is used
extensively in the definition of the MR-EOM formalism. The various transformations which need to be considered
in the ORCA implementation of MR-EOM are summarized in Table Table 7.24. The table also includes the expressions for the operator components of the various internally contracted cluster operators and the residual equations
that must be solved for the various amplitudes. Note that the residual equations are typically of the many-body type
(i.e. obtained by setting the corresponding elements of the similarity transformed Hamiltonian to zero). The only
exception is the residual equation which defines the *𝑡* *[𝑎]* *𝑖* [amplitudes, which is a projected equation of the form]

*𝑅* *𝑖* *[𝑎]* [=] ∑︁ *𝑤* m ⟨︀Φ m *|𝐸* [̂︀] *𝑎* *[𝑖]* *[𝐻]* [̂︀] *[|]* [Φ] [m] ⟩︀ *.*

m

Here, *|* Φ m ⟩︀ is the m [th] state included in the state averaged CAS, with weight *𝑤* m . The reason the equation for the
singles is of the projected form is that it satisfies the Brillouin theorem (i.e. the first order singles vanish for all *𝑖*
and *𝑎* ), whereas the corresponding many-body equation ( *ℎ* [¯] *[𝑎]* *𝑖* [= 0)][ does not.]

Table 7.25: Details of the three MR-EOM approaches implemented in ORCA

**870** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Note that there are three different MR-EOM approaches which have been implemented in ORCA. Namely, the
current implementation allows for MR-EOM-T|T *[†]* -h-v, MR-EOM-T|T *[†]* |SXD-h-v and MR-EOM-T|T *[†]* |SXD|U-h-v
calculations. At this point it is useful to discuss the naming convention used for these approaches. We use a vertical
line to separate each transformation involved in the sequence of transformations defining the given MR-EOM
approach. For example, T|T *[†]* |SXD indicates that a T transformation, is followed by a T *[†]* transformation, which is
then followed by an SXD transformation. The h-v indicates that the elements of the transformed Hamiltonian have
been hermitized (h) and vertex symmetrized (v) before entering the MRCI diagonalization (see Ref. [407] for more
information). Essentially, this means that the full eightfold symmetry of the two-electron integrals (and hermiticity
of the one-body elements) have been enforced upon the elements of the transformed Hamiltonian. The details
of the three MR-EOM approaches are summarized in Table Table 7.25. This table includes the keyword (in the
first line of input) used to initiate the calculation in ORCA, the various operators involved, and the configurations
included in the final diagonalization manifold. One can clearly see that the MR-EOM-T|T *[†]* |SXD|U-h-v approach is
the most cost effective, as it only includes the 1h and 1p configurations, beyond the CAS, in the final diagonalization
manifold.

The various `%mdci` keywords, which are important for controlling MR-EOM calculations are (i.e. default values
are given here):



As discussed below, the orbital selection scheme is activated by adding `!OrbitalSelection` to the simple input
line. Keywords that are specific to the CASSCF and MRCI modules are discussed in sections *The Complete Active*
*Space Self-Consistent Field (CASSCF) Module* and *The Multireference Correlation Module*, respectively. We
note that in MR-EOM-T|T *[†]* -h-v and MR-EOM-T|T *[†]* |SXD-h-v calculations, it is possible to override the default
excitation classes in the final MRCI diagonalization. This is done by specifying `excitations none` and then
explicitly setting the excitation flags within a given multiplicity block. For example, if we wanted to have 1h, 1p,
1h1p, 2h and 2h1p excitations in the final diagonalization manifold, we would specify (i.e. here we have requested
6 singlets and have a CAS(6,4) reference):



**7.40. Multireference Equation of Motion Coupled-Cluster (MR-EOM-CC) Theory** **871**

**ORCA Manual** **,** **Release 6.0.1**

**7.40.1 The Steps Required to Run an MR-EOM Calculation**

To illustrate the various steps required in a typical MR-EOM calculation, we will consider the calculation of the
excitation energies of the neutral Fe atom at the MR-EOM-T|T *[†]* |SXD|U-h-v level of theory.

**State-Averaged CASSCF Calculation**

Evidently, the first step is to determine a suitable state-averaged CASSCF reference for the subsequent MR-EOM
calculation. In choosing the state-averaged CAS for an MR-EOM calculation, we typically include a few of the
low-lying multiplets that have the same character as the (much larger number of) states that we wish to compute
in the final MR-EOM calculation. For the neutral Fe atom, we typically have electronic states which have either
4s [2] 3d [6] character or 4s [1] 3d [7] character. From the NIST atomic spectra database [1, 606], we find that the lowest lying
a [5] D multiplet is of 4s [2] 3d [6] character and the higher lying a [5] F multiplet is of 4s [1] 3d [7] character. Hence, we can set up
a state-averaged CASSCF(8,6) calculation (i.e. 8 electrons in 6 orbitals (4s and 3d)) which includes the [5] D and [5] F
states and choose the weights such that the average occupation of the 4s orbital is 1.5. As discussed in Ref. [529],
this is done to avoid a preference toward either of the 4s configurations in the state-averaging. We will run the
state-averaged CASSCF calculation, making use of the second order DKH (see *The Douglas-Kroll-Hess Method* )
method for the inclusion of relativistic effects in a Def2-TZVPP basis (i.e. the DKH-Def2-TZVPP relativistically
recontracted basis, listed in section *Choice of Basis Set* ). The input file for the state-averaged CASSCF(8,6) calculation takes the form:

Here, we have requested 12 quintet states (the lowest lying [5] D and [5] F multiplets) and we have chosen the weights
to be 0.7 for the five [5] D states and 0.5 for the seven [5] F states, such that the overall occupation of the 4s orbital will
be 1.5. Once the calculation has converged, it is important to inspect the results printed in the final macro-iteration
of the CASSCF calculation (macro-iteration 8 in this case). In this case, we have:



(continues on next page)

**872** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Directly below `CI-ITERATION 0`, the final CAS-CI energies are printed, and one observes that they follow the correct degeneracy pattern (i.e. 5 states with energy `-1271.258899450` and 7 states with energy `-1271.186288591` ).
Furthermore, the final state-averaged CASSCF energy ( `E(CAS)= -1271.222594021` ) and occupation numbers
( `N(occ)= 1.50000 1.30000 1.30000 1.30000 1.30000 1.30000` ) are also printed. As expected, the occupation number of the 4s orbital is indeed 1.5, while the 3d orbitals each have an occupation of 1.3.

**Selection of the States to Include in the MR-EOM Calculation**

Once a satisfactory CASSCF reference has been obtained, the next step is to determine the number of states to
include in the MR-EOM calculation. From the NIST atomic spectra database, one finds that the higher lying states
of 4s [2] 3d [6] and 4s [1] 3d [7] character are either singlets, triplets, or quintets. To figure out how many states should be
included in each multiplicity block, one can perform an inexpensive CAS-CI calculation. This is done by reading
in the orbitals from the previous CASSCF calculation (here they are stored in the file `CAS.gbw` ) and requesting a
single iteration (i.e. using the `NoIter` keyword) of a state-averaged CASSCF calculation:



Here, after some experimentation, we have chosen 15 quintets, 90 triplets and 55 singlets. It is important that we
calculate states up to sufficiently high energy (i.e. all the states that are of interest) and it is imperative that we have
complete multiplets. Hence, several iterations of this procedure might be required to choose the proper number
of states for each multiplet. The relevant section of the output file which should be analyzed is the `SA-CASSCF`
`TRANSITION ENERGIES` . For the above calculation, we obtain (i.e. only the CAS-CI energies for the first 33 roots
are shown here):




(continues on next page)

**7.40. Multireference Equation of Motion Coupled-Cluster (MR-EOM-CC) Theory** **873**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**Running the MR-EOM Calculation**

Now that we have chosen a suitable CASSCF reference and the states that we wish to calculate, we can finally
proceed with the MR-EOM calculation. The following input file runs an MR-EOM-T|T *[†]* |SXD|U-h-v calculation
for 15 quintet, 90 triplet and 55 singlet states of the neutral Fe atom (i.e. the CASSCF orbitals are read from
`CAS.gbw` ):



(continues on next page)

**874** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



Note that since the default frozen core settings exclude the 3p orbitals from the correlation treatment, we have used
an energy window (i.e. the line `ewin -6, 10000` in both the `%mdci` and `%mrci` blocks) such that they are included
in the current calculation. We note that a detailed discussion of the input and output of an MR-EOM calculation
has already been given in section *MR-EOM-CC: Multireference Equation of Motion Coupled-Cluster* and thus,
we do not repeat it here. It is important to reiterate that one should always inspect the values of the largest (T, S
and U) amplitudes. Ideally, the largest amplitudes should be smaller than 0.1 and should not exceed 0.15. If some
amplitudes are larger than 0.15, it might be necessary to revisit the definition of the CAS and the weights used.
For the T amplitudes, an alternative solution is to use the projection/singular PT scheme discussed in section *A*
*Projection/Singular PT Scheme to Overcome Convergence Issues in the T Amplitude Iterations* below.

As discussed in section *MR-EOM-CC: Multireference Equation of Motion Coupled-Cluster*, the excitation energies
are printed under the heading `TRANSITION ENERGIES` . For the current calculation, we obtain the following results
(only the results for 33 states are shown here):



(continues on next page)

**7.40. Multireference Equation of Motion Coupled-Cluster (MR-EOM-CC) Theory** **875**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

It is also important to recall that one should always inspect the reference weights for each state, as only states
which are dominated by reference space configurations can be treated accurately at the MR-EOM level of theory.
Generally, the reference weights should be larger than (or close to) 0.9. In each multiplicity block, the individual
state energies and reference weights can be found following convergence of the MRCI procedure, under the heading
`CI-RESULTS` (see section *MR-EOM-CC: Multireference Equation of Motion Coupled-Cluster* for a more detailed
discussion).

**7.40.2 Approximate Inclusion of Spin-Orbit Coupling Effects in MR-EOM Calcu-**
**lations**

The effects of spin-orbit coupling can approximately be included in MR-EOM calculations using the SOC submodule of the MRCI module, as outlined in section *Properties Calculation Using the SOC Submodule* . This can be
viewed as a first order approximation to the inclusion of spin-orbit coupling effects in MR-EOM. In a more rigorous
formulation, one would have to consider the various similarity transformations of the spin-orbit coupling operator.
The details of the SOC submodule of the MRCI module have already been discussed in detail in Sec. *Properties*
*Calculation Using the SOC Submodule* and its usage within the MR-EOM formalism is identical to that discussed
therein. Let us consider the calculation of spin-orbit coupling effects in the excitation spectrum of the neutral Fe
atom considered in the previous section. The input file for this calculation is:



(continues on next page)

**876** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



In contrast with the calculation performed in section *The Steps Required to Run an MR-EOM Calculation*, the
convergence thresholds have been tightened in all aspects of the calculation (i.e. the use of the `ExtremeSCF` keyword, `etol` and `gtol` (CASSCF energy and orbital gradient convergence tolerance) are set to 1 *×* 10 *[−]* [12] and the
convergence tolerance for the residuals in the MR-EOM amplitude iterations have been set to 1 *×* 10 *[−]* [12] ). We note
that with the use of the `ExtremeSCF` keyword, the convergence tolerance on the energy ( `Etol` ) and residual ( `Rtol` )
in the MRCI portion of the calculation are also set to 1 *×* 10 *[−]* [12] . Although it is not absolutely necessary, we have
used very strict convergence thresholds to preserve the degeneracies of the various multiplets as much as possible.
The output of spin-orbit corrected MR-EOM spectrum appears under the heading `SOC CORRECTED ABSORPTION`

`SPECTRUM VIA TRANSITION DIPOLE MOMENTS` :



It is possible to obtain more accurate results by performing an MR-EOM-T|T *[†]* |SXD-h-v calculation and including
the 1h1p excitations. It is important to note that these calculations are significantly more expensive. As discussed
above, to run an MR-EOM-T|T *[†]* |SXD-h-v calculation, the keyword `MR-EOM-T|Td|SXD` must appear in the first
line of input and, in order to activate the 1h1p excitations in each multiplicity block of the MRCI calculation, the
`%mrci` block takes the form:



(continues on next page)

**7.40. Multireference Equation of Motion Coupled-Cluster (MR-EOM-CC) Theory** **877**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

We use `excitations none` to set the default excitation flags to false and then manually set the 1h ( `Flags[is]` ),
1p ( `Flags[sa]` ), 1h1p ( `Flags[ia]` ) and 2h ( `Flags[ijss]` ) excitation flags to true.

WARNINGS

  - Currently, MR-EOM-T|T *[†]* |SXD|U-h-v calculations can only be run with the default excitation classes in the
final MRCI (i.e. 1h and 1p). Any other input options for the excitation flags will automatically be overwritten
and set to the default values.

  - Only the inclusion of spin-orbit coupling effects has been tested for MR-EOM calculations. Other features
that are available in the MRCI module (e.g. spin-spin coupling, magnetic property calculations, etc.) have
not been tested for use within MR-EOM calculations.

**7.40.3 A Projection/Singular PT Scheme to Overcome Convergence Issues in the**
**T Amplitude Iterations**

In certain cases, there may be nearly singular T 2 amplitudes (often, but not always large in magnitude), which can
cause convergence issues in the solution of the T amplitude equations. Hence, it is sometimes necessary to discard
some of the amplitudes to remedy these convergence problems. The nearly singular T 2 amplitudes are of the form
*𝑡* *[𝑎𝑏]* *𝑤𝑥* [, where (] *[𝑤, 𝑥]* [) is a pair of active orbitals which corresponds to a small eigenvalue (pair occupation number]
*𝑛* *𝑤𝑥* ) of the two-body reduced density matrix (RDM). When nearly singular amplitudes are present, it is possible
to employ a singular PT/projection scheme (i.e. Scheme I described in Ref. [193]), using the two-body RDM as the
metric matrix, to discard these nearly singular amplitudes and replace them with suitable perturbative estimates.
As a first example, let us consider the following calculation on the cyclopentadiene molecule:



(continues on next page)

**878** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



The T amplitude iterations do not converge after 60 iterations and show no signs of convergence (i.e. final largest
residual of 0.000458135 and oscillatory behavior over a significant portion of the iterations). If we inspect the
largest T amplitudes,

one can see that there are no unusually large amplitudes. If we turn on the singular PT/projection scheme by adding
the line `DoSingularPT true` to the `%mdci` block:



and rerun the calculation, we find that the T amplitude iterations now successfully converge in 22 iterations. If we
look at the largest T amplitudes:



(continues on next page)

**7.40. Multireference Equation of Motion Coupled-Cluster (MR-EOM-CC) Theory** **879**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

most of the amplitudes corresponding to the active pair ( *𝑤, 𝑥* ) = (19 *,* 19) no longer appear in the list (i.e. they are
nearly singular amplitudes which have been projected out). The only one that does appear in the list, corresponds
to a projected perturbative estimate (e.g. `19-> 41 19-> 41 0.020463` ).

By default, when the singular PT/projection scheme is active, the amplitudes *𝑡* *[𝑎𝑏]* *𝑤𝑥* [for which the pair occupation]
numbers satisfy *𝑛* *𝑤𝑥* *<* 0 *.* 01 (i.e. `SingularPTThresh = 0.01` ), are replaced by perturbative amplitudes in the
procedure. However, in some cases, it might be necessary to increase the `SingularPTThresh` threshold beyond
the default value to achieve convergence. One such example is the ferrocene molecule. Consider the following
calculation:



(continues on next page)

**880** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

The T amplitude iterations do not converge after 50 iterations, even though the singular PT/projection scheme is
activated. If we increase `SingularPTThresh` to 0.05 by adding `SingularPTThresh 0.05` to the `%mdci` block:



the T amplitude iterations successfully converge in 25 iterations.

In conclusion, it occasionally happens that the T amplitude iterations do not converge. In these cases, the singular
PT/projection scheme can be activated ( `DoSingularPT true` ) to overcome these convergence difficulties. Sometimes, like in the case of ferrocene, it is necessary to adjust the threshold for the singular PT/projection procedure
( `SingularPTThresh` ) to achieve convergence. If the procedure still fails with larger values of the threshold, then
it might be necessary to revisit the definition of the state-averaged CAS.

**7.40.4 An Orbital Selection Scheme for More Efficient Calculations of Excitation**
**Spectra with MR-EOM**

As described in Ref. [406], the MR-EOM implementation in ORCA can make use of a sophisticated scheme to
discard inactive and virtual orbitals, which are not important for the description of the excited states of interest.
The selection of inactive core orbitals is based on the eigenvalues of the core orbital selection density

Tr ( *𝐷* *[𝑡]* )
*𝐷* *𝑖* *′* *𝑗* *′* = *𝐷* *𝑖* *[𝑡]* *[′]* *𝑗* *[′]* [ +] Tr ( *𝐷* *[𝑠]* ) + Tr ( *𝐷* *[𝑢]* ) (︀ *𝐷* *𝑖* *[𝑠]* *[′]* *𝑗* *[′]* [ +] *[ 𝐷]* *𝑖* *[𝑢]* *[′]* *𝑗* *[′]* )︀ *,* (7.250)

in which

*𝐷* *𝑖* *[𝑡]* *[′]* *𝑗* *[′]* [ =] ∑︁ *𝑡* *[𝑎𝑏]* *𝑖* *[′]* *𝑤* [(1)] (︁2 *𝑡* *[𝑎𝑏]* *𝑗* *[′]* *𝑤* [(1)] *[−]* *[𝑡]* *[𝑏𝑎]* *𝑗* *[′]* *𝑤* [(1)] )︁ *,*

*𝑤,𝑎,𝑏*


*𝐷* *𝑖* *[𝑠]* *[′]* *𝑗* *[′]* [ =] ∑︁

*𝑘,𝑤,𝑎*



[︁ *𝑠* *[𝑎𝑤]* *𝑖* *[′]* *𝑘* [(1)] (︁2 *[𝑎𝑤]* *𝑗* *[′]* *𝑘* [(1)] *−* *𝑠* *[𝑎𝑤]* *𝑘𝑗* *[′]* [(1)] )︁ + *𝑠* *[𝑎𝑤]* *𝑘𝑖* *[′]* [(1)] (︁2 *𝑠* *[𝑎𝑤]* *𝑘𝑗* *[′]* [(1)] *−* *𝑠* *[𝑎𝑤]* *𝑗* *[′]* *𝑘* [(1)] )︁]︁ *,*


*𝐷* *𝑖* *[𝑢]* *[′]* *𝑗* *[′]* [ =] ∑︁ *𝑢* *[𝑤𝑥]* *𝑖* *[′]* *𝑘* *[′]* [(1)] (︁2 *𝑢* *[𝑤𝑥]* *𝑗* *[′]* *𝑘* [(1)] *[′]* *−* *𝑢* *[𝑤𝑥]* *𝑘* *[′]* *𝑗* [(1)] *[′]* )︁ *,*

*𝑘* *[′]* *,𝑤,𝑥*


are respectively, the contributions from the first order *𝑡* *[𝑎𝑏]* *𝑖* *[′]* *𝑤* [(1)] [,] *[ 𝑠]* *[𝑎𝑤]* *𝑖* *[′]* *𝑘* [(1)] and *𝑢* *[𝑤𝑥]* *𝑖* *[′]* *𝑘* *[′]* [(1)] amplitudes (i.e. note that all amplitudes have at least one active label). Similarly, the selection of virtual orbitals is based upon the eigenvalues of the
virtual orbital selection density

[(] *[𝜌]* *[𝑡]* [)]
*𝜌* *𝑎𝑏* = *𝜌* *[𝑡]* *𝑎𝑏* [+] Tr [Tr] ( *𝜌* *[𝑠]* ) *[𝜌]* *𝑎𝑏* *[𝑠]* *[,]* (7.251)

in which, the contribution *𝜌* *[𝑡]*, from the first order *𝑇* 2 amplitudes, is given by


∑︁ *𝑡* *[𝑎𝑐]* *𝑤𝑘* [(1)] (︁2 *𝑡* *[𝑏𝑐]* *𝑤𝑘* [(1)] *−* *𝑡* *[𝑐𝑏]* *𝑤𝑘* [(1)] )︁ + ∑︁

*𝑘,𝑤,𝑐* *𝑖* *[′]* *,𝑤,𝑐*


*𝜌* *[𝑡]* *𝑎𝑏* [=] ∑︁


∑︁ *𝑡* *[𝑎𝑐]* *𝑖* *[′]* *𝑤* [(1)] (︁2 *𝑡* *[𝑏𝑐]* *𝑖* *[′]* *𝑤* [(1)] *[−]* *[𝑡]* *[𝑐𝑏]* *𝑖* *[′]* *𝑤* [(1)] )︁ *,* (7.252)

*𝑖* *[′]* *,𝑤,𝑐*


and the contribution *𝜌* *[𝑠]*, from the first order *𝑆* 2 amplitudes, is given by


∑︁ *𝑠* *[𝑎𝑤]* *𝑖* *[′]* *𝑘* [(1)] ( 2 *𝑠* *[𝑏𝑤]* *𝑖* *[′]* *𝑘* [(1)] *−* *𝑠* *[𝑏𝑤]* *𝑘𝑖* *[′]* [(1)] ) + ∑︁

*𝑖* *[′]* *,𝑘,𝑤* *𝑖* *[′]*


*𝜌* *[𝑠]* *𝑎𝑏* [=] ∑︁


∑︁ *𝑠* *[𝑎𝑤]* *𝑥𝑖* *[′]* [(1)] ( 2 *𝑠* *[𝑏𝑤]* *𝑥𝑖* *[′]* [(1)] *−* *𝑠* *[𝑏𝑤]* *𝑖* *[′]* *𝑥* [(1)] ) *.* (7.253)

*𝑖* *[′]* *,𝑤,𝑥*


**7.40. Multireference Equation of Motion Coupled-Cluster (MR-EOM-CC) Theory** **881**

**ORCA Manual** **,** **Release 6.0.1**

Diagonalization of the core orbital selection density *𝐷* *𝑖* *′* *𝑗* *′* and the virtual orbital selection density *𝜌* *𝑎𝑏* then yields
two respective sets of eigenvalues *{𝜆* *𝑖* *′* *}* and *{𝜆* *𝑎* *}* . We have found it useful to compute the ratios,

*ℛ* core = ∑ ∑︀ *𝑛* *𝑖* ︀ *[′]* *𝑛𝑖* [excluded] core = *[′]* core =0 0 *[𝜆]* *𝜆* *[𝑖]* *[′]* *𝑖* *′* *×* 100% *,* (7.254)

∑ *𝑛* *𝑎* ︀ = [excluded] virt 0 *𝜆* *𝑎*
*ℛ* virt = ∑︀ *𝑛𝑎* =0 virt *[𝜆]* *[𝑎]* *×* 100% *,* (7.255)

of the sum of the excluded eigenvalues to the sum over all eigenvalues. The orbital selection in the core and virtual
subspaces is then based upon the values of these ratios, as will be discussed below.

The orbital selection procedure is activated by adding the keyword `OrbitalSelection` to the first line of input,

e.g.
```
! MR-EOM def2-TZVPP VeryTightSCF OrbitalSelection

```
There are two threshold parameters `CoreThresh` and `VirtualThresh`, which are used to determine which inactive
core and virtual orbitals are to be discarded in the orbital selection procedure, respectively. Namely, all inactive
core orbitals for which *ℛ* core *<* `CoreThresh` (i.e. *ℛ* core as defined in Eq. (7.254)) are discarded and all virtual
orbitals satisfying the condition *ℛ* virt *<* `VirtualThresh` (i.e. *ℛ* virt as defined in Eq. (7.255)) are discarded. The
default values of these thresholds are `CoreThresh = 0.0` (no core orbital selection) and `VirtualThresh = 1.0` .
However, the values of these parameters can easily be changed by redefining them in the `%mdci` block:


︀

︀


︀

︀


︀

︀

Let us consider the calculation of the previous section ( *A Projection/Singular PT Scheme to Overcome Convergence*
*Issues in the T Amplitude Iterations* ) on ferrocene, with the orbital selection procedure activated (using the default
thresholds):


︀

︀


︀

︀


︀

︀

(continues on next page)

**882** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

The details of the orbital selection procedure are printed under the heading `ORBITAL SELECTION` :



Comparing the number of virtual orbitals before the orbital selection procedure (171) with the number that are left
after orbital selection (77), we see that more than half have been discarded (94). The canonical calculation (without
orbital selection) takes 149373 seconds to run and yields the following excitation energies:




(continues on next page)

**7.40. Multireference Equation of Motion Coupled-Cluster (MR-EOM-CC) Theory** **883**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

In contrast, the calculation with the orbital selection procedure activated runs in 28977 seconds (a factor of 5
speedup) and produces the following excitation energies:



(continues on next page)

**884** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

We note that the excitation energies in the orbital selection procedure agree very nicely with those of the canonical calculation. However, the total energies are significantly different, as we currently have not implemented a
procedure to correct them. Hence, the following warning is particularly important.

WARNING

  - The orbital selection procedure should only be used for the calculation of excitation energies. Total energies computed with the orbital selection procedure have not been corrected and can differ greatly from the
canonical results.

Before leaving the discussion of the orbital selection procedure, we note that there is also a keyword
`PrintOrbSelect`, which can be added to the `%mdci` block to print the eigenvalues of the inactive core orbital selection and virtual orbital selection densities and the corresponding values of *ℛ* core and *ℛ* virt defined in Eqs. (7.254)
and (7.255), respectively. This is useful if one wants to manually select the orbitals to discard in the orbital selection procedure by adjusting the values of `CoreThresh` and `VirtualThresh` . We note that the program terminates
after printing. In the case of the calculation on ferrocene, if we modify the `%mdci` block to read



we find the following information in the `ORBITAL SELECTION` section of the output (only the first 50 values for
the virtual orbital selection density are shown here):

(continues on next page)

**7.40. Multireference Equation of Motion Coupled-Cluster (MR-EOM-CC) Theory** **885**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
 24 0.00533017 49.294785
 25 0.00533019 57.592429
 26 0.00658679 67.846267
 27 0.00662033 78.152314
 28 0.00701718 89.076149
 29 0.00701719 100.000000
 Eigenvalues and corresponding R_virt values for the virtual orbital selection density
Orbital Eigenvalue R_virt
  0 0.00000119 0.000450
  1 0.00000119 0.000899
  2 0.00000134 0.001404
  3 0.00000134 0.001909
  4 0.00000136 0.002423
  5 0.00000177 0.003091
  6 0.00000178 0.003764
  7 0.00000178 0.004437
  8 0.00000215 0.005248
  9 0.00000224 0.006096
 10 0.00000224 0.006944
 11 0.00000238 0.007844
 12 0.00000347 0.009154
 13 0.00000347 0.010465
 14 0.00000364 0.011841
 15 0.00000386 0.013299
 16 0.00000396 0.014793
 17 0.00000396 0.016287
 18 0.00000437 0.017937
 19 0.00000437 0.019587
 20 0.00000499 0.021472
 21 0.00000499 0.023357
 22 0.00000794 0.026354
 23 0.00000794 0.029352
 24 0.00000819 0.032447
 25 0.00000819 0.035543
 26 0.00000927 0.039044
 27 0.00000927 0.042546
 28 0.00001002 0.046332
 29 0.00001002 0.050119
 30 0.00001137 0.054415
 31 0.00001137 0.058711
 32 0.00001158 0.063086
 33 0.00001158 0.067461
 34 0.00001381 0.072678
 35 0.00001381 0.077894
 36 0.00001417 0.083249
 37 0.00001417 0.088604
 38 0.00001465 0.094137
 39 0.00001495 0.099785
 40 0.00001495 0.105432
 41 0.00001554 0.111302
 42 0.00001554 0.117172
 43 0.00001623 0.123303
 44 0.00001689 0.129685
 45 0.00001754 0.136310
 46 0.00001754 0.142934
 47 0.00001805 0.149752
 48 0.00001805 0.156570
 49 0.00002111 0.164546

```
(continues on next page)

**886** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

In conclusion, the orbital selection scheme provides a more efficient way to calculate accurate excitation spectra
within the framework of MR-EOM. It can be used to extend the applicability of this approach to larger systems and
we expect it to be much more effective in larger systems where the chromophore is localized to a small part of the
molecule. We reiterate that it is currently limited to the calculation of excitation energies and should not be used
if one is interested in total energies.

**7.40.5 Nearly Size Consistent Results with MR-EOM by Employing an MR-**
**CEPA(0) Shift in the Final Diagonalization Procedure**

One drawback of the MR-EOM methodology is that it is not size-extensive (or size-consistent). The size-extensivity
errors arise due to the final uncontracted MR-CI diagonalization step. Namely, they result from the components of
the eigenvectors of the transformed Hamiltonian, which lie outside of the CASSCF reference space (e.g. 1h, 1p, etc.
configurations). As more of the excitation classes are included through the successive similarity transformations
of the Hamiltonian, the size of the final diagonalization manifold is greatly decreased resulting in much smaller
size-extensivity errors upon going from MR-EOM-T|T *[†]* -h-v to MR-EOM-T|T *[†]* |SXD|U-h-v. To illustrate this, let
us consider the O 2 —O 2 dimer where the O 2 molecules are separated by a large distance. For the O 2 monomer,
we employ a minimal active space consisting of 2 electrons distributed amongst the two *𝜋* *[*]* orbitals and we only
consider the ground [3] Σ *[−]* *𝑔* [state (no state-averaging). In the MR-EOM calculations, we also calculate the higher]
lying [1] ∆ *𝑔* and [1] Σ [+] *𝑔* [singlet states. For example, the input file for the MR-EOM-T|T] *[†]* [|SXD|U-h-v calculation is]
given by:



In the case of the dimer, we take the reference state as the coupled quintet state which is formed as the product
3 Σ +
*𝑔* *[⊗]* [3] [Σ] [+] *𝑔* [of the monomer states. We note that at large separation, in the non-interacting limit, the dimer state]
energies can be decomposed as the sum of monomer state energies. There are various possibilities, taking into
account the degeneracies of the various states:

**7.40. Multireference Equation of Motion Coupled-Cluster (MR-EOM-CC) Theory** **887**

**ORCA Manual** **,** **Release 6.0.1**

1. a singlet, a triplet, and a quintet with energy *𝐸* ( [3] Σ *[−]* *𝑔* [+] [ 3] [Σ] *[−]* *𝑔* [)][,]

2. four triplets with energy *𝐸* ( [3] Σ *[−]* *𝑔* [+] [ 1] [∆] *[𝑔]* [)][,]

3. two triplets with energy *𝐸* ( [3] Σ *[−]* *𝑔* [+] [ 1] [Σ] [+] *𝑔* [)][,]

4. four singlets with energy *𝐸* ( [1] ∆ *𝑔* + [1] ∆ *𝑔* ),

5. four singlets with energy *𝐸* ( [1] ∆ *𝑔* + [1] Σ [+] *𝑔* [)][,]

6. a singlet with energy *𝐸* ( [1] Σ [+] *𝑔* [+] [ 1] [Σ] *𝑔* [+] [)][.]

Hence, in the final diagonalization step of the MR-EOM calculation, we must ask for 10 singlets, 7 triplets and
1 quintet. The input file for the MR-EOM-T|T *[†]* *|* SXD|U-h-v calculation on the dimer is given by:



In Table *Test for size consistency in MR-EOM: Differences in energy (in mE_\text{h}) between the _2—O_2 dimer*
*energies (at large separation) and the sum of the monomer energies for the ground state and various excited states.*
*The results were obtained in an aug-cc-pVTZ basis using minimal active spaces.*, we have compiled the results
of the size consistency test, taking the difference of the dimer state energies (at large separation) and the sum of
the monomer state energies (in m *𝐸* h ). It is evident that as more excitation classes are included in the similarity
transformed Hamiltonian and the size of the final diagonalization manifold is decreased, the size-consistency errors
decrease. Of particular note are the results for the MR-EOM-T|T *[†]* |SXD|U-h-v approach (only includes 1h and 1p
configurations in the final diagonalization manifold), for which the largest deviation is 1 *.* 25 *×* 10 *[−]* [2] m *𝐸* h . The
much larger deviations for the MR-EOM-T|T *[†]* *|* SXD-h-v approach clearly demonstrate the large effect that the 2h
excitations have on the size-consistency errors.

**888** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.26: Test for size consistency in MR-EOM: Differences in energy (in mE h ) between the 2 —O 2 dimer
energies (at large separation) and the sum of the monomer energies for the ground state and various excited states.
The results were obtained in an aug-cc-pVTZ basis using minimal active spaces.

To reduce the size-consistency errors, one can make use of the MR-CEPA(0) shift in the final diagonalization step.
This MR-CEPA(0) shift can easily be activated by adding the line
```
citype mrcepa_0

```
to the beginning of the `%mrci` block. The results of the size-consistency test with the use of the MR-CEPA(0) shift
are tabulated in Table *Test for size consistency in MR-EOM, using the MR-CEPA(0) shift: Differences in energy (in*
*mE_\text{h}) between the O_2—O_2 dimer energies (at large separation) and the sum of the monomer energies*
*for the ground state and various excited states. The results were obtained in an aug-cc-pVTZ basis using minimal*
*active spaces and the MR-CEPA(0) shift was applied in the final diagonalization in each case.* . For each of the
methods, we see a marked improvement over the results of Table *Test for size consistency in MR-EOM: Differences*
*in energy (in mE_\text{h}) between the _2—O_2 dimer energies (at large separation) and the sum of the monomer*
*energies for the ground state and various excited states. The results were obtained in an aug-cc-pVTZ basis using*
*minimal active spaces.*, which do not make use of the MR-CEPA(0) shift. The greatest improvement occurs in the
MR-EOM-T|T *[†]* |SXD-h-v and the MR-EOM-T|T *[†]* |SXD|U-h-v results. Namely, the errors in the former case are
on the order of nano Hartrees, while the errors in the MR-EOM-T|T *[†]* |SXD|U-h-v results are not detectable (subnano Hartree), as the energy is only printed with nine decimal places. It is interesting to note that upon adding
the 1h1p configurations to the diagonalization manifold in the MR-EOM-T|T *[†]* |SXD-h-v calculations (i.e. with
1h1p), the size-consistency errors increase greatly. Hence, it appears that the use of the MR-CEPA(0) shift is most
effective at reducing the size-consistency errors resulting from the presence of the 1h, 1p and 2h configurations
in the final diagonalization manifold. In any case, one can easily take advantage of this approach to obtain nearly
size-consistent results with both the MR-EOM-T|T *[†]* |SXD-h-v and MR-EOM-T|T *[†]* |SXD|U-h-v methods.

Table 7.27: Test for size consistency in MR-EOM, using the MR-CEPA(0) shift: Differences in energy (in mE h )
between the O 2 —O 2 dimer energies (at large separation) and the sum of the monomer energies for the ground state
and various excited states. The results were obtained in an aug-cc-pVTZ basis using minimal active spaces and the
MR-CEPA(0) shift was applied in the final diagonalization in each case.

**7.40. Multireference Equation of Motion Coupled-Cluster (MR-EOM-CC) Theory** **889**

**ORCA Manual** **,** **Release 6.0.1**

**7.40.6 Perturbative MR-EOM-PT**

The MR-EOMPT approach was developed for situations where the full accuracy of the iterative MR-EOMCC
method is not required. It performs on par with other multireference perturbation theories such as fic-NEVPT2
and does not have the convergence difficulties with the *𝑇* [ˆ] and *𝑆,* [ˆ] *𝑋,* [ˆ] *𝐷* [ˆ] amplitudes like its iterative parent method
as these amplitudes are computed in a non-iterative fashion. The only iterative part of the MR-EOMPT method is
the calculation of the *𝑈* [ˆ] amplitudes since they are quick to converge anyways [501].

The setup procedure for the MR-EOMPT method is the same as for the MR-EOMCC method, and the foregoing
also applies to the perturbative variant. Please note that the orbital selection scheme has not been tested with this
variant and should be unnecessary anyways since calculations are much faster than with the iterative MR-EOMCC
method.

To invoke the new variant, set up the calculation as you would for an MR-EOMCC calculation and then add the
keyword `DoMREOM_MRPT True` to the `%mdci` block.

The results are interpreted just like results for the iterative MR-EOMCC method. After transforming the Hamiltonian with the perturbatively estimated amplitudes and the final MRCIS diagonalization step, the final state energies
are printed along with their reference weights. For reliable results, we again recommend that the reference weight
be >90%.
### **7.41 Simulation and Fit of Vibronic Structure in Electronic Spec-** **tra, Resonance Raman Excitation Profiles and Spectra with** **the orca_asa Program**

**Deprecated since ORCA 6.0.0**

  - The `orca_asa` program is no longer supported. It is still included in the 6.0.0 release and the documentation
is preserved below. However, it may not function correctly and will be removed in a future ORCA version!

  - The `!NMScan` and `!NMGrad` keywords are still available but these calculations may fail or not generate valid
input for `orca_asa` . Please use the *ESD module* instead, if applicable.

In this section various aspects of the simulation and fit of optical spectra, including absorption, fluorescence, and
resonance Raman are considered. This part of the ORCA is fairly autonomous and can also be used in a data
analysis context, not only in a “quantum chemistry” mode. The program is called `orca_asa`, where ASA stands
for “Advanced Spectral Analysis”. The program was entirely designed by Dr. Taras Petrenko.

The general philosophy is as follows: An ORCA run produces the necessary data to be fed into the `orca_asa`
program and writes an initial input file. This input file may be used to directly run `orca_asa` in order to predict an
absorption, fluorescence or resonance Raman spectrum. Alternatively, the input file may be edited to change the
parameters used in the simulations. Last – but certainly not least – the `orca_asa` program can be used to perform
a fit of the model parameters relative to experimental data.

**890** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

All examples below are taken from [679], which must be cited if you perform any work with the `orca_asa` program!

**7.41.1 General Description of the Program**

The program input comprises the following information: (1) model and specification of the model parameters
characterizing the electronic structure of a molecule, as well as lineshape factors; (2) spectral ranges and resolution
for simulations; (3) specification of vibrational transitions for rR excitation profile and spectra generation; (4)
certain algorithm-selecting options depending on the model; (5) fitting options.

All optional parameters (1)-(3) are given in the `%sim` block, and fitting options are in the `%fit` block. The model
parameters are specified within various blocks that will be described below. The program `orca_asa` is interfaced
to ORCA and inherits its input style. The input for `orca_asa` run can be also generated upon ORCA run.

The current implementation features so called “simple”, “independent mode, displaced harmonic oscillator”
(IMDHO), and “independent mode, displaced harmonic oscillator with frequency alteration” (IMDHOFA) models.

**7.41.2 Spectral Simulation Procedures: Input Structure and Model Parameters**

**Example: Simple Mode**

This model represents the simplest approach which is conventionally used in analysis of absorption spectra. It
neglects vibrational structure of electronic transitions and approximates each individual electronic band by a standard lineshape, typically a Gaussian, Lorentzian or mixed (Voigt) function. This model can only make sense if
vibrational progressions are not resolved in electronic spectra. Upon this approximation the intensity of absorption
spectrum depends on the energy of the incident photon ( *𝐸* *𝐿* ), the electronic transition energy ( *𝐸* *𝑇* ), the transition
electric dipole moment ( **M**, evaluated at the ground-state equilibrium geometry). Lineshape factors are specified
by homogeneous linewidth Γ and standard deviation parameter *𝜎* corresponding to Gaussian distribution of transition energies. The following example illustrates a simple input for simulation of absorption bandshapes using
various intensity and lineshape parameters.

**7.41. Simulation and Fit of Vibronic Structure in Electronic Spectra, Resonance Raman** **891**
**Excitation Profiles and Spectra with the orca_asa Program**

**ORCA Manual** **,** **Release 6.0.1**



The parameters of of the final electronic states reached by the respective transitions are specified in the `$el_states`
block. The spectral range and resolution used in the calculation are defined by the `AbsRange` and `NAbsPoints`
keywords in `%sim` block. The calculation of the absorption spectrum is automatically invoked if `NAbsPoints>1` .
After the `orca_asa` run you will find in your directory file `example001.abs.dat` containing absorption spectrum
in simple two-column ASCII format suitable to be plotted with any spreadsheet program. Absorption spectra
corresponding to individual electronic transitions are stored in file `example001.abs.as.dat` ( the suffix “ `as` ”
stands for “All States”).

**892** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.43: Absorption spectrum generated after orca_asa run on file `example001.inp.` Three bands have different
lineshape pararameters. Note that although all transitions are characterized by the same transition electric dipole
moment their intensities are scaled proportionally to the transition energies.

The output of the program run also contains information about oscillator strengths and full-width-half-maximum
(FWHM) parameters corresponding to each electronic band:



Note that although all three types of lineshape functions are symmetric this is not true for the overall shapes of
individual absorption bands since the extinction coefficient (absorption cross-section) is also proportional to the
incident photon energy. Therefore, if the linewidth is larger than 10% of the peak energy the asymmetry of the
electronic band can be quite noticeable.

**7.41. Simulation and Fit of Vibronic Structure in Electronic Spectra, Resonance Raman** **893**
**Excitation Profiles and Spectra with the orca_asa Program**

**ORCA Manual** **,** **Release 6.0.1**

**Example: Modelling of Absorption and Fluorescence Spectra within the IMDHO Model**

The IMDHO model is the simplest approach that successfully allows for the prediction of vibrational structure in
electronic spectra as well as rR intensities for a large variety of real systems. This model assumes:

1. harmonic ground- and excited-state potential energy surfaces;

2. origin shift of the excited-state potential energy surface relative to the ground-state one;

3. no vibrational frequency alteration or normal mode rotation occurs in the excited state;

4. no coordinate dependence of the electronic transition dipole moment.

In addition to the parameters that enter the “Simple model” defined above it requires some information about the vibrational degrees of freedom. The required information consists of the ground-state vibrational frequencies *{𝜔* *𝑔𝑚* *}*
and (dimensionless) origin shifts *{* ∆ *𝑚𝑖* *}*, where *𝑖* and *𝑚* refer to electronic states and normal modes respectively.
∆ is expressed in terms of dimensionless normal coordinates. Accordingly, for the IMDHO model one has to
specify the following blocks

  - The `$el_states` block contains the parameters *𝐸* *𝑇* *,* Γ *, 𝜎,* **M** for each electronic state. By default *𝐸* *𝑇* is
assumed to be adiabatic minima separation energy. Alternatively, it can be redefined to denote for the vertical
transition energy.This is achieved by specifiying the keyword `EnInput=EV` in the `%sim` block.

  - A `$vib_freq_gs` block specifies ground-state vibrational frequencies.

  - A `$sdnc` block contains parameters *{* ∆ *𝑚𝑖* *}* in matrix form such that the *𝑖* -th column represents the dimensionless displacements along all normal modes for the *𝑖* -th excited-state PES.

The file `example002.inp` provides the input for simulation of absorption and fluorescence spectra of a system
characterized by significant displacements of the excited-state origin along 5 normal coordinates.



(continues on next page)

**894** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



The calculation of absorption and fluorescence spectra is automatically invoked if the parameters `NAbsPoints>1`
and `NFlPoints> 1` . The input file also contains the optional block `$ss` which specifies the Stokes shift *𝜆* for
each electronic transition. This parameter is equal to the energy separation between the 0-0 vibrational peaks in
the absorption and fluorescence spectra as shown in Fig. 7.44 . In general *𝜆* accounts for solvent induced effects as
well as unresolved vibrational structure corresponding to low-frequency modes that are not specified in the input.
Note that we have specified parameters `AbsScaleMode=Rel` and `FlScaleMode=Rel` in `%sim` block in order to
ensure that the simulated spectra are normalized to unity. The calculated absorption and fluorescence spectra are
stored in `example002.abs.dat` and `example002.fl.dat` files, respectively.

**7.41. Simulation and Fit of Vibronic Structure in Electronic Spectra, Resonance Raman** **895**
**Excitation Profiles and Spectra with the orca_asa Program**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.44: Absorption and fluorescence spectra generated after `orca_asa` run on the file `example002.inp.` If the
homogeneous broadening is set to be Γ = 10 cm *[−]* [1] one can resolve underlying vibrational structure and identify
various fundamental and combination transitions.

**Example: Modelling of Absorption and Fluorescence Spectra within the IMDHOFA Model**

IMDHOFA (Independent Mode Displaced Harmonic Oscillators with Frequency Alteration) is based on the same
assumptions as the IMDHO model except for vibrational frequency alteration in excited state can take place. The
file `example003.inp` features almost the same input parameters as `example002.inp` . The IMDHOFA model
is invoked by the keyword `Model=IMDHOFA` in the `%sim` block. Additionally, one has to provide the obligatory
block `$vib_freq_es` . It contains the excited-state vibrational frequencies *{𝜔* *𝑒𝑚𝑖* *}* in matrix form such that the
*𝑖* -th column represents the vibrational frequencies of all normal modes for the *𝑖* -th excited-state PES.

**896** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.45: Absorption and fluorescence spectra generated after `orca_asa` run on the file `example003.inp` . Also,
the high-resolution spectra corresponding to homogeneous broadening Γ = 10 cm *[−]* [1] are shown.

**Example: Modelling of Effective Broadening, Effective Stokes Shift and Temperature Effects in**
**Absorption and Fluorescence Spectra within the IMDHO Model**

For the IMDHO model the `orca_asa` is capable to model absorption and emission spectra in the finite-temperature
approximation. While the keyword `Model=IMDHO` assumes the zero-temperature approximation, the value of
`Model=IMDHOT` invokes the calculation of the spectra for the finite temperature which is specified by the paramter
`TK` in the block `%sim` :



(continues on next page)

**7.41. Simulation and Fit of Vibronic Structure in Electronic Spectra, Resonance Raman** **897**
**Excitation Profiles and Spectra with the orca_asa Program**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



This example illustrates a typical situation in large molecules which feature a number of low frequency modes
with significant values of dimensionless displacements for a given excited-state PES. In the case of high density
of vibrational states with frequencies below or comparable to the intrincic value of FWHM (determined by Γ and
*𝜎* ) the vibrational progression is unresolved, whereby the spectra become very diffuse and show large separation
between the maxima of absorption and emission spectra (Fig. 7.45). Besides, upon the condition *ℎ𝜈* *𝑖* ⩽ *𝑘𝑇* the
effective bandwidths and positions of maxima in the spectra can be strongly subject to temperature effects.

**898** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.46: Absorption and fluorescence spectra for T=0 K (blue) and T=300 K (red) generated after `orca_asa` run
on the file `example004.inp` . Black lines show spectra corresponding to the case where all low-frequency modes
were excluded from the calculation.

The effective Stokes shift and linewidth parameters which are evaluated in the simple self-consistent procedure are
given in the output of the `orca_asa` run:



Note that the evaluation of the effective parameters is rather approximate and these values can noticeable deviate
from those which can be directly deduced from the calculated spectra. However, such an information usually
provides the proper order of magnitude of the effective vibronic broadening and Stokes shift. As indicated in
the program output above, the effective bandshape has predominantly a Gaussian character which varies with the
temperature so that *𝜎* = 1125 cm *[−]* [1] ( *𝑇* = 0 K) and *𝜎* = 1414 cm *[−]* [1] ( *𝑇* = 300 K). Indeed, as shown in Fig.
7.47 the absorption spectrum at *𝑇* = 300 K can be well fitted using Gaussian lineshape with *𝜎* = 1388 cm *[−]* [1]

(FWHM= 3270 cm *[−]* [1] ). One can see that at higher temperatures the deviation between the spectrum and its Gauss

**7.41. Simulation and Fit of Vibronic Structure in Electronic Spectra, Resonance Raman** **899**
**Excitation Profiles and Spectra with the orca_asa Program**

**ORCA Manual** **,** **Release 6.0.1**

fit becomes even smaller.

In molecules the normal distribution of the electronic transition energies in the ensemble would give rise to a
Gaussian bandshape of the absorption band. However, the corresponding standard deviation is expected to be
of the order of 100 cm *[−]* [1], whereby a typical Gaussian bandwidth of the order of 1000 cm *[−]* [1] appears to result
from unresolved vibronic progression. In general, this statement is supported by quantum chemical calculation of
the model parameters. In principle the effective bandwidth parameters can also be used for characterization and
assignement of individual electronic bands.

Fig. 7.47: Absorption spectrum (blue) for *𝑇* = 300 K generated after `orca_asa` run on the file `example004.inp` .
Red line represents the Gauss-fit of the calculated spectrum.

**Example: Modelling of Absorption and Resonance Raman Spectra for the 1-** [1] **A** *𝑔* *→* **1-** [1] **B** *𝑢* **Transi-**
**tion in** ***trans*** **-1,3,5-Hexatriene**

The hexatriene molecule is characterized by 9 totally-symmetric normal modes which dominate vibrational structure in absorption and are active in rR spectra corresponding to the strongly dipole-allowed 1 *−* [1] *𝐴* *𝑔* *→* 1 *−* [1] *𝐵* *𝑢*
transition around 40000 cm *[−]* [1] . Except for some peculiarities related to the neglect of normal mode rotations in
the excited state the optical spectra are quite satisfactorily described by the IMDHO model.

The following input exemplifies simulation of absorption spectrum and rR spectra for an arbitrary predefined number of excitation energies.



(continues on next page)

**900** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



After the `orca_asa` run the following files will be created:

   - `example005abs.dat` contains the simulated absorption spectrum. It is shown in Fig. 7.48.

   - `example005.o4.rrs.39500.dat`, `example005.o4.rrs.39800.dat` and `example005.o4.rrs.`
`41400.dat` contain the simulated rR spectra for excitation energies at 39500, 39800 and 41400 cm *[−]* [1],
respectively. The suffix “ `o4` ” stands for the order of Raman scattering specified in the input by keyword
`RamanOrder=4` . The rR specta are shown in Fig. 7.49.

**7.41. Simulation and Fit of Vibronic Structure in Electronic Spectra, Resonance Raman** **901**
**Excitation Profiles and Spectra with the orca_asa Program**

**ORCA Manual** **,** **Release 6.0.1**

   - `example005.o4.rrs.39500.stk`, `example005.o4.rrs.39800.stk` and `example005.o4.rrs.`
`41400.stk` provide Raman shifts and intensities for each vibrational transition. Corresponding vibrational
states are specified by the quantum numbers of excited modes.

Fig. 7.48: Absorption spectrum corresponding to 1 *−* [1] *𝐴* *𝑔* *→* 1 *−* [1] *𝐵* *𝑢* transition in *trans* -1,3,5-hexatriene generated
after `orca_asa` run on the file `example005.inp` .

**902** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.49: Resonance Raman spectra for 3 different excitation energies which fall in resonance with 1 *−* [1] *𝐴* *𝑔* *→*
1 *−* [1] *𝐵* *𝑢* transition in *trans* -1,3,5-hexatriene.

NOTE

  - By default the program provides rR spectra on an arbitrary scale since only relative rR intensities within a
single rR spectrum are of major concern in most practical cases. However, one can put rR spectra corresponding to different excitation energies on the same intensity scale by providing the keyword `RSISM=ASR`

**7.41. Simulation and Fit of Vibronic Structure in Electronic Spectra, Resonance Raman** **903**
**Excitation Profiles and Spectra with the orca_asa Program**

**ORCA Manual** **,** **Release 6.0.1**

in `%sim` block (RSISM – Raman Spectra Intensity Scaling Mode; ASR – All Spectra Relative). By default
`RSISM=SSR` (SSR – Single Spectrum Relative) for which each rR spectrum is normalized so that the most
intense band in it has intensity 1.0. The relative intensities of bands in rR spectra measured for different excitation energies can be compared if they are appropriately normalized relative to the intensity of a reference
signal (e.g. Raman band of the solvent). We also keep in mind the possibility to extend our methodology in
order to provide the absolute measure of rR intensities in terms of the full or differential cross-sections.

  - Within the harmonic model, for a single electronic state neither relative rR intensities nor absorption bandshapes in the case of `AbsScaleMode=Rel` do depend on the values of the electronic transition dipole moment
(unless it is precisely zero).

In the example above resonance Raman spectra have been generated for all vibrational transitions with total excitation number up to the value specified by the parameter `RamanOrder` . Its is also possible to make explicit
specification of vibrational states corresponding to various fundamental, overtone and combination bands via the
`$rr_vib_states` block. In such a case rR spectra involving only these vibrational transitions will be generated
separately.



Each vibrational transition is specified via the subblock which has the following structure:



This means that the *𝑘* -th transition is characteriezed by excitation numbers *𝑞* *𝑖* for modes *𝑚* *𝑖* so that corresponding
Raman shift is equal to *𝜈* = [∑︀] *𝑞* *𝑖* *𝜈* *𝑖*, where *𝜈* *𝑖* is vibrational frequency of the mode *𝑚* *𝑖* .

After the `orca_asa` run the following files will be created in addition:

   - `example005.us.rrs.39500.dat`, `example005.us.rrs.39800.dat` and `example005.us.rrs.`
`41400.dat` contain the simulated rR spectra involving only vibrational transitions specified in the
`$rr_vib_states` block, for excitations energies at 39500, 39800 and 41400 cm *[−]* [1], respectively. The suffix
“us” stands for “User specified vibrational States”.

   - `example005.us.rrs.39500.stk`, `example005.us.rrs.39800.stk` and `example005.us.rrs.`
`41400.stk` provide Raman shifts and intensities for each vibrational transition specified in the
`$rr_vib_states` block.

**904** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**Example: Modelling of Absorption Spectrum and Resonance Raman Profiles for the 1-** [1] **A** *𝑔* *→*
**1-** [1] **B** *𝑢* **Transition in** ***trans*** **-1,3,5-Hexatriene**

The following example illustrates an input for simulation of absorption bandshape and resonance Raman profiles
(RRP):



(continues on next page)

**7.41. Simulation and Fit of Vibronic Structure in Electronic Spectra, Resonance Raman** **905**
**Excitation Profiles and Spectra with the orca_asa Program**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

The keyword `RamanOrder=2` will invoke generation of rR profiles for all vibrational transitions with total excitation
number up to 2 in the range of excitation energies specified by the keywords `RRPRange` and `NRRPPoints` . Likewise,
rR profiles for the vibrational states given in the `$rr_vib_states` block will be generated separately. Since in most
cases only relative rR intensities are important, and one would be interested to compare absorption bandshape and
shapes of individual rR profiles, the keyword `CAR = 0.8` is used to scale rR profiles for all vibrational transitions
by a common factor in such a way that the ratio of the maximum of all rR intensities and the maximum of absorption
band is equal to 0.8.

After the `orca_asa` run the following files will be created:

   - `example006.abs.dat` contains the simulated absorption spectrum (Fig. 7.50).

   - `example006.o1.rrp.dat` and `example006.o2.rrp.dat` contain rR profiles for vibrational transitions
with total excitation numbers 1 and 2, respectively. RR profiles for all fundamental bands (from the file
`example006.o1.rrp.dat` ) are shown in Fig. 7.50.

   - `example006.o1.info` and `example006.o1.info` contain specification of vibrational transitions with total excitation numbers 1 and 2, respectively, as well as corresponding Raman shifts.

   - `example006.us.rrp.1.dat–example006.us.rrp.5.da` t contain rR profiles for vibrational transitions
1–5 specified in the `$rr_vib_states` block.

**906** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.50: Absorption spectrum and resonance Raman profiles of fundamental bands corresponding to 1 *−* [1] *𝐴* *𝑔* *→*
1 *−* [1] *𝐵* *𝑢* transition in *trans* -1,3,5-hexatriene.

**7.41.3 Fitting of Experimental Spectra**

**Example: Gauss-Fit of Absorption Spectrum**

An absorption spectrum basically consists of a number of absorption bands. Each absorption band corresponds to
a transition of the ground electronic state to an excited electronic state. In molecules such transitions are usually
considerably broadened. In many cases there will be overlapping bands and one would need to deconvolute the
broad absorption envelope into contributions from individual transitions. Within the “Simple model” the `orca_asa`
program enables fit of an absorption spectrum with a sum of standard lineshape functions (Gaussian, Lorentzian)
or more general Voigt functions. In most cases, one simply performs a “Gauss-Fit”. That is, it is assumed that the
shape of each individual band is that of a Gaussian function. Then one applies as many (or as few) Gaussians as
are necessary for an accurate representation of the absorption envelope. In order to explain the fitting procedures
within the “Simple model” let us consider an experimental absorption spectrum in Fig. 7.51:

**7.41. Simulation and Fit of Vibronic Structure in Electronic Spectra, Resonance Raman** **907**
**Excitation Profiles and Spectra with the orca_asa Program**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.51: Experimental absorption spectrum. Bars indicate transition energies which were used for the initial
guess in the input for spectral fitting.

As shown in Fig. 7.51 one can identify roughly 7 electronic bands. The initial estimates of transition energies
corresponding to the maxima and shoulders in the absorption spectrum (indicated by bars in Fig. 7.51) and rather
approximate values of inhomogeneous broadening and transition dipole moment components are specified in the
`$el_states` block of the input file for the spectral fitting:



(continues on next page)

**908** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



The functionality of the constraint block `$el_states_c` should be understood as follows: 1) 0 flag indicates that
the corresponding parameter in the `$el_state` block will not be varied in the fitting; 2) if the number corresponding to a certain parameter coincides with the number of the corresponding electronic state this parameter will be
varied independently. Thus, the block `$el_states_c` in the input indicates that all transition energies, inhomo
**7.41. Simulation and Fit of Vibronic Structure in Electronic Spectra, Resonance Raman** **909**
**Excitation Profiles and Spectra with the orca_asa Program**

**ORCA Manual** **,** **Release 6.0.1**

geneous linewidths and x-components of the transition electric dipole moment will be varied independently, while
homogeneous linewidths, y- and z-components of the transition dipole moment will be fixed to their initial values.

The following considerations are important:

  - Since in conventional absorption spectroscopy one deals with the orientationally averaged absorption crosssection, the signal intensity is proportional to the square of the transition electric dipole moment *|* **M** *|* [2] . Thus,
the intensities do not depend on the values of the individual components of **M** as long as *|* **M** *|* [2] = const.
Therefore, we have allowed to vary only *𝑀* *𝑥* components. Otherwise there can be problems in convergence
of the fitting algorithm.

  - The sum of the weights of experimental points which enter the mean absolute difference function employed
in the minimization is always kept equal to the number of experimental points. In the case of equidistant
experimental photon energies all weights are assumed to be equal. However, in experimental electronic
spectra the density of spectral points can increase significantly upon going from high- to low-energy spectral
regions, which is due to the fact that experimental absorption spectra are initially acquired on the wavelength
scale. In such a case the quality of the fit can be noticeably biased towards low-energy spectral region.
Therefore, it is advisable to adjust relative weights of experimental points according to the their density
which is controlled by the keyword `WeightsAdjust` in the `%fit` block. Although this parameter is not
crucial for the present example, in general, it will provide a more balanced fit.

  - The parameters `E0Step`, `TMStep`, `E0SDStep` in the `%fit` block specify the initial dimension of the simplex
in the space of *𝐸* *𝑇* *,* **M** *, 𝜎* and should roughly correspond to the expected uncertainty of initial guess on these
parameters in the `$el_states` block relative to their actual values. The quality of the fit can noticeably
deteriorate if the parameters specifying initial steps are too low or too high.

The fit run of `orca_asa` on file `example007.inp` will converge upon approximately 3600 function evaluations
(for `MWADRelTol=1e-5` ). The results of the fit will be stored in file `example007.001.inp` which has the same
structure as the input file `example007.inp` . Thus, if the fit is not satisfactory and/or it is not fully converged it
can be refined in a subsequent `orca_asa` run upon which file `example007.002.inp` will be created, and so on.
Some model parameters in intermediate files can be be additionally modified and/or some constraints can be lifted
or imposed if so desired. The output file `example007.001.inp` will contain fitted model parameters stored in the
`$el_states` block:



The overall quality of the fit is determined by the parameter MWAD which upon convergence reaches the value of
*≈* 0.009 (MWAD stands for Mean Weighted Absolute Difference).

After the `orca_asa` run files `absexp.fit.dat` and `absexp.fit.as.dat` will be created. Both files contain the
experimental and fitted spectra which are shown in Fig. 7.52 . In addition, the file `absexp.fit.as.dat` will
contain individual contributions to the absorption spectrum corresponding to different excited states.

**910** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.52: Comparison of the experimental (black curve) and fitted (red) absorption spectra corresponding to the fit
run of `orca_asa` on the file `example007.inp` . Blue curves represent individual contributions to the absorption
spectrum from each state.

Since there is a noticeable discrepancy between the fitted and experimental spectra around 13000 cm *[−]* [1] (Fig. 7.52)
it is worthwhile to refine the fit after adding parameters for a new state in the file `example007.001.inp` :

Actually, the character of the discrepancy in the present case is very similar to that in Fig. 7.49 (section *Example:*
*Modelling of Effective Broadening, Effective Stokes Shift and Temperature Effects in Absorption and Fluorescence*
*Spectra within the IMDHO Model* ) where a vibronically broadened absorption spectrum was fitted with a Gaussian
lineshape. Thus, the poor fit in the region around 1300 cm *[−]* [1] is most likely due to the essentially asymmetric
character of the vibronic broadening rather than to the presence of another electronic band.

As shown in Fig. 7.53 the refined fit leads to much better agreement between the experimental and fitted absorption

=
spectra (MWAD 0.0045).

**7.41. Simulation and Fit of Vibronic Structure in Electronic Spectra, Resonance Raman** **911**
**Excitation Profiles and Spectra with the orca_asa Program**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.53: Comparison of the experimental (black) and fitted (red) absorption spectra corresponding to the fit run
of `orca_asa` on the file `example007.001.inp` . Blue curves represent individual contributions to the absorption
spectrum from each state.

Due to some peculiarities of the simplex algorithm for function minimization, you can still refine the fit by rerunning
`orca_asa` on the file `example007.002.inp` ! This leads to an even lower value of the parameter MWAD= 0.0038,
and therefore to better agreement of experimental and fitted spectra (even though the previous run has been claimed
to be converged).

It is also possible to perform a fit using the same value of inhomogeneous linewidth for all electronic states. For
this purpose one needs to choose as a guess the same linewidth parameters in the `$el_states` block:



In addition the constraint block should be modified as follows:



(continues on next page)

**912** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

The constraint parameters for the inhomogeneous broadening were chosen to be 1, which means that formally *𝜎* 1
corresponding to the first state is varied independently while the linewidths *{𝜎* *𝑖* *}* for other bands are varied in such
a way that the ratios *𝜎* *𝑖* */𝜎* 1 are kept fixed to their initial values, whereby the same linewidth parameter will be used
for all states.

Fig. 7.54: Comparison of the experimental (black) and fitted (red) absorption spectra corresponding to the fit run
of `orca_asa` on the file `example007.002.inp` in which equal broadening was assumed for all electronic bands.
Blue curves represent individual contributions to the absorption spectrum from each state.

One can see (Fig. 7.54) that the assumption of equal linewidths for all electronic bands leads to a rather pronounced

=
deterioration of the quality of the fit in the low-energy spectral range (MWAD 0.017). Apparently, this discrepancy
can be fixed assuming more electronic states at higher energies.

NOTE

  - The homogeneous linewidth parameters can also be included in the fit in a similar way. However, one can
see that in most cases they appear to be much smaller than corresponding Gaussian linewidth parameters.

  - Gauss-fit of absorption spectra is coventionally performed assuming the same linewidth parameters for all
bands. However, since a large portion of Gaussian broadening is mainly due to the unresolved vibronic
structure in the spectra which can significantly vary depending on the nature of transition, the assumption of
unequal Gaussian bandwidths seems to be a physical one.

**7.41. Simulation and Fit of Vibronic Structure in Electronic Spectra, Resonance Raman** **913**
**Excitation Profiles and Spectra with the orca_asa Program**

**ORCA Manual** **,** **Release 6.0.1**

**Example: Fit of Absorption and Resonance Raman Spectra for 1-** [1] **A** *𝑔* *→* **1-** [1] **B** *𝑢* **Transition in** ***trans*** **-**
**1,3,5-Hexatriene**

Below we provide an example of the fit of the lineshape parameters and *{* ∆ *𝑚* *}* corresponding to the strongly dipoleallowed 1- [1] A *𝑔* *→* 1- [1] B *𝑢* transition in hexatriene. It is known that the most intense bands in rR spectra correspond
to the most vibronically active in absorption spectrum. For the IMDHO model this correlation is determined by
the values of *{* ∆ *𝑚* *}* . Thus, the larger ∆, the larger is the rR intensity of a given mode and the more pronounced is
the progression in the absorption spectrum corresponding to this mode. In principle, if all vibrational transitions in
absorption are well resolved it is possible to determine *{* ∆ *𝑚* *}* by a fit of the absorption spectrum alone. In practice
this task is ambiguous due to the limited resolution of the experimental absorption spectra. The observation of
a rR spectrum enables the identification of the vibrational modes that are responsible for the progression in the
absorption spectrum, as well as a quantitative analysis in terms of *{* ∆ *𝑚* *}* . The file `example006.inp` provides a
brute-force example on how to approach the fit employing the minimal possible experimental information: 1) An
absorption spectrum; 2) relative rR intensities of fundamental bands for a given excitation energy. The rR spectrum
upon the excitation in resonance with the 0-0 vibronic band at 39809 cm *[−]* [1] is shown in Fig. 7.43.

Fig. 7.55: Experimental Resonance Raman spectrum corresponding to 1- [1] A *𝑔* *→* 1- [1] B *𝑢* transition in *trans* -1,3,5hexatriene.

The experimental rR spectrum has enabled the identification of seven vibrational modes that give rise to the most
intense resonance Raman bands. Therefore, they are expected to have the largest excited-state displacements and
the most pronounced effect on the vibrational structure of the absorption spectrum. Their vibrational frequencies
have been entered as input for the fit as shown below:



(continues on next page)

**914** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
#
# Parameters to be varied:
# 1) adiabatic minima transiton energy
# 2) homogeneous linewidth (Gamma)
# 3) dimensionless normal coordinate displacements of the
# excited-state origin
#
%sim
   Model IMDHO
end
%fit
  Fit true # boolean parameter to switch on the fit
  # boolean parameter to include experimental absorption
  # spectrum in the fit:
  AbsFit true
  # boolean parameter to include experimental rR spectra
  # specified in $rrs_exp block in the fit:
  RRSFit true
  AbsExpName "hex-abs.dat" # name of the file with experimental absorption
               # spectrum
  # the following value of keyword ExpAbsScaleMode
  # indicates that only the shape of absorption band
  # but not its total intensity will be accounted in the fit:
  ExpAbsScaleMode Rel
  # the weight of absorption relative to the total weight of
  # rR intensities in the difference function to be minimized:
  CWAR 5.0
  NMaxFunc 1000 # maximum number of function evaluations in simplex
           # algorithm
  MWADRelTol 1e-4 # Relative Tolerance of the Mean Weighted Absolute
           # Difference (MWAD) function which specifies the
           # convergence criterion
  SDNCStep 1.0
end
# The values specified in $el_states block serve as initial guess in the fit
$el_states
1
  1 40000.0 200.00 0.0 1.0 0.0 0.0
# the integer values specified in $el_states_c block indicate parameters
# in $el_states block to be varied
$el_states_c
1
  1 1 1 0 0 0 0
# 7 totally symmetric vibrations which give rise to the most
# intense bands in the rR spectra are included into analysis.

```
(continues on next page)

**7.41. Simulation and Fit of Vibronic Structure in Electronic Spectra, Resonance Raman** **915**
**Excitation Profiles and Spectra with the orca_asa Program**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
# Experimental values of vibration frequencies are given:
$vib_freq_gs
7
  1 354.0
  2 444.0
  3 934.0
  4 1192.0
  5 1290.0
  6 1403.0
  7 1635.0
# Initial guess for the values of dimensionless normal
# coordinate displacements of the excited-state origin
$sdnc
7 1
        1
   1 0.0
   2 0.0
   3 0.0
   4 0.0
   5 0.0
   6 0.0
   7 0.0
# the integer values specified in $sdnc_c block indicate parameters
# in $sdnc block to be varied
$sdnc_c
7 1
       1
   1 1
   2 2
   3 3
   4 4
   5 5
   6 6
   7 7
# specification of vibrational transitions and their intensities
# in experimental rR spectra:
$rrs_exp
1 # number of rR spectra
1 1 # start of the block specifying the 1st rR spectrum
  Ex 39809.0 # excitation energy for the first rR spectrum
  NTr 7 # number of vibrational transitions for which intensities are
        # provided
  1
    int 10.0 1.0
    modes 1
    quanta 1;
  2
    int 5.0 1.0
    modes 2
    quanta 1;
  3
    int 1.5 1.0
    modes 3
    quanta 1;
  4
    int 21.0 1.0
    modes 4

```
(continues on next page)

**916** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

The input of rR intensities for an arbitrary number of excitation energies follows the keyword `$rrs_exp` block:



The first “1” in the last line denotes the number of the rR spectrum for which specification starts below. If the
second number is the same as the number of the spectrum, then it means that only relative intensities for the first
rR spectrum are meaningful in the fit. If several spectra are given in the input then the second number may have a
different value, e.g.:



This input is to be interpreted as indicating that 3 rR spectra are provided and the relative intensities for the first
spectrum are given on the same scale as the second one that will be accounted for in the fit. The value of the excitation energies and the number of vibrational transitions specified are indispensable within the blocks specifying
intensities for each rR spectrum.

Following the number of vibrational transitions given by the keyword `NTr` one has to specify each vibrational
transition and its intensity. Thus, in the present case there are seven subblocks with the following structure:



This means that the *𝑘* -th transition has intensity *𝐼* and weight *𝑊* in the mean absolute difference function that is
used for the minimization ( *𝑊* is an optional parameter). The following 2 lines specify the vibrational transitions
by providing excitation numbers *𝑞* *𝑖* for modes *𝑚* *𝑖* so that the corresponding Raman shift is equal to *𝜈* = [∑︀], where

*𝑞* *𝑖* *𝜈* *𝑖*

*𝜈* *𝑖* is vibrational frequency of the mode *𝑚* *𝑖* .

The parameters that are to be varied are specified within the constraint blocks `$el_states_c` and `$sdnc_c` . Both
blocks have the same structure and number of parameters as `$el_states` and `$sdnc`, respectively. A parameter
from the `$el_states` block is supposed to be independently varied if its counterpart from the `$el_states_c`
block is equal to the number of the electronic state. Likewise, a parameter from the `$sdnc` block is supposed to
be independently varied if its counterpart from the `$sdnc_c` block is equal to the number of the normal mode.
Model parameters that are set to 0 in the corresponding constraint blocks are not varied in the fit. The values of
the following parameters may be important for the quality of the fit:

   - `CWAR` in the `%fit` block specifies the weight of absorption relative to the weight of rR intensities in the
difference function to be minimized. If this parameter was not specified the fit would be almost insensitive
to the rR intensities in the input, since typically the number of experimental absorption points is much larger
than the number of rR transitions in the input. In most cases the value of `CWAR` in the range 1.0–5.0 is a good
choice since the error in the measured experimental intensity is expected to be much smaller for absorption

**7.41. Simulation and Fit of Vibronic Structure in Electronic Spectra, Resonance Raman** **917**
**Excitation Profiles and Spectra with the orca_asa Program**

**ORCA Manual** **,** **Release 6.0.1**

than for resonance Raman.

   - `SDNCStep` in the `%fit` block specifies the initial dimension of the simplex in the space of *{* ∆ *𝑚* *}* and should
roughly correspond to the expected uncertainty of initial guess on *{* ∆ *𝑚* *}* in the `$sdnc` block compared to
their actual values. You can notice in the present example that if this parameter is too large (>2.0) or too
small (<0.4) the quality of the fit may significantly deteriorate

  - Although the default initial dimensions of the simplex have reasonable values for different types of parameters it may turn out to be helpful in some cases to modify the default values:



The fit run of `orca_asa` on the file `example008.inp` will converge upon approximately 700 function evaluations
(for `MWADRelTol=1e-4` ). The results of the fit will be stored in file `example008.001.inp` which has the same
structure as the input file `example008.inp` . Thus, if the fit is not satisfactory and/or it is not fully converged it
can be refined in subsequent `orca_asa` run upon which file `example008.002.inp` will be created, and so on.
Some model parameters in intermediate files can be be additionally modified and/or some constraints can be lifted
if so desired. The output file `example008.001.inp` will contain fitted displacement parameters *{* ∆ *𝑚* *}* stored in
the `$sdnc` block:



In the present example, these parameters are actually in very close agreement with those published for the hexatriene
molecule!

The overall quality of the fit is determined by the parameter MWAD which upon convergence reaches the value of
*≈* 0.027. The fitted rR intensities are presented in the commented lines next to the experimental rR intensities in
file `example008.001.inp` :



(continues on next page)

**918** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

The file hex-abs.fit.dat will contain the experimental and fitted absorption spectra in ASCII format which can be
plotted in order to visualize the quality of absorption fit (Fig. 7.56).

Fig. 7.56: Experimental (black) and fitted (red) absorption spectrum corresponding to 1- [1] A *𝑔* *→* 1- [1] B *𝑢* transition
in 1,3,5 *trans* -hexatriene.

NOTE

  - The more experimental rR intensities are included in the analysis the more reliable is the fit. In principle it is
possible to obtain fully consistent results even if only a limited number of vibrational transitions is provided.
However, in such a case it is desirable to include into analysis at least a single Raman transition involving
the mode for which ∆ is to be determined.

**7.41. Simulation and Fit of Vibronic Structure in Electronic Spectra, Resonance Raman** **919**
**Excitation Profiles and Spectra with the orca_asa Program**

**ORCA Manual** **,** **Release 6.0.1**

  - The quality of the fit can be improved if the IMDHOFA model is invoked and excited-state vibrational frequencies are allowed to vary.

  - Due to the initial guess and dimension of the simplex, as well as some peculiarities of the simplex algorithm
for function minimization, you can still refine the fit by rerunning `orca_asa` on file `example008.001.inp`
that may lead to an even lower value of the parameter `MWAD = 0.021`, and therefore to better agreement of
experimental and fitted spectra (even though the previous run has been claimed to be converged).

  - In this respect it appears to be wise to perform the fit in 3 steps:

1. Fit the preresonance region below the 0-0 vibronic band with a single Lorentzian band, from which
the adiabatic transition energy *𝐸* 0, and homogeneous linewidth Γ are obtained. The range for fit of the
absorption spectrum can be specified by the `AbsRange` keyword in the `%fit` block.

2. Fix *𝐸* 0 and Γ, and optimize *{* ∆ *𝑚* *}* fitting the entire spectral range and rR intensities.

3. Lift constraints on *𝐸* 0 and Γ, and reoptimize simultaneously all parameters.

**Example: Single-Mode Fit of Absorption and Fluorescence Spectra for 1-** [1] **A** *𝑔* *→* **1-** [1] **B** 2 *𝑢* **Transition**
**in Tetracene**

In this section we provide an example and discuss the most important aspects of joint fit of fluorescence and
absorption spectra. Fig. 7.57 displays the experimental emission and absorption spectra corresponding to 1- [1] A *𝑔*
*→* 1- [1] B 2 *𝑢* transition in tetracene.

Fig. 7.57: Deconvoluted absorption (red) and fluorescence (blue) spectra of tetracene in cyclohexane upon the
assumption of a single vibronically active mode. The black solid lines represent experimental spectra.

Both spectra show pronounced effective vibrational progressions that are dominated by 3 and 5 peaks, respectively.
As can be shown on the basis of quantum chemical calculations this progression has essentially multimode character. However, the experimental spectra can be well fitted under the assumption of a single vibronically active
mode. The input has the following structure:

**920** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**



(continues on next page)

**7.41. Simulation and Fit of Vibronic Structure in Electronic Spectra, Resonance Raman** **921**
**Excitation Profiles and Spectra with the orca_asa Program**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



The parameter `CWAF=1.0` in the `%fit` block specifies the weight of absorption relative to the weight of fluorescence
in the difference function to be minimized. If this parameter was not specified the quality of the fit would be biased
towards the spectrum with a larger number of experimental points. In some typical situations where the error in the
measured experimental intensity is expected to be smaller for absorption than for emission it is desirable to choose
the value of `CWAF` to be more than 1.0.

In order to account for a broad featureless background signal in the absorption spectrum above 24000 cm *[−]* [1], the
second band was included into the analysis and approximated with a Voigt lineshape which means also that the
corresponding frequency in the `$vib_freq_gs` block and displacement parameter in the `$sdnc` block are fixed to
zero in the fit. Thus, the `$el_states` block contains an initial guess on the transition energies, transition electric

**922** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


dipole moments and linewidth parameters for 2 states:



The initial value of the adiabatic minima separation energy for the first state was approximated by the energy
corresponding to the first vibronic peak in the absorption spectrum (21100 cm *[−]* [1] ). The transition energies and
linewidth parameters are varied independently as indicated in the `$el_states_c` block. Since we allow to fit only
bandshapes, but not the overall intensities of the spectra, only relative absolute values of the transition electric
dipole moments of two bands are important. Therefore it is reasonable to fix all components of the transition
moment for the first state and vary only *𝑀* *𝑥* component for the second one:



Since we assume the absorption by both states and emission only from the first one, it is necessary to include
Boolean arrays $abs_bool and $fl_bool which specify states which will be included in the treatment of the absorption and fluorescence spectra, respectively:

We need also to vary the value of vibrational frequency of the mode which determines separation of vibrational
peaks in the spectra. This is done via the constraint block `$vib_freq_gs_c` :



Note that it is meaningless to include into the treatment the Stokes shift for the second state which give rise to the
background signal in the absorption since the corresponding emission is not present. Therefore *𝜆* for the second
state is fixed to zero as indicated in the `$ss` block and its constraint counterpart `$ss_c` :



The fit run of `orca_asa` on file `example009.inp` will converge upon approximately 700 function evaluations
(for `MWADRelTol=1e-4` ). The file `example009.001.inp` will contain the fitted effective values of the vibrational
frequency and dimensionless displacement: *𝜔* = 1404 cm *[−]* [1], ∆= 1 *.* 35. One can notice that the fit is rather
poor in the low- and high-energy edges of the absorption and fluorescence spectra, respectively (Fig. 7.57). The
source of this discrepancy is the single-mode approximation which was employed here. The quality of the fit can
be significantly improved assuming several modes with non-zero displacement parameters. Note that in such a case

**7.41. Simulation and Fit of Vibronic Structure in Electronic Spectra, Resonance Raman** **923**
**Excitation Profiles and Spectra with the orca_asa Program**

**ORCA Manual** **,** **Release 6.0.1**

the proper guess on the number of active modes and corresponding dimensionless displacements can be deduced
from quantum chemical calculations.

**7.41.4 Quantum-Chemically Assisted Simulations and Fits of Optical Band-**
**shapes and Resonance Raman Intensities**

In this section we finally connect the spectra simulation algorithms to actual quantum chemical calculations and
outline a detailed approach for the analysis of absorption, fluorescence and resonance Raman spectra within the
IMDHO model. Our procedure becomes highly efficient and nearly automatic if analytical excited state derivatives
with respect to nuclear displacements are available. However, this availability is not mandatory and hence, spectral
predictions may as well be achieved by means of normal mode scan calculations for high-level electronic structure
methods for which analytic gradients have not been implemented.

**Example: Quantum-Chemically Assisted Analysis and Fit of the Absorption and Resonance Ra-**
**man Spectra for 1-** [1] **A** *𝑔* *→* **1-** [1] **B** *𝑢* **Transition in** ***trans*** **-1,3,5-Hexatriene**

The following input file for an ORCA run invokes the calculation of the excited-state origin displacements along all
normal modes by means of energy and excited state gradient calculations at the ground-state equilibrium geometry.
The method is valid for the IMDHO model for which the excited-state energy gradient along a given normal mode
and corresponding origin shift are related in a very simple way.



(continues on next page)

**924** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

In the ORCA run the TDDFT excited state gradient calculations are performed on top of a TDDFT calculation.
Note, that the numbers of the excited-states which have to be included into analysis and input file for spectral
simulations must be specified after the `States` keyword in the `%rr` block. They should also be consistent with the
required number of roots in the `%tddft` block. The 1- [1] B *𝑢* excited state appears to be the first root in the TDDFT
calculation. Therefore, `NRoots=1` in the `%tddft` block, and `States=1` in the `%rr` block. One should also provide
the name of the file containing the nuclear Hessian matrix via the `HessName` keyword in the `%rr` block. Here we
used the `.hess` file obtained in a frequency calculation at the BHLYP/SV(P) level of theory.

After the ORCA calculation you will find in your directory a file called `example010.asa.inp` that is appropriate
to be used together with the `orca_asa program` as defined in the preceding sections.



(continues on next page)

**7.41. Simulation and Fit of Vibronic Structure in Electronic Spectra, Resonance Raman** **925**
**Excitation Profiles and Spectra with the orca_asa Program**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
     FlRange 0.0, 10000000.0
     RRPRange 0.0, 10000000.0
     RRSRange 0.0, 10000000.0
     AbsName ""
     FlName ""
     ExpFlScaleMode Rel
     ExpAbsScaleMode Rel
     CWAR -1.000
     CWAF -1.000
     NMaxFunc 100
     MWADRelTol= 1.000000e-004
     SFRRPSimStep= 1.000000e+002
     SFRRSSimStep 1.000000e+002
     FREQGStep 1.000000e+001
     FREQEStep 1.000000e+001
     E0Step 3.000000e+002
     SSStep 2.000000e+001
     TMStep 5.000000e-001
     GammaStep 5.000000e+001
     E0SDStep 5.000000e+001
     SDNCStep 4.000000e-001
end
$el_states
1
  1 42671.71 100.00 0.00 1.0725 3.3770 -0.0000
$vib_freq_gs
12
  1 359.709864
  2 456.925612
  3 974.521651
  4 1259.779018
  5 1356.134238
  6 1370.721341
  7 1476.878592
  8 1724.259894
  9 1804.572974
  10 3236.588264
  11 3244.034359
  12 3323.831066
$sdnc
12 1
          1
   1 -0.594359
   2 0.369227
   3 -0.132430
   4 -0.727616
   5 0.406841
   6 -0.105324
   7 0.177617
   8 -0.090105
   9 -1.412258
   10 0.048788
   11 0.021438

```
(continues on next page)

**926** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
   12 0.008887

```
This input file can be used to construct theoretical absorption and rR spectra. **In order to compare experimental**
**and theoretical rR spectra, it is necessary to use in both cases excitation energies that are approximately**
**in resonance with the same vibrational transitions in the absorption spectrum. Therefore, in the case of**
**the absorption spectrum with resolved or partially resolved vibrational structure it is necessary to modify**
**the transition energies in the** `%el_states` **such that they coincide with the experimentally observed 0-0**
**vibrational peaks.** It is also desirable to roughly adjust homogeneous and, possibly, inhomogeneous linewidth
parameters such that the experimental and calculated absorption spectra show similar slopes in the preresonance
region (below the 0-0 transition). Then the assignment of experimental rR spectra can be done on the basis of
comparison with the theoretical rR spectra calculated for the corresponding experimental excitation energies. For
the sake of consistency and simplicity it is better to use those excitation energies which fall into the preresonace
region and/or are in resonance with the 0-0 transition. **In the case of diffuse absorption spectra (i.e. those**
**not showing resolved vibrational structure) it is also necessary to adjust the theoretical transition energies**
**and linewidth parameters such that experimental and calculated positions of absorption maxima roughly**
**coincide, and corresponding slopes below the maxima have a similar behavior.** According to above mentioned
considerations one needs to modify the `%el_states` block in the file `example010.asa.inp` :



The calculated absorption spectrum obtained by providing `AbsScaleMode= Rel`, `AbsRange= 39000`, `49000` and
`NAbsPoints= 2000` is shown in Fig. 7.58. Upon comparison with the experimental spectrum one can notice that
the BHLYP functional gives relatively small discrepancies with somewhat lower intensity in the low-frequency
edge and larger intensity on the high-energy side of the spectrum. Besides, there is a noticeable mismatch in
the separation between individual vibronic peaks which is due to overestimation of vibrational frequencies by the
BHLYP functional (typically by *≈* 10%).

You can arbitrarily vary various normal coordinate displacements in `%sdnc` block within 10–30% of their values
in order to observe modifications of the calculated spectrum. This will tell you how these parameters influence the
spectrum and probably it will be possible to obtain better initial guesses for the fit. In the present example you will
find that reduction of the absolute value of the displacement parameter corresponding to the ninth mode by *≈* 10%,
and reduction of vibrational frequencies by *≈* 10% can noticeably improve the spectral envelope. Such a quick
analysis suggests that experimentally observed peaks in the absorption spectrum represent different vibrational
transitions corresponding to a single electronically excited state rather than to different electronic excitations. This
conclusion will be confirmed upon establishing the fact that the absorption and rR spectra can be successfully fitted
based on the assumption of a single electronic transition.

**7.41. Simulation and Fit of Vibronic Structure in Electronic Spectra, Resonance Raman** **927**
**Excitation Profiles and Spectra with the orca_asa Program**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.58: Experimental and calculated at the BHLYP/SV(P) and B3LYP/SV(P) levels of theory absorption (left
panel) and rR spectra (right panel) corresponding to 1- [1] A *𝑔* *→* 1- [1] B *𝑢* transition in *trans* -1,3,5-hexatriene.

In order to calculate the rR spectrum for experimental excitation energies you need to specify its value through `RRSE`
keyword in `%sim` block as well as possibly to modify the parameters related to the spectral range and linewidth of
rR bands which are suitable for comparison with the experimental rR spectrum:



The calculated rR spectrum is shown in Fig. 7.58. In the input we have invoked the calculation of rR intensities for
the transitions with up to 3 vibrational quanta in the final vibrational state ( `RamanOrder = 3` ). Make sure that the
rR intensity pattern in the given spectral range does not change noticeably upon further increase of this parameter.
Typically, the larger are the normal coordinate displacements the greater order of Raman scattering is required
in the calculation to account for all the most intense transitions in the rR spectrum. The inclusion of vibrational
transitions beyond the fundamentals is a particular feature of the `orca_asa` program.

Comparison of the calculated and experimental rR spectra (Fig. 7.58) mainly shows discrepancies in the values of
the Raman shifts that are mainly related to the low accuracy of the vibrational frequencies obtained at the BHLYP
level (typically overestimated by *≈* 10%). However, the intensity patterns of the calculated and experimental rR
spectra show very nice agreement with experiment that is already sufficient to assign the experimental peaks to

**928** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

individual vibrational transitions. This can be done upon examination of file `example010.asa.o3.rrs.39808.`
`stk` which provides intensity, Raman shift, and specification for each vibrational transition. It is actually one of the
most consistent procedures that enables one to identify different fundamental, overtone and combination bands in
the experimentally observed rR spectrum. Such an assignment is a necessary prerequisite for the fit. The current
example is relatively straightforward since the spectral region 1–1700 cm *[−]* [1] is actually dominated by fundamental bands while the most intense overtone and combination transitions occur at higher frequencies. However, in
many cases even the low-frequency spectral range is characterized by significant contributions from overtone and
combination bands that sometimes are even more intense than fundamental transitions! Thus, quantum chemical
calculations can greatly facilitate the assignment of experimental rR bands.

After having performed the assignment it is advisable to discard those modes from the analysis that are not involved
in any of the experimentally observed fundamental, overtone, or combination rR bands with noticeable intensities.
In the present example these are the modes 6, 8, 10–12 from the input file given above. For these modes it is
implied that the fitted displacement parameters are zero. You will find that the calculated displacement values are
rather small indeed. Also it is advisable to change the ground-state vibrational frequencies in the `$vib_freq_gs`
block to their experimental values.

Below is the modified input file for the fit run:



(continues on next page)

**7.41. Simulation and Fit of Vibronic Structure in Electronic Spectra, Resonance Raman** **929**
**Excitation Profiles and Spectra with the orca_asa Program**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
  7 1635.0
$sdnc
7 1
          1
   1 -0.594359
   2 0.369227
   3 -0.132430
   4 -0.727616
   5 0.406841
   6 0.177617
   7 -1.412258
$sdnc_c
7 1
       1
   1 1
   2 2
   3 3
   4 4
   5 5
   6 6
   7 7
$rrs_exp
1
1 1
  Ex 39809.0
  NTr 11
  1
    int 10.0 1.0
    modes 1
    quanta 1;
  2
    int 5.0 1.0
    modes 2
    quanta 1;
  3
    int 1.5 1.0
    modes 3
    quanta 1;
  4
    int 21.0 1.0
    modes 4
    quanta 1;
  5
    int 7.5 1.0
    modes 5
    quanta 1;
  6
    int 2.0 1.0
    modes 6
    quanta 1;
  7
    int 46.0 1.0
    modes 7
    quanta 1;
  8

```
(continues on next page)

**930** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)


In addition to the experimental intensities of fundamental bands the input file also contains the information about
some overtone and combination transitions. Note that it is not really necessary to include all of them them into the
fit, in particular if some of the rR bands are strongly overlapping with each other.

Fitted normal coordinate displacements of the excited-state origin show nice agreement with the published values:



NOTE

  - It is not really important to employ the BHLYP/SV(P) method in the frequency calculations in order to
obtain the `.hess` file (this was merely done to be consistent with the TDDFT/BHLYP/SV(P) method for the
excited-state model parameters calculation). The frequency calculations can for example be carried out at
the BP86/TZVP or RI-SCS-MP2/TZVP level of theory. This will provide displacements pattern very similar
to that of the BHLYP/SV(P) method, but much more accurate vibrational frequencies which will further
facilitate the assignment of rR spectra (Fig. 7.58). However, such a procedure can be inconsistent if the
two methods give noticeably different normal mode compositions and/or vibrational frequencies. From our
experience it can lead to significant overestimation of the excited-state displacements for some low-frequency
modes.

  - It is known that predicted dimensionless normal coordinate displacements critically depend on the fraction
of the “exact” Hartree-Fock exchange (EEX) included in hybrid functionals. In general no universal amount
of EEX exists that provides a uniformly good description for all systems and states. Typically, for a given
molecule either the BHLYP/TZVP (50% of EEX) or B3LYP/TZVP (20% of EEX) methods yields simulated
spectra that compare very well with those from experiment if vibrational frequencies are appropriately scaled.

**7.41. Simulation and Fit of Vibronic Structure in Electronic Spectra, Resonance Raman** **931**
**Excitation Profiles and Spectra with the orca_asa Program**

**ORCA Manual** **,** **Release 6.0.1**

**Important Notes about Proper Comparison of Experimental and Quantum Chemically Calculated**
**Resonance Raman Spectra**

In order to compare experimental and theoretical rR spectra, **it is necessary to use in both cases excitation ener-**
**gies that are approximately in resonance with the same vibrational transitions in the absorption spectrum** .
Therefore, in the case of diffuse absorption spectra (i.e. those not showing resolved vibrational structure) one needs
to adjust the transition energies and linewidth paramters in the `%el_states` block such that the envelopes of the
experimental and theoretical spectra rouhgly coincide, and then to employ experimental values of excitation energies to construct theoretical rR spectra. Typically in the case of diffuse absorption spectra rR profiles are rather
smooth. Therefore, even though excitation energies are not in resonance with the same vibrational transition in the
absorption spectrum, the rR spectra are not expected to vary significantly in the case of such mismatch.

In the case of the absorption spectrum with resolved or partially resolved vibrational structure it is necessary to
modify the transition energies in the `%el_states` block such that the calculated and experimentally observed 0-0
vibrational peaks coincide, and modify linewidth parameters so that the low-energy slopes in the calculated and
experimental spectra have a similar behavior.

Consider a single-mode model system for which “experimental” and calculated absorption spectra are shown in
Fig. 7.59.

**932** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.59: Experimental and theoretical absorption spectra for a single-mode model system. The calculated spectrum is adjusted such that the position of 0-0 peak coincide with the experimental one.

**7.41. Simulation and Fit of Vibronic Structure in Electronic Spectra, Resonance Raman** **933**
**Excitation Profiles and Spectra with the orca_asa Program**

**ORCA Manual** **,** **Release 6.0.1**

Comparison of the calculated and experimental spectra shows that some adjustment of the linewidth parameters
is neceassy before construction of theoretical rR spectra. One can directly compare calculated and experimental
rR spectra upon the excitation at 16200 cm *[−]* [1] which is in resonance with the 0-0 vibronic band. However, it is
not consistent to use experimental values of the excitation energy in the calculation of rR spectrum which is in
resonance with one of the other vibronic bands since the separation between vibrational peaks in the experimental
and calculated spectra is different whereby positions of the peaks in both spectra do not coincide. Instead **one**
**should use the excitaition energy which corresponds to the same vibronic peak in the calculated absorption**
**spectrum as in the experimental one** . Alternatively, one can adjust theoretical value of vibrational frequency
such that positions of corresponding vibronic peaks in the spectra coincide, and then use experimental values of
excitation energies for the calculation of rR spectra.

**Example: Normal Mode Scan Calculations of Model Parameters for 1-** [1] **A** *𝑔* *→* **1-** [1] **B** *𝑢* **Transition in**
***trans*** **-1,3,5-Hexatriene**

If excited state gradients are not available (which is the case for many of the electronic structure methods supported
by ORCA), you have to resort to a more laborious procedure – single point calculations at geometries that are
displaced along the various normal modes of the system. This roughly corresponds to taking numerical derivatives
– however, once this extra effort is invested more information can be obtained from the calculation than what would
be possible from an analytic derivative calculation.

The present example illustrates the application of normal mode scan calculations for the evaluation of excited state
harmonic parameters that are necessary to simulate optical spectra within the IMDHO model. This method can be
applied with any method like CIS, CASSCF, MRCI or TD-DFT.

The reference wavefunctions for the multireference calculations reported below are of the state-averaged CASSCF
(SA-CASSCF) type. The complete active space CAS(6,6) includes all 6 valence shell *𝜋* -orbitals. The average is
taken over the first four states which was found necessary in order to include the ground state and the strongly
allowed 1- [1] B *𝑢* state.



(continues on next page)

**934** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
%scf
  rotate {23,27} end
end
%casscf
    nel 6
    norb 6
    mult 1
    nroots 4
end
* xyz 0 1
 C -0.002759 0.680006 0.000000
 H -0.966741 1.204366 0.000000
 C 1.187413 1.500920 0.000000
 H 2.146702 0.969304 0.000000
 C 1.187413 2.850514 0.000000
 H 0.254386 3.420500 0.000000
 H 2.116263 3.422544 0.000000
 C 0.002759 -0.680006 0.000000
 H 0.966741 -1.204366 0.000000
 C -1.187413 -1.500920 0.000000
 H -2.146702 -0.969304 0.000000
 C -1.187413 -2.850514 0.000000
 H -0.254386 -3.420500 0.000000
 H -2.116263 -3.422544 0.000000
*
# do normal mode scan calculations
# to map CASSCF ground and excited-state PESs
$new_job
! TZVP TightSCF NMScan
%casscf
    nel 6
    norb 6
    mult 1
    nroots 4
end
%rr
  HessName "hexatriene_bp86.hess"
  NMList 10,11,18,24,26,28,29,31,32
  NSteps 6
  FreqAlter true
  EnStep 0.0001
  State 3
end
* xyz 0 1
 C -0.002759 0.680006 0.000000
 H -0.966741 1.204366 0.000000
 C 1.187413 1.500920 0.000000
 H 2.146702 0.969304 0.000000
 C 1.187413 2.850514 0.000000
 H 0.254386 3.420500 0.000000
 H 2.116263 3.422544 0.000000
 C 0.002759 -0.680006 0.000000
 H 0.966741 -1.204366 0.000000
 C -1.187413 -1.500920 0.000000

```
(continues on next page)

**7.41. Simulation and Fit of Vibronic Structure in Electronic Spectra, Resonance Raman** **935**
**Excitation Profiles and Spectra with the orca_asa Program**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

The file containing the Hessian matrix ( `"hexatriene_bp86.hess"` ) was obtained from the BP86/TZVP frequency calculations. The keyword `NMList` provides the list of the normal modes to be scanned. These should
be only the totally symmetric vibrations, since only they can be significant for absorption and resonance Raman
spectra within the constraints of the IMDHO model. The `FreqAlter` flag indicates whether frequency alterations
are assumed in the post-scan potential surface fit. The Parameter `EnStep` is used to select the appropriate step
during the scan calculations. The value is chosen such that the average energy change (in Eh) in both directions is
not less than this parameter.
### **7.42 One Photon Spectroscopy**

**7.42.1 General Description**

Introduced in Orca 6.0, the One Photon Spectroscopy (OPS) tool now takes charge of computing one-photon
absorption (OPA), emission (OPE), and natural electric circular dichroism (ECD) intensities. In each of these
processes, the intensity of the spectrum ( *𝐼* ( *𝜔* )) resulting from a transition between an initial state *𝐼* and a final state
*𝐽* is determined by the square modulus of the transition moment *𝑇* *𝐼𝐽* = *⟨* Ψ *𝐼* *|𝐻* [ˆ] 1 *|* Ψ *𝐽* *⟩*, weighted by the populations
*𝑁* *𝐼* and *𝑁* *𝐽* of states *𝐼* and *𝐽*, respectively.

*𝐼* ( *𝜔* ) = *𝛼𝜔* *[−]* [1] [ ∑︁] ( *𝑁* *𝐼* *−* *𝑁* *𝐽* ) *|⟨* Ψ *𝐼* *|𝐻* [ˆ] 1 *|* Ψ *𝐽* *⟩|* [2] *𝛿* ( *𝐸* *𝐽𝐼* *±* ℏ *𝜔* ) (7.256)

*𝐼𝐽*

In this context, *𝛼* represents a positive constant, *𝜔* stands for photon energy, and the expression for *𝐻* [ˆ] 1 hinges on
the specific modeling of photon-matter interaction.

**7.42.2 Light-matter interaction approaches**

Expressions for *𝐻* [ˆ] 1 can be derived from different theoretical perspectives. For instructional purposes, a classical
electrodynamic approach is adopted here. By representing light classically through a vector potential ( **A** ) and a
scalar potential ( *𝜑* = 0), the radiation can be integrated into the Hamiltonian that models the molecular system.


*𝑁*
∑︁ **B** ( **r** *𝑖* *, 𝑡* ) *·* ˆ *𝑠* *𝑖* + *𝑉* ( **r** 1 *, ...,* **r** *𝑁* )

*𝑖* =1


**p** ˆ *𝑖* *−* *[𝑒]* 2 *−* *𝑔* *𝑒*

[︁ *𝑐* **[A]** [(] **[r]** *[𝑖]* *[, 𝑡]* [)] ]︁ 2 *𝑚* *𝑒* *𝑐*


ˆ
*𝐻* =


*𝑁*
∑︁

*𝑖* =1


1

2 *𝑚* *𝑒*


By disregarding the coupling between the magnetic field of light and the spin, as well as the *|* **A** *|* [2] term, and applying
Fermi’s golden rule, an expression for *⟨* Ψ *𝐼* *|𝐻* [ˆ] 1 *|* Ψ *𝐽* *⟩* under the Full-Semiclassical Light-Matter interaction can be
derived.


*𝑒*
*𝑇* *𝐼𝐽* *[𝐹𝐹𝑀𝐼𝑂]* =
*𝑚* *𝑒*


*𝑁*
∑︁ *⟨𝐼| ℰ·* [︁ *𝑒* *[𝑖]* **[k]** *[·]* **[r]** *[𝑖]* **p** ˆ *𝑖* ]︁ *|𝐽⟩* (7.257)

*𝑖* =1


Where *𝑇* *𝐼𝐽* *[𝐹𝐹𝑀𝐼𝑂]* is the transition moment for the **F** ull (semiclassical) **F** ield- **M** atter **I** nteraction **O** perator, while *𝑘*
and *ℰ* denote the wave and polarization vectors describing the light, respectively. **r** *𝑖* and **p** *𝑖* represent the position
and linear momentum operators for the i-th electron.

Proceeding from eq. (7.257) and approximating the exponential term of *𝑇* *𝐼𝐽* *[𝐹𝐹𝑀𝐼𝑂]* with a Taylor expansion yields
various orders of interaction. The zeroth order ( *𝑇* *𝐼𝐽* [[0]] [) results in the electric dipolar velocity formulation (] *[𝐸𝐷𝑣𝑒𝑙]* [),]
which, upon molecular orientational averaging, yields:

2 ˆ

*𝜖* *𝐸𝐷𝑣𝑒𝑙* ( *𝜔* ) = ∑︁( *𝑁* *𝐼* *−* *𝑁* *𝐽* ) 3 *𝐸* *𝐽𝐼* *|⟨* Ψ *𝐼* *|𝑝|* Ψ *𝐽* *⟩|* [2] *𝛿* ( *𝐸* *𝐽𝐼* *±* ℏ *𝜔* ) (7.258)

*𝐼𝐽*

**936** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

For exact solutions of the Hamiltonian, or in theories that satisfy the Hypervirial theorem by construction, equation
(7.258) can be transformed into a length formulation (7.259) ( *𝐸𝐷𝑙𝑒𝑛* ).


∑︁( *𝑁* *𝐼* *−* *𝑁* *𝐽* ) [2] *[𝐸]* 3 *[𝐽𝐼]*

*𝐼𝐽*


*𝜖* *𝐸𝐷𝑙𝑒𝑛* ( *𝜔* ) = ∑︁


*|⟨* Ψ *𝐼* *|𝜇* ˆ *|* Ψ *𝐽* *⟩|* [2] *𝛿* ( *𝐸* *𝐽𝐼* *±* ℏ *𝜔* ) (7.259)
3


The absorption spectrum under *𝐸𝐷𝑙𝑒𝑛* and *𝐸𝐷𝑣𝑒𝑙* formulations can be obtained in all Orca modules utilizing
OPS by setting **DoDipoleLength** and **DoDipoleVelocity** to true, respectively, in the corresponding module’s block.
The results are then presented in the following tables:


Here, transitions are denoted using spectroscopic notation, such as 1-3B3g representing 1 [3] *𝐵* 3 *𝑔* . If symmetry is
not specified in the calculation (or is unavailable in the selected method), the system defaults to *𝐶* 1 point group
symmetry. The “fosc(D2)” and “fosc(P2)” columns indicate the computed oscillator strengths in lenght and velocity
formulations respectively. Additionally, “D2”, “P2”, “DX”, “DY”, “DZ”, “PX”, “PY”, and “PZ” represent the
square modulus of the electric transition dipole moment, square modulus of the transition linear momentum, and
its Cartesian components, respectively (with the imaginary unit in the linear momentum being implicit).

The first-order term ( *𝑇* *𝐼𝐽* [[1]] [) in the Taylor expansion of] *[ 𝑇]* *𝐼𝐽* *[𝐹𝐹𝑀𝐼𝑂]* gives rise to the electric quadrupole velocity formulation and the magnetic dipole contributions.

*𝑖𝑒*
*⟨* Ψ *𝐼* *|* ( *𝑇* *𝐸𝑄𝑣𝑒𝑙* ) *𝛼𝛽* *|* Ψ *𝐽* *⟩* = *𝑘* *𝛼* *𝜖* *𝛽* *⟨* Ψ *𝐼* *|𝑟* *𝛼* *𝑝* *𝛽* + *𝑝* *𝛼* *𝑟* *𝛽* *|* Ψ *𝐽* *⟩* (7.260)
2 *𝑚* *𝑒*

**7.42. One Photon Spectroscopy** **937**

**ORCA Manual** **,** **Release 6.0.1**

*𝑖𝑒*
*⟨* Ψ *𝐼* *|𝑇* *𝑀𝐷* *|* Ψ *𝐽* *⟩* = *⟨* Ψ *𝐼* *|* ( *𝑘* *× 𝜖* )( *𝑟* *× 𝑝* ) *|* Ψ *𝐽* *⟩* (7.261)
2 *𝑚* *𝑒*

Under the same conditions applied to the electric dipole transition moment, the quadrupole contribution can be
reformulated in terms of a length representation.


*⟨* Ψ *𝐼* *|* ( *𝑇* *𝐸𝑄𝑙𝑒𝑛* ) *𝛼𝛽* *|* Ψ *𝐽* *⟩* = *[𝑒𝐸]* *[𝐽𝐼]*

2 *𝑚* *𝑒*


∑︁ *𝑘* *𝛼* *𝜖* *𝛽* *⟨* Ψ *𝐼* *|𝑟* *𝛼* *𝑟* *𝛽* *|* Ψ *𝐽* *⟩* (7.262)

*𝑖*


By squaring the modulus of ( *𝑇* *𝐼𝐽* [[0]] [+] *[ 𝑇]* *𝐼𝐽* [[1]] [), six terms emerge in the oscillation strength intensity: the dipole]
square contribution as listed previously in the dipole-approximation tables, a magnetic dipole square, an electric
quadrupole square, and three cross-product terms: electric dipole-electric quadrupole, electric dipole-magnetic
dipole, and magnetic dipole-electric quadrupole. Enabling **DoHigherMoments** to true allows for the estimation
of spectrum intensity by including all three squared terms in the calculation of the intensity. Similarly to the
*𝐸𝐷𝑙𝑒𝑛* and *𝐸𝐷𝑣𝑒𝑙* tables, the **DoDipoleLength** and **DoDipoleVelocity** keywords control the length and velocity
representations of the electric operators.


Here, the column “fosc(D2+M2+Q2)” and “fosc(P2+M2+Q2)” refer to the total oscillator strengths obtained
in length and velocity formulations, respectively, while the columns “fosc(D2)”/”fosc(P2)”, “fosc(M2)”, and
“fosc(Q2)” refer to the individual contributions of each term.

In scenarios where the dipolar contribution to the intensity is non-zero, dividing the total intensity into D2/P2, M2,
and Q2 contributions becomes challenging due to the dependence of M2 and Q2 terms on the chosen origin. To

**938** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

address this origin-dependence issue, OPS offers additional formulations to the multipolar expansion. One possible
approach devised by our group describes each transition from an origin that minimizes the contributions of M2
and Q2, thereby redistributing the intensity from these terms to all other components in the expansion of *𝑒* *[𝑖]* **[k]** *[·]* **[r]** *[𝑖]* .
This refined formulation is readily accessible in an “origin-adjusted” table, provided that **DoHigherMoments** is
enabled and additionally **DecomposeFoscLength** is set to true. [201], [200]



Alternatively, the intensity described through a truncated expansion of *𝑒* *[𝑖]* **[k]** *[·]* **[r]** *[𝑖]* be achieved in an origin-independent
manner. In this scenario, the cross-terms between the electric dipole moment and the electric octupole, as well as
between the electric dipole moment and the magnetic quadrupole moments, arise from the second-order expansion
( *𝑇* *𝐼𝐽* [[2]] [), resolving the origin dependence on the D2, M2, and Q2 contributions. This formulation is provided in]
both length and velocity representations for the electric operators by setting the keywords **DecomposeFoscLength**
and **DecomposeFoscVelocity** to true, and the results are presented in the tables “Origin Independent, Length” and
“Origin Independent, Velocity,” respectively.”




(continues on next page)

**7.42. One Photon Spectroscopy** **939**

**ORCA Manual** **,** **Release 6.0.1**


(continued from previous page)



Finally, intensity computation directly using *𝑇* *𝐼𝐽* *[𝐹𝐹𝑀𝐼𝑂]* is achievable in OPS through the utilization of the keyword
**DoFullSemiclassical** set to true. In this scenario, the orientational average is computed semi-numerically due to
the absence of available analytical expressions.



The tables presented in this section can be generated using the following input example:




**940** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.42.3 Natural electric circular dichroism**

In the case of ECD modeling, intensity is determined by computing the difference between two absorption spectra:
one acquired using left-circularly polarized light and the other utilizing right-circularly polarized light.

∆ *𝐼* ( *𝜔* ) = *𝐼* *𝑙𝑒𝑓𝑡* ( *𝜔* ) *−* *𝐼* *𝑟𝑖𝑔𝑡ℎ* ( *𝜔* )

To initiate these calculations, the keyword **DoCD** should be set to true. There are three available implementations, which involve utilizing the length or velocity representations for the electric dipole moment, and also using
the FFMIO, selected by including the keywords **DoDipoleLength**, **DoDipoleVelocity**, and **DoFullSemiclassical**
respectively.




The following input example may be used to generate the CD tables presented in this section:




(continues on next page)

**7.42. One Photon Spectroscopy** **941**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**7.42.4 SOC and SSC corrected spectrum**

All the OPS keywords and tables listed above are available for the cases in which spin-orbit coupling and spin-spin
coupling effects are taken into account by a QDPT formulation (when the method is available in the selected ORCA
module). In those cases, ORCA 6.0 does not provide symmetry after the relativistic correction; therefore, *𝐶* 1 group
symmetry transitions are reported. Additionally, the multiplicity of the relativistically corrected roots are not well
defined anymore; therefore, the average value is reported.

For the last case example presented in this section, when **DoSOC** is set to true in the input, OPS reports:



In this case, due to the complex nature of the relativistically-corrected wave functions, dipole moments are not
necessarily real values, and their modulous are reported in the “|DX|”, “|DY|”, and “|DZ|” columns. Real and

**942** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

imaginary components may be obtained in extended tables by increasing the selected print level. In this instance,
selecting **Printlevel 4** in the %CIS block.



**7.42.5 OPS Full list of keywords**

The folowing list of keywords may be included directly in the correcponding module block to trigger OPS compute
the corresponding intensities.




(continues on next page)

**7.42. One Photon Spectroscopy** **943**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



In Orca 6.0 the modules in which OPS is avaylable are: %cis/%tddft, %rocis, %casscf, %mrci, %mdci, %lft,
%mcrpa and %xes.

**7.42.6 Notes**

1. All values in the OPS tables are expressed in atomic units unless otherwise specified.

2. Keyword corrections are done internally when necessary.

3. **IMPORTANT** : Input keywords have been standardized across all OPS-utilizing modules; Orca 5 keywords
are no longer valid.

4. **IMPORTANT** : In CASSCF and MRCI, keywords controlling the absorption and ECD spectrum no longer
belong in the “%rel” block.

5. Origin-adjusted formulation is approximated in SOC/SSC formulations.

6. OPS is not available for sTDDFT and sTDADFT.

7. The MDCI module reports spectra using left, right, and both solutions.

8. ADC2 and EOM-CCSD methods exclusively utilize ED length tables.
### **7.43 Magnetic properties through Quasi Degenerate Perturbation** **Theory**

**7.43.1 Quasi Degenerate Perturbation Theory (QDPT) in a nutshell**

Quasi Degenerate Perturbation Theory offers a versatile and accurate approach to to a number of magnetic properties for basically every wavefunction based excited states method.

In a nutshell at the non relativistic limit for every excited state single or multireference wavefunction based method,
bearing a CASSCF, MRCI, or a ROCIS type of zeroth order wavefunction one can set up an excitation problem that is a combination of the zeroth order wavefunction and excited spin-adapted configuration state functions
(CSFs)⃒⃒Φ *𝑆𝑆𝜇* ⟩︀.

That takes the form:

⃒⃒Ψ *𝑆𝑆𝐼* ⟩︀ = ∑︁ *𝜇* *[𝐶]* *[𝜇𝑙]* ⃒⃒Φ *𝑆𝑆𝜇* ⟩︀ (7.263)

Here the upper indices *𝑆𝑆* stand for a wave function of the spin quantum number *𝑆* and spin projection *𝑀* *𝑆* = *𝑆* .
Since the BO Hamiltonian does not contain any complex-valued operator, the solutions ⃒⃒Ψ *𝑆𝑆𝐼* ⟩︀ may be chosen to
be real-valued.

By obtaining a solution to the above eigenvalue problem provides the coefficients with which the CSFs enter into the
chosen wavefunction as well as the eigenstates of the spin-free operator. These eigenstates maube used to expand
towards the respective relativistic eigenstates by setting up the relevant quasi-degenerate eigenvalue problem. In
fact the spin-orbit coupling (SOC), the spin-spin coupling (SSC) effects along with the Zeeman interaction can be
included by means of the quasi-degenerate perturbation theory (QDPT). In this approach the SOC, the SSC, and
the Zeeman operators are calculated in the basis of pre-selected solutions of the BO Hamiltonian{︀Ψ *[𝑆𝑀]* *𝐼* }︀.

Ψ *[𝑆𝑀]* *𝐼* *𝐻* ˆ BO + ˆ *𝐻* SOC + ˆ *𝐻* SSC + ˆ *𝐻* Z Ψ *𝑆𝐽* *′* *𝑀* *′* = *𝛿* *𝐼𝐽* *𝛿* *𝑆𝑆* *′* *𝛿* *𝑀𝑀* *′* *𝐸* *𝐼* [(] *[𝑆]* [)] + Ψ *[𝑆𝑀]* *𝐼* *𝐻* ˆ SOC + ˆ *𝐻* SSC + ˆ *𝐻* Z Ψ *𝑆𝐽* *′* *𝑀* *′*
⟨ ⃒⃒⃒ ⃒⃒⃒ ⟩ ⟨ ⃒⃒⃒ ⃒⃒⃒ ⟩

(7.264)

Diagonalization of this matrix yields the energy levels and eigenvectors of the coupled states. These eigenvectors
in fact represent linear combinations of the solutions of *𝐻* [ˆ] BO with complex coefficients.

**944** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

The effective one-electron SOC operator in second quantized form can be written as [611]:

*̸*


*𝐻* ˆ SOMF = [1]

2

*̸*


*𝑧* *[−]* *𝑎* ˆ *[↑]*

∑︁ *𝑝𝑞* *[𝑎]* [ˆ] *[↑]* *𝑝* [ˆ] *[𝑏]* *[𝑞]* [+] *[ 𝑧]* *𝑝𝑞* [+] [ˆ] *[𝑏]* *[↑]* *𝑝* *[𝑎]* [ˆ] *[𝑞]* [+] *[ 𝑧]* *𝑝𝑞* [0] [︁ *𝑝* *[𝑎]* [ˆ] *[𝑞]* *[−]* [ˆ] *[𝑏]* *[↑]* *𝑝* [ˆ] *[𝑏]* *[𝑞]* ]︁ (7.265)

*𝑝𝑞*

*̸*


Here ˆ *𝑎* *[↑]*
*𝑝* [and][ ˆ] *[𝑏]* *[↑]* *𝑝* [stand for creation of] *[ 𝛼]* [and] *[ 𝛽]* [electrons respectively;][ ˆ] *[𝑎]* *[𝑝]* [and][ ˆ] *[𝑏]* *[𝑝]* [represent the corresponding annihila-]
tion operators. The matrix elements *𝑧* *𝑝𝑞* *[−]* [=] *[ 𝑧]* *𝑝𝑞* *[𝑥]* *[−][𝑖𝑧]* *𝑝𝑞* *[𝑦]* [,] *[ 𝑧]* *𝑝𝑞* [+] [=] *[ 𝑧]* *𝑝𝑞* *[𝑥]* [+] *[𝑖𝑧]* *𝑝𝑞* *[𝑦]* [, and] *[ 𝑧]* *𝑝𝑞* [0] [=] *[ 𝑧]* *𝑝𝑞* *[𝑧]* [(upper] *[ 𝑥]* [,] *[ 𝑦]* [,] *[ 𝑧]* [indices denote]
the Cartesian components) are constructed from the matrix elements described in section *Zero-Field-Splitting* .

In this concept the SOC Hamiltonian reads:

*̸*


~~⏟~~ ⏞

*̸*


*−* ⏞ (7.266)

*𝑌* *[𝑆𝑆][′]*
*𝐼𝐼* *[′]* [ (] *[𝑚]* [)]

*̸*


⟨Ψ *[𝑆𝑀]* *𝐼* ⃒⃒⃒ *𝐻* ˆ SOC ⃒⃒⃒ Ψ *𝑆𝐽* *′* *𝑀* *′* ⟩ = *𝑚* =0 ∑︁ *,±* 1 ( *−* 1) (︂ *𝑀𝑆* *′* *[′]* *𝑚* 1

*̸*


*𝑆*

*𝑀*
⃒⃒⃒⃒

*̸*


⟨ Ψ *[𝑆𝑆]* *𝐼* *[||][𝐻]* *−* *[𝑆𝑂𝐶]* *𝑚* *[||]* [Ψ] *[𝑆𝑆]* *𝐽* ⟩
)︂ ~~⏟~~ ⏞

*̸*


*𝑆* *[′]* 1
where *𝑚* represents the standard vector operator components.
*𝑀* *[′]* *𝑚*
(︂

*̸*


*𝑆*

*𝑀*
⃒⃒⃒⃒

*̸*


is a Clebsch–Gordon coefficient
)︂

*̸*


that has a single numer- ical value that is tabulated. It satisfies certain selection rules and contains all of the Mdependence of the SOC matrix elements. The quantity *𝑌* *𝐼𝐼* *[𝑆𝑆]* *[′]* [ (] *[′]* *[𝑚]* [)][ is a reduced matrix element. It only depends on]
the standard components of the two states involved. There are only three cases of non-zero *𝑌* *𝐼𝐼* *[𝑆𝑆]* *[′]* [ (] *[′]* *[𝑚]* [)][ which arise]
from state pairs that either have the same total spin or differ by one unit.[622]

*̸*


The SSC Hamiltonian reads:

ˆ *𝑒* *[𝛼]* [2]
*𝐻* SSC = *−* [3] *[𝑔]* [2]

8

*̸*


∑︁

*𝑖* = *̸* *𝑗*


(2)

*̸*


(7.267)

*̸* *𝑚*


∑︁

*̸* *𝑚* =0 *,±* 1 *,±* 2


( *−* 1 ) *[𝑚]*

*̸*



[ **r** *𝑖𝑗* *×* **r** *𝑖𝑗* ] *−* [(2)] *𝑚* [[] **[S]** [ (] *[𝑖]* [)] *[ ×]* **[ S]** [ (] *[𝑗]* [)]]
*𝑟* [5]

*̸* *𝑖𝑗*


*̸*

For matrix elements between states of the same multiplicity it can be simplified to
⟨ *𝑎𝑆𝑀* ⃒⃒⃒ *𝐻* ˆ SSC ⃒⃒⃒ *𝑎* *′* *𝑆𝑀* *′* ⟩ = *√* *√* ( *𝑆𝑆* +1(2 )( *𝑆* 2 *−𝑆* 1)+3 )


*̸*

( *𝑆* +1 )( 2 *𝑆* +3 )
*√* *𝑆* (2 *𝑆−* 1)


*̸*

*𝑆* (2 *𝑆−* 1)


*̸*

*𝑆*

*𝑀*
⃒⃒⃒⃒


*̸*

(7.268)
0 *′*
*𝑝𝑞𝑟𝑠* *[𝐷]* *𝑝𝑞𝑟𝑠* [(] *[−][𝑚]* [)] ⟨︀ *𝑎𝑆𝑆* ⃒⃒ *𝑄* *𝑝𝑞𝑟𝑠* ⃒⃒ *𝑎* *𝑆𝑆* ⟩︀
)︂∑︀


*̸*

*𝑆* *′* 2

*×* [∑︀] ( *−* 1) *[𝑚]*

*𝑚* (︂ *𝑀* *[′]* *𝑚*


*̸*

*𝑆* *′* 2

[∑︀] ( *−* 1) *[𝑚]*

*𝑚* (︂ *𝑀* *[′]* *𝑚*


*̸*

Here


*̸*

1
*𝑄* [(0)] *𝑝𝑞𝑟𝑠* [=]
4 *√* 6


*̸*

*𝐸* *𝑝𝑞* *𝛿* *𝑠𝑟* *−* *𝑆* *𝑝𝑠* *[𝑧]* *[𝑆]* *𝑟𝑞* *[𝑧]* [+ 1] (︀ *𝑆* *𝑝𝑞* *[𝑧]* *[𝑆]* *𝑟𝑠* *[𝑧]* *[−]* *[𝐸]* *[𝑝𝑞]* *[𝐸]* *[𝑟𝑠]* )︀ [}︂] (7.269)
{︂ 2


*̸*

represents the two-electron quintet density. The operators *𝐸* *𝑝𝑞* = ˆ *𝑎* *[↑]* *𝑝* *[𝑎]* [ˆ] *[𝑞]* [+ ˆ] *[𝑏]* *[↑]* *𝑝* [ˆ] *[𝑏]* *[𝑞]* [and] *[ 𝑆]* *𝑝𝑞* *[𝑧]* [= ˆ] *[𝑎]* *[↑]* *𝑝* *[𝑎]* [ˆ] *[𝑞]* *[−]* [ˆ] *[𝑏]* *[↑]* *𝑝* [ˆ] *[𝑏]* *[𝑞]* [symbolize]
here the one-electron density operator and the spin density operator accordingly. The spatial part


*̸*

1
*𝐷* [(0)]
*𝑝𝑞𝑟𝑠* [=]
*√* 6


*̸*

*𝜙* *𝑝* ( **r** 1 ) *𝜙* *𝑟* ( **r** 2 ) [3] *[𝑟]* [1] *[𝑧]* *[𝑟]* [2] *[𝑧]* *[−]* **[r]** [1] **[r]** [2] *𝜙* *𝑞* ( **r** 1 ) *𝜙* *𝑠* ( **r** 2 ) *𝑑* **r** 1 *𝑑* **r** 2 (7.270)
∫︁∫︁ *𝑟* 12 [5]


*̸*

denotes the two-electron field gradient integrals. These two-electron integrals can be evaluated using the RI approximation.

Finally, the Zeeman Hamiltonian is included in the form of:

*𝐻* ˆ Z = *𝜇* *𝐵* **^L** + *𝑔* *𝑒* **^S** **B** (7.271)
(︁ )︁

with **L** **[^]** representing the total orbital momentum operator, and **S** **[^]** being the total spin operator.

In this concept solution of a selected relativistic Hamiltonian provide access to a numerous magnetic properties
namely EPR properties *EPR and NMR properties* as well as Magnetization and Susceptibility properties *Mag-*
*netization and Magnetic Susceptibility* In addition monitoring the impact of an external Magnetic Field to the
relativistic eigenstates and eigenvectors *Addition of Magnetic Fields* becomes straightforward.

Collectively within the QDPT framework the following magnetic properties become available

1) G-Tensor/Matrix

2) Zero Field Splitting

**7.43. Magnetic properties through Quasi Degenerate Perturbation Theory** **945**

**ORCA Manual** **,** **Release 6.0.1**

3) Hyperfine A-Tensor/Matrix

4) Electric Field Gradient

5) Magnetization

6) Susceptibility

7) Inclusion of Magnetic Fields

**7.43.2 Magnetic properties through the Effective Hamiltonian**

Since both the energies and the wavefunction of the low-lying spin-orbit states are available, the effective Hamiltonian theory can be used to extract EPR parameters such as the full G, Zero Field Splitting (ZFS) and hyperfine
A tensors.

Provided that the ground state is non-degenerate. By applying this Hamiltonian on the basis of the model space,
i.e. the *|𝑆, 𝑀* *𝑆* *⟩* components of the ground state, the interaction matrix is constructed.

The construction of effective Hamiltonian relies on the information contained in both the energies and the wavefunctions of the low-lying spin-orbit states. Following des Cloizeaux formalism, the effective Hamiltonian reproduces
the energy levels of the “exact” Hamiltonian *𝐸* *𝑘* and the wavefunctions of the low-lying states projected onto the
model space Ψ [˜] :

ˆ
*𝐻* eff *|* ˜Ψ *𝑘* *⟩* = *𝐸* *𝑘* *|* ˜Ψ *𝑘* *⟩*

These projected vectors are then symmetrically orthonormalized resulting in an Hermitian effective Hamiltonian,
which can be written as:


*|𝑆* *[−]* 2 [1]

*𝑘*


ˆ
*𝐻* eff *|* ˜Ψ *⟩* = ∑︁



[1]

2 ˜Ψ *𝑘* *⟩𝐸* *𝑘* *⟨𝑆* *[−]* 2 [1]


2 ˜Ψ *𝑘* *|*


The effective interaction matrix obtained by expanding this Hamiltonian into the basis of determinants belonging
to the model space, is the compared to the matrix resulted from expanding the model Hamiltonian. Based on a
singular value decomposition procedure, all 9 elements of the G, A and/or ZFS tensors may be extracted.

**7.43.3 Organization of QDPT Magnetic Properties Computation**

Starting from ORCA 6.0 the calculation of the magnetic properties through the Quasi Degenerate Perturbation Theory (QDPT) in all available correlation type modules is unified and simplified. Following the general architecture
design of ORCA 6.0 the computation of all the involved magnetic properties are centrally performed by a driver
data structure called the QDPT Driver. The Driver takes into account all the specific variables that are populated
by the involved module and proceeds accordingly to calculated and represent the requested property in a uniform
fashion. This presently involves the `casscf`, `mrci`, `rocis` and `lft` modules

In this way

1) Results analysis process from the user’s perspective is simplified

2) Cross module correlation and comparisons are also easily accessible

The general keywords that activate the generation of QDPT properties are:



In a first step SOC contributions will be computed for any level of theory that is available

**946** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**




Upon request the non-zero SOC Matrix Elemnts will be printed



followed by printing of the SOC Hamiltonian



leading to the printout of the relativistically corrected eigenvalues and eigenvectors




(continues on next page)

**7.43. Magnetic properties through Quasi Degenerate Perturbation Theory** **947**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



Then in following all the relevant QDPT properties will be printed:

(continues on next page)

**948** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



If requested in a second step Spin-Spin Coupling contributions will be generated and wiil be added to the SOC
Hamiltonian to generate SOC+SSC contributions



The the program will undergo the exact same analysis as above printing the SOC+SSC analysis




(continues on next page)

**7.43. Magnetic properties through Quasi Degenerate Perturbation Theory** **949**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

for both the Magnetic properties e.g. the ZFS



as well as the Optical properties


### **7.44 Simulation of (Magnetic) Circular Dichroism and Absorption** **Spectra**

**7.44.1 General description of the program**

ORCA can now simulate optical spectra that include spin-orbit coupling contributions at all levels of theory by
using a common implementation. [269]

Following the energy-loss approach, the absorption cross section for a transition between states *𝑃* [˜] and *𝑄* [˜] can be
expressed as:

4 *𝜋* [2]
*𝜎* *𝑃* ˜ *𝑄* [˜] [=] *𝑐* ( *𝐸* *𝑄* ˜ *[−]* *[𝐸]* *𝑃* [˜] [)] *[|][𝑇]* *𝑃* [˜] *𝑄* [˜] *[|]* [2] *[,]*

where c is the speed of light; *𝐸* *𝑃* ˜ [and] *[ 𝐸]* *𝑄* [˜] [are the energy of the states][ ˜] *[𝑃]* [and][ ˜] *[𝑄]* [, respectively;] *[ 𝑇]* *𝑃* [˜] *𝑄* [˜] [is the tran-]
sition moment between states *𝑃* [˜] and *𝑄* [˜] and it can be computed with different expressions based on the applied
approximation.

Under a dipolar approximation to the light-matter interaction, the transition moment takes the form:


*𝑁*
∑︁


∑︁ *⟨𝑃* [˜] *| ℰ·* ˆ **p** *𝑖* *|𝑄* [˜] *⟩,*

*𝑖* =1


*𝑇* ˜
*𝑃* *𝑄* [˜] [=]


where the sum runs over all electrons *𝑖* ; ˆ **p** *𝑖* is the linear momentum operator; and *ℰ* is the polarization vector of the
incident light.

In order to take into account all the electric and magnetic mechanisms in the transition, it is necessary to use the
full field-matter interaction operator (FFMIO). For transition moment, it leads to the equation (7.272).


*𝑇* ˜ *[𝑒]*
*𝑃* *𝑄* [˜] [=] *𝑚* *𝑒*


*𝑁*
∑︁ *⟨𝑃* [˜] *| ℰ·* [︁ *𝑒* *[𝑖]* **[k]** *[·]* [^] **[r]** *[𝑖]* **p** ˆ *𝑖* ]︁ *|𝑄* [˜] *⟩* (7.272)

*𝑖* =1


**950** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

where ˆ *𝑟* *𝑖* is the position operator of i-th electron and **k** is the wave vector that points in the direction of the light
propagation whose magnitude is related to the wavelength by *𝜆* = 2 *𝜋/|* **k** *|* .

For free-rotating molecules, it is necessary to consider all possible orientations of the molecule with respect to
the direction of the incident light. In some cases, such as the absorption of linear-polarized light under a dipolar
approximation, the effect of the orientation can be averaged analytically. However, numerical integration over some
selected molecular orientations, labeled as *𝑜* in equation (7.273), is generally necessary.


4 *𝜋* [2]
*𝑜* *𝑤* *𝑜* *𝑐* ( *𝐸* *𝑄* ˜ [(] *[𝑜]* [)] *[ −]*


*< 𝜎* *𝑃* ˜ *𝑄* [˜] *[>]* [=] ∑︁


*𝑐* ( *𝐸* *𝑄* ˜ [(] *[𝑜]* [)] *[ −]* *[𝐸]* *𝑃* [˜] [(] *[𝑜]* [))] *[|][𝑇]* *𝑃* [˜] *𝑄* [˜] [(] *[𝑜]* [)] *[|]* [2] (7.273)


where *𝑤* *𝑜* is the weight of the orientation in the quadrature.

The implementation has been designed to compute the absorption of circularly-polarized light on systems under the
effect of an additional external magnetic field, B, which modifies the states *𝑃* [˜] and *𝑄* [˜] for each orientation *𝑜* through
a Zeeman perturbation. The computed results are presented as the difference in the absorption of the left (-) and
right (+) circularly-polarized light (∆f *𝑜𝑠𝑐* ) and as the sum of the oscillator strength (f *𝑜𝑠𝑐* ), which corresponds to
the linearly-polarized light absorption. The molecular orientations are constructed by using rotation matrices with
three Euler angles: *𝜒*, *𝜃*, and *𝜑* . Herein, *𝜒* (the rotation angle on a plane perpendicular to the direction of external
magnetic field/incident light) is integrated analytically whereas *𝜃* and *𝜑* are taken on a grid.

Finally, the states *𝑃* [˜] and *𝑄* [˜] are obtained from QDPT by expanding the states over non-relativistic eigenstates of *𝐻* [ˆ] 0
( *{𝐼, 𝐽}* ) and the coefficients of the expansion ( *𝑑* *𝐼𝑄* ˜ [) are obtained from the diagonalization of the complex matrix,]
which contains *𝐻* [ˆ] 0 as well as the SOC and Zeeman contributions (and SSC, if it is implemented in the selected
electronic structure theory) expressed in *{𝐼, 𝐽}* .

*⟨* Ψ *[𝑆𝑀]* *𝐼* *|* *𝐻* [ˆ] 0 + *𝐻* [ˆ] *𝑆𝑂𝐶* + *𝐻* [ˆ] *𝑍𝑒𝑒𝑚𝑎𝑛* *|* Ψ *[𝑆]* *𝐽* *[′]* *[𝑀]* *[′]* *⟩* = *𝛿* *𝐼𝐽* *𝛿* *𝑆𝑆* *′* *𝛿* *𝑀𝑀* *′* *𝐸* *𝐼* *[𝑆]* [+] *[ ⟨]* [Ψ] *𝐼* *[𝑆𝑀]* *|* *𝐻* [ˆ] *𝑆𝑂𝐶* + *𝐻* [ˆ] *𝑍𝑒𝑒𝑚𝑎𝑛* *|* Ψ *[𝑆]* *𝐽* *[′]* *[𝑀]* *[′]* *⟩* (7.274)

**7.44.2 Running and analyzing MCD calculations in TDDFT module**

A minimum input to compute the Magnetic Circular Dichroism (MCD) requires setting the keyword DoMCD to
true and to include an intensity for the external magnetic field B (in Gauss). An example input for the TD-DFT
module is as follows:



In the output file of this job, the estimated oscillator strengths (f *𝑜𝑠𝑐* ) and the difference between left and right
circularly polarized light absorption (∆f *𝑜𝑠𝑐* ) are provided:

**7.44. Simulation of (Magnetic) Circular Dichroism and Absorption Spectra** **951**

**ORCA Manual** **,** **Release 6.0.1**



These results may not be accurate when the energetic order of the states changes with respect to the relative orientation between the molecule and the external magnetic field. To obtain accurate results, it is necessary to perform
a post-processing step for all orientations using the `orca_mapspc` program, which saves the results in a file that
has the `.cis-el.dipole-length.1.mcd` extension:
```
orca_mapspc fur-mcd.cis-el.exact.1.mcd MCD -x050000 -x155000 -n10000 -w2000

```
In this example, we generate the spectrum (M *[−]* [1] ) between 50000 and 55000 cm *[−]* [1] (-x050000 -x155000), using
10000 points (-n10000) and including a broadened normalized Gaussian function with a full width at half maximum
of 2000cm *[−]* [1] (-w2000).

Multiple MCD calculations can be performed in one run by setting multiple values for B. Transition moments can
be also obtained through ED velocity formulation and FFMIO operator by setting the keywords `DoVelocity` and
`DoQuadrupole` to true, respectively:



The results are printed separately in the output file for each setting:




(continues on next page)

**952** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)




Post-processing results are saved in the files having the `.cis-el.dipole-length.1.mcd`, `.cis-el.`
`dipole-vel.1.mcd`, and `.cis-el.exact.1.mcd` extensions.

**NOTE:** It is worth enphasizing that the computed values of ∆f *𝑜𝑠𝑐* correspond to the difference in absorption
between left and right circularly polarized light for the selected transition moments. In the case of both ED approximations, ∆f *𝑜𝑠𝑐* corresponds to the MCD signal. The sum of natural circular dichroism and magnetic-induced
circular dichroism is obtained when the FFMIO is requested. To obtain only the MCD spectrum in an FFMIO
scheme, it is necessary to subtract the natural circular dichroism by setting B to 0.0.

**7.44.3 Running MCD calculations in other modules**

The MCD implementation can also be used in other modules such as STEOM-CCSD, CAS, ROCIS, and MRCI
(see the input file examples given below) by using the same keywords as those described for the TDDFT module.
In the case of CAS, ROCIS, and MR-CI modules, it is necessary to include the keyword `NewMCD True` ; otherwise,
the previous MCD implementation will be called instead.




**7.44. Simulation of (Magnetic) Circular Dichroism and Absorption Spectra** **953**

**ORCA Manual** **,** **Release 6.0.1**




It is important to keep in mind that the calculation of the MCD relies on the proper description of the transition
moments and angular momentum for calculating the Zeeman perturbation. Therefore, the user is responsible for
selecting the proper electronic structure method.

**7.44.4 List of related keywords**


### **7.45 More on the Excited State Dynamics module**

ORCA has now a module designed to calculate properties related to excited states named `ORCA_ESD` . It can be
used to predict absorption/emission spectra, transition rates, resonant Raman, and MCD spectra, based on a path
integral approach to the dynamic process [199]. It has some of the functionalities of `ORCA_ASA` and even more,
as it will be discussed. What we do here is NOT a conventional dynamics with trajectories along time points, we
rather solve the equation for the transition rates or intensities depending on the different cases considered.

This formulation works because there is an analytic solution to the path integral of the Multidimensional Harmonic
Oscillator and the assumption of Harmonic nuclear movement is critical. In many cases that approximation does
hold and the results are in very good agreement with the experiment. The general usage of the `ORCA_ESD` module
and some examples are already presented on Sec. *Excited State Dynamics* and it is recommended to read that
before going into the details here. We now will discuss the specifics and keywords related to of each part of the
module. A complete keyword list can be found at the end of this section.

**954** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.45.1 Absorption and Emission Rates and Spectrum**

**General Aspects of the Theory**

The idea behind calculating the absorption or emission rates starts with the equation from the quantization of the
electromagnetic field for the transition rates between and initial and a final state:

*𝑘* ( *𝜔* ) *𝑖𝑓* = [4] *[𝜔]* [3] *[𝑛]* [2] (7.275)

3ℏ *𝑐* [3] *[ |⟨]* [Ψ] *[𝑖]* *[|][𝜇]* [̂︀] *[|]* [Ψ] *[𝑓]* *[⟩|]* [2] *[𝛿]* [(] *[𝐸]* *[𝑖]* *[−]* *[𝐸]* *[𝑓]* *[±]* [ ℏ] *[𝜔]* [)]

with ℏ *𝜔* being the energy of the photon, ̂︀ *𝜇* the dipole operator and *𝑛* the refractive index of the solvent, as suggested
by Strickler and Berg [831].

One way to obtain *𝑘* ( *𝜔* ) is to compute it in the frequency domain, by calculating the Franck-Condon Factors
between all initial and final states that satisfy the Dirac delta in Eq. *(7.275)*, considering the thermally accessible
initial states with the appropriate weight,

*𝑘* *[𝑜𝑏𝑠]* = *𝑘* ( *𝜔* ) *𝑑𝜔,* *𝑘* ( *𝜔* ) = ∑︁ *𝑃* *𝑖* ( *𝑇* ) *𝑘* *𝑖𝑓* ( *𝜔* ) *,* (7.276)
∫︁

*𝑖𝑓*

*𝜖* *𝑖*
where *𝑃* *𝑖* ( *𝑇* ) = *𝑒* *[−]* *𝑘𝐵𝑇* */𝑍* is the Boltzmann population of a given initial state at temperature *𝑇*, *𝜖* *𝑖* is the total
vibrational energy of state *𝑖* and *𝑍* is the vibrational partition function. However, this can lead to a very large
number of states to be included, particularly if there are low frequency modes. In this work we will take the a
different approach and switch to the time domain, by using the Fourier Transform representation of the Dirac delta,


*𝛿* ( *𝜔* ) = [1]

2 *𝜋*


+ *∞*

*𝑒* *[𝑖𝜔𝑡]* *𝑑𝑡,* (7.277)

∫︁ *−∞*


so that the equation to solve, in atomic units, is:


2 *𝜔* [3]
*𝑘* ( *𝜔* ) =

3 *𝜋𝑐* [3] *𝑍*


*𝜖* *𝑖*

∑︁ *𝑒* *[−]* *𝑘𝐵𝑇* *⟨* Θ *𝑖* *|⃗𝜇* *[𝑒]* *|* ¯Θ *𝑓* *⟩⟨* ¯Θ *𝑓* *|⃗𝜇* *[𝑒]* *|* Θ *𝑖* *⟩* *𝑒* *[𝑖]* [(] *[𝐸]* *[𝑖]* *[−][𝐸]* *[𝑓]* *[−][𝜔]* [)] *[𝑡]* *𝑑𝑡,*

∫︁
*𝑖𝑓*


with *⃗𝜇* *[𝑒]* being the “electronic transition dipole” and *|* Θ *⟩* the vibrational wavefunction of the initial or final state.

After some extra steps, redefinition of the time variable and insertion of a resolution of identity, it can be shown
that this equation is ultimately simplified to a Discrete Fourier Transform (DFT) of a correlation function *𝜒* ( *𝑡* ) with
a timestep ∆ *𝑡*, multiplied by a prefactor *𝛼* [199]:

*𝑘* ( *𝜔* ) = *𝛼* *𝑇𝑟* ( *⃗𝜇* *[𝑒]* *𝑒* *[−][𝑖]* *𝐻𝜏* [̂︀] *⃗𝜇* *𝑒* *𝑒* *−𝑖𝐻* ~~[̂]~~ *𝜏* ¯ ) *𝑒* *𝑖* Δ *𝐸𝑡* *𝑒* *−𝑖𝜔𝑡* *𝑑𝑡*
∫︁

= *𝛼* *𝜒* ( *𝑡* ) *𝑒* *[−][𝑖𝜔𝑡]* *𝑑𝑡*
∫︁

*∞*
= 2 *𝛼* Re *𝜒* ( *𝑡* ) *𝑒* *[−][𝑖𝜔𝑡]* *𝑑𝑡*
∫︁ 0

*≃* 2 *𝛼* ∆ *𝑡* Re *𝐷𝐹𝑇* *{𝜒* ( *𝑡* ) *},*

and this correlation function is then calculated using path integrals analytically at each time point *𝑡* .

If one considers that the electronic part of the transition dipole varies with nuclear displacements and we allow for
it to depend on the normal coordinates ( **Q** ), such as:


*𝑄* *𝑖* + *. . .,* (7.278)
⃒⃒⃒⃒ **Q** =0


*⃗𝜇* *[𝑒]* ( **Q** ) = *⃗𝜇* *[𝑒]* 0 [+] ∑︁

*𝑖*


*𝜕⃗* *𝜇* *[𝑒]*

*𝜕𝑄* *𝑖*


we can even include vibronic coupling or the so-called Herzberg-Teller (HT) effect. The Frank-Condon (FC)
approximation keeps only the coordinate-independent term. The correlation function for the HT cases can then be
derived recursively from the FC one and the calculation is done quite efficiently. It is important to say the one must
choose ONE set of coordinates in order to expand the transition dipole. In our formulation, it is always that of the
FINAL state and that has some implications discussed below.

**7.45. More on the Excited State Dynamics module** **955**

**ORCA Manual** **,** **Release 6.0.1**

Other important aspect of this theory is that, in order to solve the path integrals, one has to work in one set of
coordinates, the initial ( **Q** ) or the final state ones ( **Q** **[¯]**, with the bar indicating final coordinates). As we have a
transition matrix element, one set of coordinates have to be transformed into the other and it is easy to show that
they are related by

**Q** = **JQ** **[¯]** + **K** *.* (7.279)

That was first proposed by Duschinsky in the late 1930s[228] with the Duschinsky rotation matrix **J** and the
displacement vector **K** defined as

**J** = **L** [T] *𝑥* **[¯L]** *[𝑥]* *[,]* **K** = **L** [T] *𝑥* [(] **[¯q]** **[0]** *[−]* **[q]** **[0]** [)] *[,]*

with **L** *𝑥* being the matrix containing the normal modes, here described in Cartesian coordinates ( *𝑥* ), and **q** **0** begin
mass weighted coordinates ( *𝑞* *𝑖* = *[√]* *𝑚* *𝑖* *𝑥* *𝑖* ).

The program runs by first reading and obtaining the initial and final state geometries and Hessians, then computes
the Duschinsky rotation matrix and displacement vector, calculates the derivatives for the transition dipoles and
computes the correlation function. After that, the DFT is done and the rates are obtained and printed when necessary. As the intensities observed experimentally are proportional to the rates, the spectrum is also calculated
and printed on a BASENAME.spectrum file. If PRINTLEVEL HIGH is requested under %ESD, the correlation
function is also printed on a BASENAME.corrfunc file.

OBS: The units for the Emission spectra are rather arbitrary, but for Absorption they are the experimental “molar
absorptivity ( *𝜀* )” in L mol *[−]* [1] cm *[−]* [1] [199]. Be aware that these are dependent on the line width of the curves.

**Approximations to the excited state PES**

As already mentioned in Sec. *Excited State Dynamics*, in order to predict the rates we need at least a ground state
(GS) and an excited state (ES) geometry and Hessian. In ORCA, we have seven different ways to approximate this
ES PES: AHAS, VH, VG, HHBS, HHAS, UFBS and UFAS. Those can can be choosen by setting the HESSFLAG
under %ESD. If you actually optimize the ES geometry and input the Hessian, that will be called an Adiabatic
Hessian (AH) method an no keyword must be given on the input.

OBS: In the present version, these approximations are only available for Absorption, Fluorescence and resonant
Raman. They cannot be directly used for phosphorescence and ISC rate calculations. However, one can do the
latter calculations by generating approximate ES Hessians from “fake” fluorescence or absorption runs, and then
using the ES Hessians in AH calculations (vide infra).

The idea behind these approximations is to do a geometry update step ( **ΔS** = *−* **gH** *[−]* **[1]** for Quasi-Newton and
**ΔS** = *−* **g** ( **H** + **S** ) *[−]* **[1]** for Augmented Hessian) to obtain the ES structure and somehow approximate the ES Hessian. The gradient ( **g** ) and Hessian ( **H** ) used on the step are on column Step of Table Table 7.28 below, with a
description of the final ES Hessian:

Table 7.28: Methods used to estimate the ES PES

**956** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

OBS: Always use the GS geometry on the input file, equal to the one in the GSHESSIAN! If you asked for OPT
FREQ at the input, a .xyz file is generated with the same geometry found on the .hess. If you picked the geometry
from the .hess file, remember that it is in atomic units, so you have to use BOHRS on the main input.

After the calculation of the ES PES, a file named BASENAME.ES.hess is printed and can be used in future calculations. For example, one can use it in a separate AH calculation, as if the file contains the optimized ES geometry
and the exact ES Hessian (of course, in reality both are approximate). This allows one to perform e.g. phosphorescence and ISC rate calculations with approximate ES PESs even though ESD does not support these calculations
directly. For example, the phosphorescence rate from a triplet state to the *𝑆* 0 state, with the VG approximation for
the triplet PES and the ES gradient computed at the TDDFT level, can be computed as follows:

  - Run an ESD fluorescence calculation using the VG approximation, but where “IROOTMULT TRIPLET”
is added to the %TDDFT block. The resulting rate and spectrum are not meaningful, but the BASENAME.ES.hess file generated from this calculation is the correct VG approximation to the triplet PES.

  - Run an ESD phosphorescence calculation using the AH method, with the aforementioned BASENAME.ES.hess file as the TSHESSIAN.

This way, the first ESD calculation only uses the information of the scalar triplet state in computing the VG step,
while the second ESD calculation only uses the SOC-corrected states. The same ES Hessian file can therefore be
used in the calculations of all three spin sublevels of the triplet state.

In addition to the BASENAME.ES.hess file, if there was any updates on the GS Hessian, like transition dipole
derivatives, a BASENAME.GS.hess is also printed.

  - The step can be controlled with the GEOMSTEP flag, with QN or AUGHESS options.

  - Currently all ES Hessians are calculated numerically, if you want to change the parameters related to the
frequency calculations, you can do that under %FREQ (Sec. *Vibrational Frequencies* ). The numerical
gradient settings are under %NUMGRAD (Sec. *Numerical Gradients* ).

  - The ES hybrid Hessian is calculated in the same way as described in Sec. *Hybrid Hessian*, except that the
“model” Hessian is the GS one.

  - The ES Hessian with updated frequencies is recalculated from the same GS normal modes, after an update
on the frequencies, as **H** *𝑢𝑝* = **L** *𝜔* [2] *𝑢𝑝* **[L]** *[𝑇]* [. With] **[ L]** [ being the normal modes and] *[ 𝜔]* *[𝑢𝑝]* [the updated frequencies,]
with negative sign being kept after the square.

  - The frequencies are updated depending on a calculation of the energy after a given step. If the ES modes
are equal to the GS, then a step over a coordinate *𝛿𝑞* *𝑖* that would result in an energy difference *𝛿𝐸* is given

by *𝛿𝑞* *𝑖* = ( *−* ~~*√*~~ *[𝑔]* *𝜔* *[𝑖]* *𝑖* + *√* *𝜔𝑔* *𝑖* *𝑖* [2] + 2 *𝛿𝐸𝜔* *𝑖* ) */𝜔* *𝑖* . The default *𝛿𝐸* used is 10 *[−]* [4] Eh, in general above the error of the

methods. If the error in energy after the step is larger than a threshold given by the UPDATEFREQERR flag
(default 0.20 or 20%), the gradients are calculated and the frequency recomputed. If not not, that mode and
frequency are assumed to be the same.

  - The Updated Frequencies method can greatly accelerate the calculation of the Hessian, for much fewer gradient calculation are necessary, although you do not correct the modes. Also, the derivatives over the modes
are already computed simultaneously.

  - The expected energy error *𝛿𝐸* can be changed using the UF_DELE flag.

  - The default method is the VG, but the AHAS is more trustworthy for unknown systems, although a lot heavier
(Sec. *A better model, Adiabatic Hessian After a Step (AHAS)* and [199]).

  - Always check the sum of *𝐾* *𝑖* [2] [printed on the output. If that number is too high (above 8 or so), it means that]
the geometries are too displaced and the theory might not work on these cases (check for different coordinate
systems then, Sec. *Normal modes coordinate systems* ).

  - Also check for RMSD between the geometries after a step. If the difference is too big, there might be
problems with the step.

**7.45. More on the Excited State Dynamics module** **957**

**ORCA Manual** **,** **Release 6.0.1**

**Mixing methods**

In principle, it is possible to use different methods to compute different parts needed for the `ORCA_ESD` module.
You could, for instance use (TD)DFT analytical gradients for the ground/excited state geometries and Hessians and
a more elaborate method such as STEOM-CCSD to get the energies and transition dipoles. If you want to do that,
just input the Hessians and use the DELE flag for the energy difference between the states - at their own geometry!

- and TDIP x,y,z to input the transition dipole. If there is SOC and the transition dipole is complex, use TDIP
x.real, x.imag, y.real, y.imag, z.real, z.imag. The program will automatically detect each case. If you don’t input
these, they will be obtained by the module during the run, so you can set the excited method you want and let the
program figure out DELE and TDIP.

OBS: It is not advisable to mix different levels of theory during a geometry step though. If you obtained a GS
Hessian from DFT, doing a step based on a CASSCF ES numerical gradient might not lead to reasonable results.
The same would be problematic even for different DFT functionals.

**Removal of frequencies**

If, after calculating an ES Hessian you end up with negative frequencies, the calculation of the correlation function
might run into trouble. The default for the module is to turn all negative frequencies positive, printing a warning
if any of them was lower than -300 cm *[−]* [1] . If that is the case, you are probably on a saddle point and not even a
minimum, so results should be taken with care,

You can also choose to completely remove the negative frequencies (and the corresponding from the GS), by setting
IFREQFLAG REMOVE or leave them as negative with IFREQFLAG LEAVE under %ESD.

Sometimes, low frequencies have displacements that are just too large (check on the **K** vector), or the experimental
low frequency modes are too anharmonic and you might want to remove them. It is also possible to do that setting
the TCUTFREQ flag (in cm *[−]* [1] ), and all frequencies below the given threshold will be removed.

**Normal modes coordinate systems**

When working with systems with weak bonds, such as hydrogen bonds and *𝜋* stacking, or with biphenyls and
similar planar molecules it is common that there will be low frequency-high amplitude modes related to the angular
bending. It has been shown that, in some cases, the normal modes transformed from Cartesian coordinates might
be not sufficient to describe systems with these large amplitude motion [149]. In those, the definition of normal
modes in terms of some curvilinear set of coordinates such as the internal ones are more suitable.

The first order transformation from Cartesian ( **x** ) to internal ( **s** ) coordinates is given by Wilson’s **B** matrix[426] as

**s** = **B** ( **x** *−* **x** **0** ) *,* (7.280)

and here we use Baker’s[68] delocalized internal coordinates as default. First, a redudant set is build and an
singular value decomposition of the **G** = **BB** *[𝑇]* matrix is performed to obtain the non-redundant set. The latter
can be generated by **B** *[′]* = **U** *[𝑇]* **B**, where **U** are the eigenvectors correponding to non-zero eigenvalues of **G** . Then
an orthogonal set is contructed from **B** *[′′]* = **G** *[′−]* [1] *[/]* [2] **U** *[𝑇]* **B** . As the eigenvectors are not conitnuous functions of
the coordinates, in order to avoid using an arbitrary selection, we will follow the work of Reimers[715] and set
**G** *[−]* [1] *[/]* [2] **U** *[𝑇]* = **G** **[¯]** *[−]* [1] *[/]* [2] **[ ¯]** **U** *[𝑇]*, or use the same transformation for the initial an final coordinates. Please note that this
may lead to numbers larger than 1 on the Duschinsky rotation matrix, for it is an approximation and the calculated
rates may vary a little. The normal modes in internal coordinates ( **L** *𝑠* ) are then obtained from those in Cartesian
ones ( **L** *𝑥* ) as

**L** *𝑠* = **B** *[′′]* **M** [1] *[/]* [2] **L** *𝑥* *,* (7.281)

and the Duschinsky relation ((7.279)) still holds[149], with the displacement vector being simply

**K** *𝑠* = **L** *[𝑇]* *𝑠* [(] **[¯s]** *[ −]* **[s]** [)] *[.]* (7.282)

The options available for coordinate systems can be set under COORDSYS, and can be CARTESIAN, INTERNAL
(for Baker delocalized - default), WINT (for weighted internals following Swart and Bickelhaupt [838]), FCWL
(force constant weighted following Lindh [526]) and FCWS (same as before, but using Swart’s model Hessian).

**958** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

OBS: Calculating in internal coordinates is usually better but not necessarily. If something goes wrong, you may
also want to try the Cartesian option.

**Geometry rotation and Duschinsky matrices**

The electronic transition should not to take place simultaneously with translations and rotations[747] of the molecular structure. Before further calculations take place, the initial and final state structures are superimposed to
satisfy Eckart’s conditions by obtaining a rotation matrix B that ensures [∑︀] *𝑚* *𝑖* (B **R** **i** *×* **R** **[¯]** **i** ) = 0 [239], with **R**
being Cartesian coordinates. As the initial geometry is rotated, so must be the corresponding normal modes **L** *𝑥*
also. This can be turned of by setting the flag USEB FALSE.

By the default the Duschinsky rotation matrix is set to Identity, to take advantage of our much faster algorithm.
To turn that on, just set USEJ TRUE. You can check the “diagonality” of this matrix by looking at the Diagonality
Index (DI), here defined as √︁∑︀ *𝑖* **[J]** *𝑖𝑖* [2] *[/]* [ ∑︀] *𝑖𝑗* **[J]** *𝑖𝑗* [2] [. A DI=1 would be a perfectly diagonal matrix. The amount of]

mixing between modes is rpresented by the Mixing Index, with is here is given by *⟨|𝐽* *𝑚𝑎𝑥* *|⟩*, or the average value
of the maximum *𝐽* *𝑖* of each line. If DI=1, it means each normal coordinate from the initial state is equal to a mode
of the final state. When USEJ=TRUE, the largest components of the **J** matrix are printed along with the **K** vector,
so you can have a better idea of how the mixing is occuring.

**Derivatives of the transition dipole**

The derivatives of the transition dipoles with respect to the normal coordinates of the final state can be obtained
directly from the derivatives with respect to the Cartesian coordinates as

**U** ( **Q** **[¯]** ) = **L** **[¯]** *[𝑇]* *𝑥* **[M]** *[−]* [1] *[/]* [2] **[U]** [(] **[¯R]** [)] *[,]* (7.283)


*𝑖* **[J]** *𝑖𝑖* [2] *[/]* [ ∑︀]


*𝑖𝑗* **[J]** *𝑖𝑗* [2] [. A DI=1 would be a perfectly diagonal matrix. The amount of]


**U** being the matrix of the x,y and z components of the derivative, **M** a 3 *𝑁* *×* 3 *𝑁* matrix with the atomic masses
along the diagonal. Also, in case one already has the derivatives with respect to the initial state, those can be
transformed into the derivatives with respect to the final state by using the Duschinsky relation, assuming that
*⃗𝜇* *[𝑒]* 0 [(] **[¯Q]** [) +][ ∑︀] *𝑖* *𝜕⃗* *𝜇* [¯] *[𝑒]* *[𝑄]* [¯] *[𝑖]* [=] *[ ⃗𝜇]* 0 *[𝑒]* [(] **[Q]** [) +][ ∑︀] *𝑖* *𝜕⃗* *𝜇* *[𝑒]* *[𝑄]* *[𝑖]* [, so that]


*𝜕⃗* *𝜇* *[𝑒]*
*𝑖* *𝜕* [¯]


*𝜕⃗* *𝜇* *[𝑒]*
*𝑖*


*𝜇*

*𝜕𝑄* *𝑖* *[𝑄]* *[𝑖]* [, so that]


*𝜇*

*𝜕𝑄* [¯] *𝑖* *[𝑄]* [¯] *[𝑖]* [=] *[ ⃗𝜇]* 0 *[𝑒]* [(] **[Q]** [) +][ ∑︀]


*𝜕⃗* *𝜇* *[𝑒]*


*𝜕⃗* *𝜇* *[𝑒]*
**J** *𝑗𝑘*

*𝜕𝑄* *𝑗*

*𝑗*


*𝜇*

=
*𝜕𝑄* [¯] *𝑘* ∑︁


*.*
(7.284)
*𝜕𝑄* *𝑗*


By default, this transformation is NOT done, since Eq. (7.284) is an approximation. If you want to turn it on, set
CONVDER TRUE under %ESD.

OBS: Remember that, if you already have the Cartesian derivatives over the final state, like if you use AHAS for
an absorption spectrum, the conversion should be exact (although there might be numerical issues, always use a
larger GRAD for frequencies!).

Alternatively, these can be calculated numerically from displacements over each normal mode. In this case, it is
convenient to use the dimensionless normal coordinates *𝑞* *𝑖* = *𝜔* *𝑖* [1] *[/]* [2] *𝑄* *𝑖* which represent proportional displacements
on the PES [678]. We use ∆ *𝑞* = 0 *.* 01 by default, but this can be changed setting the DER_DELQ flag.

  - Again, DO NOT MIX different coordinates systems. If the derivatives were calculated over one coordinate
set and you decide to change it, it has to be recalculated. You can manually delete them from the BASENAME.ES.hess file.

  - For hybrid functionals, you can choose to use DFT for the gradient, energy and transition dipole, and the fast
simplified TDA (Sec. *Simplified TDA and TD-DFT* ) only for the derivatives by seting STDA TRUE under
%ESD.

  - A simple trick can be used to accelerate the computation of derivatives. If the first displacement gives a
transition dipole that is too close to the reference, then the derivative can be assumed to be small and just the
plus displacement may be taken to compute the derivative (with an usually small error). If it is large enough,
then the minus displacement is also done and central differences is used. This is the default method and can
be turned off by setting FASTDER to FALSE.

  - The central differences option can be altogether turned off by setting CENTRALDIFF FALSE under %ESD.

**7.45. More on the Excited State Dynamics module** **959**

**ORCA Manual** **,** **Release 6.0.1**

  - If you are having problems, set a larger PRINTLEVEL to check the individual calculation of the derivatives,
you might be having some kind of root flipping during the displacement, or some other issue.

**The Fourier Transform step**

After the calculation of the correlation function, it is necessary to do a Fourier Transform (FT) step. To do that
numerically, it is needed to correctly choose the grid in wich the time points will be computed, for that affects how
the results will be obtained in the frequency domain. We have developed a method to generate an optimal set of
parameters, depending on the final spectral resolution desired [199] and it will be used by default. Even so, you
can choose your own grid by setting the NPOINTS and MAXTIME (in atomic units!) flags under %ESD. There
are a few comments related to that:

  - Because we solve the FT using a very efficient Cooley-Tukey algorithm, the NPOINTS should be always
multiple of two. You can put any number on the input, but the next larger multiple of two will be calculated
and set.

  - The MAXTIME should be enough so that the correlation function goes to zero. If anything goes wrong,
please check the BASENAME.corrfunc file for that.

  - The finer the spectral resolution chosen with SPECRES, the largest MAXTIME must be.

  - If you have a larger MAXTIME, you also must increase NPOINTS, otherwise the grid will be too sparse and
many oscillations will be skipped.

**Spectrum options**

The final spectrum is saved in a BASENAME.spectrum file, with the total spectrum, the FC and HT parts discriminated, as explained in Sec. *Excited State Dynamics* . He are some detailed about it:

  - The range for which the spectrum is saved is given by default, but it can be set using SPECRANGE flag
under %ESD, as SPECRANGE 10000,70000.

  - All of the INPUT units should always be in CM-1, but you can choose the OUTPUT units by setting the
UNIT flag to CM-1, NM or EV.

  - In order to better converge the correlation function and approximate experimental spectra, a lineshape function can be used instead of the delta. The default is to use a LOREZENTIAN lineshape, but LINES can be
set to DELTA, LORENTZ, GAUSS or VOIGT.

  - The DELTA lineshape might lead to a correlation function that oscillates forever, so please take care with
that option.

  - The default line widths are LINEW 50 and INLINEW 250.

  - If you use a VOIGT lineshape, the Gaussian width can be controlled separately using the INLINEW flag.
By default, it will be proportial to the Lorezntian to reach the same FWHM.

  - The LINEW and INLINEW are NOT the full width half maximum ( *𝐹𝑊𝐻𝑀* ) of these curves. However
they are related to them by: *𝐹𝑊𝐻𝑀* *𝑙𝑜𝑟𝑒𝑛𝑡𝑧* = 2 *× 𝐿𝐼𝑁𝐸𝑊* and *𝐹𝑊𝐻𝑀* *𝑔𝑎𝑢𝑠𝑠* = 2 *.* 355 *× 𝐼𝑁𝐿𝐼𝑁𝐸𝑊* .
For the VOIGT curve, it is a little more complicated but in terms of the other FWHMs, it can be a p roximated

as *𝐹𝑊𝐻𝑀* *𝑣𝑜𝑖𝑔𝑡* = 0 *.* 5346 *× 𝐹𝐻𝑊𝑀* *𝑙𝑜𝑟𝑒𝑛𝑡𝑧* + ~~√~~ (0 *.* 2166 *× 𝐹𝑊𝐻𝑀* *𝑙𝑜𝑟𝑒𝑛𝑡𝑧* [2] [+] *[ 𝐹𝑊𝐻𝑀]* *𝑔𝑎𝑢𝑠𝑠* [2] [)][.]

  - The resolution of the spectrum can be modified with the SPECRES flag. By default it is a fraction of the
LINEW. Please be aware that higher resolution (smaller SPECRES), mean a larger grid for the correlation
function and more time points to calculate on.

**960** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**General**

  - The temperature is accounted for exactly on Absorption and Emission [199] and can be set using the TEMP
flag.

  - PRINTLEVEL can be set to HIGH in order to print more details, including Huang-Rhys factors which are
useful for rationalizing the contribution of different vibrational modes to the rate/spectrum.

  - The frequencies read from the Hessian files can be scaled by any number by setting the SCALING flag under
%ESD. The default is 1.0.

  - If necessary, the transition dipole can also be scaled by setting the TDIPSCALING flag.

  - If you just want to compute an ES PES and stop, set WRITEHESS to TRUE and the correlation function
will be skipped.

  - In order to make use of the fastest algorithm, set SAMEFREQ to TRUE and the DO method will be used,
assuming equal Hessians between initial and final states and maximizing the efficiency when calculating the
correlation function.

  - If you want to calculate phosphorescence rates, you MUST input the adiabatic energy difference DELE
manually (the energy difference between each state at its own geometry). And, of course, don’t forget to set
the SOC module to true.

**7.45.2 Intersystem crossing rates**

**General Aspects of the Theory**

Intersystem crossing (ISC) rates between a given initial state *𝑖* and a final state *𝑓* can be calculated from Fermi’s
Golden rule:

*𝑘* ( *𝜔* ) *𝑖𝑓* = [2] *[𝜋]* (7.285)

ℏ *[|⟨]* [Ψ] *[𝑓]* *[|][𝐻]* [ ̂︀] *[𝑆𝑂]* *[|]* [Ψ] *[𝑖]* *[⟩|]* [2] *[𝛿]* [(] *[𝐸]* *[𝑖]* *[−]* *[𝐸]* *[𝑓]* [)] *[,]*

which is quite similar to the Eq. (7.275) for Fluorescence, except for the frequency term. The same trick used there
can be applied here to swtich to the time domain. Then, we are left with a simple time integration, which is not
anymore difficult to solve than the equations above.

One can use all of the infrastructure already presented to compute these ISC rates, including Duschisnky rotation, vibronic coupling effects, use of different coordinate systems and so on. Right now, its use is optimized for
CIS/TDDFT, as explained in Section *ISC, TD-DFT and the HT effect*, but it can be applied in general by combining
simpler methods to obtain the geometries and Hessians with more advanced methods to compute the SOC matrix
elements, when needed.

**Tips and Tricks**

  - The DELE must be given when using ESD(ISC), it is not automatically computed.That is the energy of the
initial state minus the energy of the final state, each at its own geometry.

  - A SOC matrix element calculated from any method can be given on the input using the SOCME Re, Im flag,
where these are the real and imaginary parts of that number.

  - The SOCMEs from TD-DFT are not bad, maybe except for those between the ground singlet and the triplets.
In that case, a multireference calculation might be the preferred option.

  - If the final state is higher in energy than then initial state, the DELE is a negative number. In that case, there
is barrier to go up when doing the ISC and the rates becomes more sensitive to the temperature.

  - In contrast to Fluorescence, the ISC rates depend strongly on the inclusion of Duschisnky rotations, please
take care when using USEJ FALSE.

  - The default LINES is GAUSS, and the default INLINEW of 250 *𝑐𝑚* *[−]* [1] might be too large. One should
always investigate it by varying the width a bit. Other LINES can increase the error, please take care when
changing it.

**7.45. More on the Excited State Dynamics module** **961**

**ORCA Manual** **,** **Release 6.0.1**

**7.45.3 Resonant Raman Spectrum**

**General Aspects of the Theory**

Raman intensities can be obtained in many different ways, depending on the experimental set up. As discussed
extensively by D. A. Long [197, 533], the part of it that is “set up independent” is the Scattering Factor (or Raman
activity), given by:

*̸*

*̸*

*̸*


2 2
*𝐶* *𝑚*
*𝑆* = 45 *𝑎* [2] + 7 *𝛾*
(︂ *𝑎𝑚𝑢𝑉* [2]

*̸*

*̸*

*̸*


*,* (7.286)
)︂

*̸*

*̸*

*̸*


where the *𝑎* is related to the isotropic part of the “transition polarizability” between an initial state and a final state

ˆ
with a different vibrational quantum number *⟨* Ψ *𝑓* *|𝛼|* Ψ *𝑖* *⟩* = *𝛼* *𝑖𝑓* :

*𝑎* = [1]

3 *[|]* [(] *[𝛼]* *[𝑥𝑥]* [+] *[ 𝛼]* *[𝑦𝑦]* [+] *[ 𝛼]* *[𝑧𝑧]* [)] *[|]*

and *𝛾* is also related to its off-diagonal elements:

*𝛾* = [1]

2 [[] *[|]* [(] *[𝛼]* *[𝑥𝑥]* *[−]* *[𝛼]* *[𝑦𝑦]* [)] *[|]* [2] [ +] *[ |]* [(] *[𝛼]* *[𝑦𝑦]* *[−]* *[𝛼]* *[𝑧𝑧]* [)] *[|]* [2] [ +] *[ |]* [(] *[𝛼]* *[𝑧𝑧]* *[−]* *[𝛼]* *[𝑥𝑥]* [)] *[|]* [2] [ + 6(] *[|][𝛼]* *[𝑥𝑦]* *[|]* [2] [ +] *[ |][𝛼]* *[𝑦𝑧]* *[|]* [2] [ +] *[ |][𝛼]* *[𝑥𝑧]* *[|]* [2] [)]] *[.]*

This transition polarizability itself can be computed using Kramers, Heisenberg and Dirac (KHD) formalism and
it can be shown that each of its Cartesian components can be calculated as a sum-over-states:

*̸*

*̸*

*̸*


)︂

*̸*

*̸*

*̸*


*𝛼* *[𝑖𝑓]* [1]
*𝜌𝜎* [=] ℏ

*̸*

*̸*

*̸*


∑︁

*𝑛* = *̸* *𝑖,𝑓*

*̸*

*̸*


∆ *𝐸* *𝑛𝑖* + *𝜔* *𝑙𝑎𝑠𝑒𝑟* + *𝑖𝛾* *𝑙𝑡*

*̸*

*̸*

*̸*


*⟨* Ψ *𝑓* *|𝜇* *𝜌* *|* Ψ *𝑛* *⟩⟨* Ψ *𝑛* *|𝜇* *𝜎* *|* Ψ *𝑖* *⟩*
(︂ ∆ *𝐸* *𝑛𝑖* *−* *𝜔* *𝑙𝑎𝑠𝑒𝑟* + *𝑖𝛾* *𝑙𝑡*

*̸*

*̸*

*̸*


*𝑓* *|𝜇* *𝜌* *|* Ψ *𝑛* *⟩⟨* Ψ *𝑛* *|𝜇* *𝜎* *|* Ψ *𝑖* *⟩*

+ *[⟨]* [Ψ] *[𝑓]* *[|][𝜇]* *[𝜌]* *[|]* [Ψ] *[𝑛]* *[⟩⟨]* [Ψ] *[𝑛]* *[|][𝜇]* *[𝜎]* *[|]* [Ψ] *[𝑖]* *[⟩]*
∆ *𝐸* *𝑛𝑖* *−* *𝜔* *𝑙𝑎𝑠𝑒𝑟* + *𝑖𝛾* *𝑙𝑡* ∆ *𝐸* *𝑛𝑖* + *𝜔* *𝑙𝑎𝑠𝑒𝑟* + *𝑖𝛾* *𝑙𝑡*

*̸*

*̸*

*̸*


(7.287)

*̸*

*̸*

*̸*


*̸*

In (7.287), the sum is over any number of electronic excited states *𝑛*, ∆ *𝐸* *𝑖𝑛* is the energy difference between the
initial state and the excited, *𝜔* *𝑙𝑎𝑠𝑒𝑟* is the laser energy and *𝛾* *𝑙𝑡* is the lifetime broadening to avoid a zero on the
denominator. If we work with a laser for which the frequency is close to the excited state energy difference, the
first term is much larger than the second and can approximate alpha by

*̸*

*̸*


*̸*

*.*
(7.288)
)︂

*̸*

*̸*


*̸*

*𝛼* *[𝑖𝑓]*
*𝜌𝜎* *[≃]* ℏ [1]

*̸*

*̸*


*̸*

∑︁

*𝑛* = *̸* *𝑖,𝑓*

*̸*


*̸*

*⟨* Ψ *𝑓* *|𝜇* *𝜌* *|* Ψ *𝑛* *⟩⟨* Ψ *𝑛* *|𝜇* *𝜎* *|* Ψ *𝑖* *⟩*
(︂ ∆ *𝐸* *𝑛𝑖* *−* *𝜔* *𝑙𝑎𝑠𝑒𝑟* + *𝑖𝛾* *𝑙𝑡*

*̸*

*̸*


*̸*

*̸*

This equation can be solved using a path integral approach by switching to the integral form of 1 */𝑥* :

*̸*


*̸*

*̸*

1 *[𝑖]*
*𝑥* [=] ℏ

So that the components of *𝛼* *𝑖𝑓* can be given by:

*̸*


*̸*

*̸*

*∞*

*𝑒* *[−][𝑖𝑥𝑡/]* [ℏ] *𝑑𝑡* (7.289)

∫︁ 0

*̸*


*̸*

*̸*

*∞*

*⟨* Ψ *𝑓* *|𝜇* *𝜌* *|* Ψ *𝑛* *⟩⟨* Ψ *𝑛* *|𝜇* *𝜎* *|* Ψ *𝑖* *⟩𝑒* *[−][𝑖𝑡]* [(Δ] *[𝐸]* *[𝑖𝑛]* *[−][𝜔]* *[𝑙𝑎𝑠𝑒𝑟]* *[−][𝑖𝛾]* *[𝑙𝑡]* [)] *𝑑𝑡* (7.290)

*̸* ∫︁ 0


*̸*

*̸*

*𝛼* *[𝑖𝑓]*
*𝜌𝜎* *[≃]* ∑︁

*𝑛* = *̸* *𝑖,𝑓*


*̸*

*̸*

*𝑖*

ℏ [2]

*̸*


*̸*

*̸*

*̸*

From here on, it is possible to show that the *𝛼* *𝜌𝜎* *[𝑖𝑓]* [can be calculated as an integral of a correlation function [][197][],]
which is similar to the one previously discussed. In order to calculate that, a path integral scheme is also used
and a geometry and Hessian for the ES are needed. The `ORCA_ESD` module predicts the ES PES (if not inputed),
computes the *𝛼* *𝑖𝑓* and then prints the Scattering factor on a spectrum named BASENAME.spectrum.LASERE.

OBS.: The actual Raman Intensity collected with any polarization at 90 degrees, the I( *𝜋/* 2; *‖* *[𝑠]* + *⊥* *[𝑠]* *, ⊥* *[𝑖]* [533]),
can be obtained by setting RRINTENS to TRUE under %ESD.

OBS2.: In the current implementation, if a multistate calculation is requested, Eq. (7.288) is solved for each state
and all spectra are summed up afterwards.

**962** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**Specific Keywords and Details**

In order to solve Eq. (7.290), the same information as for Absorption/Emission is needed and to compute the
ES PES all of the above approximations are also valid. The main difference here is that a laser energy, given by
the LASERE flag, should be given. If it is not given, the default is to set it to the 0-0 energy difference between
the ground and the excited state. As mentioned before, more information can be found on Sec. *Resonant Raman*
*Spectrum* .

  - You can choose more than one laser energy by setting LASERE 1,2,3,4 and etc. If so, each spectrum will be
saved on a different BASENAME.spectrum.LASERE file.

  - You can also choose more than one excited state to be accounted for with the flag STATES 1,2,3, etc. and the
final spectrum will be the sum of all of Scattering Factors given by the *𝛼* *𝑖𝑓* s. You can NOT choose several
states and laser energies currently.

  - The automatic selection for the integral grid is also done based on the same ideas as mentioned before.

  - The default lineshape for resonant Raman is VOIGT.

  - The lineshape of the RR spectra will be taken from the RRSLINEW flag. In this case, LINEW and INLINEW
are used only in the calculation of the correlation function.

  - Currently the only temperature for which this model works is at 0K.

  - In terms of which vibrationally excited states to be considered, currently it goes up to Raman Order 2, which
means fundamentals, first overtones and combination bands (up to a total quantum number of 2). You can
reduced that using RORDER flag.

  - It is also possible to include HT effect here for weak transitions, but be aware the calculation is much more
costly. Due to technical reasons, the data is saved only on memory so, if you plan to go being 300 modes
and do HT, there should be A LOT of memory available, about 8 *× 𝑁𝑀𝑂𝐷𝐸𝑆* [4] . Also, you should expect
a VERY long time for the computation of the correlation function. We are currently working on ways to
accelerate this particular case.

  - As it is explained on the reference paper [197], the calculations using both Duschinsky rotation and HT effect
can be greatly accelerated setting cutoffs for the derivatives and J matrix elements. The RRTCUTDER is a
ratio with respect to the transition dipole moment below which the derivatives will be ignored and RRTCUTJ
is a cutoff for J matrix elements. As the paper suggests, RRTCUTDER = 0.001 and RRTCUTJ = 0.01 are
in general good numbers. We do recommend using these, but please be aware of the specific needs of your

system.

**7.45.4 Circular Polarized Spectroscopies**

**General Aspects of the Theory**

Starting from ORCA 6, the ESD module has been expanded to include calculations of CP rates and spectra for chemical system. This enables the computation of the vibronic effect on ECD, CPF, and CPP spectra. The methodology
is generally similar to the interaction of unpolarized light with matter, including absorption and photoluminescence.
However, when a CP photon interacts with an optically active system, the electric field of the photon induces a linear
displacement of the charge (transition electric dipole), while the magnetic field induces a circulation of the charge
(transition magnetic dipole). These combined interactions cause an electron to be excited in a helical motion,
involving both translation and rotation, along with their associated operators.

In a commonly use practice by defining a laboratory frame in which the z-axis defines the direction of the light
1
trajectory, CP light interactions can be generated with the use of the complex vectors *ℰ±* = ~~*√*~~ 2 [(ˆ] *[𝑥]* *[±][ 𝑖][𝑦]* [ˆ][)]

In this framework the FFMIO operator transforms as:


T *[±]* IF [= 1] *[/]* [2]


*𝑁*
∑︁

*𝑗* =1


⟨︀I⃒⃒e *−* ikr j ( *𝜀∙* ˆp x )⃒⃒F⟩︀ *±* ⟨︀I⃒⃒e *−* ikr j ( *𝜀∙* ˆp y )⃒⃒F⟩︀ (7.291)


**7.45. More on the Excited State Dynamics module** **963**

**ORCA Manual** **,** **Release 6.0.1**

In both ECD and CPL (CPF or CPP) spectroscopies the measured intensities are related to the difference of absorption or luminescence of the left and right polarized transition moments given by:

∆ *[𝐿]* *𝐼𝐹* *[±][𝑅]* ( *𝑘, 𝜖* ) = *|𝑇* *[−]* *𝐼𝐹* *[|]* 2 *± |𝑇* + *𝐼𝐹* *[|]* 2 (7.292)

2
which leads to the following expressions for the sum and the difference of the square moduli *|𝑇* *𝐼𝐹* *[±]* *[|]* :


⃒⃒⃒⃒⃒⃒


∑︁ *𝑒* *[−][𝑖𝑘𝑟]* *[𝑗]* ( *𝜀* *∙* *𝑝* ˆ *𝑥* )

*𝑗* =1


⃒⃒⃒⃒⃒⃒


∑︁ *𝑒* *[−][𝑖𝑘𝑟]* *[𝑗]* ( *𝜀* *∙* *𝑝* ˆ *𝑦* )

*𝑗* =1


*𝐹*
⃒⃒⃒⃒⃒⃒


*𝐹*
⃒⃒⃒⃒⃒⃒


∆ *[𝐿]* *𝐼𝐹* [+] *[𝑅]* ( *𝑘, 𝜖* ) = 1 */* 2


*𝐼*

⟨


⟨


*𝑁*
∑︁


*𝐼*

⟩⟨


*𝑁*
∑︁


⟩


(7.293)


⃒⃒⃒⃒⃒⃒


⃒⃒⃒⃒⃒⃒


∑︁ *𝑒* *[−][𝑖𝑘𝑟]* *[𝑗]* ( *𝜀* *∙* *𝑝* ˆ *𝑦* )

*𝑗* =1


*𝐹*
⃒⃒⃒⃒⃒⃒


*𝐹*
⃒⃒⃒⃒⃒⃒


∆ *[𝐿]* *𝐼𝐹* *[−][𝑅]* ( *𝑘, 𝜖* ) = *−* **Im**


⎛

⎝


⟨


*𝐼*

⟩⟨


⟩⟨


*𝑁*
∑︁


(7.294)

⟩ [⎞] ⎠


*𝐼*


*𝑁*
∑︁


∑︁ *𝑒* *[−][𝑖𝑘𝑟]* *[𝑗]* ( *𝜀* *∙* *𝑝* ˆ *𝑥* )

*𝑗* =1


Hence within the ED approximation, ECD and CPL radiative transition rates can be calculated through the orientational average of Equation (4), employing the Fermi’s Golden rule:


*𝑘* *𝐸𝐶𝐷* ( *𝜔* ) = [16] *[𝜋]* [2] *[𝜔]* *[𝐸𝐶𝐷]*

3


∑︁ **Im** ( *|⟨* Ψ *𝐼* *|𝜇* ˆ *|* Ψ *𝐹* *⟩⟨* Ψ *𝐹* *|𝑚* ˆ *|* Ψ *𝐼* *⟩|* ) *𝛿* ( *𝐸* *𝐹𝐼* *± 𝜔* *𝐸𝐶𝐷* ) (7.295)

*𝐹*


*𝑘* *𝐶𝑃𝐿* ( *𝜔* ) = [16] *[𝜔]* *[𝐶𝑃𝐿]* [3] *[𝑛]* [2]


**Im** ( *|⟨* Ψ *𝐼* *|𝜇* ˆ *|* Ψ *𝐹* *⟩⟨* Ψ *𝐹* *|𝑚* ˆ *|* Ψ *𝐼* *⟩|* ) *𝛿* ( *𝐸* *𝐹𝐼* *± 𝜔* *𝐶𝑃𝐿* ) (7.296)

*𝐹*


3 *[𝐶𝑃𝐿]* ℏ *𝑐* [3] ∑︁


where *𝜔* *𝐸𝐶𝐷/𝐶𝑃𝐿* are the excitation and emission CP photon energies, respectively while *𝜔* *𝐹𝐼* are the energies
between the initial and final states reached in the absorption or the photoluminescent processes. Similarly *𝐸* *𝐹𝐼*
is the transition energy and *𝛿* refers to the line-broadening mechanism arising from the lifetimes of the relevant
final states and c is the speed of light. In the above expressions ˆ *𝜇* defines electric dipole operator while ˆ *𝑚* is the
respective magnetic dipole operator **Im** ( *|⟨* Ψ *𝐼* *|𝜇* ˆ *|* Ψ *𝐹* *⟩⟨* Ψ *𝐹* *|𝑚* ˆ *|* Ψ *𝐼* *⟩|* ) represents the rotatory strength ( ˆ *𝑚* = 2 *𝑚* 1 *𝑒* *𝑐* ∑︀ *𝑖* *[𝑟]* *[𝑖]* *[×]* [ ̂︀] *[𝑝]* *[𝑖]* [and] *[ 𝑚]* *[𝑒]* *𝑅* [is the electron mass. In the above expressions] *𝐼𝐹* ). As discussed above the transition rates

including the vibronic coupling, on the Frank-Condon (FC) and Herzenberg-Teller (HT) limits, can be efficiently
proceed through the path integral approach[199] in which it is possible to calculate *𝑘* *𝐸𝐶𝐷/𝐶𝑃𝐿* *[𝑜𝑏𝑠]* [from the Fourier]
Transform (FT) of the respective correlation function *𝜒* ( *𝑡* ) that is computed from the path integral of the multidimensional harmonic oscillator according to[785]:


*∞*
*𝑘* *𝐸𝐶𝐷/𝐶𝑃𝐿* *[𝑜𝑏𝑠]* [(] *[𝜔]* [) = 2] *[𝛼][ℛ][𝑒]* *𝜒* ( *𝑡* ) *𝑒* *[±][𝑖𝜔𝑡]* *𝑑𝑡* (7.297)
∫︁ 0


with *𝛼* being a collection of constants and for CP transition one-photon rates (ECD, CPL) considering electric
dipole and magnetic dipole interactions in the expression of the rotatory strengths it takes the form:[785]


*𝜒* ( *𝑡* ) = *𝑒* *[±][𝑖𝜔𝑡]* [ **Im** [ *𝜇* *𝑒* *𝑚* *[*]* *𝑒* []] *[ 𝜌]* *[𝐹𝐶]* [(] *[𝑡]* [) +] ∑︁ *𝑘* **Im** [︂ *𝜇* *𝑒* *𝜕𝑚𝜕𝑄* [¯] *𝑘* *[*]* *𝑒*


*𝜌*
]︂


*𝜕* *𝜇* *𝑒*
**Im**
*𝑘* [︂ *𝜕𝑄* [¯]


*𝜕* *𝜇* *𝑒*
**Im**
*𝑘𝑙* [︂ *𝜕𝑄* [¯] *𝑘*


*𝜌* *[𝐻𝑇]* *𝑘* ( *𝑡* )]
]︂


*𝜕𝑄* [¯] *𝑘*


*𝐻𝑇*
*𝑘* *𝐹𝐶* ( *𝑡* ) + ∑︁


*𝜕𝑄* [¯] *𝑘* *𝑚* *[*]* *𝑒*


*𝜌*
]︂


*𝐻𝑇*
*𝑘* *𝐹𝐶* ( *𝑡* ) + ∑︁


*𝜕𝑚* *[*]* *𝑒*
*𝜕𝑄* [¯] *𝑙*


(7.298)

where *𝜇* *𝑒* and *𝑚* *𝑒* represent the respective transition dipole *⟨* Ψ *𝐼* *|𝜇* ˆ *|* Ψ *𝐹* *⟩* and magnetic dipole *⟨* Ψ *𝐹* *|𝑚* ˆ *|* Ψ *𝐼* *⟩* moment
integrals between initial and final states *𝐼, 𝐹* while:

*𝜌* *[𝐹𝐶]* = *𝑇𝑟* ( *𝑒* *[−][𝑖]* *𝐻𝜏* [^] *𝑒* *−𝑖𝐻𝜏* [^] ) (7.299)

*𝜌* *[𝐻𝑇/𝐹𝐶]* *𝑘* = *𝑇𝑟* ( *𝑄* [¯] *𝑘* *𝑒* *−𝑖𝐻𝜏* [^] *𝑒* *−𝑖𝐻𝜏* ^ ) (7.300)

*𝜌* *[𝐻𝑇]* *𝑘𝑙* = *𝑇𝑟* ( *𝑄* [¯] *𝑘* *𝑒* *−𝑖𝐻𝜏* [^] *𝑄* ¯ *𝑙* *𝑒* *−𝑖𝐻𝜏* ^ ) (7.301)

where, these traces can be evaluated following the approach discussed in Ref[199].

Finally, it is quite commonly that the ECD and CPL spectral intensities are represented against normalized absorption and photoluminescent intensities defining, similar expressions for, the dissymmetry factors *𝑔* *𝑎𝑏𝑠* and *𝑔* *𝑙𝑢𝑚* :


*𝑔* *𝑎𝑏𝑠/𝑙𝑢𝑚* = 2 *[𝐼]* *[𝐿𝐶𝑃]* *[−]* *[𝐼]* *[𝑅𝐶𝑃]*

*𝐼* *𝐿𝐶𝑃* + *𝐼* *𝑅𝐶𝑃*


4 *𝑅*

*𝐷*


; *−* 2 *< 𝑔* *𝑎𝑏𝑠/𝑙𝑢𝑚* *<* 2 (7.302)
⃒⃒⃒⃒ *𝐺𝑆/𝐸𝑆𝑆𝑡𝑟𝑢𝑐𝑡𝑢𝑟𝑒*


Implying that the associated dissymmetry spectra can also be calculated, where D and R the square of the transition
dipole and the rotatory strength, respectively.

**964** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.45.5 Magnetic Circular Dichroism**

**General Aspects of the Theory**

The formulation presented for the calculation of the absorption spectrum may be extended to the absorption of
circularly polarized light (CPL) of a system under the effect of an external magnetic field in order to compute
the MCD spectrum.[268] By assuming an electric dipolar approximation under a length formulation for the lightmatter interaction, the molar absorptivity contribution by the transition between an initial state i and a final state f
of one fixed oriented molecule may be expressed as:

ˆ
*𝜖* ( *𝜔* ) *𝑖𝑓* = *𝛼𝜔|ℰ· ⟨* Ψ *𝑖* *|𝜇|* Ψ *𝑓* *⟩|* [2] *𝛿* ( *𝐸* *𝑖* *−* *𝐸* *𝑓* *±* ℏ *𝜔* ) (7.303)

where *ℰ* is the polarization vector of the incident light, and *𝛼* is a positive collection of constants.

By considering the case in which the light is propagating in the laboratory fixed ˆ *𝑧* *[′′]* direction, the circularly polarized
light is described by *ℰ* = ~~*√*~~ 1 2 [(ˆ] *[𝑥]* *[′′]* *[ ±][ 𝑖][𝑦]* [ˆ] *[′′]* [)][ where the “] *[−]* [” sign corresponds to the left circularly polarized light and]

the “+” to the right circularly polarized light.

Similarly, as the MCD calculations presented in section *Simulation of (Magnetic) Circular Dichroism and Absorp-*
*tion Spectra*, the total absorptivity may be obtained by summing over all possible transitions and averaging the
molecular orientations by using 3 rotation angles *𝜃*, *𝜑*, and *𝜒* .


2 *𝜋*
*𝜖* ( *𝜔* ) = *𝛼𝜔*
∫︁ 0


∫︁ 02 *𝜋*


∫︁ 0 *𝜋*


∑︁

*𝑖𝑓*


*𝜖* *𝑖*
*𝑒* *[−]* *𝑘𝐵𝑇* ˆ

*|ℰ· ⟨* Ψ *𝑖* *|𝜇|* Ψ *𝑓* *⟩|* [2] *𝑠𝑖𝑛* ( *𝜃* ) *𝛿* ( *𝐸* *𝑖* *−* *𝐸* *𝑓* *±* ℏ *𝜔* ) *𝑑𝜃𝑑𝜑𝑑𝜒* (7.304)
*𝑍*


Considering *𝜒* the angle which rotates the molecule in the plane perpendicular to the magnetic field perturbation
(which is colinear with the incident light propagation direction), the integrals of eq. (7.304) may be computed
conveniently in a seminumerical scheme by using an intermediate *𝑟* *[′]* frame.


∑︁

*𝛽𝛾* = *𝑥* *[′]* *,𝑦* *[′]*


*𝑤* *𝑝* ∑︁
*𝑝* *𝑖𝑓*


*𝜖* *𝑖*
*𝑒* *[−]* *𝑘𝐵𝑇*

*𝑍*


*𝜖* ( *𝜔* ) = *𝛼𝜔* ∑︁


ˆ ˆ
*ℰ* *𝛽𝛾* *⟨* Ψ *𝑖* *|𝜇* *𝛽* *|* Ψ *𝑓* *⟩⟨* Ψ *𝑓* *|𝜇* *𝛾* *|* Ψ *𝑖* *⟩𝛿* ( *𝐸* *𝑖* *−* *𝐸* *𝑓* *±* ℏ *𝜔* ) (7.305)


*𝑖𝑓*


where *𝜃* and *𝜑* values are defined by a point p in a numerical grid, *𝑥* *[′]*, and *𝑦* *[′]* are determined by *𝜃* and *𝜑* values
according to eq. (7.306), and *𝜒* has been integrated analytically in the *ℰ* *𝛽𝛾* values.

ˆ
*𝜇* ˆ *𝑥* *′* = *𝑐𝑜𝑠* ( *𝜃* ) *𝑐𝑜𝑠* ( *𝜑* ) *𝜇* *𝑥* *′′* + *𝑐𝑜𝑠* ( *𝜃* ) *𝑠𝑖𝑛* ( *𝜑* ) *𝜇* *𝑦* *′′* *−* *𝑠𝑖𝑛* ( *𝜃* ) *𝜇* *𝑧* *′′* (7.306)

*𝜇* *𝑦* *′* = *−𝑠𝑖𝑛* ( *𝜑* ) *𝜇* *𝑥* *′′* + *𝑐𝑜𝑠* ( *𝜑* ) *𝜇* *𝑦* *′′*


*±* 2 *𝜋*

*𝛽𝛾* [=]
∫︁ 0


*±*
*ℰ*


*ℰ* *𝛽* *[±]* *[ℰ]* *𝛾* *[±*]* *[𝑑𝜒]* (7.307)
0


Finally, by applying the Bohr-Oppenheimer approximation and writing the Dirac delta function in the time domain,

we get:


∑︁

*𝛽𝛾* = *𝑥* *[′]* *,𝑦* *[′]*


*𝜖* ( *𝜔* ) = *𝛼𝜔* ∑︁


*𝑤* *𝑝* ∑︁
*𝑝* *𝑖𝑓*


*𝜖* *𝑖*
*𝑒* *[−]* *𝑘𝐵𝑇*

*𝑍*


*ℰ* *𝛽𝛾* *⟨* Θ *𝑖* *|𝜇* ˆ *[𝑒]* *𝛽* *[|]* [Θ] *[𝑓]* *[⟩⟨]* [Θ] *[𝑓]* *[|][𝜇]* [ˆ] *[𝑒]* *𝛾* *[|]* [Θ] *[𝑖]* *[⟩]* *𝑒* *[𝑖]* [(] *[𝐸]* *[𝑖]* *[−][𝐸]* *[𝑓]* *[−][𝜔]* [)] *[𝑡]* *𝑑𝑡* (7.308)
∫︁


*𝑖𝑓*


and by taking the difference of absorbance between left and right CPL produce we reach an expression of the MCD

intensities:


∆ *𝜖* ( *𝜔* ) = *𝜖* *[−]* ( *𝜔* ) *−* *𝜖* [+] ( *𝜔* ) = *−* 2 *𝑍* *[𝛼]* *[𝜔]* ∑︁

*𝑖𝑓*


*∞*
*𝑤* *𝑝* *𝐼𝑚*
*𝑝* [︁ [∫︁] *−∞*


∑︁


*−∞* *𝜒* ˜( *𝑡, 𝑥* *[′]* *, 𝑦* *[′]* ) *𝑒* *[−][𝑖]* [ℏ] *[𝜔𝑡]* *𝑑𝑡* ]︁ (7.309)


where ˜ *𝜒* under a first-order approximation of the transitions moments with respect to the nuclear displacement is:


*𝑘𝑙*


*𝜕𝜇* ˆ *[*]* *𝛾* *𝜌* *[𝐻𝑇]* ( *𝑡* )
*𝜕𝑄* *𝑙* ]︁

(7.310)


*𝜒* ˜( *𝑡, 𝛽, 𝛾* ) = *𝑒* *[𝑖]* [Δ] *[𝐸𝑡]* [[︁] *𝜇* ˆ 0 *𝛽* *𝜇* ˆ *[*]* 0 *𝛾* *[𝜌]* *[𝐹𝐶]* [(] *[𝑡]* [) +] ∑︁

*𝑘*


*𝜕* *𝜇* ˆ *𝛽* ˆ
*𝜇* *[*]* 0 *𝛾* *[𝜌]* *[𝐹𝐶/𝐻𝑇]* [(] *[𝑡]* [) +] ∑︁
*𝜕𝑄* *𝑘*


*𝜇* ˆ 0 *𝛽* *𝜕𝜇* ˆ *[*]* *𝛾* *𝜌* *[𝐹𝐶/𝐻𝑇]* ( *𝑡* ) + ∑︁
*𝜕𝑄* *𝑘*
*𝑘* *𝑘𝑙*


*𝜕* *𝜇* ˆ *𝛽*
*𝜕𝑄* *𝑘*


Similarly, as section *Simulation of (Magnetic) Circular Dichroism and Absorption Spectra*, the transition moments
under the effect of an external magnetic field perturbation may be estimated by using a QDPT (eq. (7.274)), and
the derivatives are approximated numerically in a similar way as the ESD-Absorption case.

**7.45. More on the Excited State Dynamics module** **965**

**ORCA Manual** **,** **Release 6.0.1**

**Specific Keywords and recommendations**

Once selected the ESD(MCD) calculation two variables need to be defined in the %esd block:

  - The intensity of the magnetic field in Gauss “B”

  - The grid to make the molecular orientational average “LEBEDEVINTEGRATIONPOINTS”

The MCD signals use to be much more sensitive than the corresponding absorption intensities. As result, the
MCD calculations are much more sensitive to errors in the electronic structure. So it is highly recommended to
first fully understand the electronic structure problem and verify there are no important problems. In this direction
we suggest the following recommendations:

  - Be sure the obtained electronic states are in the correct order by assigning point group symmetry labels and
comparing them with better electronic structure methods. Due to the MCD intensities emerging as a result
of the interaction of states by the magnetic field perturbation, a wrong-located state in energy may affect the
MCD intensities, even if it is not in the energy range you are computing. We do not recommend using the
method as a black box.

  - It is recommended to do first an ESD-absorption calculation on the exact same level of theory, verify the
intensities and also solve any problem related to the PES representation.

  - The lineshape for the best agreement of the MCD intensities compared against the experimental measurements may differ for the best value for absorption intensities.

**7.45.6 Complete Keyword List for the ESD Module**



(continues on next page)

**966** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
 STDA FALSE #Use sTDA during derivatives?
 APPROXADEN FALSE #Compute the DELE by extrapolating info from
                 #the Hessians, avoiding second single-point
                 #at the ES geometry
 USEJ FALSE #Consider Duschinsky rotations?
 USEB TRUE #Rotate the initial state?
 SAMEFREQ TRUE #Use DO method and J=1.
 DELE 12000 #Custom energy difference
 TDIP x,y,z #Custom transition electric dipole
       x.re,x.im,y.re,y.im,z.re,z.im
 TMDIP x,y,z #Custom transition magnetic dipole
       x.re,x.im,y.re,y.im,z.re,z.im
 SOCME x.re,x.im #Custom spin-orbit coupling matrix elements, in a.u.
 LASERE 34000 #The laser energy for RR
 B 3000.0 #Magnetic field in Gauss for MCD
 LEBEDEVINTEGRATIONPOINTS 14 #Lebedev Grid for MCD molecular
                 #orientational average
 GEOMSTEP AUGHESS (default) #Geometry step?
       QN
 STEPSCALING 1.0 #A number for scaling the steps
 STEPCONSTR 0,2,5 #A list of atoms that will not be moved
 COORDSYS CART #Coordinate system for the normal modes?
       INT (default)
       WINT
       FCWL
       FCWS
 TCUTFREQ 100 #Cutoff for frequencies
 IFREQFLAG POSITIVE (default) #What to do with negative frequencies?
       LEAVE
       REMOVE
 UF_DELE 1E-4 #Energy difference for updated freq.
 UFFREQERR 0.2 #Tolerated percentual error
 TEMP 298.15 (default) #Temperature to consider
 UNIT WN #wavenumbers (Output units - input still in cm-1!)
       NM #nanometers
       EV #electron volts
 CENTRALDIFF TRUE #Central differences?
 CONVDER FALSE #Convert derivatives between state
 SCALING 1.0 (default) #Scaling for frequencies
 TDIPSCALING 1.0 (default) #Scaling for the transition dipole
 LINES DELTA #The lineshape function
       LORENTZ (default)
       GAUSS
       VOIGT (default for RR)
 LINEW 50 (default)
 INLINEW 250 (default)
 RRSLINEW 10 (default)
 RORDER 2 (default) #The Raman Order for RR
 RRINTENS false #Calculate the intensities instead
 RRTCUTDER 0 (default) #A cutoff for derivatives
 RRTCUTJ 0 (default) #A cutoff for J matrix elements

```
(continues on next page)

**7.45. More on the Excited State Dynamics module** **967**

**ORCA Manual** **,** **Release 6.0.1**


(continued from previous page)


### **7.46 More details on the ORCA DOCKER**

**Note:** The content here will assume you already have some basic knowledge from *The ORCA DOCKER: An*
*Automated Docking Algorithm*, if not, please check that section first!

**7.46.1 Underlying theory**

The basic idea behind the DOCKER is to use a type of swarm intelligence [787] to find local minima for where the
`HOST` would best be positioned, based on the energies and gradients of a given Potential Energy Surface (PES).

Swarm intelligence algorithms were invented trying to mimic the behavior of animals such as bees and ants, and
it actually fits the problem here quite well (as shown below). The basic steps needed for the algorithm are:

1. Optimize `HOST` and `GUEST` .

2. Create a spacial grid around the `HOST` .

3. Initialize a possible set of random solutions.

4. Let the swarm intelligence find local minima.

5. Collect a fraction of the best solutions found on 4. and fully optimize them.

6. The structure with the lowest energy is considered the best solution.

To quickly demonstrate how the initial set of solutions “evolve” to find different local minima, take as an example
the substituted biphenyl as `HOST` below. The figure below demonstrates how a water molecule ( `GUEST` ) is docked
onto the initial `HOST` .

Each gray ball represents one possible placing of the water molecule (ignoring here its rotation angle). At the
start, they are all distributed over the `HOST` without any bias. As the iterations go by, the algorithm starts to detect
that both sides of the molecule have lower energy solutions than the aromatic rings, as expected, and the possible
solutions start to converge to those points.

In the end, solutions containing water molecules binding to both sides are taken, the system is then fully optimized
and one finds that the best biding occurs with the hydroxy group to the right.

**968** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.60: The docking process of a water molecule on the substituted biphenyl.

**Important:** Right now the DOCKER can only be used together with the fast GFN-XTB methods, it will be
generalized later. It is also not fully exploring the parallelization potential yet, and can be much faster for the next

versions.

**7.46.2 Looking Deeper into the Output**

The details related to the grid and the swarm optimization can be found on the output, here is one example taken
from the water dimer example from the earlier section:



The `Population Density` here defines how many solutions will be placed on the initial grid around the `HOST`
and can be controlled by `%DOCKER POPDENSITY 0.50 END`, while the population size is a direct consequence of
that, unless specified by `POPSIZE` under `%DOCKER` .

Another important piece of information is the `Min, Max Iterations`, which define the minimum number of
iterations before checking for convergence, and the maximum possible number of iterations. These can be changed

**7.46. More details on the ORCA DOCKER** **969**

**ORCA Manual** **,** **Release 6.0.1**

by setting `MINITER` and `MAXITER` under the `%DOCKER` .

Then during the swarm search itself (here called the “evolution step”), the `HOST` and `GUEST` are partially optimized
using the same criteria as from `!SLOPPYOPT`, and their energy at convergence is taken as a convergence criteria.
The printing, still for the previous example, reads:

**Note:** All of the optimizations respect constraints and/or wall potentials given on the `%GEOM` block. The `HOST` can
be easily frozen with `%DOCKER FIXHOST TRUE END` .

Here we have the number of iterations, the energy of the best solution found during the process, the average energy
difference from the lowest solutions and its standard deviation. The first number shows if the system is evolving
towards a lower energy solutions and the later two give an idea of the “spread” of the energies found.

If no new minimum is found over `MINITER` iterations, the algorithm is considered to be converged and the best
solutions are taken to the final optimization step.

**7.46.3 The final steps**

After the evolution step, a total of *𝑚𝑎𝑥* ( *𝑠𝑞𝑟𝑡* ( *𝑃𝑜𝑝𝑆𝑖𝑧𝑒* ) *,* 5) structures are taken from the set of solutions for a final
full optimization. The output looks like:



To avoid redundant solutions being optimized here, a check is made such that only structures with an energy
difference of at least a `Minimum energy difference` and `Maximum RMSD` (obtained after an optimal rotation
using the quaternion approach) are taken. The coordinate system might also be automatically set to Cartesian if
the number of atoms is above 300 to speedup.

If some optimizations fail during the process, they will be flagged as `optimization failed`, as in the example
below:



That only means some of the solutions failed to fully optimize at the end, and on the printed file their energy is set
to 1000 Eh to show the job was not completed. If you want to increase the number of iterations, or change the final

**970** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

convergence criteria, just change them using the `%GEOM` block as usual.

**7.46.4 General Tips**

1. In order to quick change the PES of the docking process, you can use `!DOCK(GFN2-XTB)`, `!`
`DOCK(GFN1-XTB)`, `!DOCK(GFN0-XTB)` or `!DOCK(GFN-FF)` .

2. For a quicker and less accurate docking the input `!QUICKDOCK` is also available.

3. There are four levels of “docking” procedure, from simple to more elaborate: `SCREENING`, `QUICK`, `NORMAL`
(default) and `COMPLETE`, which can be given as `%DOCK DOCKLEVEL COMPLETE END` .

4. To increase the final number of structures optimized in the end, just change `NOPT` under `%DOCKER` .

5. If the guest topology is somehow changed during the docking process, that structure will be discarded. This
can be turned off by setting `%DOCK CHECKGUESTTOPO FALSE END` .

**Important:** By the time of the ORCA6 release, this algorithm was still not published. Publications are under
preparation.

**7.46.5 Complete Keyword List**



(continues on next page)

**7.46. More details on the ORCA DOCKER** **971**

**ORCA Manual** **,** **Release 6.0.1**


(continued from previous page)


### **7.47 More on the ORCA SOLVATOR**

Here we will present a few more technical details about the SOLVATOR that were too specific to be presented
on the more general section. This section presumes that the section *ORCA SOLVATOR: Automatic Placement of*
*Explicit Solvent Molecules* was already read. If not, please return here after that.

**7.47.1 The Simpler Stochastic Mode**

The `CLUSTERMODE STOCHASTIC`, as the name suggests, uses random trial and error to assign the placing of the
solvents. Well, it is actually more complicated than that.

The algorithm actually uses information from self-consistent EEQ charges [132] as part of an extremely simplistic
potential to guide the placing of polar molecules in a more reasonable way.

After trying to distribute the solvent molecule somewhere and checking for clashes, we first compute the electrostatic energy between solvent and solute:


*𝑠𝑜𝑙𝑣𝑒𝑛𝑡*
∑︁

*𝐵*


*𝐸* *𝑒𝑙𝑒𝑐* =


*𝑠𝑜𝑙𝑢𝑡𝑒*
∑︁

*𝐴*


*𝑄* *𝐴* *𝑄* *𝐵*
*𝑅* *𝐴𝐵* 4 *𝜋𝜖* *𝑠𝑜𝑙𝑣* *,* (7.311)


**972** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

and define our target function to be minimized ( *𝑉* ) as a damped version of that, using the minimum distance *𝑅* *𝑚𝑖𝑛*
between the solute and solvent atoms:

*𝑉* = *𝐸* *𝑒𝑙𝑒𝑐* *𝑒* *[−][𝑅]* *𝑚𝑖𝑛* [2] if *𝐸* *𝑒𝑙𝑒𝑐* *<* 0

(7.312)
= *𝑅* *𝑚𝑖𝑛* otherwise *,*

The `STOCHASTIC` mode then consists of finding the correct solvent placement that minimizes *𝑉* for a given solute.
The damping function is there to ensure that:

1. The electrostatic interaction decays strongly with distance,

2. Repulsive energies will be so unfavorable that only the distance will matter.

The result is such that solvent molecules are placed as close as possible to the solute and maximizing electrostatic
interactions. This helps to create the solvent shell such that is does look like the actual result one would expect
from a more elaborate calculation, but with essentially zero cost.

The best value for *𝑉* found after each solvent was added is what is printed in the output as `Target function` :



When using the `DROPLET` mode, the *𝑅* *𝑚𝑖𝑛* is defined as the distance to the centroid of the solute, instead of that of
the closest atom pair instead.

If you don’t want to include the electrostatic component for any reason, just set `%SOLVATOR USEEEQCHARGES`
`FALSE END` . In the future other charge models will be available as well.

**7.47.2 Adding Explicit Solvents with the Docker**

**The Wall Potential**

If one uses the default approach using the DOCKER, a fictitious wall potential is added to guarantee that the solvents
are added such that they fill most of the first solvation sphere around the solute before being placed further.

**Note:** This resembles to some extent what was published recently by the group of Prof. Stefan Grimme (called
“quantum cluster growth”), but here only a single outer wall potential is used [813]. Otherwise, the present algorithm is independent and unrelated to it.

As one can see from the output of the Histine example of the before mentioned section, by default an ellipsoid
potential is built:
```
Ellipsoid potential radii: .... 8.37, 6.28, 5.76 Angs

```
with dimensions such that it will enclose the solute plus at least one molecule of the solvent in all directions.

**7.47. More on the ORCA SOLVATOR** **973**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.61: A simple scheme to show how the wall potential is built to keep the solvent molecules close to the solute

space.

A single parameter controlled by `SOLVWALLFAC` under the `%SOLVATOR` block defines how further this wall is built
outside the solute. Its default value is 1.0, and increasing it to larger values will increase the default initial wall by
about half the sum of the maximum dimensions of solute plus solvent for each unit.

The initial wall potential is by default not changed, unless a) the algorithm can not place a solvent, or b) the energy
of the placed solvent is higher than before. Only then the walls will be updated to help allocating the next solvent
molecule, and a message will be printed with the current scaling factor.

**The DOCKER**

All options related to the docking process can be controlled as usual via the `%DOCKER` block. Please check the
section *The ORCA DOCKER: An Automated Docking Algorithm* for more info.

Also, all options given under the `%GEOM` block such as constraints and etc., will be respected during the docking of
the solvent, as with the general docking, but these can only be given for the solute.

**7.47.3 Controlling True Randomness**

Both these algorithms are intrinsically dependent on random numbers, but ORCA sets a fixed random seed such
that the same results are always obtained on the same machine if calculations are repeated.

In order to make both fully random, please set `%SOLVATOR RANDOMSOLVATION TRUE END` .

**7.47.4 Vacuum Search**

One option that might come in handy under certain conditions is to use the SOLVATOR to add the explicit solvent
based on the implicit solvation information, but actually **not** use any implicit solvation while trying to place them.

That is useful for instance when trying to generate aggregates of solute plus solvents that can form in gas-phase only,
where there will be no other solvent molecules around. That can be set with `%SOLVATOR VACUUMSEARCH TRUE`

`END` and the implicit solvation method will be ignored to compute energies and gradients. In the `STOCHASTIC`
method, the *𝜖* *𝑠𝑜𝑙𝑣* will be set to 1.0.

**974** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**Important:** By the time of the ORCA6 release, this algorithm was still not published. Publications are under
preparation.

**7.47.5 Complete Keyword List**



**7.47. More on the ORCA SOLVATOR** **975**

**ORCA Manual** **,** **Release 6.0.1**
### **7.48 Ab initio Molecular Dynamics Simulations**

A few years ago, we included an *ab initio* molecular dynamics (AIMD) module into ORCA. [1] As a plethora of
different electron structure methods with analytical gradients is already implemented, all these methods are now
available also for MD simulations, offering a wide range of accuracy/performance trade-offs.

Despite the relatively short history inside of the ORCA package, the MD module has grown considerably over the
last years. A few features found in other MD codes are still missing. In future releases, many more new features
and methods will (hopefully) be added to this part of the program. We will always do our best to keep a strict
backward compatibility, such that the sample inputs from this section will remain valid in all future releases.

For some more information as well as input examples for the ORCA MD module, please visit

[https://brehm-research.de/orcamd](https://brehm-research.de/orcamd)

**7.48.1 Changes in ORCA 5.0**

  - Added a `Metadynamics` module with many features and options:

**–** Can perform one-dimensional and two-dimensional Metadynamics simulations [487] to explore free
energy profiles along reaction coordinates, called collective variables (“Colvars”).

**–** `Colvars` can be distances *(including projections onto vectors and into planes)*, angles, dihedrals, and
coordination numbers [408]. The latter allows, *e. g.*, to accurately compute p *𝐾* A values of weak acids

[855, 856].

**–**
For all Colvars, groups of atoms *(e. g., centers of mass)* can be used instead of single atoms.

**–**
Metadynamics simulations can be easily restarted and split over multiple runs.

**–** Ability to run well-tempered Metadynamics [73] for a smoothly converging free energy profile.

**–** Ability to run extended Langrangian Metadynamics [408], where a virtual particle on the bias profile
is coupled to the real system via a spring. The virtual particle can be thermostated.

  - Added two modern and powerful `thermostats` *(both available as global and massive)* :

**–** The widely used Nosé–Hoover chain thermostat (NHC) with high-order Yoshida integrator [563, 564];
allows for a very accurate sampling of the canonical ensemble.

**–** The stochastical “Canonical Sampling through Velocity Rescaling” (CSVR) thermostat [129] which
has become quite popular recently.

  - Can define harmonic and Gaussian `restraints` for all Colvars *(distance, angle, dihedral, coordination*
*number)* . This allows for umbrella sampling [430, 482], among other methods. Can also define one-sided
restraints which act as lower or upper wall.

  - Can now print the instantaneous and average force on `constraints` and `restraints` ; this allows for thermodynamic integration [430].

  - The target value for `constraints` and `restraints` can now be a ramp, so that it can linearly change during
the simulation.

  - Can now keep the system’s center of mass fixed during MD runs.

  - Can now print population analyses, orbital energies, and .engrad files in every MD step if requested.

1 Strictly speaking, these simulations are Born–Oppenheimer molecular dynamics simulations (BOMD), because they approximately solve
the time-independent Schrödinger equation to compute gradients and then move the atoms according to these gradients.

**976** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.48.2 Changes in ORCA 4.2 (Aug 2019)**

  - Added a Cartesian minimization command to the MD module, based on L-BFGS and simulated annealing.
Works for large systems ( *>* 10 000) atoms and also with constraints. Offers a flag to only optimize hydrogen
atom positions *(for crystal structure refinement)* . See `Minimize` command.

  - The MD module can now write trajectories in DCD file format *(in addition to the already implemented XYZ*
*and PDB formats)*, see `Dump` command.

  - The `thermostat` is now able to apply temperature ramps during simulation runs.

  - Added more flexibility to region definition *(can now add/remove atoms to/from existing regions)* . Renamed
the `Define_Region` command to `Manage_Region` .

  - Added two new constraint types which keeps centers of mass fixed or keep complete groups of atoms rigid,
see `Constraint` command.

  - Ability to store the GBW file every *𝑛* -th step during MD runs *(e.g. for plotting orbitals along the trajectory)*,
see `Dump` command.

  - Can now set limit for maximum displacement of any atom in a MD step, which can stabilize dynamics with
poor initial structures. Runs can be cleanly aborted by “ `touch EXIT` ”. See `Run` command.

  - Better handling/reporting of non-converged SCF during MD runs.

  - Fixed an issue which slowed down molecular dynamics after many steps.

  - Stefan Grimme’s xTB method can now be used in the MD module, allowing fast simulations of large systems.

**7.48.3 Changes in ORCA 4.1 (Dec 2018)**

  - Molecular dynamics simulation can now use Cartesian, distance, angle, and dihedral angle constraints. These
are managed with the `Constraint` command.

  - The MD module now features cells of several geometries (cube, orthorhombic, parallelepiped, sphere, ellipsoid), which can help to keep the system inside of a well-defined volume. The cells have repulsive harmonic
walls.

  - The cells can be defined as elastic, such that their size adapts to the system. This enables to run simulations
under constant pressure.

  - Trajectories can now be written in XYZ and PDB file format.

  - A restart file is written in each simulation step. With this file, simulations can be restarted to seamlessly
continue (useful for batch runs or if the job crashed). Restart is handled via the `Restart` command; see
below.

  - Introduced regions ( *i. e.*, subsets of atoms), which can be individually defined. Regions can be used to
thermostat different parts of the system to different temperatures ( *e. g.*, cold solute in hot solvent), or to
write subset trajectories of selected atoms.

  - The energy drift of the simulation is now displayed in every step (in units of Kelvin per atom). Large energy
drift can be caused by poor SCF convergence, or by a time step length chosen too large.

  - Physical units in the MD input are now connected to their numeric values via underscore, such as `350_pm` .
A whitespace between value and unit is no longer acceptable. This slightly breaks backward compatibility

– sorry.

  - Fixed a bug in the time integration of the equations of motion, which compromised energy conservation.

  - Fixed crashes for semiempirics and if ECPs were employed. You can now run MD simulations with methods
such as PM3 and with ECPs.

**7.48.** ***Ab initio*** **Molecular Dynamics Simulations** **977**

**ORCA Manual** **,** **Release 6.0.1**

**7.48.4 Input Format**

The molecular dynamics module is activated by specifying “ `MD` ” in the simple input line. The actual MD input
which describes the simulation follows in the “ `%md` ” section at some later position in the input file. The contents
of this section will subsequently be referred to as “MD input”.



Please note that the MD input is not processed by ORCA’s main parser, but by a dedicated parser in the MD module.
Therefore, the MD input is not required to obey the general ORCA syntax rules. The syntax will be described in
the following.

In contrast to general ORCA input, the MD input is not based on keywords, but on *commands*, which are executed
consecutively on a line-by-line basis starting at the top (like, *e. g.*, in a shell script). This means that identical commands with different arguments may be given, coming into effect when the interpreter reaches the corresponding
line. This enables to perform multiple simulations ( *e. g.*, pre-equilibration and production run) within a single
input file:



Work is already under way to add variable definitions, loops, and conditional branching to the MD input. [2] This
will enable even larger flexibility ( *e. g.*, to run a simulation until a certain quantity has converged). The MD input
is written in the SANscript language (“Scientific Algorithm Notation Script”), which is under development. A first
glimpse can be found at

[https://brehm-research.de/sanscript](https://brehm-research.de/sanscript)

As in standard ORCA input, **comments** in the MD input are initiated by a “ `#` ” sign and span to the end of the
current line. Commands can be started both at the beginning of a line and after a command. The only place where
a “ `#` ” is **not** treated as start of a comment is inside of a string literal ( *e. g.*, in file names).



Some more MD input syntax rules:

  - The MD input is generally **not** case-sensitive. The only exception are file names on platforms with casesensitive file systems (such as GNU Linux).

  - Empty lines are allowed.

2
Technically speaking, ORCA will then be a Turing-complete script interpreter, such that *any* computational problem can be solved with
ORCA :-)

**978** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

  - Commands and options are separated by space or tabulator characters. Any combination of these characters
may be used as separator.

  - Both DOS and UNIX line break style is acceptable.

**Commands**

As already noted above, the central item of the MD input is a command. Each input line contains (at most) one
command, and these commands are executed in the given order. A command typically takes one or more arguments,
which are given behind the command name, separated by whitespaces, tabulator characters, or commas (optional).
The order of the arguments for a command is fixed (see command list in section *Command List* . Commands may
have optional arguments, which are always specified at the end of the argument list, after the last non-optional
argument. If there exist multiple optional arguments for a command, not all of them need to be specified; however,
they need to be specified in the correct order and without gaps:



Apart from arguments and optional arguments, commands can also have *modifiers* . These can be considered as
“sub-commands”, which modify a given command, and may possess their own argument lists. Modifiers generally
follow after all non-optional and optional arguments, and they may **not** possess optional arguments on their own.
If a command has multiple modifiers, the order in which they are given is not important.

In the following input example, “ `Mod1` ” and “ `Mod2` ” are modifiers of “ `Command` ”. “ `Mod1` ” takes one argument,
“ `Mod2` ” does not take arguments:



To make this abstract definition a little more illustrative, please consider again one line from the input sample at
the beginning of this section:



Here, “ `Dump` ” is the command, which takes one non-optional argument to specify which quantity shall be dumped
– in this case, “ `Position` ”. The “ `Dump` ” command has two modifiers, namely “ `Stride` ” and “ `Filename` ”. The
former takes one integer argument, the latter a string argument. Swapping the two modifiers (together with their
respective arguments, of course) would not change the behavior.

**7.48.** ***Ab initio*** **Molecular Dynamics Simulations** **979**

**ORCA Manual** **,** **Release 6.0.1**

**Separating Arguments**

As shown above, the arguments which are passed to a command do not need to be separated by commas. However,
it is allowed (and recommended) to still use commas. First, it can increase the readability of the input file. Secondly,
there exist a few ambiguous cases in which commas (or parentheses) should be used to clarify the intended meaning.
One of these cases is the arithmetic minus operator. It can either be used as binary operator (subtracting one number
from another), or as unary operator (returning the negative of a number). By default, the minus operator will be
considered as binary operator (if possible).

Consider the case in which you want to pass two integer arguments “ `10` ” and “ `-10` ” to a command. Without
commas (or parentheses), the minus is mistreated as binary operator, and only one argument will be passed to the
command:



**Physical Units**

In many cases, it is required to specify quantities which bear a physical unit in an input file ( *e. g.*, temperature,
time step lengths, ...). For many quantities, there are different units in widespread use, which always leads to
some confusion (just consider the “kcal vs kJ” case). ORCA handles this problem by defining default units for
each quantity and requiring that all quantities are given in their default unit. ORCA’s default units are the atomic
units, which are heavily used in the quantum chemistry community, but not so much in the molecular dynamics
community. As an *ab initio* molecular dynamics module exists in the small overlap region of both communities,
some “unit conflicts” might arise. To prevent those from the beginning, it is allowed to specify units of personal
choice within ORCA’s MD input.

Luckily, this is as simple and convenient as it sounds. The parser of the MD module checks if a unit is given after
a numeric constant, and automatically converts the constant to the internal default unit. If no explicit unit is given,
the default unit is assumed. Please note that the default units within the MD module are not necessarily atomic
units (see table below). Units are connected to the preceding numerical value by an underscore:



In the following, all units which are currently known to the MD module’s parser are listed, sorted by physical
quantities. The default unit for each quantity is printed in `bold letters` . Additive constant and factor are applied
to convert a unit into the default unit. The additive constant is applied before the factor. A “ *−* ” means that the
constant/factor is not applied. More units will be probably added in the future.

**980** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**



**7.48.5 Discussion of Features**

**Restarting Simulations**

*Ab initio* molecular dynamics simulation are computationally expensive, and will typically run for a long time
even in the case of medium-sized systems. Often, it is desirable to perform such a simulation as a combination
of multiple short runs ( *e. g.*, if the queuing system of the cluster imposes a maximum job time). The ORCA MD
module writes a restart file in each simulation step, which allows for the seamless continuation of simulations.
This restart file has the name “ `basename.mdrestart` ”, where `basename` is the project’s base name. To load an
existing restart file, use the `Restart` command *(see command list below)* .

In the first run of a planned sequence of runs, no restart file exists yet. for this case, the `Restart` command offers
the `IfExists` modifier. The restart file is only loaded if it exists. If not, the restart is simply skipped, and no
error is thrown. By using this modifier, you can have the `Restart` command already in place in the first run of a
sequence (where no restart file exists in the beginning), and do not need to modify the input after the first run has
finished.

Concerning the `Dump` command, it is good to know that trajectory files are appended ( *not* overwritten) by default.
If you ever want to overwrite an existing trajectory file by a `Dump` command, use the `Replace` modifier.

Please note that **only** the positions, velocities, thermostat internal state *(only for NHC)*, Metadynamics hills, and
time step counters are restarted when executing a `Restart` command. All other properties (thermostats, regions,
trajectory dumps, constraints, cells, etc.) are **not** restarted. They should all remain in the input file, as executed in
the first run of a sequence. Just add the `Restart` command after all other relevant commands have been executed,
directly before the `Run` command.

To conclude this discussion, a short example is given. If the MD input file



(continues on next page)

**7.48.** ***Ab initio*** **Molecular Dynamics Simulations** **981**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

is subsequently executed ten times (without any modification), the resulting trajectory file will be identical *(apart*
*from numerical noise)* to that obtained if the following input is executed once:



**Regions**

In the ORCA MD module, **regions** can be defined. This concept does *not* refer to regions in space, but rather to
subsets of atoms in the system. A region is nothing more than a list of atoms. Regions may overlap, *i. e.*, atoms
can be part of more than one region at a time. The atoms which are part of a certain region remain the same until
the region is manually re-defined, *i. e.*, regions are fixed and do not adapt to any changes in the system. There exist
a few pre-defined regions which have a name. User-defined regions, in contrast, only carry an integer identifier.
The following regions are pre-defined in any case:

   - `all` : Contains all atoms of the system. This is the default if no region is specified in some commands, so by
default, these commands will always act on the whole system.

   - `active` : This region contains all movable (“non-frozen”) atoms. By default, it is identical to the `all` region.
Atoms inside of this region are updated by the time integration in a molecular dynamics run, displaced in a
minimization, and are considered for computing the kinetic energy.

   - `inactive` : This region contains all atoms which are *not* part of the `active` region. These atoms are
“frozen”; they are ignored by the time integration / minimization, and also not considered for the computation of the kinetic energy. They simply remain on their initial positions. This is in principle identical to
applying Cartesian constraints to the atoms; however, it is much faster. As constraints have to be solved iteratively *(see below)*, Cartesian constraints become quite computationally demanding if applied to thousands
of atoms.

From these three pre-defined regions, only the `active` region can be manually modified. Changes in the composition of the `active` region automatically modify the `inactive` region. The `all` region obviously cannot be
changed.

In case of a QM/MM simulation, the following four additional regions can be used:

   - `qm` : This is the “quantum mechanics” region – it contains all atoms which are treated by the electron structure
method.

   - `mm` : This is the “molecular mechanics” region – it contains all atoms which are treated by a force-field
approach. It exactly contains those atoms which are not part of the `qm` region.

   - `active_qm` : Contains exactly those atoms which are part of both the `qm` and the `active` regions.

   - `active_mm` : Contains exactly those atoms which are part of both the `mm` and the `active` regions.

These regions can **not** be modified in the MD input. The MD module just reads the region definitions from the
QM/MM module, but is not able to make any changes here.

Regions can be useful for many purposes. For example, a “realistic” wall of atoms can be built around the system
by defining the `active` region such that it only contains the non-wall atoms. The wall atoms will then be frozen.
Apart from that, trajectories of regions can be written to disk, only containing the “interesting” part of a simulation.
Furthermore, velocity initialization can be applied to regions, enabling to start a simulation in which different sets
of atoms possess different initial temperatures. Thermostats can be attached to regions to keep different sets of

**982** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

atoms at different temperatures during the whole simulation. This allows for sophisticated simulation setups (cold
solute in hot solvent, temperature gradient through the system, etc).

Regions are defined or modified by the `Manage_Region` command. Many other commands take regions as optional
arguments. Please see the command list below.

**Metadynamics**

Metadynamics is a powerful tool to analyze free energy profiles of reactions and other processes *(solvation, ag-*
*gregation, conformer change, dissociation)* based on molecular dynamics simulations. It has been developed by
Laio and Parrinello in 2002 [487]. In principle, the frequency of observing a certain process in MD simulations is
directly related to the free energy barrier of the process. However, many interesting processes *(such as chemical*
*reactions)* possess such a high free energy barrier that they will never occur on the time scales typical for AIMD
simulations (100 ps). To increase the frequency at which such processes happen, so-called rare event sampling
methods can be employed. Metadynamics is one among those. It works by building up a bias potential as a sum
of Gaussian hills, so that free energy minima are slowly filled up and the system is gradually pushed away from its
resting points.

Please note that there is also a method with the same name for exploring conformation space that has been published by Grimme in 2019 [330]. It is in principle based on the original “Parrinello” Metadynamics, but with
several modifications and extensions. The ORCA MD module contains the original Parrinello variant of Metadynamics [487], together with several extensions such as well-tempered Metadynamics [73] and extended Lagrangian
Metadynamics [408]. The Grimme method for conformer search will probably be implemented in the future.

In Metadynamics, one has to define one or more “collective variables” (Colvars) along which the free energy profile
of the system will be sampled. A Colvar is in principle nothing more than a continuous function of all atom positions
which returns a real number. A simple example of a Colvar is the distance between two atoms, which could be
used to explore the free energy profile of a bond formation or cleavage. In the ORCA MD module, Colvars can be
defined via the `Manage_Colvar` command. Available Colvar types are distances *(including projections onto lines*
*or into planes)*, angles, dihedral angles, and coordination numbers [408]. The latter allows, *e. g.*, to accurately
compute p *𝐾* A values of weak acids in solvent [855, 856]. For the distances, angles, and dihedral angles, atom
groups instead of single atoms can be specified, so that, *e. g.*, the distance between the centers of mass of two
molecules can be defined as a Colvar.

Based on one or two Colvars (ORCA supports one-dimensional and two-dimensional Metadynamics), a Metadynamics simulation can be set up. There are many parameters to choose, which are described in the section of the
`Metadynamics` command. After all parameters have been set, the actual simulation is simply started via the `Run`
command. It is also possible to restart Metadynamics simulations so that they can be split into multiple successive runs; see the `Restart` command. A full example for a two-dimensional well-tempered extended Lagrangian
Metadynamics simulation can be found on *below* .

Note that Metadynamics simulations typically require very much computational time *(at least several 10 000 MD*
*steps for a roughly converged result, depending on the Colvar choice)* . So this is by no means a method to “shortly
try out”. However, there are no cheaper methods for predicting free energy profiles *(apart from very simple ap-*
*proximations such as the harmonic oscillator)*, and the predictive power of computing free energy profiles comes
at a price.

**7.48.6 Command List**

In the following, an alphabetical list of all commands currently known to the MD module is given. The description
of each command starts with a small box which contains the command’s name and a table of arguments and
modifiers. The last-but-one column in the table specifies the type of each argument. Possible types are “Integer”,
“Real”, “String”, and “Keyword”. In the latter case, the last column contains a list of allowed keyword values in
{ `braces` }. If the type is “Real” and is a physical quantity with unit, the quantity is given in the last column in

[square brackets]. Each such box is followed by a textual description of the corresponding command.

**7.48.** ***Ab initio*** **Molecular Dynamics Simulations** **983**

**ORCA Manual** **,** **Release 6.0.1**

**7.48.7 Command Overview**
```
Cell

```
Defines a harmonic repulsive wall around the system *(the wall is “soft” with a spring constant and atoms can*
*slightly penetrate; “hard” repulsive walls are not supported)* . This helps to keep the molecules inside of a welldefined volume, or to keep a constant pressure in the system. In the latter case, the cell can be defined as elastic,
such that it exerts a well-defined pressure *(see below)* . Please note that ORCA does not feature periodic boundary conditions, and therefore, all cells are non-periodic (just repulsive walls). There are several cell geometries
available *(only one type of cell can be active at a time)* :



- `Cube` : Defines a cubic cell. If two real values *𝑝* 1 and *𝑝* 2 are specified as coordinates, the cell ranges from
(︀ *𝑝* 1 *, 𝑝* 1 *, 𝑝* 1 )︀ to (︀ *𝑝* 2 *, 𝑝* 2 *, 𝑝* 2 )︀. If only one real value *𝑝* is supplied, the cell ranges from (︀ *−* *[𝑝]* 2 *[,][ −]* *[𝑝]* 2 *[,][ −]* *[𝑝]* 2 )︀ to


(︀ *𝑝* 1 *, 𝑝* 1 *, 𝑝* 1 )︀ to (︀ *𝑝* 2 *, 𝑝* 2 *, 𝑝* 2 )︀. If only one real value *𝑝* is supplied, the cell ranges from (︀ *−* *[𝑝]* 2 *[,][ −]* *[𝑝]* 2 *[,][ −]* *[𝑝]* 2 )︀ to

(︀ *𝑝* 2 *[,]* *[𝑝]* 2 *[,]* *[𝑝]* 2 )︀, *i. e.* it is centered at the origin with edge length *𝑝* .



*[𝑝]*

2 *[,][ −]* *[𝑝]* 2



*[𝑝]*

2 *[,][ −]* *[𝑝]* 2


*𝑝* *[𝑝]*

2 *[,]* 2



*[𝑝]* *[𝑝]*

2 *[,]* 2



*[𝑝]* 2 )︀, *i. e.* it is centered at the origin with edge length *𝑝* .



   - `Rect` : Defines an orthorhombic cell. Six real values *𝑥* 1, *𝑦* 1, *𝑧* 1, *𝑥* 2, *𝑦* 2, and *𝑧* 2 have to be specified as
coordinates *(in this order)* . The cell will range from (︀ *𝑥* 1 *, 𝑦* 1 *, 𝑧* 1 )︀ to (︀ *𝑥* 2 *, 𝑦* 2 *, 𝑧* 2 )︀.

   - `Rhomb` : Defines a parallelepiped-shaped cell (also termed as rhomboid sometimes). You have to specify
twelve real values in total. The first three define one corner point *𝑝* of the cell, and the remaining nine define
three cell vectors *𝑣* 1, *𝑣* 2, and *𝑣* 3, each given as Cartesian vector components. The cell is then defined as the

**984** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

set of points {︀ *𝑝* + *𝑐* 1 *𝑣* 1 + *𝑐* 2 *𝑣* 2 + *𝑐* 3 *𝑣* 3 *|* 0 *≤* *𝑐* 1 *, 𝑐* 2 *, 𝑐* 3 *≤* 1}︀ The vectors *𝑣* 1, *𝑣* 2, and *𝑣* 3 do not need to be
orthogonal to each other, but they may not all lie within one plane (cell volume would be zero).

   - `Sphere` : Defines a spherical cell. You need to specify four real values *𝑐* *𝑥*, *𝑐* *𝑦*, *𝑐* *𝑧*, and *𝑟* . The cell will then
be defined as a sphere around the central point (︀ *𝑐* *𝑥* *, 𝑐* *𝑦* *, 𝑐* *𝑧* )︀ with radius *𝑟* .

   - `Ellipsoid` : Defines an ellipsoid-shaped cell. As first three arguments, you have to specify three real values
*𝑐* *𝑥*, *𝑐* *𝑦*, *𝑐* *𝑧*, which define the center of the ellipsoid to be (︀ *𝑐* *𝑥* *, 𝑐* *𝑦* *, 𝑐* *𝑧* )︀. As fourth argument, a keyword has to
follow, which may either be “ `XYZ` ” or “ `Vectors` ”. In the “ `XYZ` ” case, three more real values *𝑟* *𝑥*, *𝑟* *𝑦*, and *𝑟* *𝑧*
have to be specified, which define the partial radii of the ellipsoid along the X, Y, and Z coordinate axes. If
instead “ `Vectors` ” was given, nine more real values *𝑣* *𝑥* [1] [,] *[ 𝑣]* *𝑦* [1] [,] *[ 𝑣]* *𝑧* [1] [,] *[ 𝑣]* *𝑥* [2] [,] *[ 𝑣]* *𝑦* [2] [,] *[ 𝑣]* *𝑧* [2] [,] *[ 𝑣]* *𝑥* [3] [,] *[ 𝑣]* *𝑦* [3] [,] *[ 𝑣]* *𝑧* [3] [have to follow after the]
keyword. These values define three vectors *𝑣* [1] := (︀ *𝑣* *𝑥* [1] *[, 𝑣]* *𝑦* [1] *[, 𝑣]* *𝑧* [1] )︀, *𝑣* [2] := (︀ *𝑣* *𝑥* [2] *[, 𝑣]* *𝑦* [2] *[, 𝑣]* *𝑧* [2] )︀, and *𝑣* [3] := (︀ *𝑣* *𝑥* [3] *[, 𝑣]* *𝑦* [3] *[, 𝑣]* *𝑧* [3] )︀,
which are the principal axes of the ellipsoid. These vectors have to be strictly orthogonal to each other. The
length of each vector defines the partial radius of the ellipsoid along the corresponding principal axis.

All cell types define a harmonic potential *𝐸* cell ( *𝑟* ) := *𝑘* *· 𝑟* [2] which acts on all atoms in the system **outside of the**
**cell**, where *𝑟* is the closest distance from the atom’s center to the defined cell surface. Atoms whose center is inside
of the cell or directly on the cell surface do not experience any repulsive force. Following from the definition, the
force which acts on an atom outside of the cell is always parallel to the normal vector of the cell surface at the point
which is closest to the atom center. This is trivial in case of cubic, rectangular, rhombic, and spherical cells, but
not so trivial for ellipsoid-shaped cells.

The spring constant *𝑘* in the above equation ( *i. e.*, the “steepness” of the wall) can be specified by the “ `Spring` ”
modifier, which expects one real value as argument. The spring constant has to be specified in the unit kJ mol *[−]* [1]

Å *[−]* [2], other units cannot be specified here. The default value is 10 kJ mol *[−]* [1] Å *[−]* [2] . Larger spring constants reduce the penetration depth of atoms into the wall, but may require shorter integration time steps to ensure energy
conservation. If jumps in the total energy occur, try to use a smaller spring constant ( *e. g.*, the default value).

The command “ `Cell None` ” disables any previously defined cell.

If you want to perform simulations under constant pressure, you can define an elastic cell. Then, ORCA accumulates
the force which the cell exerts on the atoms in each time step, and divides this total force by the cell surface area
to obtain a pressure. As this momentarily pressure heavily fluctuated, a running average is used to smooth this
quantity. If the averaged pressure is larger than the external pressure which was specified, the cell will slightly
grow; if it was smaller, the cell will slightly shrink. In the beginning of a simulation, the cell size will not vary
until at least the running average history depth of steps have been performed.

An elastic cell is enabled by using the “ `Elastic` ” modifier after the cell geometry definition. Subsequently, two real
values *𝑡* avg and *𝑐* response are required. While *𝑡* avg defines the length of the running average to smooth the pressure *(in*
*units of physical time,* ***not*** *time steps)*, the *𝑐* response constant controls how fast the cell size will change at most. More
specific, *𝑐* response is the fraction of the cell volume growth per time step if the ratio of averaged and external pressure
would be infinite, and at the same time the fraction of the cell volume reduction per step if the aforementioned ratio
is zero. Put into mathematical form, the cell volume change per time step is


*𝑉* old *·* *𝑐* response *·* *𝑝* *[⟨][𝑝]* ext *[⟩]*


*𝑝* ext *[≤]* [1] *[,]*



*·* *𝑝* ext [+1] if *[⟨][𝑝][⟩]*

*𝑐* response +1 *𝑝* ext

response *⟨𝑝⟩* +1) *·* *𝑝* *[⟨][𝑝]* ext *[⟩]* if *[⟨]* *𝑝* *[𝑝]* ext *[⟩]*

*𝑝* ext [+] *[𝑐]* [response]


*𝑉* new :=


⎧⎪⎨⎪⎩


*𝑉* old *·* ( *𝑐* response +1) *·* *𝑝* *[⟨][𝑝]* ext *[⟩]*


(7.313)

*[⟨][𝑝][⟩]*

*𝑝* ext *[>]* [ 1] *[,]*


where *⟨𝑝⟩* represents the averaged pressure the system exerts on the walls, and *𝑝* ext is the specified external pressure.
Good starting points are *𝑡* avg = 100 fs and *𝑐* response = 0 *.* 001. Please note that larger values of *𝑐* response or smaller
values of *𝑡* avg may lead to uncontrolled fluctuations of the cell size. An already defined fixed cell can be switched
to elastic by the command “ `Cell Elastic ...` ” (the dots represent the two real arguments).

By default, the size change of an elastic cell due to pressure is performed *isotropically*, *i. e.*, the cell is scaled
as a whole, and exactly retains its aspect ratio. By specifying the “ `Anisotropic` ” modifier after switching on
an elastic cell, the cell pressure is broken down into individual components, and the size of the cell is allowed to
change independently in the individual directions. This, of course, only makes sense for the cell geometries `Rect`,
`Rhomb`, and `Ellipsoid` . An already defined isotropic cell can be switched to anisotropic by simply executing
“ `Cell Anisotropic` ”.

In case of an elastic cell, the external pressure is defined by the modifier “ `Pressure` ”, which expects either one or
three real values as arguments. If one argument is given, this is the isotropic external pressure. If three arguments
are supplied, these are the components of the pressure in X, Y, and Z direction *(in case of orthorhombic cells)*

**7.48.** ***Ab initio*** **Molecular Dynamics Simulations** **985**

**ORCA Manual** **,** **Release 6.0.1**

or along the direction of the three specified vectors *(in case of parallelepiped-shaped and ellipsoid-shaped cells)* .
This allows for anisotropic external pressure (probably only useful for solid state computations). Both the pressure
and the pressure components have to specified in units of bar (= 10 [5] N m *[−]* [2] ), other units cannot be used. If this
modifier is not used, the default pressure will be set to 1.0 bar (isotropic) if an elastic cell is used. The external
pressure of an already defined cell can be changed by the command “ `Cell Pressure ...` ” (the dots represent
the real argument(s)).

As all cells are non-elastic by default, there is no keyword to explicitly request this at the time of cell definition.
However, possible applications might require to use an elastic cell during equilibration period, and then “freeze”
this cell at the final geometry for the production run. This can be achieved by using the “ `Cell Fixed` ” command
(without any additional arguments).

If the cell is elastic, there is a volume work term which contributes to the total energy of the system. ORCA
computes this term in every step and adds it to the potential energy. Without this contribution, the conserved
quantity would drift excessively in elastic cell runs.

To completely switch off a previously defined cell, simply use “ `Cell None` ”.

Please note that cells are **not** automatically restarted by using the `Restart` command.

**Examples:**

Cubic cell with edge length 10 Å centered around origin:
```
Cell Cube 10

```
Spherical cell with radius 5 Å centered around origin and 20 kJ mol *[−]* [1] Å *[−]* [2] wall steepness:
```
Cell Sphere 0, 0, 0, 5 Spring 20

```
Elastic orthorhombic cell from (︀ *−* 2 *, −* 2 *,* 0)︀ to (︀12 *,* 12 *,* 10)︀, *𝑡* avg = 100 fs, *𝑐* response = 0 *.* 001:
```
Cell Rect -2, -2, 0, 12, 12, 10 Elastic 100, 0.001

```
Ellipsoid-shaped cell centered on origin with partial radii 5, 10, 15 Å along the X, Y, Z axes:
```
Cell Ellipsoid 0, 0, 0 XYZ 5, 10, 15

```
The commas are optional, but make sure to use them with negative numbers. By default, the minus operator will
act as binary operator if possible *(see* **discussion above** *)* .
```
Constraint

```




Manages constraints in the molecular dynamics simulation. Unlike `Restraints`, constraints are geometric relations which are strictly enforced at every time ( *i. e.*, they do not fluctuate around their target value). All atoms
involved in constraints have to be included in the active region. In principle, constraints also work in Cartesian
geometry optimizations with the `Minimize` command, but the performance together with L-BFGS may be poor
(except for Cartesian constraints, which work flawlessly in L-BFGS). In these cases, try to use the simulated annealing method instead.

The simplest possibility is to constrain the Cartesian position of an atom to some value. A zero-based atom index is
required. The command `Constraint Add Cartesian 3` would fix the fourth atom in the simulation at its current

**986** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

position in space. If the desired position shall be explicitly given, it can be specified via the `Target` modifier, *e.*
*g.*, `Constraint Add Cartesian 3 Target 5.0 1.0 1.0` . To determine which dimensions to fix, one of the
`XYZ`, `XY`, `XZ`, `YZ`, `X`, `Y`, or `Z` modifiers can be added. For example, `Constraint Add Cartesian 3 X Target`
`1.0` would constrain the X coordinate of atom 3 to the absolute value 1.0, but would not influence movement along
the Y and Z coordinate at all.

By using the `Distance` keyword, distances between atoms can be fixed. The command `Constraint Add`
`Distance 3 5` would fix the distance between atom 3 and 5 to its current value. You need to specify exactly
two atom indices; multiple distance constraints are entered via multiple `Constraint` commands. Also here, a
desired distance value can be given via the `Target` modifier, such as `Constraint Add Distance 3 5 Target`
`350_pm` .

Similarly, angles and dihedral angles between atoms can be fixed with the `Angle` and `Dihedral` keywords. Angles
are defined by three atom indices, and dihedral angles by four atom indices. Also here, target values may be
specified. Any combination of Cartesian, distance, angle, and dihedral constraints may be used simultaneously,
and may even be applied to the same group of atoms. A molecule can be made completely rigid by constraining
all its bonds, angles, and torsions. Please make sure that your constraints are not over-determined, and do not
contradict each other. Otherwise, they can’t be enforced and the simulation will print warnings or crash.

A different and powerful class of constraints can be defined with the `Center` argument. Directly after the keyword,
a list of integer atom numbers is expected. This list can be a combination of numbers and ranges, *e. g.*, “ `1, 3,`
`5..11, 14` ”. The weighted average position of this subset of atoms is then constrained to a fixed position in
Cartesian space. By default, the weights are taken as the atom masses, such that the center of mass of the selected
atoms is kept fixed. This allows, *e. g.*, to run a MD simulation of two molecules with fixed center of mass, such that
their center of mass distance remains constant. Custom weights for the definition of the center can be entered by
using the `Weights` modifier after the atom list. It expects exactly the same number of real arguments as the length
of the specified atom list. The geometric center of a group of atoms can be held fixed by setting all weights to 1 *.* 0,
for example “ `Constraint Add Center 2, 5..7 Weights 1.0 1.0 1.0 1.0` ”. If desired, a `Target` for the
center position can be given, which expects three real numbers for the X, Y, and Z coordinate after the keyword.
If no target is specified, the current center position is held fixed.

With the `Rigid` type of constraints, complete groups of atoms can be kept rigid, *i. e.*, keep all their distances and
angles relative to each other, but move as a whole. After the `Rigid` keyword, a list of atom numbers is expected.
More than one group of atoms can be kept rigid at the same time – just call the `Constraint Add Rigid` command
multiple times with different atom lists. Internally, the rigid constraint is realized by defining the correct number of
distance constraints. Such a large number of distance constraints is hard to converge; therefore, warning messages
that RATTLE did not converge will **not** be shown if a rigid constraint is active. Almost planar (or even linear)
groups of atoms are hard to keep rigid by using only distance constraints. It might help do add a dummy atom
outside of the plane and include this into the constraint.

ORCA supports constraints with linearly changing target value during the simulation. To define such a constraint,
write “ `Ramp` ” directly after the “ `Target` ” modifier. After “ `Ramp` ”, twice the number of real numbers that would
have been required for “ `Target` ” follows (two instead of one for distances, angles, and dihedrals; six instead of
three for “ `Cartesian XYZ` ”, and so on). The first half of these arguments are the starting values, the second half
are the final target values. For example, “ `Constraint Add Distance 3 5 Target Ramp 300_pm 400_pm` ”
will define a distance constraint with a target value rising from 300 pm to 400 pm. The ramp will be performed
once during the `Run` command which follows next after the constraint definition. Therefore, the number of steps
specified in this `Run` command also specifies the rate at which the constraint target is modified. After the ramp has
been completed once, the final (constant) target value(s) will be used for all subsequent `Run` commands.

If an already defined constraint is defined again, it is overwritten, *i. e.*, the old version of the constraint is automatically deleted first.

Constraints are removed with the `Remove` keyword. You can either remove single constraints, *e. g.*, `Constraint`
`Remove Distance 3 5`, or groups of similar constraints. To remove all angle constraints, use `Constraint`
`Remove Angle All` . To remove all restraints, enter `Constraint Remove All` .

The `List` argument prints all currently active constraints to the screen and log file. No additional arguments can
be specified.

By default, the external force acting on each constraint is computed in every MD step and written to a file named
“ `basename-constraints.csv` ” *(one column per constraint)* . This can be useful – the average force acting on a
constraint can be, *e. g.*, used for thermodynamic integration [430]. If a large number of constraints is defined, this

**7.48.** ***Ab initio*** **Molecular Dynamics Simulations** **987**

**ORCA Manual** **,** **Release 6.0.1**

might waste computer time if it is not required. In these cases, the constraints can be defined with the `Noprint`
modifier. For such constraints, the acting forces are not computed and not written to the file. Note that constraints
which have been pre-defined *(e. g., by the force field for rigid molecules such as TIP3P water)* automatically have
this modifier.

Please note that each constraint decreases the number of the system’s degrees of freedom (DoF) by one. This effect
is included, *e. g.*, in the temperature computation, where the DoF count enters. From this consideration, it can also
be understood that a constraint behaves significantly different from a restraint with very large spring constant: In
the former case, the DoF is removed from the system; in the latter case, the DoF is still there, but can only move in
a tiny interval.

It is computationally inefficient to define a large number of Cartesian constraints if a subset of atoms simply shall be
fixed. A more efficient approach is to define an active region which only contains the atoms which shall be movable
(see `Manage_Region` command). All atoms outside of the active region will not be subject to time integration and
therefore keep their positions. However, please note that these atoms may not be involved in any other (distance,
angle, dihedral) constraint.
```
Dump

```
Specifies how to write the output trajectory of the simulation. The *quantity* argument can be one of the keywords
`Position`, `Velocity`, `Force`, `GBW`, and `EnGrad` . While the velocities are written in Angstrom/fs, the unit of the
forces is Hartree/Angstrom. The following paragraphs only apply to the first three quantities. Dumping GBW and
EnGrad files works differently, and is described at the very end of this section.

The `Stride` modifier specifies to write only every *𝑛* -th time step to the output file (default is *𝑛* = 1, *i. e.*, every
step). A stride value of zero only writes one frame to the trajectory at the time when the `Dump` command is called
– no further frames will be written during the run. This can be helpful, *e. g.*, to write an initial PDB snapshot for
DCD trajectories, or to keep a single GBW file at some point.

The `Format` modifier sets the format of the output file. Currently, only the `XYZ`, `PDB`, and `DCD` formats are implemented. Please note that the `DCD` format is not well-defined, and different programs use different formats with
this extension. Furthermore, `DCD` files do not store atom type information and are only valid together with a PDB
snapshot of the system (a single PDB snapshot can be written via “ `Dump Position Format PDB Stride 0` ”).
If not specified, ORCA tries to deduce the format from the file extension of the specified file name. If also no file
name is given, trajectories will be written in XYZ format by default.

The `Filename` modifier sets the output file name. If not specified, the default file name will have the form
“ `proj-qty-rgn.ext` ”, where `proj` is the base name of the ORCA project, `qty` is one of `postrj`, `veltrj`, or
`frctrj`, `rgn` specifies the name or number of the region for which the dump is active, and `ext` is the file extension
selected by the `Format` modifier.

If the trajectory file already exists at the beginning of a `Run` command, new frames will be appended to its end
by default. If you want to overwrite the existing file instead, use the `Replace` modifier. The old existing file is
erased only once after a dump with this modifier has been specified. If multiple `Run` commands follow after the
dump definition, the trajectory will **not** be replaced before each of these runs, only before the first one among them.
To overwrite the file another time, simply re-define the dump with the `Replace` modifier. If the file does not yet
exist at the beginning of a run, this modifier has no effect. Appending frames to DCD trajectories is not possible
*(because they store the total frame count in the header)* . Therefore, `Replace` is automatically switched on if the
format is DCD.

**988** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

With the `Region` modifier, the trajectory output can be restricted to a specific region ( *i. e.*, subset of atoms). This
modifier expects one argument, which is either the name of a pre-defined region or the number of a user-defined
region *(see above)* . If not specified, the trajectory of the whole system will be written. Multiple dump commands
for multiple regions can be active at the same time, but each pair of region and quantity *(position/velocity/force)*
can have only one attached dump command at a time (re-defining will overwrite the dump settings).

Use the `None` modifier to disable writing this quantity to an output file. The command “ `Dump Position None` ”
will disable writing of all position trajectories for all regions. To disable only the dump for a specific region, use
“ `Dump Position Region r None` ”, where `r` is the name or number of the region.

The default is to write a position trajectory with `Stride 1` and `Format XYZ` to a file named “ `proj-postrj-all.`
`xyz` ”, where “proj” is the base name of the ORCA project. If you want to create no output trajectory at all, use
“ `Dump Position None` ” as described above.

The `Dump GBW` command keeps a copy of the GBW file every *𝑛* steps, which can be used for computing properties along the MD trajectory, *e. g.*, plotting orbitals. This does not yield a trajectory, as all the GBW files are
stored individually. The value of *𝑛* is controlled by the `Stride` modifier. The file names are formed by appending the step number *(six digits with leading zeros)* followed by “.gbw” to the `Filename` argument. Therefore,
this argument should not contain the “.gbw” extension by itself. If the `Filename` modifier is not specified, the
default will be “proj-step”, where “proj” is the base name of the ORCA project. This will lead to files such as
“ `proj-step000001.gbw` ”, etc. The `Format` and `Region` modifiers can not be used for `Dump GBW` .

In a very similar way, `Dump EnGrad` stores an ORCA `.engrad` file *(energy and gradient)* every *𝑛* steps. All the
`.engrad` files are stored individually *(not as a continuous trajectory)* . The value of *𝑛* is controlled by the `Stride`
modifier. By default file names such as “ `proj-step000001.engrad` ” will be used.
```
Initvel

```
Initializes the velocities of the atoms by random numbers based on a Maxwell–Boltzmann distribution, such that
the initial temperature matches *𝑡𝑒𝑚𝑝* (see also section *1.5.2* ). Please note that this overwrites all velocities, so do
not call this command when your system is already equilibrated ( *e. g.*, to change temperature – use a thermostat
instead).

The total linear momentum of the initial configuration is automatically removed, such that the system will not start
to drift away when the simulation begins. This only concerns the initial configuration. Total linear momentum
might build up during the simulation due to numeric effects.

With the `Region` modifier, the initialization of velocities can be performed for a specific region ( *i. e.*, subset of
atoms). This modifier expects one argument, which is either the name of a pre-defined region or the number of a
user-defined region *(see above)* . If not specified, the command acts on the whole system.

The `No_Overwrite` modifier only initializes the velocities if no atom velocities have been defined/read before.
This is useful in combination with the `Restart` command: After reading an existing restart file, the velocities
are already known, and the initialization will be skipped if this modifier is used. The following combination of
commands in a MD input would initialize the velocities only upon first execution, and restart the positions and
velocities on all following executions of the same input:



If neither the `Initvel` command nor a `Restart` command is not invoked before a `Run` call, the atom velocities
will be initialized to zero before starting the run.

**7.48.** ***Ab initio*** **Molecular Dynamics Simulations** **989**

**ORCA Manual** **,** **Release 6.0.1**
```
Manage_Colvar

︁

︁


```
Defines collective variables (“Colvars”) which are used for `Metadynamics` or to impose `Restraints` on the
system. In a general sense, a Colvar is simply a continuous function of all the atom positions which returns a real
number. As Colvars don’t have any effect on the simulation by themselves, they can currently only be defined or
re-defined; there is no requirement for deleting them. The second argument of the `Manage_Colvar` command is
the number of the Colvar. This number is used to address the Colvar later. Allowed numbers are within the range
of 1 *. . .* 10000. If a Colvar number which had previously been defined is defined again, it is simply overwritten
*(and all restraints based on the old Colvar are deleted!)* . The third mandatory argument is the type of the Colvar,
which can be `Distance`, `Angle`, `Dihedral`, and `CoordNumber` . More Colvar types will probably be added in the
future *(feel free to make suggestions in the forum!)* .

Distance Colvars are defined between two points in space. Each point can either be a single atom (expressed
by “ `Atom` ”) or the weighted average (center) of the positions of a group of atoms (expressed by “ `Group` ”). For
example, the command “ `Manage_Colvar Define 1 Distance Atom 0 Atom 7` ” defines Colvar 1 to be the
distance between atoms 0 and atom 7 *(as always, the atom count starts at zero)* . On the other hand, the command
“ `Manage_Colvar Define 2 Distance Group 0 1 2 Group 3 4 5` ” sets Colvar 2 to be the distance between
the centers of atoms 0, 1, 2 and atoms 3, 4, 5. If many atoms shall be selected, the range syntax “ `Group 0..2` ” can
be used, including multiple such ranges if required, such as in “ `Group 0..2, 5, 7..11` ” *(see also discussion*
*of the* `Manage_Region` *command)* . By default, the center of mass is used for groups. However, weights can be
manually specified if required by using the “ `Weights` ” modifier directly after the atom list for the center is finished.
“ `Weights` ” expects as many real numbers as the group possesses atoms, for example “ `Manage_Colvar Define`
`2 Distance Atom 0 Group 1 2 3 Weights 1.0 1.0 1.0` ”. The “ `Atom` ” and “ `Group` ” syntax can be mixed,
*e. g.*, to define the distance between a single atom and a center of mass. When defining distance Colvars, one of
the modifiers `X`, `Y`, `Z`, `XY`, `XZ`, `YZ`, and `XYZ` may be specified directly after “ `Distance` ”. The first three among them
denote that the positions shall be projected onto the corresponding Cartesian vector before computing the distance.
The following three modifiers require that the two positions are projected into the corresponding Cartesian plane
prior to computing the distance. The last one is the default *(just measure the standard distance in 3D space)* and
does not need to be specified explicitly.

In a very similar manner, angle Colvars can be defined. Instead of two points in space, an angle Colvar is defined via
three points in space, each of which can either be an “ `Atom` ” or a “ `Group` ” *(see above)* . For example, the command
“ `Manage_Colvar Define 3 Angle Group 0 1 2 Atom 3 Atom 4` ” defines Colvar 3 to be the angle spanned
by the mass center of atoms 0, 1, 2, atom 3, and atom 4, respectively.

Dihedral Colvars are defined through four points in space, each of which can either be an “ `Atom` ” or a “ `Group` ”
*(see above)* . For example, the command “ `Manage_Colvar Define 4 Dihedral Atom 0 Group 1..5 Atom`
`6 Atom 7` ” defines Colvar 4 to be the dihedral angle spanned by atom 0, the mass center of atoms 1, 2, 3, 4, 5,
atom 6, and atom 7, respectively.

The Colvar type “ `CoordNumber` ” has been suggested in literature [408] to measure the coordination number of
some atom species around some other atom. An example where this type of Colvar has been successfully applied
is the calculation of p *𝐾* A values of weak acids in solvent via Metadynamics [855, 856]. The Colvar is defined by
the following equation

︁

︁


*𝑁* *𝐵* ︁
∑︁ ︁

*𝑗*


1 *−* *𝑟* *𝑖* *𝑗* ︁
( *𝑟* cut

1 *−* *𝑟* *𝑖* *𝑗* ︁
( *𝑟* cut


) ︁ 6

︁


︁

) ︁ 12 *[,]*


︁

1
*𝐶* :=
*𝑁* *𝐴* ︁


*𝑁* *𝐴* ︁
∑︁ ︁

*𝑖*


︁

︁

**990** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

where *𝑁* *𝐴* is the set of atoms which is coordinated *(typically only one atom)*, *𝑁* *𝐵* is the set of coordinating atoms,
*𝑟* *𝑖𝑗* is the distance between atoms *𝑖* and *𝑗*, and *𝑟* cut is a constant cutoff distance which specifies a threshold for coordination. After “ `CoordNumber` ”, two atoms or groups of atoms must follow, which correspond to *𝑁* *𝐴* and *𝑁* *𝐵*,
respectively. The distance cutoff is specified after the “ `Cutoff` ” modifier which should follow the two group definitions. For example, the command “ `Manage_Colvar Define 5 CoordNumber Atom 0 Group 1..10 Cutoff`
`200_pm` ” defines Colvar 5 as the coordination number of the group of atoms 1 to 10 around atom 0 with a distance
cutoff of *𝑟* cut = 200 pm.

For every defined Colvar, the temporal development of the position and the external force acting on the Colvar is
written to a text file named “ `basename-colvars.csv` ” in every MD step by default. If a large number of Colvars
are defined, this might be a waste of time and disk space. In these cases, the “ `Noprint` ” modifier can be specified
when defining the Colvar. Colvars defined with this modifier will not appear in the text file, and the force acting
on the Colvar will not be computed *(if not required otherwise, e. g., for restraints)* .
```
Manage_Region

```
Defines or modifies regions. Regions are just subsets of atoms from the system – see [ **Section**
***1.3*** ](#moldyn:sec_regions) above.

As described above, there exist several pre-defined regions which are identified by names. The only such predefined region which can be re-defined by the user is the `active` region. All atoms in this region are subject to
time integration in molecular dynamics and displacement in minimization runs. All other atoms are simply ignored
and remain on their initial positions. Please note that the `active` region may never be empty.

To re-define the `active` region, use the command “ `Manage_Region active Define 1 5 7 ...` ”. The integer
arguments after `active` are the numbers of the atoms to be contained in the region, in the order given in the ORCA
input file. Atom numbers are generally zero-based in ORCA, *i. e.*, counting starts with 0.

Apart from that, user-defined regions are supported. These are identified with an integer number instead of a name.
The integer numbers do not need to be sequential, *i. e.*, it is fine to define region 2 without defining region 1. To
give an example, the command “ `Manage_Region 1 Define 17 18 19` ” defines region 1, and adds atoms 17, 18,
and 19 to this newly defined region. Using `Define` without an atom list, such as in “ `Manage_Region 1 Define` ”,
deletes the user-defined region, as it will be empty then. Atoms can be added to or removed from previously defined
regions (including the `active` region) with the `AddAtoms` and `RemoveAtoms` operations. The atom numbers
specified after the operation name are added to or removed from the region. For example, “ `Manage_Region`
`active RemoveAtoms 15 16 17` ” will remove atoms 15 to 17 from the `active` region (and add them to the
`inactive` region instead).

If you want to specify a range of atoms, you can use the syntax “ `a..b` ” to include all atom numbers from `a` to
`b` . If you want only, *e. g.*, every third atom in a range, you can use “ `a..b..i` ” to add the range from `a` to `b` with
increment `i` . As an example, “ `2..10..3` ” will expand to the list `2, 5, 8` . You can mix atom numbers and ranges,
as shown in the following two examples *(as always, the commas are optional)* :



Instead of an atom list, the `Element` modifier can be used, followed by a string which represents an element label.
This will have the same effect as specifying an atom list with all atoms of this element type instead. Don’t forget the
double quotes around the element label string. For example, `Manage_Region active RemoveAtoms Element`
`"H"` removes all hydrogen atoms from the active region.

**7.48.** ***Ab initio*** **Molecular Dynamics Simulations** **991**

**ORCA Manual** **,** **Release 6.0.1**
```
Metadynamics

```
Sets the parameters for a `Metadynamics` simulation [487]. After all parameters have been set, the actual simulation
can be started by a `Run` command. The parameters can either all be set in a single call to the `Metadynamics`
command, or distributed over multiple such calls to avoid very long lines. In both cases, there are some rules for
the order of parameter settings. All Colvars for the Metadynamics need to be specified before setting any other
parameters. Modifiers which are related to Colvars (such as `Scale`, `Wall`, or `Range` ) only apply to the Colvar that
was specified last before them in the `Metadynamics` command.

The `Colvar` modifier specifies a Colvar to be used in the Metadynamics simulation. It expects one integer argument, which is the number of the Colvar, as defined before via the `Manage_Colvar` command. The ORCA MD
module supports one- and two-dimensional Metadynamics, so either one or two `Colvar` modifiers can be given.
The number of `Colvar` modifiers specified defines the dimensionality of the Metadynamics simulation. Please
note that modifiers which are related to Colvars (such as `Scale`, `Wall`, or `Range` ) only apply to the Colvar that
was specified last before them, so after specifying the first Colvar, these should be set before specifying the second
Colvar.

Colvars can have different physical units, such as Angstrom for distances and degree for angles. In a multidimensional Metadynamics run, the different numerical magnitude of the corresponding numbers can be an issue:
Angles span over a range of 180 degree, while distances will often be within an interval of only 10 Angstrom. To
bring all Colvars to a similar scale, the Metadynamics module internally divides every Colvar by a user-supplied
constant. These internal values are dimensionless, they will be referred to as “scale units”. For a previously specified Colvar, the scale constant can be set via the `Scale` modifier. It expects one real argument which has to
be specified in physical units of the Colvar (length units for distance Colvars, angle units for angle and dihedral
Colvars). Coordination number Colvars are dimensionless anyway. If not specified, reasonable default values for
the scale are used, which are 1.0 Angstrom for distance Colvars, 20.0 degree for angle and dihedral Colvars, and
0.2 for coordination number Colvars. Note that the `Scale` modifier only applies to the Colvar given last before it
in the `Metadynamics` command.

As an example, consider the following commands to set up a two-dimensional Metadynamics simulation:



**992** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

To keep Colvars within the region of interest during Metadynamics simulations, harmonic walls can be imposed
on Colvars. This is achieved via the `Wall` modifier. As a first argument, it expects the direction of the wall,
which can be `Lower` or `Upper` . The second argument is the position of this wall – given in physical units of the
Colvar ( *e. g.*, Angstrom for distance Colvars), **not** in scale units. As an optional third real argument, the spring
constant of the harmonic wall can be specified in kJ mol *[−]* [1] unit *[−]* [2], where unit is the default physical unit of the
Colvar (Angstrom for distances, degree for angles). If omitted, a spring constant of 50 kJ mol *[−]* [1] Angstrom *[−]* [2] for
distances, 0.5 kJ mol *[−]* [1] degree *[−]* [2] for angles, and 250.0 kJ mol *[−]* [1] for coordination numbers is used *(a reasonable*
*choice)* . Both lower and upper wall can be defined after one `Wall` modifier, such as in “ `Metadynamics Colvar`
`1 Wall Lower 3.0_A 50.0 Upper 10.0_A 50.0` ”. Note that one-sided harmonic walls can also be imposed
on Colvars via the `Restraint` command. For standard Metadynamics, this is redundant. However, for extended
Lagrangian Metadynamics *(see below)*, it makes a difference: Restraints act on the Colvar and therefore on the real
atomistic system, whereas the walls defined in the `Metadynamics` command act directly on the virtual particle.
Again, note that the `Wall` modifier only applies to the Colvar given last before it in the `Metadynamics` command.

The last modifier which applies to Colvars is the `Range` modifier. It has no influence on the Metadynamics run itself,
and only controls the output of the free energy profiles. The `Range` modifier expects three arguments. The first
two have to be real numbers and define the lower and upper interval borders for which the free energy profile with
respect to this Colvar shall be output. The third argument is of integer type and controls the number of grid points
to produce for this interval. In two-dimensional Metadynamics, both Colvars can have associated `Range` modifiers,
which then control the interval and resolution of the 2D grid for the free energy profile. In this case, the grid should
not be much finer than 100 *×* 100; otherwise, the evaluation of the grid points will become quite slow. If no `Range`
modifier is given, default values are used (range of 0 *. . .* 20 Angstrom for distance Colvars, 0 *. . .* 180 degree for
angle Colvars, *−* 180 *. . .* 180 degree for dihedral Colvars, and 0 *. . .* 3 for coordination number Colvars). As above,
note that the `Range` modifier only applies to the Colvar given last before it in the `Metadynamics` command.

Addition of new Gaussian hills to the bias potential is controlled via the `HillSpawn` modifier. It expects three
arguments. The first argument has to be of integer type and defines the hill spawning frequency, *i. e.*, every how
many MD steps a new hill is added *(typically every 10 – 50 fs)* . The second argument is a real number and specifies
the height of each new hill in units of kJ mol *[−]* [1] *(typically 0.1 – 1.0 kJ mol* *[−]* [1] *)* . The third argument sets the width
of the Gaussian hills *𝜎* (which is the standard deviation, **not** the variance *𝜎* [2] ) in “scale units” – see the `Scale`
modifier above. In two-dimensional Metadynamics simulations, the width applies for both dimensions at the same
time, and the scales of the two Colvars need to be adjusted to obtain the correct “aspect ratio” of the hill width.
Standard choices for *𝜎* are 0.1 – 1.0 scale units. The hill spawning parameters can be changed at any point during
a Metadynamics simulations, not modifying the hills which are already present. If spawning of new hills shall be
temporarily suspended during a Metadynamics simulations, “ `Metadynamics HillSpawn Off` ” can be specified.
If you want do delete all hills, consider the `Reset` modifier described below.

The `Store` modifier controls how often the current intermediate free energy profile is saved to disk.
It expects one integer argument which specifies the number of MD simulation time steps between two
such stores. In case of one-dimensional Metadynamics, these free energy profiles have the file names
“ `basename-metadynamics_profile_###.csv` ”, where “ `###` ” indicates the step number after which the profile was written. In addition to that, a file “ `basename-metadynamics_profile_history.csv` ” is written, which contains all the previously computed free energy profiles as columns, so that they can easily
be printed in one single plot. For two-dimensional Metadynamics, Gnuplot source files with file names
“ `basename-metadynamics_2d_profile_###.gp` ” are written, which can be converted into contour plots with
the freeware tool Gnuplot *(runs both on Windows and GNU Linux)* . The raw data for these contour plots can be
found in corresponding files named “ `basename-metadynamics_2d_profile_###.gp.csv` ”. Note that in both
cases, the free energy scale origin is set to the deepest free energy well, so that all numbers are positive. If the
`Store` modifier is not specified, the free energy profiles are stored every 1000 MD steps per default.

The `WellTempered` modifier switches on well-tempered Metadynamics [73]. In contrast to standard Metadynamics, the free energy profile converges towards a limit for long runs with this approach. In short terms, this approach
scales down the hill size at positions where already many hills have been spawned before, so that the changes in the
bias potential become smaller over time *(convergence)* . The `WellTempered` modifier expects one real argument,
which is the so-called bias temperature, specified in temperature units. The bias temperature should be chosen in
a way so that [1] 2 *[·][ 𝑘]* [B] *[ ·][ 𝑇]* [Bias] [ is around the same size as the largest barrier which the simulation shall overcome.]

For example, a bias temperature of 12 000 K is well-suited to overcome barriers of around 100 kJ mol *[−]* [1] . Note
that the Metadynamics module needs to know the simulation temperature in order to reconstruct the free energy
profile in a well-tempered Metadynamics run. Typically, a thermostat should be active during a Metadynamics run,
keeping the simulation temperature constant. In this case, the temperature is simply obtained from the thermostat.

**7.48.** ***Ab initio*** **Molecular Dynamics Simulations** **993**

**ORCA Manual** **,** **Release 6.0.1**

However, if no thermostat for the region `all` is specified, the simulation temperature has to be specified manually
for well-tempered Metadynamics. This can be achieved by the `temperature` modifier, which expects one real
argument – the simulation temperature in temperature units.

The `Lagrange` modifier switches on extended Lagrangian Metadynamics [408]. In this variant, a virtual particle
*(with mass and velocity)* moves in the space spanned by the Colvars, and the only connection between this particle
and the real atomistic system is a harmonic spring. The bias potential *(the Gaussian hills)* only acts on the virtual
particle. The first argument is the mass of the virtual particle in a.m.u. The second argument is the harmonic
spring constant in units of kJ mol *[−]* [1], which is evaluated in scale units – see the `Scale` modifier above. Typical
values depend on the system and Colvars, but might be 100 a.m.u. and 10 kJ mol *[−]* [1] . Optionally, a third and
fourth parameter can be given to switch on thermostating of the virtual particle. A simple Berendsen thermostat
is applied here. The third argument is the target temperature of the virtual particle, and the fourth argument is the
thermostat time constant *𝜏* . A good choice would be a target temperature of 100 K and *𝜏* = 10 fs. Note that in
contrast to the normal Berendsen thermostat, the virtual particle is only cooled, but never heated. In other words,
the thermostat only becomes active if the instantaneous temperature of the virtual particle becomes larger than the
target temperature. This is to ensure that the virtual particle can change its direction – otherwise, it might happen
that it is driven in the same direction for very long time intervals.

The `Reset` modifier resets the bias profile, *i. e.*, it deletes all hills which had been spawned, so that the bias profile
becomes flat again. All other parameters of the Metadynamics simulation are not modified. If, for example, hill
spawning is still on, then new hills will be spawned in the next simulation run.

The `Off` modifier completely switches off Metadynamics. It deletes all hills and turns off the Metadynamics
module. It also resets the choice of Colvars for Metadynamics, so you will need to use this first if you want to
set up a second different Metadynamics run within the same input script. This modifier can only be given as first
argument to the `Metadynamics` command, and no further arguments can follow.

A restart file for the Metadynamics module (file name “ `basename.metarestart` ”) is written each time a new hill
has been spawned. The `Restart` command detects this file and automatically restarts the Metadynamics run *(i. e.,*
*loads all hills and the positions and velocities of the extended Lagrangian virtual particle if active)* . However, this
only happens when Metadynamics is active and set up at the time when the `Restart` command is invoked. The
parameters for the Metadynamics simulation are **not** restarted. Therefore, leave all parameter settings via calls to
the `Metadynamics` command in place in your input file, and simply call the `Restart` command after all those,
directly before the `Run` command.

Please see also the discussion on Metadynamics in [ **Section** ***1.3*** ](#moldyn:sec_metadynamics).

This section is concluded with a full example for a two-dimensional well-tempered extended Lagrangian Metadynamics run with restart ability *(just run the same input again to continue the simulation where it ended last)* . The
two Colvars are defined as distances between atoms. You need to adapt all parameters in blue to your question and

system:



**994** **Chapter 7. Detailed Documentation**

```
Minimize

```

**ORCA Manual** **,** **Release 6.0.1**


Performs a Cartesian energy minimization of the system. For molecules, this is less efficient than ORCA’s built-in
geometry optimization in internal coordinates *(i. e., requires more steps to converge)* . However, the algorithms
employed here also work with large atom counts *(e. g., 50 000)* as sometimes encountered in QM/MM simulations,
which is absolutely out of scope of ORCA’s primary optimization module. Furthermore, the minimization also
works under all types of constraints (which some limitations in the case of L-BFGS) that have been set with the
`Constraint` command, and also includes the effect of the repulsive simulation cell if activated. Only atoms
contained in the active region are displaced, while all other atoms are kept at their positions.

The simplest way of performing a minimization is simply calling the `Minimize` command without arguments.
This defaults to the L-BFGS method, which is fairly robust and efficient. If the minimization seems unstable, try to
reduce the `History` or `StepLimit` parameters. L-BFGS may sometimes show poor performance with constraints
other than Cartesian type. Apart from that, there is also a simulated annealing method implemented, which can
be selected by specifying `Anneal` as the first argument. In contrast to L-BFGS, the simulated annealing method
works equally well with all types of constraints. There is also a `Combined` method, which is a combination of
some L-BFGS steps in the beginning, followed by a simulated annealing run until the temperature falls below a
threshold, and another final L-BFGS run until the convergence criteria are reached.

With the `Steps` modifier, the maximum number of minimization steps can be specified. If this number of steps has
been performed, the minimization finishes, no matter if the convergence criteria are fulfilled or not. The default
value is 500.

The `MaxGrad` and `RMSGrad` modifiers control the convergence thresholds for the largest gradient on some atom and
the root mean square average of the gradients. The default values are currently set to 5.0 and 1.0 kJ mol *[−]* [1] Å *[−]* [1],
respectively, which is about the same criterion as the default setting in the primary ORCA geometry optimization.

If the `TempConv` modifier is given, a simulated annealing run finished after the temperature was monotonously
decreasing within 5 successive steps, and dropped below the specified value. Note that the simulated annealing
run will finish if either this condition is reached, or the gradient thresholds are observed. It is not required to fulfill
both criteria.

The `Accel` modifier specifies the acceleration factor for simulated annealing runs *(has no effect on L-BFGS)* . As
long as the angle between velocity vector and gradient vector of some atom is below 90 degrees, the gradient is
multiplied by this factor and the velocity is multiplied by a fraction of this factor. This helps to enforce a faster
movement in gradient direction. The default value is 4.0. If this feature is not desired, use `Accel 1.0` to switch it
off (1.0 means “no artificial acceleration”).

The `Damp` modifier is the damping factor for simulated annealing runs *(has no effect on L-BFGS)* . Atom velocities
are multiplied by this factor in every integration step. The default value is 0.98. Smaller values will make the
algorithm more stable and less prone to oscillations and overshoots, but will also require significantly more steps
to converge. Don’t use values *≥* 1, as then it won’t be an “annealing” anymore :-)

The `StepLimit` modifier specifies the maximum displacement of any atom *(in length units)* that can happen in
one step of a minimization run. This can help to avoid large, unreliable steps which could lead to abrupt jumps in
geometry and very high potential energies. This modifier concerns both L-BFGS and simulated annealing runs.

**7.48.** ***Ab initio*** **Molecular Dynamics Simulations** **995**

**ORCA Manual** **,** **Release 6.0.1**

Negative values disable the step limit. The step limit is disabled by default. If you need to switch it on, try something
in the order of 0.1 Å.

The `History` modifier controls the depth of gradient and position vector history that is used in the L-BFGS method
to approximate the inverse Hessian. The default value is 20. Smaller values can help to stabilize the algorithm.

With the `Noise` modifier, small random numbers can be added to the atom positions before the minimization starts.
This can help to escape local maxima and saddle points in the minimization. For example, a minimization of an
initially linear water molecule would not be able to leave this maximum – but with some random “noise”, it will
be possible. The modifier expects one real argument which specifies the maximum atom displacement in length
units (something like 0.01 Å will be reasonable). This feature is switched off by default.

If the `OnlyH` modifier is given, all non-hydrogen atoms are removed from the active region before the minimization
starts. After the minimization has finished, the original active region is restored. This is helpful if only hydrogen
positions shall be optimized, *e. g.*, to refine experimental crystal structures.
```
PrintLevel

```
Controls the amount of information which is printed to the screen during the simulation. `Debug` should be used
only in rare cases, because it might slow the simulation down heavily.

The default value is `Medium` .
```
Randomize

```
There are a few algorithms in the ORCA MD module which rely on random numbers, *e. g.*, the initialization of
atom velocities with the `Initvel` command. These random numbers are so-called “pseudo-random numbers”,
produced by a deterministic generator. This generator has a *state*, which is simply an integer number. If initialized
to the same state, the generator will always create the same sequence of “random” numbers. This sounds like a
deficiency at first thought, but is a very important feature for scientific reproducibility and for debugging purposes.
If you start the same MD input file with “random” velocity initialization a couple of times, the trajectory will be
exactly identical in all runs.

However, there are cases in which this behavior is not desired, *e. g.*, if you want to average a property over multiple
trajectories of the same system. In these cases, call the `Randomize` command in the beginning of the input. If no
argument is given, the random number generator is initialized with the current system time as a seed. MD runs
started at different times will have different random velocities in the beginning. If you want more control over
this process, you can also specify a positive integer number as argument, which is used as initial random seed.
Simulations started with the same seed argument will have identical initial random velocities (if all other system
parameters such as atom count, atom types, ... remain identical).

Without a call to `Randomize`, a seed of 1 is always used.

**996** **Chapter 7. Detailed Documentation**

```
Restart

```

**ORCA Manual** **,** **Release 6.0.1**


Reads a restart file to continue a previous molecular dynamics run. Such a restart file is written after every simulation step, such that a crashed simulation may easily be recovered. The file name of the restart file may be given
via *fname* ; otherwise, it is deduced from the project’s base name as `<basename>.mdrestart` .

If the `IfExists` modifier is specified, a restart is only performed if the restart file exists. The error and abort that
would normally occur in case of a non-existent restart file are suppressed by this flag. This is useful in the first of
a series of batch runs, where the restart file does not yet exist in the beginning.

Please note that the following quantities are stored to/loaded from restart files:

  - Atom Positions

  - Atom Velocities

  - Thermostat internal state *(only for NHC)*

  - Metadynamics hills and extended Lagrangian internal state

  - Simulation step number and elapsed physical time

All other quantities (timestep, regions, thermostat, constraints, cells, etc.) are **not** restarted and need to be set in
the input file, typically **before** the `Restart` command. It is safe to just call the `Restart` command immediately
before the `Run` command.

Please see also the discussion on restarting simulations in [ **Section** ***1.3*** ](#moldyn:sec_restart).
```
Restraint

```
This command imposes restraints on collective variables (“Colvars”) defined before via the `Manage_Colvars`
command. As a first argument, it expects the kind of operation to perform, which can be `Add` and `Reset` . The
second argument needs to be the keyword “ `Colvar` ”, and the third argument is an integer number specifying the
Colvar on which the operation shall be performed.

If the first argument is “ `Add` ”, a new restraint is added to the specified Colvar. Note that an arbitrary number
of restraints of different types can be active on a Colvar at the same time. The next argument after the Colvar
number needs to be the type of the restraint. Currently, `Harmonic` and `Gaussian` are allowed. When adding
harmonic restraints, the `Spring` modifier can be given, specifying the harmonic spring constant of the restraint in

**7.48.** ***Ab initio*** **Molecular Dynamics Simulations** **997**

**ORCA Manual** **,** **Release 6.0.1**

kJ mol *[−]* [1] unit *[−]* [2], where unit is the default physical unit of the Colvar (Angstrom for distances, degree for angles).
If not specified, a value of 50 kJ mol *[−]* [1] unit *[−]* [1] is used. When adding Gaussian restraints, the `Height` and `Sigma`
modifiers are allowed. The former sets the height of the Gaussian hill in kJ mol *[−]* [1], while the latter sets the width
of the Gaussian function in physical Colvar units *(𝜎* *is the standard deviation,* ***not*** *the variance 𝜎* [2] *)* . The height
can be either positive or negative, allowing for both Gaussian hills and Gaussian wells. If not specified, the default
values of *−* 10 kJ mol *[−]* [1] for the height *(i. e., Gaussian well)* and 10 Colvar units *(e. g., Angstrom or degree)* for
sigma are used.

The position of the new restraint is controlled via the `Target` modifier, which expects one real argument in Colvar
units. If the restraint shall be an one-sided wall, the modifiers `Lower` and `Upper` can be used instead of `Target` . It
is also possible to specify both `Lower` and `Upper` in order to define a lower and an upper wall at different positions
in one command. If `Ramp` is given directly after `Target`, `Lower`, or `Upper`, a restraint with linearly moving target
position over time is defined. `Ramp` expects two arguments, which are the initial restraint position, and the final
restraint position after the next subsequent `Run` command.

The following example shows how to assign a harmonic two-sided restraint with different lower and upper wall parameters to a distance Colvar with number 7 that has been previously defined via the `Manage_Colvars` command:
```
Restraint Add Colvar 7 Harmonic Lower 400_pm Spring 50.0
Restraint Add Colvar 7 Harmonic Upper 800_pm Spring 80.0

```
By default, some additional data *(current position, potential energy, external force, internal force)* for each restraint
is printed to a file with the name “ `basename-restraints.csv` ” in every MD step. This data can be used, *e. g.*,
for thermodynamic integration. If a large number of restraints is defined, this can waste time and disk space. To
switch this off for a restraint, specify the `Noprint` modifier when defining it.

If the first argument was “ `Reset` ”, all restraints imposed on the specified Colvar are deleted. No further arguments
or modifiers *(apart from the three mandatory arguments described above)* can be given.
```
Run

```
Performs a molecular dynamics run over *𝑛* time steps with the current settings, applying the velocity Verlet algorithm to solve the equations of motion (see section *1.5.1* ). You might want to call commands like `Timestep`,
`Initvel`, `Thermostat`, and `Dump` before. Please note that only atoms within the `active` region will be subject
to time integration. All other atoms will be skipped, and will therefore retain their initial positions.

The `StepLimit` modifier can be used to limit the maximum displacement of any atom in a MD time integration
step. In addition to the displacement, also the velocities will be limited to a maximum of *value·* ∆ *𝑡* . This can help
to stabilize the dynamics if the initial geometry is poor and large forces are acting (close atoms, etc.). The keyword
expects one real argument in distance units. A reasonable choice would be 0.1 Å.

If the `CenterCOM` modifier is given, the center of mass (CoM) of the total system is kept fixed. Normally, the
CoM should not drift anyway, because the velocity initialization is performed in a way which gives the CoM a zero
initial velocity, and the conservation of momentum should keep it like that. However, numerical errors and massive
`Thermostats` *(among other factors)* can break this momentum conservation, leading to a drift of the CoM over
time. If this shall be avoided, specify this modifier.

If no call to `Initvel` occurred before this command, the atom velocities are initialized to zero. If no call to
`Timestep` occurred before this command, a default time step of 0 *.* 5 fs is set.

You can cleanly end a MD run by creating an empty file with the name “ `EXIT` ” *(note the all-uppercase letters*
*on case-sensitive file systems)* . On Unix operating systems such as GNU Linux, this can easily be achieved by the
command “ `touch EXIT` ”. will detect the file, abort the MD run, and delete the file. You will still get the remaining
output *(such as the timing statistics)*, and you don’t have to delete all the remaining “ `.tmp` ” files, which both would
not be the case if you would have killed the process instead.

**998** **Chapter 7. Detailed Documentation**

```
SCFLog

```

**ORCA Manual** **,** **Release 6.0.1**


Controls how/if the detailed output from the electron structure calculation ( *i. e.*, integrals, scf, gradient, ...) will
be written to log files. `Discard` completely discards the output. `Last` only keeps the last output for each program
call (useful to read error message if simulation aborts). `Append` redirects all the output into one single log file
(“basename.scf.log”, “basename.int.log”, “basename.grad.log”, ...), appending each step at the end of the file.
`Each` writes the output for each step and each program to different log files, which have the step number in their
file names.

The amount of information which is printed to the SCF log file can be controlled by the standard ORCA print
flags, such as “ `%output PrintLevel Maxi end` ”. Note that by default, ORCA reduces the print level after the
first SCF. Due to this, properties such as orbital energies and population analyses will only be printed once by
default. If you want to keep the print level constant for subsequent SCF runs, disable this feature via “ `%method`
`ReducePrint false end` ” in the ORCA input.

The default value is `Append` . Note that this can lead to large log files in long runs.
```
Screendump

```
Prints the current state of the MD module (atom positions, velocities, potential and kinetic energy, cell properties,
etc.) to the screen and log file in a well-defined and “grepable” format. This is mostly useful for unit testing, *e. g.*,
to verify if the system state after a MD run equals the state obtained from some other ORCA binary distribution.
```
Thermostat

```
Changes the atom thermostat settings for subsequent simulation runs. “ *Type* ” sets the thermostat type. Currently,
three thermostat types are implemented: Berendsen [92], Nosé–Hoover chains (NHC) [563, 564], and “Canonical
Sampling through Velocity Rescaling” (CSVR) [129]. The very basic and robust Berendsen thermostat should
only be used for early pre-equilibration runs, as it does **not** sample the canonical ensemble and leads to problems
such as the flying ice cube effect. Both the NHC and the CSVR thermostats are very sophisticated, and correctly
sample the canonical ensemble. One of these two should be used in all standard NVT simulations. Use `None` as
type to disable the thermostat.

The optional *temperature* argument sets the target temperature to which the system is thermostated. If this argument
is omitted, the temperature from the last call to the `Initvel` command is used (if no such call was invoked before,
the simulation is aborted).

**7.48.** ***Ab initio*** **Molecular Dynamics Simulations** **999**

**ORCA Manual** **,** **Release 6.0.1**

The `Timecon` modifier sets the coupling strength of the thermostat (large time constants correspond to weak coupling). The default value is 10 fs, which is a relatively strong coupling. For a production run, 100 fs would be
appropriate. Values in the range of 10 *. . .* 100 fs are reasonable (see also section *1.5.3* ).

If the `Ramp` modifier is used, a temperature ramp can be applied during a MD run. The final temperature at the
end of the ramp has to be specified directly after the modifier. The initial temperature at the beginning of the ramp
is taken from the *temperature* argument *(or from the last* `Initvel` *command if this argument is missing)* . The
temperature ramp is applied only to the `Run` command which first follows the ramp definition. The slope of the
ramp is chosen such that the final temperature is reached at the end of the run. Any subsequent `Run` command
will simply use the final temperature for thermostating. To apply another temperature ramp, you need to explicitly
define it again.

The `Chain`, `MTS`, and `Yoshida` modifiers only apply to NHC thermostats. They specify the chain length of the
Nosé–Hoover chain (default: 3), the number of multiple time steps in which the thermostat integration is performed
(default: 2), and the order of the Yoshida integrator used (default: 3, allowed: 1, 3, 5, 7), respectively. Normally,
there is little need to modify one of these parameters. For more information, refer to the original publications [563,
564].

The `Massive` modifier activates *massive thermostating*, which means that each degree of freedom is assigned to an
independent thermostat. This is useful for pre-equilibration runs (helps to reach energy equipartition) and should
not be used during production runs, as it might heavily distort the dynamics. Note that massive thermostats also
break the conservation of momentum (both linear and angular), so better specify the `CenterCOM` modifier for the
`run` command if this is an issue. Please also note that massive NHC thermostats of large systems can be quite slow,
because each NHC thermostat is a dynamical system on its own which needs to be time integrated.

With the `Region` modifier, the thermostat can be attached to a specific region ( *i. e.*, subset of atoms). This modifier
expects one argument, which is either the name of a pre-defined region or the number of a user-defined region *(see*
*above)* . If not specified, the thermostat acts on the whole system. Multiple thermostats for multiple regions can be
active at the same time, but each region can have only one attached thermostat at a time (re-defining will overwrite
the thermostat settings).

The command “ `Thermostat None` ” will remove all thermostats from all regions. If you want to disable a thermostat for a specific region only, use “ `Thermostat None Region r` ”, where `r` is the name or number of the
region.

Please note that all three implemented thermostat types will show no effect (or unexpected effects) if the system’s
temperature is close to 0 K, as they all work by multiplying the velocities with a *(more or less complicated)* factor.
```
Timestep

```
Sets the simulation time step ∆ *𝑡* used to integrate the equations of motion for all following runs to *𝑑𝑡* . If your
system contains hydrogen atoms, a time step not above 0 *.* 5 fs is recommended. If only heavier atoms are present,
a larger time step may be chosen. A good estimate for a time step that still allows for an accurate simulation is
∆ *𝑡* = *[√]* *𝑚* *·* 0 *.* 5fs, where *𝑚* is the mass of the lightest atom in the system (in a.m.u.). This is one reason why some
scientists perform simulations with fully deuterated compounds: It allows to increase the time step by a factor of
*≈* 1.4 :-)

If this command is not invoked before a `Run` call, a default time step of 0 *.* 5 fs will be set before starting the run.

**1000** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.48.8 Scientific Background**

In this section, some of the methods and algorithms used within ORCA’s MD module are described in some more
depth, with a focus on the scientific background.

**Time Integration and Equations of Motion**

The central concept of molecular dynamics simulations is to solve Newton’s equations of motion (at least as long
as the atom cores are treated classically). These read

¨ *𝐹* *𝑖* ( *⃗𝑥* ( *𝑡* ) )
*𝑥* *𝑖* ( *𝑡* ) = *,* *𝑖* = 1 *. . . 𝑁,*

*𝑚* *𝑖*

where *𝑥* *𝑖* ( *𝑡* ) denotes the position of the *𝑖* -th degree of freedom at time *𝑡*, *𝑚* the corresponding mass, and *𝐹* *𝑖* the
force acting upon this degree of freedom. As the force may depend on all positions, this is a coupled system of *𝑁*
ordinary differential equations (ODEs). In the general case, it is not possible to obtain an analytical solution of this
system, and therefore numerical solution methods are applied. These are almost always based on discretizing the
time variable and approximately solving the system by taking finite time steps.

Of all different methods to numerically solve coupled systems of ODEs, the *symplectic integration schemes* for
Hamiltonian systems attained special attention in the field of molecular dynamics. They possess a very good
conservation of energy. In contrast to many other methods, they show a reasonable behavior when investigating the
long-term evolution of chaotic Hamiltonian systems (like, *e. g.*, MD simulations). Three popular such symplectic
integration schemes are the *Leapfrog* algorithm, the *Verlet* method, and the *Velocity Verlet* integrator. Despite
their different names, they are very similar. It can be easily seen that the Verlet and Velocity Verlet methods are
algebraically equivalent (by eliminating the velocities from the Velocity Verlet algorithm), and it can be shown
that, eventually, all three methods are identical. [3] All three methods are explicit integration methods with a global
error of order 2, and therefore one order better than the semi-implicit Euler method, which is also a symplectic
integration scheme. As the Velocity Verlet algorithm is the only of these three methods which yields velocities and
positions at the same point in time, many popular molecular dynamics packages (CP2k, CPMD, LAMMPS) use
this scheme. For the same reasons, the ORCA MD module uses the Velocity Verlet algorithm as time integration
method.

The general equations of the Velocity Verlet scheme read

*⃗𝑥* ( *𝑡* + ∆ *𝑡* ) = *⃗𝑥* ( *𝑡* ) + *⃗𝑣* ( *𝑡* ) ∆ *𝑡* + [1]

2 *[⃗𝑎]* [(] *[𝑡]* [) ∆] *[𝑡]* [2] *[,]*

*⃗𝑣* ( *𝑡* + ∆ *𝑡* ) = *⃗𝑣* ( *𝑟* ) + *[⃗𝑎]* [(] *[𝑡]* [)] [ +] *[ ⃗𝑎]* [(] *[𝑡]* [+ ∆] *[𝑡]* [)] ∆ *𝑡.*

2


By inserting

one arrives at the two-step method


*⃗𝐹* *𝑖* ( *𝑡* )
*⃗𝑎* *𝑖* ( *𝑡* ) = *,* *𝑖* = 1 *. . . 𝑁,*

*𝑚* *𝑖*


*⃗𝐹* *𝑖* ( *𝑡* )
*⃗𝑥* *𝑖* ( *𝑡* + ∆ *𝑡* ) = *⃗𝑥* *𝑖* ( *𝑡* ) + *⃗𝑣* *𝑖* ( *𝑡* ) ∆ *𝑡* + ∆ *𝑡* [2] *,* *𝑖* = 1 *. . . 𝑁,*

2 *𝑚* *𝑖*


*⃗𝐹* *𝑖* ( *𝑡* ) + *⃗𝐹* *𝑖* ( *𝑡* + ∆ *𝑡* )
*⃗𝑣* *𝑖* ( *𝑡* + ∆ *𝑡* ) = *⃗𝑣* *𝑖* ( *𝑟* ) + ∆ *𝑡,* *𝑖* = 1 *. . . 𝑁,*

2 *𝑚* *𝑖*


which is implemented in ORCA’s MD module.

3 Hairer, Lubich, Wanner, “Geometric Numerical Integration”, Springer 2006.

**7.48.** ***Ab initio*** **Molecular Dynamics Simulations** **1001**

**ORCA Manual** **,** **Release 6.0.1**

**Velocity Initialization**

In the beginning of a MD simulation, it is often the case that only the initial positions of the atoms are known, but
not the velocities. As MD simulations are performed at some finite temperature, it is a good idea to initialize the
velocities in a way such that the desired simulation temperature is already present in the beginning. In statistical
mechanics, it is often assumed that the velocity distribution of atoms is given by a Maxwell–Boltzmann distribution
(which is strictly only the case in idealized gases). Therefore, it is a reasonable choice to initialize the atom’s
velocities according to the Maxwell–Boltzmann equation in the beginning of a MD simulation. The goal is to find
an initial velocity distribution in which each degree of freedom possesses a similar amount of energy, such that the
equipartition theorem is approximately fulfilled.

The scalar Maxwell–Boltzmann velocity distribution (leaving out the normalization factor) at temperature *𝑇* is
given by


*𝑓* ( *𝑣* ) = *𝑣* [2] exp *−* *[𝑚𝑣]* [2]
(︁ 2 *𝑘* *𝐵* *𝑇*


*.*
)︁


To initialize the particle’s velocities such that this distribution function is fulfilled, one starts with a series of normaldistributed random numbers with mean 0 and variance 1, denoted by *𝒩* (0 *,* 1). The Cartesian velocity components
for each atom are then computed by


*𝑘* *𝐵* *𝑇*


*𝑣* *𝑖,𝛼* :=


√︂


*𝑘* *𝐵* *𝑇*

*𝒩* (0 *,* 1) *,* *𝛼* *∈{𝑥, 𝑦, 𝑧}, 𝑖* = 1 *. . . 𝑁.*
*𝑚* *𝑖*


As the C++98 standard does not offer a platform-independent way of obtaining normal-distributed random numbers, these are internally computed from uniformly distributed random numbers by applying the *Box–Muller trans-*
*form* [115]: Assuming that *𝑢* 1 and *𝑢* 2 are two uniformly distributed random numbers from the interval [0 *,* 1], the
equations

*𝑧* 1 := ~~√~~ *−* 2 log ( *𝑢* 1 ) cos (2 *𝜋𝑢* 2 ) *,*

*𝑧* 2 := ~~√~~ *−* 2 log ( *𝑢* 1 ) sin (2 *𝜋𝑢* 2 )

yield two new random numbers *𝑧* 1 and *𝑧* 2 which obey a normal distribution with mean 0 and variance 1.

After the velocities have been initialized, the total linear momentum of the system will probably have some finite
value other than zero. As the linear momentum is (approximately) conserved within a molecular dynamics simulation, this would result in the system drifting away into one direction during the course of the simulation, which
is probably not desired. Therefore, the total momentum is explicitly set to zero after the Maxwell–Boltzmann
initialization:


*⃗𝑃* tot :=


*𝑁*
∑︁ *𝑚* *𝑖* *⃗𝑣* *𝑖,* old *,*

*𝑖* =1


*⃗𝑣* *𝑖,* new := *⃗𝑣* *𝑖,* old *−* *⃗𝑃* tot *𝑖* = 1 *. . . 𝑁.*
*𝑚* *𝑖* *𝑁* *[,]*

This, of course, might change the initial temperature. Therefore, a final step is performed, in which all velocity
vectors are multiplied with a factor that is determined such that the initial temperature exactly matches the target
value.

**Thermostats**

After the initial velocities have been initialized to some finite temperature, it might be assumed that one can simply
start the time integration of the dynamical system (equivalent to the *NVE ensemble* ), and the starting temperature
would be approximately preserved. In a real system, however, there are (at least) two reasons why the temperature
will strongly deviate from the initial value already after a few steps. First, the initial velocity distribution only
considers the kinetic energy of the particles, but some amount of energy will be exchanged with the potential
energy contribution ( *e. g.*, bond stretching) immediately, altering the temperature. Secondly, the numerical errors
introduced due to the finite time step (and in case of *ab initio* MD, also due to the approximate forces) will lead to
a drift in energy and therefore in temperature. To counter these effects, it is often desirable to have a temperature
control during the course of the simulation (which then runs in the *NVT ensemble* ), which is called a thermostat.

**1002** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

There exist many different kinds of thermostats, ranging from simple expressions up to highly complex dynamical
systems on their own. But all of them share a common issue: If the thermostat is coupled only weakly to the
system, the temperature will change anyway. However, if the thermostat is coupled more strongly to the system
( *i. e.*, intervenes stronger), then the dynamics of the simulation will change, no longer resembling the undisturbed
original dynamics which one wants to investigate. Therefore, it is always a tradeoff between temperature stability
and disturbed dynamics to decide how strong a thermostat should be coupled to the system.

In ORCA, currently three thermostats are implemented: The Berendsen thermostat [92], the Nosé–Hoover chain
thermostat (NHC) [563, 564], and the “Canonical Sampling through Velocity Rescaling” thermostat (CSVR) [129].

**Berendsen Thermostat**

The Berendsen thermostat [92] is similar to the simple velocity rescaling scheme, but enhanced by a time constant
*𝜏* to control the coupling strength. Let *𝑇* 0 be the desired target temperature and *𝑇* the current temperature of the
system. Then the temperature gradient caused by the thermostat can be expressed as


*𝑑𝑇*


*𝑑𝑇*

*𝑑𝑡* [=] *[ 𝑇]* [0] *[ −]* *𝜏* *[𝑇]*


*.*

*𝜏*


Considering the fact that discrete time steps ∆ *𝑡* are used, the correction factor for the velocities in each time step
is determined by


*𝑓* :=

The new velocities are then easily obtained as


√︂


1 + [∆] *[𝑡]* [(] *[𝑇]* [0] *[ −]* *[𝑇]* [)]

*𝑇𝜏*


1 + [∆] *[𝑡]* [(] *[𝑇]* [0] *[ −]* *[𝑇]* [)]


*⃗𝑣* *𝑖,* new := *𝑓* *· ⃗𝑣* *𝑖,* old *,* *𝑖* = 1 *. . . 𝑁.*

Let’s consider some special cases. If *𝜏* = ∆ *𝑡*, the whole temperature deviation from *𝑇* 0 is corrected immediately,
such that the temperature is always exactly kept at the target value. This is identical to simple velocity rescaling
(without any time constant), which is known to work poorly for most systems (a single harmonic oscillator would,
*e. g.*, simply explode). With a larger time constant *𝜏>* ∆ *𝑇*, the coupling strength is reduced, leading to reasonable
results. Typically, a value of *𝜏* in the range of 20 *. . .* 200 *·* ∆ *𝑇* will be applied. For *𝜏* *→∞*, the coupling strength
goes to zero, such that the thermostat is no longer active. Values of *𝜏<* ∆ *𝑇* are not allowed.

From the formula, it becomes clear that a Berendsen thermostat will have no effect if the system has a temperature
of 0 K (or in the “massive” case: if the considered degree of freedom has 0 K), because it is based on multiplying
the velocities by a factor to modify the temperature. Therefore, this type of thermostat can’t be used to heat a
system up starting from 0 K.

**Constraints**

Unlike restraints, constraints are geometric relations which are strictly enforced at every time ( *i. e.*, they do not
fluctuate around their target value). Many molecular dynamics techniques make use of geometric constraints ( *e. g.*,
to keep water molecules rigid, or to fix some reaction coordinate). Standard BOMD describes the nuclei as point
charges in space, such that the motion of the atoms is governed by the laws of classical mechanics. Systems in
classical mechanics can be described by the Lagrange formalism, which contains a well established sub-formalism
for holonomic constraints, namely the method of Lagrange multipliers.

However, molecular dynamics discretizes time to solve the equations of motions with finite time steps, often using
a Verlet integrator. With discretized time, it is slightly more involved to enforce and keep exact constraints. Within
the last decades, algorithms have been developed to do so. One famous among them is the SHAKE algorithm.
However, it comes with the disadvantage of only enforcing the constraints in the positions, not in the velocities. This
may lead to problems such as artificially high temperature values due to “hidden” velocities along the constrained
directions. An extension of SHAKE which also enforces the constraints for the velocities is the RATTLE algorithm,
which is implemented in the AIMD module of ORCA.

The RATTLE scheme is a generalization of the Velocity Verlet integrator to allow for constraints. This means that
RATTLE is not applied in addition to the Velocity Verlet integrator, but replaces it. In case of no active constraints,

**7.48.** ***Ab initio*** **Molecular Dynamics Simulations** **1003**

**ORCA Manual** **,** **Release 6.0.1**

both methods are identical. A system of coupled constraints cannot be solved exactly in one step, and RATTLE
uses an iterative approach to enforce all constraints simultaneously. This is often a matter of concern with respect
to performance. However, in AIMD, the energy and gradient calculations typically take seconds or even minutes
per step, such that the additional computation time for iteratively solving the constraints can be totally neglected.

As an iterative procedure, RATTLE is not able to give exact solutions, but only converged up to a given tolerance.
In the ORCA MD module, the tolerance is currently set to 10 *[−]* [2] pm for distances, and 10 *[−]* [4] degree for angles
and dihedral angles. This tolerance is typically reached within a few dozen iterations. In some cases, it might
happen that the RATTLE iterations do not converge to the required tolerance. This is typically the case if the set
of constraints is over-determined or contradictory.

The mathematical and technical details of RATTLE are not described here, they can be found in the literature.
The general concept of RATTLE was suggested by Andersen [35]. The original article only covered distance
constraints. A follow-up work describes how to handle any holonomic constraints, in particular how to constrain
angles and dihedral angles [483]. The Wilson vectors ( *i. e.*, derivatives of angles and dihedral angles with respect
to Cartesian atom positions) are taken from Wilson’s original work [890].
### **7.49 Fast Multipole Method**

The Fast Multipole Method (FMM) algorithm was proposed in the 1980s[317], to reduce the computation time
for two-centre interactions in large systems, by moving from a quadratic relationship (O( *𝑁* [2] )) to a quasi-linear
relationship (O( *𝑁𝑙𝑜𝑔* ( *𝑁* ))) of the computation time with the number *𝑁* of particles (atoms, point charges, etc.).
This algorithm is particularly useful for long-range interactions that are difficult to ignore, such as the Coulombic
interaction (1/r) which is fundamental to any system but grows quadratically with the number of centers.

The FMM is used in ORCA for accelerating QMMM calculations in the scope of electrostatic embedding: FMMQMMM (cf. *Embedding Types* ).

**7.49.1 The Octree hierarchy**

There exists a lot of detailed and pedagogical literature on the subject (we recommend for instance [49] and [377]).
In the following we will only describe the main parameters.

The idea of the algorithm is to divide space to handle differently short- and long-range interactions. The latter will
be approximated (cf. *Approximation of the Far Field interactions* ). To do so, the whole system is placed in a cubic
box which is iteratively divided in 8 children boxes (forming levels L: L = 0 *→* L = L max ) so as to form a structure
called an Octree (see Fig. Fig. 7.62).

**1004** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.62: Division of the system into boxes, schematic representation in 2D.

At the deepest level, L = L max, for every box, we can define a layer of nearest neighbours boxes (NN) which will
be responsible for the Near-Field (NF, i.e.short-range). The electrostatic potential due to the rest of the boxes is
define as the Far-Field (FF, i.e. long-range).

*∀𝐵,* **V** *𝐵* = **V** **[NF]** *𝐵* [+] **[ V]** *𝐵* **[FF]**

As visible on Figure Fig. 7.62, one can divide the FF area between a Local Far Field (LFF, green) area and a Remote
Far Field area (RFF, grey), so that a recursive scheme between levels appears:



[=] **[ V]** *𝐵* **[LFF]** + **V** **[RFF]** *𝐵*

= **V** **[LFF]** + **W** *[𝑇]*


*∀𝐵* **V** **[FF]** *𝐵* [=] **[ V]** *𝐵* **[LFF]**



**[LFF]** *𝐵* + **W** *[𝑇]* *𝑃𝑎𝑟𝑒𝑛𝑡* ( *𝐵* ) *→𝐵* **[V]** **[FF]** *𝑃𝑎𝑟𝑒𝑛𝑡* ( *𝐵* )


The LFF boxes are the boxes in the NF of the parent but not in the NF of the children, that represents a maximum
of 189 boxes. The RFF potential is due to boxes which actually represent the FF area of the parent box of B. This
means that one needs to calculate only the LFF term at every level, the rest of the potential will be inherited from
the parent box.

The number of levels, L max, can be setup in the input directly (FMMQMMM_Levels), or will be deduced from
the provided box dimension (FMMQMMM_BoxDimInp, dimension of the box at L max ). The second option
(default) is recommended, with a box dimension around 9.0 Bohr (FMMQMMMM_BoxDimInp 9.0 ). If FMMQMMM_DoBoxDimOpt option is turned to TRUE (default), the box dimension will be reduced as much as
possible while keeping the same value of L max, this to ensure the algorithm works optimally regarding both accuracy and efficiency.



The higher L max, the bigger the number of boxes: at L = 2 one has 64 boxes only but for L = 6 the code generates
more than 200,000 boxes (8 [6] ). For L max *≥* 7, more than 2 millions boxes are generated, this can start leading to
memory issues, so that the user should ensure enough memory is available (cf. *Global memory use* ).

**7.49. Fast Multipole Method** **1005**

**ORCA Manual** **,** **Release 6.0.1**

**7.49.2 Approximation of the Far Field interactions**

In a space of origin O(0,0,0), let P ( **r** *𝑃* ) be the center of a charge distribution (e.g. a Gaussian overlap or a distribution of point charges). Let’s consider a point A in the vicinity of P, such that A = (q *𝐴* ; **r** *𝐴* ), with q *𝐴* the charge of a
point charge or q *𝐴* = *−* 1 if we consider a Gaussian overlap. In that case, the charge would indeed be the one of the
electron situated at a position **r** *𝐴𝑃* = **r** *𝐴* *−* **r** *𝑃* from the center of the Gaussian overlap. Similarly, let Q ( **r** *𝑄* ) be the
center of a charge distribution and B, a point in the vicinity of Q, such that B = (q *𝐵* ; **r** *𝐵* ). We note **r** *𝑄𝑃* = **r** *𝑄* *−* **r** *𝑃* .

The Coulomb interaction between A and B can be expressed as:


1
*𝑈* *𝐴𝐵* = *𝑓* (︁ *|* **r** *𝑎* *−* **r** *𝑏* *|* )︁ *,*


The name of the algorithm comes from the way the FF interactions are evaluated. It is done through a mutlipole
1
expansion of the *|* **r** *𝑎* *−* **r** *𝑏* *|* [term, leading to the following expression:]


*∞* *𝑗*
∑︁ ∑︁ ( *−* 1) *[𝑗]* *𝑅* *𝑙,𝑚* ( **r** *𝐴𝑃* ) *𝐼* *𝑙* + *𝑗,𝑚* + *𝑘* ( **r** *𝑄𝑃* ) *𝑅* *𝑗,𝑘* ( **r** *𝐵𝑄* ) *,*

*𝑗* =0 *𝑘* = *−𝑗*


*𝑙*
∑︁

*𝑚* = *−𝑙*


1
*|* **r** *𝐴* *−* **r** *𝐵* *|* [=]


*∞*
∑︁

*𝑙* =0


This series converges for well separated centers only, that is why a NF layer is required. *𝑅* *𝑙,𝑚* and *𝐼* *𝑙,𝑚* are regular
and irregular solid scaled harmonics [707]:


1 4 *𝜋*
*𝑅* *𝑙,𝑚* ( **r** ) = **r** *[𝑙]*
~~√~~ ( *𝑙* *−* *𝑚* )!( *𝑙* + *𝑚* )! ~~√~~ 2 *𝑙* + 1 *[𝑌]* *[𝑙,𝑚]* [(] **[r]** [)]


*𝐼* *𝑙,𝑚* ( **r** ) = √︀


( *𝑙* *−* *𝑚* )!( *𝑙* + *𝑚* )! [1]

**r** *[𝑙]* [+1] √︂


4 *𝜋*
2 *𝑙* + 1 *[𝑌]* *[𝑙,𝑚]* [(] **[r]** [)]


*𝑌* *𝑙,𝑚* are spherical harmonics of degree *𝑙* and order *𝑚* . For details on the derivation of this equation see [49].

We can now introduce the multipole expansion centered in P ( **r** *𝑃* ), of a charge distribution **Q** ( **r** *, 𝑃* ), as:


**Q** ( **r** *, 𝑃* ) = *𝑓* (︁ ∑︁ *[∞]*

*𝑙* =0


*𝑙*
∑︁ *𝑅* *𝑙,𝑚* ( **r** *−* **r** *𝑃* ))︁

*𝑚* = *−𝑙*


In practise:


**Q** ( **r** *, 𝑃* ) *≈* *𝑓* (︁ *[𝑀𝐴𝑀]* ∑︁

*𝑙* =0


*𝑙*
∑︁ *𝑅* *𝑙,𝑚* ( **r** *−* **r** *𝑃* ))︁

*𝑚* = *−𝑙*


**Q** is a vector, with elements *𝑄* *𝑙,𝑚* defined by the pair of values ( *𝑙*, *𝑚* ). In the case of a point charge A (q *𝐴*, **r** ) we
have:

*𝑄* *[𝐴]* *𝑙,𝑚* [(] **[r]** *[, 𝑃]* [) =] *[ 𝑞]* *[𝐴]* *[×][ 𝑅]* *[𝑙,𝑚]* [(] **[r]** *[ −]* **[r]** *[𝑃]* [)] *[,]*

while for a Gaussian overlap distribution *⟨𝜇|𝜈⟩* it becomes:

*𝑄* *[𝜇𝜈]* *𝑙,𝑚* [(] **[r]** *[, 𝑃]* [) =] *[ ⟨][𝜇][|][ 𝑅]* *[𝑙,𝑚]* [(] **[r]** *[ −]* **[r]** *[𝑃]* [)] *[ |][𝜈][⟩]*

= *𝜇* ( **r’** ) *𝑅* *𝑙,𝑚* ( **r** *−* **r** *𝑃* ) *𝜈* ( **r’** ) *𝑑* **r’**
∫︁

So that we can approximate the electrostatic interaction between a Gaussian overlap *⟨𝜇|𝜈⟩* with center in **r** *𝐵* and a
point charge A (q *𝐴*, **r** *𝐴* ) in the FF, through the following expansion:

∫ *𝑞* *𝐴* *𝜇* ( **r** ) *𝜈* ( **r** ) *𝑑* **r**

*|* **r** *𝐴* *−* **r** *𝐵* *|* *≈* **Q** *[𝜇𝜈]* ( **r** *𝑏* *, 𝑃* *[′]* ) **I** ( **r** *𝑃𝑃* *′* ) **Q** *[𝐴]* ( **r** *𝐴* *, 𝑃* ) *,*

with *𝑃* and *𝑃* ’ the respective center of the multipole expansions, and I the interaction matrix.

The truncation parameter of the expansion, MAM, is the Maximum Angular Momentum of the underlying solid
scaled harmonics. In our setup, it is the same value for the expansion of the point charges in the embedding or
the Gaussian overlaps in the QM part. It can be setup through the keyword FMMQMMM_MAM. We recommend
FMMQMMM_MAM = 20 to ensure a good accuracy, in the order of 0.0001-0,0001 Ha. With a lower value of
MAM=15, one can usually expect a mHa (0.63 kcal.mol *[−]* [1] ) precision. However it is system dependent, so that we
recommend you to start with MAM=20 and see how it behaves if you decrease it to a value of 15. The available
values for MAM are in the range 1-25.

**1006** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**



**7.49.3 The “Very” Fast Multipole Method (VFMM)**

Due to the recursive scheme between levels, the FF felt in the center of a box is built by only calculating interactions
with the LFF boxes at every level. The evaluation of *𝑉* *[𝐿𝐹𝐹]* becomes the bottleneck of the algorithm. To accelerate
it, an option has been implemented in which different MAM truncation parameters will be used for all the (>189)
boxes in the LFF area. This option FMMQMMMM_DoVFMM is turned ON by default, but should be switched
OFF whenever the MAM is smaller than 15, that would impact to much the accuracy without improving much the
efficiency.



**7.49.4 Recommended input**

Whenever there is an electrostatic embedding, for systems containing more than 10,000 point charges (ECM)
or MM atoms (QMMM), it is recommended to turn on the FMM in order to accelerate the calculation of the
electrostatic potential. However, when using heavy parallelization with more than 24 processors, the impact of
enabling the Fast Multipole Method (FMM) may be negligible for small embedding size.

**Caution:** FMM-QMMM does not replace the QMMM keyword.

The two elements one can play on are the truncation parameter of the expansion, MAM, and the box dimension
at the deepest level (L max ). Recommended/default parameters can be called in the keyword line directly using
FMM-QMMM or by setting the parameters accordingly in the %method block:



The parameters used by the algorithm are printed in the output by default, we recomend you to check them in your
first calculations:



(continues on next page)

**7.49. Fast Multipole Method** **1007**

**ORCA Manual** **,** **Release 6.0.1**


(continued from previous page)



This can be turned off by modifying the relative printing options.



**7.49.5 Some examples**

Call the recommanded FMM parameters through the keyword line:




Change the MAM from 20 (value when one uses the keyword line) to 15, and use 5 levels:




Specify the box dimension without optimizing it:

**1008** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**



Specifying the box dimension and ask to optimize it:



### **7.50 Implicit Solvation Models**

Implicit solvation models play an important role in quantum chemistry. Without resorting to placing multiple
solvation shells of solvent molecules implicit solvent models are able to mimic the effect of a specific solvent on
the solute.

The implicit solvent models available in ORCA are

1. C-PCM[76] : The Conductor-like Continuum Polarization Model

2. SMD[559] : The Solvation Model based on Density

3. OpenCOSMO-RS[293] : Interface to the open source implementation of the COSMO-RS model

**7.50. Implicit Solvation Models** **1009**

**ORCA Manual** **,** **Release 6.0.1**

4. ALPB/ddCOSMO/CPCM-X : The solvation models available in XTB

Regarding C-PCM and SMD, they are natively implemented in ORCA. Points 1, 2 and 3 are covered in this section.
For more information on point 4, check Section *ONIOM Methods* .

**7.50.1 The Conductor-like Polarizable Continuum Model (C-PCM)**

The conductor-like polarizable continuum model (C-PCM) is an implementation of the conductor-like apparent
surface charge methods. In these models the solute is placed in a cavity of roughly molecular shape. The solvent
reaction field is described by apparent polarization charges on the cavity surface, which are in turn determined by
the solute. These charges can be treated as punctual (point charges) or be modelled as spherical Gaussians [905].
The cavity in ORCA is constructed differently depending on how the charges are treated. In the case of using point
charges, the cavity is generated through the GEPOL[650, 651, 652] algorithm, either as solvent-excluding surface
(SES), or solvent-accessible surface (SAS). When Gaussian charges are considered, the user can choose between a
scaled vdW surface or the GEPOL SES, and the charge positions are determined following a Lebedev quadrature
approach. This scheme is known as Gaussian Charge Scheme[287] and more details on how to use it are given in
Section *Use of the Gaussian Charge Scheme* .

The ORCA C-PCM implementation closely follows the C-PCM[76] paper. The molecular Hamiltonian of the
isolated system is perturbed by the solvent:

*𝐻* ˆ = ˆ *𝐻* [0] + ˆ *𝑉*

where *𝐻* [ˆ] [0] is the Hamiltonian of the isolated molecule, whereas *𝑉* [ˆ] describes the solute – solvent interactions. The
SCF procedure leads to the variational minimization of the free energy of the solute, *𝐺* :


*𝐺* = ⟨Ψ ⃒⃒⃒ *𝐻* ˆ 0 ⃒⃒⃒ Ψ⟩ + [1] 2


Ψ *𝑉* ˆ Ψ
⟨ ⃒⃒⃒ ⃒⃒⃒ ⟩


Using the conductor-like boundary condition the electrostatic potential can be determined by


*𝑉* ( *⃗𝑟* ) +


*𝑁* *𝑞*
∑︁ *𝑉* *𝑞* *𝑖* ( *⃗𝑟* ) = 0

*𝑖*


where *𝑉* and *𝑉* *𝑞* *𝑖* are the electrostatic potential due to the solute and to the polarization charges, *⃗𝑟* is a point on
the cavity surface, and *𝑁* *𝑞* is the total number of solvation charges. The vector of polarization charge can then be
determined by

**AQ** = *−* **V** (7.314)

where the vector **V** contains the electrostatic potential due to the solute at the position of the charges. The elements
of the matrix **A** have a different functional form depending on how the charges are treated. If we use point charges:


*𝐴* *𝑖𝑖* = 1 *.* 07
√


4 *𝜋*

*𝑆* *𝑖*


*𝐴* *𝑖𝑗* = [1] (7.315)

*𝑟* *𝑖𝑗*

in which *𝑆* *𝑖* is the area of the surface element *𝑖*, and *𝑟* *𝑖𝑗* = *|⃗𝑟* *𝑖* *−* *⃗𝑟* *𝑗* *|* . When Gaussian charges are considered:

*𝐴* *𝑖𝑖* = *[𝜁]* *[𝑖]* √ 2 */* *𝜋*

*𝐹* *𝑖*

*𝐴* *𝑖𝑗* = [erf ] [(] *[𝜁]* *[𝑖]* *[𝑗]* *[𝑟]* *[𝑖]* *[𝑗]* [)]

*𝑟* *𝑖𝑗*

Here, *𝜁* *𝑖* is the exponent of the Gaussian charge *𝑖* ( *𝑖* belongs to sphere *𝐼* ). This quantity is calculated as *𝜁* *𝑖* =
*𝜁/* ( *𝑅* *𝐼* *[√]* *𝑤* *𝑖* ), where *𝑅* *𝐼* is the radius of sphere *𝐼*, *𝑤* *𝑖* is the weight of the Lebedev point *𝑖*, and *𝜁* is a width parameter

optimized for each particular Lebedev grid [905]. On the other hand, *𝜁* *𝑖𝑗* = *𝜁* *𝑖* *𝜁* *𝑗* */* ~~√~~ *𝜁* *𝑖* [2] [+] *[ 𝜁]* *𝑗* [2] [. The function] *[ 𝐹]* *[𝑖]* [,]

**1010** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

known as switching function, measures the contribution of the Gaussian charge *𝑖* to the solvation energy. This
function is calculated as


*𝐹* *𝑖* =


atoms
∏︁ *𝑔* ( *⃗𝑟* *𝑖* *, 𝑅* *[⃗]* *𝐽* )

*𝐽,𝑖/∈𝐽*


where *𝑔* ( *⃗𝑟* *𝑖* *, 𝑅* *[⃗]* *𝐽* ) is the elementary switching function. In ORCA we use the improved Switching/Gaussian (ISWIG)
function for *𝑔* ( *⃗𝑟* *𝑖* *, 𝑅* *[⃗]* *𝐽* ) proposed in ref. [494]:

*𝑔* ( *⃗𝑟* *𝑖* *, 𝑅* *[⃗]* *𝐽* ) = 1 *−* [1]

2 *[{]* [erf [] *[𝜁]* *[𝑖]* [(] *[𝑅]* *[𝐽]* *[−]* *[𝑟]* *[𝑖𝐽]* [)] + erf [] *[𝜁]* *[𝑖]* [(] *[𝑅]* *[𝐽]* [+] *[ 𝑟]* *[𝑖𝐽]* [)]] *[}]*

If *𝑔* ( *⃗𝑟* *𝑖* *, 𝑅* *[⃗]* *𝐽* ) *<* 10 *[−]* [7] the value of *𝑔* is set equal to 0.

If we consider a solvent with a dielectric constant *𝜀*, eq. (7.314) reads as

**AQ** = *−𝑓* ( *𝜀* ) **V** (7.316)

where *𝑓* ( *𝜀* ) = ( *𝜀* *−* 1) */* ( *𝜀* + *𝑥* ) is a scaling function, and *𝑥* is in the range 0-2. In C-PCM *𝑥* is equal to 0.

The C-PCM model can be used via
```
! CPCM(solvent)

```
where `solvent` is one of the available solvents in Table 7.29

Table 7.29: List of available solvents for the different implicit solvation methods in ORCA. The data for the dielectric constant used within C-PCM is that at 293.15,[368] except for ammonia, which has a boiling point of 239.81
K. For the rest of solvation models, see the corresponding sources.[559][815]

continues on next page

**7.50. Implicit Solvation Models** **1011**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.29 – continued from p revious p a g e

continues on next page

**1012** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.29 – continued from p revious p a g e

continues on next page

**7.50. Implicit Solvation Models** **1013**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.29 – continued from p revious p a g e

The parameters can be more accurately defined using the `%cpcm` block input. The available options are as follows



(continues on next page)

**1014** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Regarding the parameters shown above, some of them can be just used within a given type of cavity surface and
charge scheme, as it is mentioned in subsections *Use of the Gaussian Charge Scheme*, and *Use of the Point Charge*
*Scheme* . ORCA supports two types of solvation charge schemes: (i) the point charge scheme, (ii) the Gaussian
charge scheme. The default solvation scheme from ORCA 5.0 on is the Gaussian charge scheme with a vdW-type
cavity (” `surfacetype vdw_gaussian` ”). Older ORCA versions considered “ `surfacetype gepol_ses` ” and
the point charge scheme as defaults. So, if one wants to reproduce the results obtained with ORCA versions older
than ORCA 5.0, please use the tag “ `surfacetype gepol_ses` ” in the “ `%cpcm` ” block.

The different charge schemes are described in the subsections *Use of the Gaussian Charge Scheme*, and *Use of*
*the Point Charge Scheme* . The availability of the analytical gradient and Hessian for the different combinations of
charge scheme and surface is shown in Table Table 7.30.

Table 7.30: Available type of gradients and Hessians within the C-PCM in ORCA. The tag “YES” means that
the feature is implemented, and “NO” that it isn’t. For clarity, we denote by “*” the default scheme in ORCA
( `surfacetype vdw_gaussian` ).

**Note:** If the user wants to turn off the C-PCM, one has to write the following tag in the simple input:
```
! NOCPCM

```
This is needed, for instance, in the context of concatenated calculations using the `$new_job` feature, where the
previous calculation involved solvation, but one wants to turn it off for the next one.

**7.50. Implicit Solvation Models** **1015**

**ORCA Manual** **,** **Release 6.0.1**

**Use of the Gaussian Charge Scheme**

The Gaussian charge scheme avoids the Coulomb singularity present in conventional point charge surface element
models. This approach, when applied together with a switching function, results in a smooth solvation potential
and, more importantly, on smooth derivatives of this quantity with respect to external perturbations. Then, it is
highly recommended to adopt this approach within the C-PCM. The Gaussian charge scheme can be used with
two types of solute cavity surfaces: (1) a scaled vdW surface, (2) a solvent-excluded surface (SES). To assign the
radii for the different atoms we follow the scheme proposed in ref. [494]. That is, we use Bondi radii [114] for
all elements, except for hydrogen where we adopt 1.1 Å. For 16 of the main-group elements in the periodic table,
where Bondi’s radii are not defined, we adopt the radii proposed in ref. [553] by Mantina et al. This is the case
for elements: Be, B, Al, Ca, Ge, Rb, Sr, Sb, Cs, Ba, Bi, Po, At, Rn, Fr, Ra. For the elements that are not covered
neither by Bondi nor by Mantina, we consider a radius of 2 Å.

   - **Scaled vdW cavity**

The Gaussian charge scheme with a scaled vdW-type cavity is now the default in ORCA, so one just needs to add
the C-PCM tag in the `%cpcm` block in the input file. That would correspond to (although the user does not need to
write that, as it is internally processed by ORCA):



In this case, the radius *𝑅* *𝐼* of atom *𝐼* for the scaled vdW cavity is calculated as

*𝑅* *𝐼* = *𝑓* *𝑠𝑐𝑎𝑙* *𝑅* *𝐼* [vdW]

where *𝑅* *𝐼* [vdW] is the vdW radius of atom *𝐼* and *𝑓* *𝑠𝑐𝑎𝑙* is a scaling factor. This parameter is by default equal to 1.2,
as suggested in ref. [494]. However, the user can modify its value through the `scale_gauss` tag in the `%cpcm`
block in the input file. The number of C-PCM charges per atom is such that we have an approximate density of
5.0 charges/Å [2] on the surface of the cavity. This number corresponds approximately to 110 points on a hydrogen
atom (110/(4 *𝜋* *×* 1 *.* 32 [2] ) *≈* 5 *.* 0Å *[−]* [2] ). ORCA will choose then different levels of discretization (Lebedev grids)
depending on the radii of the atoms. This scheme is called isodensity scheme. The threshold for the number of
charges per unit of area on hydrogens and non-hydrogen atoms can be specified by the user via `thresh_h` and
`thresh_noth`, respectively. Alternatively, the user can request a fixed number of Lebedev points per sphere in the
cavity (independent of the radius of the sphere). This can be done via the `num_leb` tag. This parameter can adopt
the following values: 50, 110, 194, 302, 434, 590, 770, 974, and 1202. ORCA versions older than ORCA 6.0 use
this last scheme.

The analytical gradient, as well as the analytical Hessian are available for this solvation method.

   - **Solvent-excluded surface**

The GEPOL-generated SES can be used together with the Gaussian charge scheme. In this case, the Gaussian
charges are not only placed on the surface of the atomic spheres but also on the surface of the new spheres generated
through the GEPOL algorithm. To use this approach we should modify the ORCA input file as follows



The SES is in general recommended when the solute is explicitly solvated by few solvation layers. In this case, the
additional GEPOL spheres prevent the solvent to fill the space between explicit solvent molecules or between those
molecules and the solute. The radius of the solvent sphere that rolls over the solute vdW-type surface to generate
the SES is controlled by the parameter “ `rsolv` ”. This radius has a default value of 1.30 Å, but the user can change
it by specifying another value for “ `rsolv` ” in the `%cpcm` block. The minimum radius for an added GEPOL sphere
is controlled by “ `rmin` ”.

Neither the analytical gradient nor the analytical Hessian are available for this strategy. They should be computed
numerically. Due to the interdependency between GEPOL spheres and the atoms present in our system, the analytical gradient computed using the SES does not converge as smooth as compared to that using the vdW-type cavity

**1016** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(see ref. [287]) and can lead to wrong minima. The Hessian is affected in the same way. Then, ORCA 6.0 does
not support anymore the analytical gradient/Hessian for such surface to prevent inaccurate results.

**Use of the Point Charge Scheme**

Within this scheme, the solvation charges are treated as punctual and no switching function is used to accept/discard
charges in the intersection between the spheres that form the solute cavity. These two facts lead to a discontinuous
potential energy surface (numerical instabilities in the SCF energy and its derivatives). Then, the point charge
scheme is not recommended within the C-PCM. If the user still wants to use this charge scheme it can be used
together with two different type of surfaces for the solute cavity: (1) the SES, and (2) the SAS.

   - **Solvent-excluded surface**

In the same way as for the Gaussian charge scheme with the SES, this surface is generated for the point charge
scheme through the GEPOL algorithm. However, while for the case of `surfacetype gepol_ses_gaussian`,
the surface is discretized using Lebedev-type grids, in the point charge scheme, the surface is divided in spherical
triangles called “tesserae”. The level of tesselation is controlled by the tag `ndiv` . The radii used for the solute
atoms in order to construct the GEPOL cavity are those optimized for the COSMO-RS model[445] for H, C, N, O,
F, S, Cl, Br, and I, while for the rest of elements scaled Bondi radii are used.

In order to use the point charge scheme with the SES, we should add the following tag in the `%cpcm` block:




   - **Solvent-accessible surface**

Here, the surface of the solute cavity is generated by following the center of a sphere with radius “ `rsolv` ” (representing the solvent molecule) rolling over the surface of the vdW surface of the solute. The discretization of the
resulting surface is done via tesserae, as done for the SES. In order to use the point charge scheme together with
the SAS, one should add the following tag in the `%cpcm` block:




   - **How to circumvent the numerical instabilities in the point charge scheme**

Numerical instabilities are implicit in the point charge scheme due to the “punctual” nature of the charges and to
the fact that no switching function is considered in the intersection between the spheres that form the solute cavity.
At the same time, there is no way to predict, in advance if there will be discontinuities in the SCF energy and/or
in its derivatives. However, if the user still wants to use this charge scheme, no matter with which type of surface
(SES or SAS), there are two things that one can try to minimize the aforementioned problems:

   - **Change** `ndiv` : The parameter “ `ndiv` ” controls the number of triangles per sphere in the solute cavity. By
changing the number of triangles, it also changes the number of triangles in the intersection between spheres
and, then, this can solve those situations where two point charges get too close making the elements *𝐴* *𝑖𝑗* in
eq (7.315) to diverge (and the solvation charges to suddenly have very large values). However, this strategy
can be a solution for a particular case, but will never ensure that for the same system with another geometry
the discontinuities in the SCF energy do not show (as it does not prevent point charges to be too close from
each other).

   - **Increase** `pmin` : This parameter removes those charges that are at a distance lower than `pmin` from each
other. The default value for `pmin` is of 0.1 a.u. ( *≈* 0 *.* 0529 Å). Then, by incrasing `pmin` one removes all
pairs of charges that are too close from each other in the intersection between the spheres. **Note:** Be careful
when increasing `pmin` . Although this prevents sudden jumps in the SCF energy, it can lead to “biasing” the
solute-solvent interaction, as one is removing a significant number of charges that represent the effect of the
solvent.

**7.50. Implicit Solvation Models** **1017**

**ORCA Manual** **,** **Release 6.0.1**

**Calculation of the free energy of solvation within the C-PCM**

The solvation free energy, ∆ *𝐺* *𝑠𝑜𝑙𝑣*, is defined as the free energy of transfer of a solute from the gas phase to the
condensed phase. This quantity can be written as (see eq 27 in ref. [287])

∆ *𝐺* *𝑠𝑜𝑙𝑣* = *𝐸* *𝑠𝑜𝑙𝑣* ( *𝑅* *[⃗]* *𝑙* *, 𝑅* *[⃗]* *𝑣* ) + ∆ *𝐺* *𝑒𝑙* + ∆ *𝐺* *𝑐𝑎𝑣* + ∆ *𝐺* *𝑑𝑖𝑠𝑝* (7.317)

The first term, *𝐸* *𝑠𝑜𝑙𝑣* ( *𝑅* *[⃗]* *𝑣* *, 𝑅* *[⃗]* *𝑙* ), corresponds to the difference between the liquid-phase expectation value of the
gas-phase Hamiltonian, *𝐸* ( *𝑅* *[⃗]* *𝑙* ), and the gas-phase potential energy surface *𝐸* ( *𝑅* *[⃗]* *𝑣* )

*𝐸* *𝑠𝑜𝑙𝑣* ( *𝑅* *[⃗]* *𝑣* *, 𝑅* *[⃗]* *𝑙* ) = *𝐸* ( *𝑅* *[⃗]* *𝑙* ) *−* *𝐸* ( *𝑅* *[⃗]* *𝑣* )

The second term in eq (7.317) accounts for the electronic-polarization contribution to ∆ *𝐺* *𝑠𝑜𝑙𝑣* and is calculated
from the charges spread over the surface of the solute cavity (vdW-type or the SES). Finally, ∆ *𝐺* *𝑐𝑎𝑣* is the cavitation
energy, that is, the reversible work required to create a cavity inside the bulk of the solvent in order to accommodate
the solute, while ∆ *𝐺* *𝑑𝑖𝑠𝑝* accounts for the changes in the dispersion energy occuring when solvating the solute. The
sum of these last two terms correspond to the non-electrostatic contribution, ∆ *𝐺* *𝑛𝑒𝑙*, to ∆ *𝐺* *𝑠𝑜𝑙𝑣*

∆ *𝐺* *𝑛𝑒𝑙* = ∆ *𝐺* *𝑐𝑎𝑣* + ∆ *𝐺* *𝑑𝑖𝑠𝑝*

In ORCA, if a system is solvated within the C-PCM (defining `!CPCM(solvent name)` in the input file, within
either the point charge scheme or the Gaussian charge scheme) there is no “non-electrostatic solvation contribution”
neither to the SCF energy, nor to its derivatives. In order to have a rough idea of the value of ∆ *𝐺* *𝑛𝑒𝑙*, one can
estimate this quantity through empirical equations available in the literature obtained from experimental data. For
instance, ∆ *𝐺* *𝑛𝑒𝑙* can be estimated from the free energy of hydration for linear-chain alkanes[853]

∆ *𝐺* nel = 1 *.* 321 + 0 *.* 0067639 *×* SASA (7.318)

where SASA is the solvent-accessible surface area. However, although eq (7.318) may give a good estimation
of ∆ *𝐺* *𝑛𝑒𝑙* for organic molecules in water, it is a bad approximation for non-electrostatic solvation effects when
considering solvents different than water (as well as for many solutes in water). There are two alternatives to this
approximation that one can adopt in order to include non-electrostatic solvation effects in ORCA calculations:

1. The use of the SMD model in combination with the C-PCM (see section *The SMD Solvation Model* ).

2. The use of Gaussian charges to compute the electrostatic contribution to ∆ *𝐺* *𝑠𝑜𝑙𝑣* together with an equation
for ∆ *𝐺* nel calculated from the contribution of the solute atoms to the SASA.[287]

Focusing on the second strategy, the cavitation energy, ∆ *𝐺* *𝑐𝑎𝑣* is calculated through the equation proposed by
Pierotti and Claverie.[180, 681] In this case, ∆ *𝐺* *𝑐𝑎𝑣* is expanded in powers of the ratio **R** between the radius of the
solute sphere *𝑅* *𝐼* and that of the solvent spheres *𝑅* *𝑆* . Then, the cavitation energy for the solute sphere centered at
atom *𝐼* reads as,


3 *𝑦*
∆ *𝐺* *𝑐𝑎𝑣,𝐼* = *−* ln(1 *−* *𝑦* ) +
(︂ 1 *−* *𝑦*


)︂


**R** + 3 *𝑦* [9]

1 *−* *𝑦* [+] 2

[︃


*𝑦*
(︂ 1 *−* *𝑦*


)︂ 2 []︃]


2 *𝑦* *𝑃* 3
**R** +
*𝜌* *𝑆* *𝑘* *𝐵* *𝑇* **[R]**


with *𝑦* = 8 *𝜋𝜌* *𝑆* *𝑅* *𝑆* [3] *[/]* [6][, being] *[ 𝜌]* *[𝑆]* [the density of the solvent,] **[ R]** [ =] *[ 𝑅]* *[𝐼]* *[/𝑅]* *[𝑆]* [,] *[ 𝑇]* [the temperature and] *[ 𝑃]* [the pressure. If]
we consider the solvent-accessible surface (SAS), then, the total ∆ *𝐺* *𝑐𝑎𝑣* is the sum of the ∆ *𝐺* *𝑐𝑎𝑣,𝐼* weighted by a
factor that depends on the exposed SASA *𝐼* of sphere *𝐼*


*𝑁* *𝑒𝑙*
∑︁

*𝑖* =1


SASA *𝑖* ∆ *𝐺* *𝑐𝑎𝑣,𝑖* (7.319)

4 *𝜋𝑅* *𝐼* [2]


∆ *𝐺* *𝑐𝑎𝑣* =


*𝑁* sph
∑︁

*𝑖* =1


SASA *𝐼*

∆ *𝐺* *𝑐𝑎𝑣,𝐼* =
4 *𝜋𝑅* *𝐼* [2]


Here, the summation over the total number of spheres ( *𝑁* sph ) that conform the SAS is replaced by a summation
over the total number of surface elements ( *𝑁* el ) in which the SAS is divided into.

With respect to ∆ *𝐺* *𝑑𝑖𝑠𝑝*, this quantity is assumed to depend linearly on the contribution of each surface element to
the SASA


∆ *𝐺* *𝑑𝑖𝑠𝑝* =


*𝑁* el
∑︁ *𝜎* *𝐼* SASA *𝑖* (7.320)

*𝑖* =1


**1018** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Here, the factor *𝜎* *𝐼* is the atomic surface tension of the sphere *𝐼* to which the surface element *𝑖* belongs to.

This strategy, that considers eqs (7.319) and (7.320) to compute ∆ *𝐺* *𝑛𝑒𝑙* assumes the use of Gaussian charges for
the calculation of ∆ *𝐺* *𝑒𝑙* in eq (7.317). When a vdW-type cavity is used to account for electrostatic solvation effects,
then the solvation approach is called GVDW_nel, while when a SES-type cavity is used we refer to the solvation
approach as GSES_nel (“G” for Gaussian charges and “nel” because of the inclusion of non-electrostatic solvation
effects). Details on the GVDW_nel and GSES_nel models can be found in ref. [287].

The GVDW_nel and GSES_nel models have been parametrized for solutes containing H, C, N and O atoms in
the following solvents: benzene, chloroform, cyclohexane, octanol, toluene and water. The parameters for the *𝜎* *𝐼*
atomic surface tensions in eq (7.320) together with the radius of the solvent molecules *𝑅* *𝑆* used to generate the
SAS are provided in ref. [287]. The use of the GVDW_nel and GSES_nel is controlled by the string `cds_cpcm` to
add in the `%cpcm` block. This flag should be equal to 2 within these two models (by default, when we use C-PCM
together with the Gaussian Charge Scheme without non-electrostatic solvation effects, `cds_cpcm` is equal to 0). In
order to calculate ∆ *𝐺* *𝑠𝑜𝑙𝑣* for the GVDW_nel scheme one has to do the following steps:

1. Optimize the geometry of the solute (anisole in this case) in vacuum. For a DFT calculation at the
B3LYP/def2-TZVP level of theory (with RIJCOSX), our input file would read like:



2. Use the resulting structure ( `anisole.xyz` ) as input structure for the subsequent geometry optimization in
solution. In this case, we consider water as the solvent. The input file looks like:




3. Search for the “ `FINAL SINGLE POINT ENERGY` ” in the output file for the solvated system (we call it *𝐸* *𝑠* ):



4. Search for the “ `FINAL SINGLE POINT ENERGY` ” in the output file for the system in vacuum (we call it *𝐸* 0 ):

**7.50. Implicit Solvation Models** **1019**

**ORCA Manual** **,** **Release 6.0.1**



5. Calculate ∆ *𝐺* *𝑠𝑜𝑙𝑣* = *𝐸* *𝑠* *−* *𝐸* 0 = *−* 0 *.* 003885 a.u. If we convert it to kcal/mol and round it to two decimal
digits, we have ∆ *𝐺* *𝑠𝑜𝑙𝑣* = *−* 2 *.* 44 kcal/mol. This quantity is in very good agreement with its experimental
counterpart (-2.45 kcal/mol[559]).

6. In case the user is interested in the value of ∆ *𝐺* *𝑛𝑒𝑙*, this quantity is printed in the “ `CPCM Solvation Model`
`Properties` ” block:



Here, ∆ *𝐺* *𝑛𝑒𝑙* corresponds to “ `Free-energy (cav+disp)` “ and is calculated through eqs (7.319) and (7.320).
The term called “ `Surface-charge` ” corresponds to the solute net charge that lies outside the C-PCM cavity. It
is basically the sum of the C-PCM charges (without the scaling by *𝑓* ( *𝜀* )). The effect of this excess of charge on
the energy and the C-PCM charges themselves can be corrected by the so-called outlying charge correction. In
ORCA, this correction is calculated through a Lagrangian-based algorithm,[706] but only printed for information
purposes. That is, the outlying charge effect is neither added to the SCF energy nor to its derivatives. In any case,
the corrected total charge is printed in “ `Corrected charge` ”, while the correction term for the energy is printed
in “ `Outlying charge corr.` ”. To further help the user, ORCA also prints a file with extension `.cpcm_corr`,
where the corrected C-PCM charges are provided.

If we want to use, instead, the GSES_nel model, one just needs to add `surfacetype gepol_ses_gaussian` in
the `%cpcm` block.

**Note:** The analytical Hessian is not available for the GVDW_nel and GSES_nel models as the second derivative
of ∆ *𝐺* *𝑛𝑒𝑙* with respect to nuclear displacements is not implemented.

**7.50.2 The Conductor-like Screening Solvation Model (COSMO)**

**Note:** The COSMO solvation model has been removed from ORCA v4.0.0 !!!

*Please use the C-PCM solvation model in combination with the COSMO epsilon function if required!*
As a short form to use the C-PCM model with the COSMO epsilon function, you can specify the solvent via
`!CPCMC(solvent)` .

**7.50.3 The SMD Solvation Model**

The SMD solvation model has been proposed by the Cramer and Truhlar groups,[559] and is based on the quantum
mechanical charge density of a solute molecule interacting with a continuum description of the solvent. In the model
the full solute electron density is used without defining partial atomic charges and the solvent is not represented
explicitly but rather as a dielectric medium with the surface tension at the solute–solvent boundary. SMD is a
universal solvation model, in the sense that it is applicable to any charged or uncharged solute in any solvent
or liquid medium for which a few key descriptors are known. In particular, these descriptors are the dielectric
constant, refractive index, bulk surface tension, and acidity and basicity parameters. Neglecting the concentration
contribution, the model separates the observable solvation free energy into two main components,

∆ *𝐺* S = ∆ *𝐺* ENP + ∆ *𝐺* CDS *.* (7.321)

In ORCA, the first component is the bulk electrostatic contribution arising from a self-consistent reaction field
treatment that involves the electrostatic interaction using the Conductor-like Polarizable Continuum Model (C
**1020** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

PCM). However, the radii are set to “intrinsic atomic Coulomb radii”. The second component, called the cavitydispersion solvent-structure (CDS) term, is the contribution resulting from short-range interactions between the
solute and solvent molecules in the first solvation shell. This contribution is a sum of terms that are proportional
(with geometry-dependent proportionality constants called atomic surface tensions) to the solvent-accessible surface areas of the individual atoms of the solute. The CDS contribution to the free energy of solvation is given
by


*𝐴* *𝑘* ( **R** *, 𝑅* *𝑍* *𝑘* + *𝑟* *𝑠* ) *,*

*𝑘*


∆ *𝐺* CDS =


atoms
∑︁


atoms
*𝜎* *𝑘* *𝐴* *𝑘* ( **R** *, 𝑅* *𝑍* *𝑘* + *𝑟* *𝑠* ) + *𝜎* [[M]] ∑︁

*𝑘* *𝑘*


where *𝜎* *𝑘* and *𝜎* [[M]] are the atomic surface tension of atom *𝑘* and the molecular surface tension, respectively, and
*𝐴* *𝑘* is the solvent-accessible surface area (SASA). The SASA depends on the geometry **R**, the set *𝑅* *𝑍* *𝑘* of all atomic
van der Waals radii, and the solvent radius *𝑟* *𝑠*, which is added to each of the atomic van der Waals radii. In the
program Bondi radii are used for CDS contribution.

More details can be found in the original paper of Marenich et al. [559], which should be cited in publications
using results of SMD calculations.

SMD can be employed in single point calculations and geometry optimizations, using single-determinant SCF (HF
and DFT) and CASSCF methods. In post-SCF methods the result is corrected in the reference wave function. The
SMD solvation model is invoked in the input file via
```
! SMD(solvent)

```
where `solvent` is one of the 179 solvents in the SMD library (see Table Table 7.29). Alternatively, one can request
the SMD model via the `%cpcm` block by writing:



Independently on the way the user invokes the SMD model, ORCA automatically sets a number of default SMD
parameters for the chosen solvent. If required, the user can also manually specify the solvent descriptors used in
an SMD calculation in the `%cpcm` block.



Let’s consider the following input for a water molecule solvated by water,

Before the SCF part starts, the program prints the SMD information. This part reads as:



(continues on next page)

**7.50. Implicit Solvation Models** **1021**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

After the SCF is converged, the SMD contribution to the total energy is printed (this term is labelled as “SMD
CDS” term).



**1022** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**Notes:**

  - If one is interested in the calculation of free energies of solvation using the SMD model, one just needs to
compute ∆ *𝐺* S according to eq (7.321). However, here one should take into account that the SMD model
considers the same concentration (1 mol/L) in both the gaseous and solution phases. Then, if a gas-phase
standard state of 1 atm is considered, and we want to compare the calculated ∆ *𝐺* S with its experimental
counterpart, a concentration term equal to 1.89 kcal/mol has to be added to the calculated ∆ *𝐺* S .

**7.50.4 Dynamic Radii Adjustment for Continuum Solvation (DRACO)**

The DRACO scheme is an approach that improves the performance of implicit solvation models, in particular the
accuracy of the calculated solvation free energies.[689] It is based on a dynamic scaling of the original static radii
used to describe the atoms/spheres that define the cavity of the solute.

In this approach, the original radii *𝑟* *𝑖* of an atom *𝑖* is scaled according to

*𝑟* *𝑖* scale = *𝑓* *𝑖* scale *𝑟* *𝑖* (7.322)

with the scaling factor *𝑓* *𝑖* scale determined from

*𝑓* *𝑖* scale = erf( *𝑎* *𝑍* ( *𝑞* eff *,𝑖* *−* *𝑏* *𝑍* )) + 1 (7.323)

Here, *𝑞* eff *,𝑖* corresponds to the effective partial charge and is defined as

*𝑞* eff *,𝑖* = *𝑞* *𝑖* + *𝑘* *𝑍* *𝑞* *𝑖* CN *𝑖* (7.324)

where *𝑞* *𝑖* is the atomic partial charge. The parameters *𝑎* *𝑍*, *𝑏* *𝑍* and *𝑘* *𝑍* are element-specific parameters, and CN *𝑖* is
the fractional coordination number.

For oxygen atoms, the *𝑓* *𝑖* scale is corrected via a term that depends on the Abraham’s hydrogen bond acidity ( *𝛼* ):

*𝑓* *𝑖* [O] scale [=] *[ 𝑓]* *[𝑖]* [scale] [+] *[ 𝑐]* [O] [(0] *[.]* [43] *[ −]* *[𝛼]* [)] (7.325)

with *𝑐* O a parameter that is different for pure C-PCM or SMD. The correction in eq (7.325) is only applied for
solvents with *𝛼<* 0 *.* 43.

DRACO is parametrized for C-PCM and SMD for the following solvents: acetonitrile, DMSO, methanol, and
[water. The element-specific parameters in eqs (7.323),(7.324), and (7.325) are available in https://github.com/](https://github.com/grimme-lab/DRACO)
[grimme-lab/DRACO.](https://github.com/grimme-lab/DRACO)

The use of DRACO with C-PCM or SMD is triggered via the following tags in the simple input:
```
! CPCM(solvent) DRACO

```
or
```
! SMD(solvent) DRACO

```
Alternatively, it can also be requested in the `%cpcm` block:



In ORCA, the default scheme to calculate the partial charges in eq (7.324) is the electronegativity-equilibration
(EEQ) charge model (D4 case),[132]. However, one can also request the Charge Extended Hückel (CEH)
model.[541] The charge scheme within DRACO is controlled by the following tag in the `%cpcm` block:



**7.50. Implicit Solvation Models** **1023**

**ORCA Manual** **,** **Release 6.0.1**

If CEH charges are requested, ORCA needs to run an XTB calculation to generate them. Here, one should have
at least the version 6.7.1 of XTB (older versions will not generate the CEH charges, see section *Program Compo-*
*nents* ). Regarding the fractional coordination number in eq (7.324), it is calculated as described in GFN2-XTB
calculations.[70]

**Note:** DRACO can only be used, for the moment, in single-point energy calculations.

**7.50.5 OpenCOSMO-RS**

ORCA is interfaced to openCOSMO-RS,[293, 542] an open source implementation of the COSMO-RS
model.[447, 448] This model is widely used in both academia and industry to predict fluid phase thermodynamics.

The main idea behind COSMO-RS is that the interaction between molecules in the liquid phase can de depicted
as an ensemble of interacting surface segments. The properties on the surface segments are calculated via QM
calculations of the solute and the solvent in a perfect conductor ( *𝜖* = *∞* ), and the interaction free energies between
segments are functions of a set of descriptors. Among them, the most relevant one is the screening charge density
( *𝜎* ).

A complete description of the COSMO-RS model used in ORCA is provided in refs [293, 542], and the code is avail[able in https://github.com/TUHH-TVT. In particular, the parametrization for ORCA 6.0 is called openCOSMO-RS](https://github.com/TUHH-TVT)
24a. The corresponding the executable is shipped together with the ORCA 6.0 binaries and called `openCOSMORS` .
ORCA will then call internally this executable whenever it is needed.

COSMO-RS calculations within ORCA are a special type of calculation. By requesting COSMO-RS, ORCA runs
a set of single-point-energy calculations for both the solute and the solvent and then calls the openCOSMO-RS
executable, which expects an input geometry for the solute and the solvent and calculates the free energy of solvation
of the solute in the solvent. A workflow of a calculation requesting COSMO-RS in ORCA is the following:

1. Single-point-energy calculation of the solute in the gas-phase

2. Single-point-energy calculation of the solute in a conductor ( *𝜖* = *∞* )

3. Single-point-energy calculation of the solvent in a conductor ( *𝜖* = *∞* )

4. Do COSMO-RS via the openCOSMO-RS executable and compute solvation properties

Points 1 to 3 correspond to DFT calculations at the BP86/def2-TZVPD level. This is the level of theory used to
parametrize COSMO-RS for ORCA 6.0. As it is shown later, the user can change the functional and basis set, but
this is not recommended!

Regarding calculations 2 and 3, to produce smooth *𝜎* profiles, ORCA discards the surface segments with an area <
0.01 Å [2] . For these two calculations, the radii of several elements used to construct the cavity of solute and solvent
are different than the defaults employed within non-COSMO-RS calculations (using C-PCM). This is due to the
fact that the provided openCOSMO-RS binaries involve a special parametrization of COSMO-RS for ORCA 6.0,
and this does not only affect the COSMO-RS parameters, but also the radii of several elements used in the C-PCM

part.

After point 4 is done, the free energy of solvation (∆ *𝐺* S ) of the solute in the solvent is printed in the ORCA output
file. In ORCA 6.0 the use of openCOSMO-RS is restricted to the calculation of ∆ *𝐺* S .

**How to Run a ORCA/COSMO-RS Calculation**

ORCA/COSMO-RS calculations are controlled through the `%cosmors` block. These type of calculations require
two input structures, one for the solute and one for the solvent. The solute coordinates are provided in the input file
as done for any other type of calculation. However, regarding the structure for the solvent, there are two options:

1. Retrieve the structure of the solvent from a database

2. Provide the structure in a separate file

To use strategy 1, we need to request the solvent via:
```
COSMORS(Solvent)

```
**1024** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


in the simple input or using the `%cosmors` block:



The list of internal solvents available in ORCA are shown in Table 7.29. For instance, for a water molecule solvated
by acetonitrile, the input file looks like:



If the user wants to provide a structure for the solvent (strategy 2), then a separate file with extension **.cosmorsxyz**
should be available. The name of this file (without extension) is controlled by the tag `solventfilename` in the
`%cosmors` block. For instance, if we want to calculate the free energy of solvation of acetone in water, the ORCA
input file would look like this:

The structure of the solvent (water) is the one in the `water.cosmorsxyz` file:



where the first line corresponds to the number of atoms, and in the second line the charge and multiplicity are
provided.

The output for COSMO-RS is printed in the ORCA output file after the line that reads `OPENCOSMO-RS`
`CALCULATION` . First of all, the information regarding the level of theory, the solute and the solvent is printed.
For the example above (acetone in water), it reads as,



(continues on next page)

**7.50. Implicit Solvation Models** **1025**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

After these lines, ORCA prints the final single point energy for each of the QM calculations, together with the
output file to which the ORCA output is redirected:




Once this information is printed, ORCA calls the openCOSMO-RS executable and ∆ *𝐺* S is printed in the following
block:

**1026** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**



As pointed out in the last paragraph of the COSMO-RS output, to calculate the Gibbs free energy of the solute
solvated by the given solvent, one should add the calculated ∆ *𝐺* S to the `Final Gibbs free energy` of the solute
in the gas-phase.

The parameters that can be defined in the `%cosmors` block in the ORCA input file are the following:



It is not recommended to change the defaults of the COSMO-RS parameters.

**Note:** The workflow explained above for ORCA/openCOSMO-RS calculations involves the same structure for the
solute in the gas-phase and in solution. However, these structures may differ substantially depending on the type
of solute and solvent. In ORCA, it is possible to optimize the structures for each of the three calculations needed
in the ORCA/openCOSMO-RS workflow. That is, (1) the solute in gas-phase, (2) the solute in a conductor, and
(3) the solvent in a conductor. To do that, one needs to add the level of optimization via the `dftfunc` tag, which is
exclusive for the DFT functional, but as an exception, can be extended with the optimization tag:



**7.50. Implicit Solvation Models** **1027**

**ORCA Manual** **,** **Release 6.0.1**

**7.50.6 Implicit Solvation in Coupled-Cluster Methods**

The coupled-cluster Lagrangian, *ℒ*, for a system implicitly solvated reads as follows,[133, 142, 285]

*ℒ* (Λ *, 𝑇* ) = *⟨𝜓* 0 *|* (1 + Λ)e *[−][𝑇]* *𝐻* 0 e *[𝑇]* *|𝜓* 0 *⟩* + [1] **¯Q** (Λ *, 𝑇* ) *·* **¯V** (Λ *, 𝑇* ) (7.326)

2

where *𝜓* 0 is the reference wave function, and *𝐻* 0 is the Hamiltonian for the isolated molecule. The operator *𝑇* for
CCSD is defined in terms of single and double excitations ( *𝑇* = *𝑇* 1 + *𝑇* 2 ), and Λ is the de-excitation operator,
defined in terms of the Lagrange multipliers:


*𝑡* *[𝑖]* *𝑎* *[𝑎]* [+] *𝑎* *[𝑎]* *[𝑖]* [+] ∑︁

*𝑖𝑎*


*𝑇* = *𝑇* 1 + *𝑇* 2 = ∑︁


∑︁ *𝑡* *[𝑖𝑗]* *𝑎𝑏* *[𝑎]* *𝑎* [+] *[𝑎]* [+] *𝑏* *[𝑎]* *[𝑗]* *[𝑎]* *[𝑖]* (7.327)

*𝑖𝑗𝑎𝑏*


*𝜆* *[𝑎]* *𝑖* *[𝑎]* [+] *𝑖* *[𝑎]* *[𝑎]* [+ 1]

2

*𝑖𝑎*


Λ = ∑︁


2


∑︁ *𝜆* *[𝑎𝑏]* *𝑖𝑗* *[𝑎]* *𝑖* [+] *[𝑎]* *[𝑎]* *[𝑎]* [+] *𝑗* *[𝑎]* *[𝑏]* (7.328)

*𝑖𝑗𝑎𝑏*


Here, *𝑡* *[𝑖]* *𝑎* [and] *[ 𝑡]* *[𝑖𝑗]* *𝑎𝑏* [are the singles and doubles wave function amplitudes and] *[ 𝑎]* *[𝑖]* [and] *[ 𝑎]* *𝑎* [+] [are standard fermion anni-]
hilation and creation operators, respectively. Canonical occupied orbitals are denoted by the symbols *𝑖, 𝑗, 𝑘, . . .*,
virtual orbitals by the symbols *𝑎, 𝑏, 𝑐, . . .*, and we use the symbols *𝑝, 𝑞, 𝑟. . .* for general orbital indices.

The quantities **Q** **[¯]** and **V** **[¯]** are the CC expectation values of the C-PCM operators **Q** and **V**, which are the solvation
charges vector and solute potential vector defined at the position the charges, respectively.

**¯Q** (Λ *, 𝑇* ) = *⟨𝜓* 0 *|* (1 + Λ)e *[−][𝑇]* **Q** e *[𝑇]* *|𝜓* 0 *⟩* (7.329)

**¯V** (Λ *, 𝑇* ) = *⟨𝜓* 0 *|* (1 + Λ)e *[−][𝑇]* **V** e *[𝑇]* *|𝜓* 0 *⟩* (7.330)

Equation (7.326) can be rewritten by introducing the normal product form of an operator:

*𝑋* *𝑁* = *𝑋* *−⟨𝜓* 0 *|𝑋|𝜓* 0 *⟩* = *𝑋* *−* *𝑋* 0 (7.331)

If one uses this result in eq (7.326), together with the fact that **Q** and **V** are related through eq (7.316), then eq
(7.326) reads as,



[1]

2 **[Q]** [0] *[ ·]* **[ V]** [0] [ +] **[ Q]** [0] *[ ·]* **[ ¯V]** *[𝑁]* [(Λ] *[, 𝑇]* [) + 1] 2


*ℒ* (Λ *, 𝑇* ) = *⟨𝜓* 0 *|𝐻* 0 *|𝜓* 0 *⟩* + *⟨𝜓* 0 *|* (1 + Λ)e *[−][𝑇]* *𝐻* 0 *𝑁* e *[𝑇]* *|𝜓* 0 *⟩* + [1]


**¯Q** *𝑁* (Λ *, 𝑇* ) *·* **¯V** *𝑁* (Λ *, 𝑇* ) =
2


= *𝐸* 0 + *⟨𝜓* 0 *|* (1 + Λ)e *[−][𝑇]* *𝐻* 0 *𝑁* e *[𝑇]* *|𝜓* 0 *⟩* + **Q** 0 *·* **V** **[¯]** *𝑁* (Λ *, 𝑇* ) + [1] **¯Q** *𝑁* (Λ *, 𝑇* ) *·* **¯V** *𝑁* (Λ *, 𝑇* )

2


(7.332)


Here, **Q** 0 and **V** 0 are the **Q** and **V** vectors calculated with the *𝜓* 0 wave function, and *𝐸* 0 is the reference energy
( *𝐸* 0 = *⟨𝜓* 0 *|𝐻* 0 *|𝜓* 0 *⟩* + [1] **[Q]** [0] *[ ·]* **[ V]** [0] [). Different approximations can be adopted in eq (][7.332][) depending on how one]


( *𝐸* 0 = *⟨𝜓* 0 *|𝐻* 0 *|𝜓* 0 *⟩* + 2 [1] **[Q]** [0] *[ ·]* **[ V]** [0] [). Different approximations can be adopted in eq (][7.332][) depending on how one]

calculates its last term [1]

2 **[¯Q]** *[𝑁]* [(Λ] *[, 𝑇]* [)] *[ ·]* **[ ¯V]** *[𝑁]* [(Λ] *[, 𝑇]* [)][.]

In ORCA there are three different CCSD/CPCM approaches: (i) the PTE scheme, (ii) the PTE(S) scheme, and the
(iii) the PTES scheme, being the last one the default. Here, the acronym PTE stands for “perturbation theory and
energy” and “S” for singles. The choice of any of these approaches is controlled via the tag “ `CPCMccm` ”. Information
about which CCSD/C-PCM is used by ORCA in a calculation is printed in the “ `ORCA-MATRIX DRIVEN CI` ” block
in the output file in the line starting by “ `CPCM scheme` ”:



[1]

2 **[¯Q]** *[𝑁]* [(Λ] *[, 𝑇]* [)] *[ ·]* **[ ¯V]** *[𝑁]* [(Λ] *[, 𝑇]* [)][.]




(continues on next page)

**1028** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



In the following subsections, we describe the different CCSD/C-PCM approaches available in ORCA and how to
use them.

**PTE scheme**

In the “perturbation theory energy” (PTE) scheme, the last term in eq (7.332) is equal to zero (this term does not
depend on Λ and *𝑇* ),

*ℒ* (Λ *, 𝑇* ) = *𝐸* 0 + *⟨𝜓* 0 *|* (1 + Λ)e *[−][𝑇]* *𝐻* 0 *𝑁* e *[𝑇]* *|𝜓* 0 *⟩* + **Q** 0 *·* **V** **[¯]** *𝑁* (Λ *, 𝑇* ) (7.333)

The potential **V** **[¯]** *𝑁* can be written as follows:


**¯V** *𝑁* (Λ *, 𝑇* ) = *⟨𝜓* 0 *|* (1 + Λ)e *[−][𝑇]* [∑︁]


**v** *𝑝𝑞* *{𝑝* [+] *𝑞}* e *[𝑇]* *|𝜓* 0 *⟩* = ∑︁

*𝑝𝑞* *𝑝𝑞*


**v** *𝑝𝑞* *⟨𝜓* 0 *|* (1 + Λ)e *[−][𝑇]* *{𝑝* [+] *𝑞}* e *[𝑇]* *|𝜓* 0 *⟩* = ∑︁

*𝑝𝑞* *𝑝𝑞*


**v** *𝑝𝑞* Γ *𝑝𝑞*

*𝑝𝑞*


(7.334)


where we have used that **V** *𝑁* = [∑︀] *𝑝𝑞* **[v]** *[𝑝𝑞]* *[{][𝑝]* [+] *[𝑞][}]* [ (second-quantized form of a normal ordered operator), with] **[ v]** *[𝑝𝑞]*

the components of the solute potential in the MO basis. The matrix Γ is the CCSD relaxed one-electron density
matrix. Then, the contribution to the equations for the *𝑇* amplitudes comes from the derivative of **V** **[¯]** *𝑁* (Λ *, 𝑇* ) with
respect to the Λ amplitudes ( **Q** 0 does not depend on the Lagrange multipliers). In this context, the Hamiltonian
*𝐻* 0 *𝑁* contains a term that depends on the elements of the Fock matrix ( [∑︀] *[𝑓]* *[𝑝𝑞]* *[{][𝑝]* [+] *[𝑞][}]* [) and that has the same]


where we have used that **V** *𝑁* = [∑︀]


*𝐻* 0 *𝑁* contains a term that depends on the elements of the Fock matrix ( [∑︀] *𝑝𝑞* *[𝑓]* *[𝑝𝑞]* *[{][𝑝]* [+] *[𝑞][}]* [) and that has the same]

functional form as **V** *𝑁* . As the Fock matrix is updated in the reference calculation with a C-PCM term that reads
as (in AO basis) *𝐹* *𝜇𝜈* [CPCM] = **Q** 0 *·* **V** *𝜇𝜈*, then the term **Q** 0 *·* **V** **[¯]** *𝑁* (Λ *, 𝑇* ) is added implicitly to eq (7.333).


Once the *𝑇* amplitudes are obtained, the total energy, *𝐸*, is calculated as


*𝐹* *𝑖𝑎* *𝑡* *[𝑖]* *𝑎* [+ 1]

4

*𝑖𝑎*


*𝐸* = *𝐸* 0 + *⟨𝜓* 0 *|* e *[−][𝑇]* ( *𝐻* 0 *𝑁* + **Q** 0 *·* **V** *𝑁* )e *[𝑇]* *|𝜓* 0 *⟩* = *𝐸* 0 + ∑︁


4


∑︁ *⟨𝑖𝑗||𝑎𝑏⟩* (︁ *𝑡* *[𝑖𝑗]* *𝑎𝑏* [+ 2] *[𝑡]* *𝑎* *[𝑖]* *[𝑡]* *[𝑗]* *𝑏* )︁ (7.335)

*𝑖𝑗𝑎𝑏*


Then, the C-PCM contribution to the CC energy within the PTE scheme occurs through the term [1] 2 **[Q]** [0] *[ ·]* **[ V]** [0] [ in] *[ 𝐸]* [0]

and implicitly through the Fock matrix elements *𝐹* *𝑖𝑎* ( *𝐹* *𝑖𝑎* = *𝐹* *𝑖𝑎* [0] [+] **[ Q]** [0] *[ ·]* **[ v]** *[𝑖𝑎]* [).]

The PTE scheme corresponds to “ `CPCMccm 0` ”, and is implemented for canonical-CCSD (RHF and UHF) and
DLPNO-CCSD (RHF and UHF). For instance, for a DLPNO-CCSD calculation (closed-shell reference) of a system
solvated by water using the PTE scheme, the input file looks like:



**7.50. Implicit Solvation Models** **1029**

**ORCA Manual** **,** **Release 6.0.1**

**PTE(S) scheme**

In this scheme (where the “S” stands for singles), the last term in eq (7.332) depends on the *𝑇* amplitudes, but not
on the Λ amplitudes,

*ℒ* (Λ *, 𝑇* ) = *𝐸* 0 + *⟨𝜓* 0 *|* (1 + Λ)e *[−][𝑇]* *𝐻* 0 *𝑁* e *[𝑇]* *|𝜓* 0 *⟩* + **Q** 0 *·* **V** **[¯]** *𝑁* (Λ *, 𝑇* ) + [1] **¯Q** *𝑁* ( *𝑇* ) *·* **¯V** *𝑁* ( *𝑇* ) (7.336)

2

Again, in the same way as for the PTE scheme, the C-PCM contribution to the equations for the *𝑇* amplitudes
comes from the term **Q** 0 *·* **V** **[¯]** *𝑁* (Λ *, 𝑇* ) in eq (7.336), which is implictly added to the Fock matrix elements in the
MO basis. The last term in eq (7.336) does not depend on the Λ amplitudes and then does not contribute to the
equations for the *𝑇* amplitudes. However, this term depends on the *𝑇* amplitudes through the elements *𝛾* *𝑎𝑖* of the
density matrix Γ,


*𝛾* *𝑎𝑖* = *𝑡* *[𝑖]* *𝑎* [+] ∑︁

*𝑚𝑒*


(︀ *𝑡* *[𝑖𝑚]* *𝑎𝑒* *[−]* *[𝑡]* *[𝑖]* *𝑒* *[𝑡]* *[𝑚]* *𝑎* )︀ *𝜆* *[𝑒]* *𝑚* *[−]* [1]

2


∑︁ *𝜆* *[𝑒𝑓]* *𝑚𝑛* (︀ *𝑡* *[𝑖𝑛]* *𝑒𝑓* *[𝑡]* *𝑎* *[𝑚]* [+] *[ 𝑡]* *[𝑚𝑛]* *𝑎𝑓* *[𝑡]* *𝑒* *[𝑖]* )︀ (7.337)

*𝑚𝑛𝑒𝑓*


∑︁


and then it contributes to the final energy *𝐸* in the following way:


*𝑡* *[𝑖]* *𝑎* **[q]** *[𝑎𝑖]*

(︃∑︁ *𝑎𝑖*


)︃


1
**¯Q** *𝑁* ( *𝑇* ) *·* **¯V** *𝑁* ( *𝑇* ) = [1]
2 2


)︃



*·*


*𝑡* *[𝑖]* *𝑎* **[v]** *[𝑎𝑖]*

(︃∑︁ *𝑎𝑖*


(︃∑︁ *𝑎𝑖*


That gives the final equation for the total energy of our system,


)︃


*𝑡* *[𝑖]* *𝑎* **[q]** *[𝑎𝑖]*

(︃∑︁ *𝑎𝑖*


*𝐸* = *𝐸* 0 + *⟨𝜓* 0 *|* e *[−][𝑇]* ( *𝐻* 0 *𝑁* + **Q** 0 *·* **V** *𝑁* )e *[𝑇]* *|𝜓* 0 *⟩* + [1]

2


*𝐸* = *𝐸* 0 + *⟨𝜓* 0 *|* e *[−][𝑇]* ( *𝐻* 0 *𝑁* + **Q** 0 *·* **V** *𝑁* )e *[𝑇]* *|𝜓* 0 *⟩* + [1]


)︃



*·*


*𝑡* *[𝑖]* *𝑎* **[v]** *[𝑎𝑖]*

(︃∑︁ *𝑎𝑖*


(︃∑︁ *𝑎𝑖*


=


(7.338)

(7.339)
)︃


)︃


*𝐹* *𝑖𝑎* *𝑡* *[𝑖]* *𝑎* [+ 1]

4

*𝑖𝑎*


= *𝐸* 0 + ∑︁


4


2



*·*


*𝑡* *[𝑖]* *𝑎* **[v]** *[𝑎𝑖]*

(︃∑︁ *𝑎𝑖*


∑︁ *⟨𝑖𝑗||𝑎𝑏⟩* (︁ *𝑡* *[𝑖𝑗]* *𝑎𝑏* [+ 2] *[𝑡]* *𝑎* *[𝑖]* *[𝑡]* *[𝑗]* *𝑏* )︁ + [1] 2

*𝑖𝑗𝑎𝑏*


∑︁


*𝑡* *[𝑖]* *𝑎* **[q]** *[𝑎𝑖]*

(︃∑︁ *𝑎𝑖*


Therefore, the CC energy for a solvated system within the PTE(S) scheme involves three C-PCM contributions:
(1) the term [1] **[Q]** [0] *[ ·]* **[ V]** [0] [ included in] *[ 𝐸]* [0] [, (2) the term][ ∑︀] **[Q]** [0] *[ ·]* **[ v]** *[𝑖𝑎]* *[𝑡]* *[𝑖]* [that occurs implicitly through][ ∑︀] *[𝐹]* *[𝑖𝑎]* *[𝑡]* *[𝑖]* [and]


(1) the term [1] 2 **[Q]** [0] *[ ·]* **[ V]** [0] [ included in] *[ 𝐸]* [0] [, (2) the term][ ∑︀] *𝑖𝑎* **[Q]** [0] *[ ·]* **[ v]** *[𝑖𝑎]* *[𝑡]* *𝑎* *[𝑖]* [that occurs implicitly through][ ∑︀] *𝑖𝑎* *[𝐹]* *[𝑖𝑎]* *[𝑡]* *𝑎* *[𝑖]* [and]

(3) the term [1] 2 (︀∑︀ *𝑎𝑖* *[𝑡]* *𝑎* *[𝑖]* **[q]** *[𝑎𝑖]* )︀ *·* (︀∑︀ *𝑎𝑖* *[𝑡]* *𝑎* *[𝑖]* **[v]** *[𝑎𝑖]* )︀.

This scheme is available in ORCA for canonical-CCSD (RHF and UHF) and DLPNO-CCSD (RHF and UHF). In
order to use it, the user needs to add the tag “ `CPCMccm 1` ” in the `%cpcm` block.


*𝑖𝑎* **[Q]** [0] *[ ·]* **[ v]** *[𝑖𝑎]* *[𝑡]* *𝑎* *[𝑖]* [that occurs implicitly through][ ∑︀]



[1]

2 **[Q]** [0] *[ ·]* **[ V]** [0] [ included in] *[ 𝐸]* [0] [, (2) the term][ ∑︀]


*𝑎𝑖* *[𝑡]* *𝑎* *[𝑖]* **[q]** *[𝑎𝑖]* )︀ *·* (︀∑︀



[1]

2 (︀∑︀


*𝑎𝑖* *[𝑡]* *𝑎* *[𝑖]* **[v]** *[𝑎𝑖]* )︀.




**PTES scheme**

In this scheme, both **Q** **[¯]** *𝑁* and **V** **[¯]** *𝑁* in the last term in eq (7.332) depend on the *𝑇* amplitudes but just one of them
depends on the Λ amplitudes,

*ℒ* (Λ *, 𝑇* ) = *𝐸* 0 + *⟨𝜓* 0 *|* (1 + Λ)e *[𝑇]* *𝐻* 0 *𝑁* e *[𝑇]* *|𝜓* 0 *⟩* + **Q** 0 *·* **V** **[¯]** *𝑁* (Λ *, 𝑇* ) + [1] **¯Q** *𝑁* ( *𝑇* ) *·* **¯V** *𝑁* (Λ *, 𝑇* ) (7.340)

2

The C-PCM terms enter these equations on the one hand, implicitly, through the elements of the Fock matrix (like
for the PTE and PTE(S) schemes), and on the other hand, explicitly through the derivatives of [1] 2 **[¯Q]** *[𝑁]* [(] *[𝑇]* [)] *[·]* **[ ¯V]** *[𝑁]* [(Λ] *[, 𝑇]* [)]

with respect to Λ. If we call *ℒ* CPCM the last C-PCM term in eq (7.340), then the contribution from this term to the
*𝑇* amplitudes equations read as:


*𝑡* *[𝑗]* *𝑎* **[v]** *[𝑗𝑖]* [+] ∑︁
*𝑗* *𝑏*


)


*𝜕ℒ* CPCM


CPCM

= [1]
*𝜕𝜆* *[𝑎]* *𝑖* 2


⎤

(7.341)
⎦


( *𝑡* *[𝑗𝑖]* *𝑏𝑎* *[−]* *[𝑡]* *𝑎* *[𝑗]* *[𝑡]* *[𝑖]* *𝑏* ) **v** *𝑏𝑗*


*𝑡* *[𝑖]* *𝑏* **[v]** *[𝑎𝑏]* [+] **[ v]** *[𝑖𝑎]* [+] ∑︁

*𝑏*


*𝑏𝑗*



*·*


⎡


*−*
∑︁
⎣ *𝑗*


2


︃∑︁ *𝑡* *[𝑖]* *𝑎* **[q]** *[𝑎𝑖]*
( *𝑎𝑖*


**1030** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


)︃


*𝜕ℒ* CPCM


CPCM

= [1]
*𝜕𝜆* *[𝑎𝑏]* 2
*𝑖𝑗*


*𝑡* *[𝑘𝑗]* *𝑎𝑏* **[v]** *[𝑘𝑖]* [+ 1]

2

*𝑘*


]︃


2


2


(︁ *𝑡* *[𝑘𝑗]* *𝑎𝑏* *[𝑡]* *𝑐* *[𝑖]* [+] *[ 𝑡]* *[𝑖𝑗]* *𝑐𝑏* *[𝑡]* *𝑎* *[𝑘]* )︁ **v** *𝑐𝑘*



*·*



[︃


*−* [1]

2


∑︁


2


*𝑡* *[𝑖]* *𝑎* **[q]** *[𝑎𝑖]*

(︃∑︁ *𝑎𝑖*


∑︁


*𝑡* *[𝑖𝑗]* *𝑎𝑐* **[v]** *[𝑏𝑐]* *[−]* [1]

2

*𝑐*


∑︁

*𝑐𝑘*


(7.342)


The contribution to the energy is the same as that for the PTE(S) scheme, but with different values for the *𝑇*
amplitudes (as the equations to calculate them differ slightly from those for the PTE(S) scheme).


)︃


*𝐸* = *𝐸* 0 + *⟨𝜓* 0 *|* e *[−][𝑇]* ( *𝐻* 0 *𝑁* + **Q** 0 *·* **V** *𝑁* )e *[𝑇]* *|𝜓* 0 *⟩* + [1]

2


*𝑡* *[𝑖]* *𝑎* **[q]** *[𝑎𝑖]*

(︃∑︁ *𝑎𝑖* )︃



*·*


*𝑡* *[𝑖]* *𝑎* **[v]** *[𝑎𝑖]*

(︃∑︁ *𝑎𝑖*


(︃∑︁ *𝑎𝑖*


=


)︃


(7.343)
)︃


∑︁ *𝐹* *𝑖𝑎* *𝑡* *[𝑖]* *𝑎* [+ 1] 4

*𝑖𝑎*


= *𝐸* 0 + ∑︁


4


2



*·*


*𝑡* *[𝑖]* *𝑎* **[v]** *[𝑎𝑖]*

(︃∑︁ *𝑎𝑖*


∑︁ *⟨𝑖𝑗||𝑎𝑏⟩* (︁ *𝑡* *[𝑖𝑗]* *𝑎𝑏* [+ 2] *[𝑡]* *𝑎* *[𝑖]* *[𝑡]* *[𝑗]* *𝑏* )︁ + [1] 2

*𝑖𝑗𝑎𝑏*


∑︁


*𝑡* *[𝑖]* *𝑎* **[q]** *[𝑎𝑖]*

(︃∑︁ *𝑎𝑖*


(︃∑︁ *𝑎𝑖*


This scheme is the default CCSD/C-PCM approach in ORCA and is available in ORCA for canonical-CCSD (RHF
and UHF) and DLPNO-CCSD (RHF and UHF). In this case, the tag “ `CPCMccm` ” in the `%cpcm` block is equal to 2.
However, as the PTES scheme is the default in ORCA, the user just needs to add the information about the solvent
in the input file, in order to use this approach.

**Notes regarding the use of the CCSD/C-PCM schemes** :

  - For calculations within the PTE(S) and the PTES schemes, the explicit C-PCM contribution to the total energy (see eqs. (7.339) and (7.343)) is printed in the “ `COUPLED CLUSTER ENERGY` ” block after the equations
for the “T” amplitudes converge. In this case, this energy is labelled as “ `C-PCM corr. term` ” and is already
included in the correlation energy, “ `E(CORR)` “. For the input example from above, this information looks
like:



This contribution does not represent the whole C-PCM contribution to the correlation energy, as this one
also occurs, implicitly, through the “T” amplitudes.

  - The C-PCM contribution to the Λ equations is implemented in ORCA for the PTE(S) and PTES schemes.
Then, the user can request unrelaxed densities.

**7.50. Implicit Solvation Models** **1031**

**ORCA Manual** **,** **Release 6.0.1**
### **7.51 Calculation of Properties**

**7.51.1 Electric Properties**

Calculation of first order (electric dipole and quadrupole moments) and second order (polarizabilities) electric
properties can be requested in the `%elprop` input block. The second order properties can be calculated through the
solution of the CP-SCF (see *CP-SCF Options* ) or CP-CASSCF (see *CASSCF Linear Response* ) equations. Details
are shown below:



The most efficient and accurate way to calculate the polarizability analytically is to use the coupled-perturbed SCF
method. The most time consuming and least accurate way is the numerical second derivative of the total energy.
Note that the numerical differentiation requires: (a) tightly or even very tightly converged SCF calculations and (b)
carefully chosen field increments. If the field increment is too large then the truncation error will be large and the
values will be unreliable. On the other hand, if the field increment is too small the numerical error associated with
the finite difference differentiation will get unacceptably large up to the point where the whole calculation becomes
useless.

**7.51.2 The Spin-Orbit Coupling Operator**

Several variants of spin-orbit coupling operators can be used for property calculations [611]. They are based on
effective potential and mean-field approaches, and have various parameters that can be selected via the `%rel` block.
Note that the SOMF operator depends on the density matrix, so the operator itself can differ for example between
a CASSCF and an MRCI calculation.

**Note** : The defaults have slightly changed in ORCA 5.0, see `SOCFlags` in the following.



(continues on next page)

**1032** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
        # disk; similar to SOCType=4
       3 # mean-field/effective potential (default)
       4 # mean-field with atomic densities generated
        # on the fly; see bellow
   # --------------------------------------------------   # Flags for construction of potential; operative
   # only for SOCType 3.
   # --------------------------------------------------   SOCFlags 1,4,3,0 # default if nothing is specified
            # 1,3,3,0 default if RI is applied and AuxJ available
            # e.g. when using !RIJCOSX (default for DFT) or !RIJONX
   # Flag 1 = 0 - do not include 1-electron terms
   # = 1 - do include 1-electron terms
   # Flag 2 = 0 - do not include Coulomb terms
   # = 1 - compute Coulomb terms fully numeric
   # = 2 - compute Coulomb term seminumeric
   # = 3 - compute Coulomb term with RI approx
   # = 4 - compute Coulomb term exactly
   # Flag 3 = 0 - do not include exchange terms
   # = 1 - do include local X-alpha exchange
   # the X-Alpha parameter can be chosen via
   # % rel Xalpha 0.7 (default)
   # = 2 - same as 1 but with sign reversed
   # = 3 - exchange via one-center exact
   # integrals including the spin-other
   # orbit interaction
   # = 4 - all exchange terms full analytic
   # (this is expensive)
   # Flag 4 = 0 - do not include DFT local correlation
   # terms
   # = 1 - do include local DFT correlation (here
   # this is done with VWN5)
   #
   SOCMaxCenter 4 # max. number of centers to include in
          # the integrals (not fully consistently
          # implemented yet; better leave equal to 4)
   # The following simple input equivalents can also be used:
   # SOMF(1X) = SOCType 3, SOCFlags 1,2,3,0 and SOCMaxCenter 4
   # RI-SOMF(1X) = SOCType 3, SOCFlags 1,3,3,0 and SOCMaxCenter 4
   # VEFF-SOC = SOCType 3, SOCFlags 1,3,1,1 and SOCMaxCenter 4
   # VEFF(-2X)-SOC = SOCType 3, SOCFlags 1,3,2,1 and SOCMaxCenter 4
   # AMFI = SOCType 3, SOCFlags 1,4,3,0 and SOCMaxCenter 1
   # AMFI-A = SOCType 4, SOCFlags 1,4,3,0 and SOCMaxCenter 1
   # (AMFI-like approach that uses pre-calculated atomic densities;
   # this can be combined with the SOCOff option
   # to exclude contributions from specific atoms)
   # NOTE: If you choose the RI option you need to specify an auxiliary basis set
   # even if the underlying SCF calculation does not make use of any form
   # of RI!
   # ----------------------------------------------   # For the effective nuclear charge SOC operator
   # the nuclear charges can be adjusted.
   # ----------------------------------------------   Zeff[26] 0.0 # set the effective nuclear charge
          # of iron (Z = 26) to zero
   # ----------------------------------------------   # Neglecting SOC contributions from particular
   # atoms
   # ----------------------------------------------   SOCOff 0,5 # turn off the SOC for atoms 0 and 5
          # this makes sense if the SOC operator

```
(continues on next page)

**7.51. Calculation of Properties** **1033**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

*̸*

*̸*


Simple input equivalents are described in more detail in [611]. More details on the AMFI-A approach which uses
pre-calculated atomic densities can be found in [284].

The Breit-Pauli spin-orbit coupling operator is given by:

*𝐻* ˆ SOC = ˆ *𝐻* SOC [(1)] [+ ˆ] *[𝐻]* SOC [(2)]

with the one- and two-electron contributions

*̸*

*̸*


*𝐻* ˆ SOC [(1)] [=] *[𝛼]* 2 [2]

*̸*

*̸*


∑︁

*𝑖*

*̸*

*̸*


∑︁

*̸*

*̸*


( **r** *𝑖* *−* **R** *𝐴* ) *×* **p** *𝑖*
*𝑍* *𝐴*
*𝐴* *|* **r** *𝑖* *−* **R** *𝐴* *|* [3]

*̸*

*̸*


*−* **R** *𝐴* ) *×* **p** *𝑖* ˆ

*𝑠* *𝑖* *≡* *[𝛼]* [2]
*|* **r** *𝑖* *−* **R** *𝐴* *|* [3] 2

*̸*

*̸*


2

*̸*

*̸*


∑︁ *𝑍* *𝐴* *𝑟* *𝑖𝐴* *[−]* [3] **[^l]** *[𝑖𝐴]* **[^s]** *[𝑖]* (7.344)

*𝐴*

*̸*

*̸*


∑︁

*𝑖*

*̸*

*̸*


*𝐻* ˆ SOC [(2)] [=] *[ −]* *[𝛼]* 2 [2]

*̸*

*̸*


∑︁

*𝑖* *̸*

*̸*


∑︁

*𝑗* = *̸* *𝑖*

*̸*


*̸* ( **r** *𝑖* *|* **r** *−* *𝑖* *−* **r** *𝑗* **r** ) *×* *𝑗* *|* [3] **p** *𝑖* ( **^s** *𝑖* + 2 **^s** *𝑗* ) (7.345)

*̸*


*̸*

*≡−* *[𝛼]* [2]

2

*̸*


*̸*

∑︁

*𝑖* *̸*


*̸*

∑︁ **^l** *𝑖𝑗* *𝑟* *𝑖𝑗* *[−]* [3] [(] **[^s]** *[𝑖]* [+ 2] **[^s]** *[𝑗]* [)] (7.346)

*𝑗* = *̸* *𝑖*


*̸*

*̸*

This operator would be hard to handle exactly; therefore it is common to introduce mean field and/or effective
potential approaches in which the operator is written as an effective one-electron operator:

ˆ
*𝐻* SOC *∼* = ∑︁ **^h** [(] *𝑖* [eff][)] **^s** *𝑖* (7.347)

*𝑖*

The simplest approximation is to simply use the one-electron part and regard the nuclear charges as adjustable
parameters. Reducing their values from the exact nuclear charge is supposed to account in an average way for the
screening of the nuclear charge by the electrons. In our code we use the effective nuclear charges of Koseki et
al. This approximation introduces errors which are usually smaller than 10% but sometimes are larger and may
approach 20% in some cases. The approximation is best for first row main group elements and the first transition
row (2p and 3d elements). For heavier elements it becomes unreliable.

A much better approximation is to take the two-electron terms into account precisely. Without going into details
here – the situation is as in Hartree-Fock (or density functional) theory and one gets Coulomb, exchange and correlation terms. The correlation terms (evaluated in a local DFT fashion) are negligible and can be safely neglected.
They are optionally included and are not expensive computationally. The Coulomb terms is (after the one-electron
term) the second largest contribution and is expensive to evaluate exactly. The situation is such that in the Coulombpart the spin-other orbit interaction (the second term in the two-electron part) does not contribute and one only has
to deal with the spin-own-orbit contribution. The exact evaluation is usually too expensive to evaluate. The RI and
seminumeric approximation are much more efficient and introduce only minimal errors (on the order of usually
not more than 1 ppm in g-tensor calculations for example) and are therefore recommended. The RI approximation
is computationally more efficient. Please note that you have to specify an auxiliary basis set to take advantage of
the RI approximation, even if the preceding SCF calculation does not make use of any form of RI. The one-center
approximation to the Coulomb term introduces much larger errors. The fully numeric method is both slower and
less accurate and is not recommended.

The exchange term has contributions from both the spin-own-orbit and spin-other-orbit interaction. These are
taken both into account in the mean-field approximation which is accessed by `Flag 3 = 3` . Here a one-center
approximation is much better than for the Coulomb term since both the integrals and the density matrix elements
are short ranged. Together with the Coulomb term this gives a very accurate SOC operator which is recommended.
The DFT-Veff operator suffers from not treating the spin-other-orbit part in the exchange which gives significant
errors (also, local DFT underestimates the exchange contributions from the spin-same-orbit interaction by some
10% relative to HF but this is not a major source of error). However, it is interesting to observe that in the precise
analytical evaluation of the SOMF operator, the spin-other-orbit interaction is exactly -2 times the spin-own-orbit
interation. Thus, in the DFT framework one gets a *much* better SOC operator if the sign of the DFT exchange term
is simply reversed! This is accessed by `Flag 3 = 2` .

**1034** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**Exclusion of Atomic Centers**

In ORCA it is possible to change the spin-orbit coupling operator in order to exclude contributions from userdefined atoms. This approach can be useful, for example, in quantifying the contribution of the ligands to the
zero-field splitting (ZFS); for an application of this method see Ref. [835].

This is illustrated for the calculation of the SOC contribution to the ZFS of the triplet oxygen molecule. Using the
input below we start by a normal calculation of the ZFS, including both oxygen atoms. Note that we use here the
effective nuclear charge operator. This is required as not all implemented SOC operators are compatible with the
decomposition in terms of individual centers contributions.



The calculated value of the D parameter is approximately 2.573 cm *[−]* [1] . In a second calculation we exclude the
contribution from the first oxygen atom. For this we change the `%rel` block to the one below.



Now the D parameter is calculated to be approximately 0.643 cm *[−]* [1], a result that deviates quite significantly from
half of the value calculated previously, implying that non-additive effects are important. In addition to the effective
nuclear charge operator, the AMFI-A operator described previously can be used. Given that this is based on precalculated atomic densities, it might be preferred for heavier elements where the effective nuclear charge operator
becomes unreliable. The method is not limited to CASSCF calculations as described above, and can be used in
DFT, MRCI and ROCIS calculations.

**7.51.3 EPR and NMR properties**

Calculation of EPR and NMR response properties can be requested in the `%eprnmr` input block. The individual
flags are given below.



(continues on next page)

**7.51. Calculation of Properties** **1035**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
 DSOC qro # quasi-restricted method; must be done with the keyword !uno
     pk # Pederson-Khanna method.
         # NOTE: both approximations are only valid for
         # pure functionals (no HF exchange)
     cp # coupled-perturbed method (default)
     cvw # van W\"ullen method
 DSS direct # directly use the canonical orbitals for the spin density
     uno # use spin density from UNOs
 PrintLevel n # Amount of output (default 2)
 # whether to calculate and print the Euler angles via �orca_euler� if the
 # calculation of the g-tensor or the D-tensor is requested
 PrintEuler false
 # For the solution of the CP-SCF equations:
 Solver Pople # Pople solver (default)
      CG # conjugate gradient
      DIIS # DIIS type solver
 MaxIter 64 # maximum number of iterations
 MaxDIIS 10 # max. number of DIIS vectors (only DIIS)
 Tol 1e-3 # convergence tolerance
 LevelShift 0.05 # level shift for DIIS (ignored otherwise)
 Ori CenterOfElCharge # center of electronic charge
     CenterOfNucCharge # center of nuclear charge
     CenterOfSpinDens # center of spin density
     CenterOfMass # center of mass
     GIAO # use the GIAO formalism (default)
     N # number of the atom to put the origin
     X,Y,Z # explicit position of the origin
               # in coordinate input units (Angstrom by default)
 # Calculate the NMR shielding tensor
 NMRShielding 1 # for chosen nuclei - specified with the Nuclei keyword
        2 # for all nuclei - equivalent to the 'NMR' simple input keyword
 # treatment of 1-electron integrals in the RHS of the CPSCF equations
 giao_1el = giao_1el_analytic # analytical, default
       giao_1el_numeric # numerical - for testing only
 # treatment of 2-electron integrals in the RHS of the CPSCF equations
 # various options for combination of approximations in Coulomb (J) and
 # exact (HF) exchange (K) part. The default is the same as used for the SCF.
 giao_2el = giao_2el_rijk # RIJK approximation
       giao_2el_same_as_scf # use same scheme as in SCF
       giao_2el_analytic # fully analytical, for testing only
       giao_2el_rijonx # RIJ approximation with analytical K
       giao_2el_cosjonx # COSJ approximation with analytical K
       giao_2el_rijcosx # RIJ approximation with COSX approximation
       giao_2el_cosjx # COSJ approximation with COSX apprxomation
       giao_2el_exactjcosx # exact J with COSX approximation
       giao_2el_exactjrik # exact J with RIK approximation
 # for g-tensor calculations using the SOMF-operator for the SOC
 # treatment, the 2-electron contribution to the GIAO terms can be
 # computed as well, but they take much more time and usually do not
 # contribute significantly and therefore are disabled by default
 do_giao_soc2el false
 # treatment of tau in meta-GGA DFT - see below

```
(continues on next page)

**1036** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
 Tau = Dobson # (default) Other options: 0, MS, GI
 # use effective nuclear charges for the gauge correction to the A-tensor
 # (this makes sense if an effective 1-electron SOC operator is used)
 hfcgaugecorrection_zeff true
 # calculate diamagnetic spin-orbit (DSO) integrals needed for the gauge
 # correction to the A-tensor numerically (faster than the analytical way)
 hfcgaugecorrection_numeric true
 # Grid settings for the above: <0 means to use the DFT grid setting
 hfcgaugecorrection_angulargrid -1
 hfcgaugecorrection_intacc -1
 hfcgaugecorrection_prunegrid -1
 hfcgaugecorrection_bfcutoff -1
 hfcgaugecorrection_wcutoff -1
 Nuclei = all type { flags }
  # Calculate nuclear properties. Here the properties
  # for all nuclei of "type" are calculated ("type" is
  # an element name, for example Cu.)
  # Flags can be the following:
  # aiso - calculate the isotropic part of the HFC
  # adip - calculate the dipolar part of the HFC
  # aorb - 2nd order contribution to the HFC from SOC
  # fgrad - calculate the electric field gradient
  # rho - calculate the electron density at the
  # nucleus
  # shift - NMR shielding tensor (orbital contribution)
  # srot - spin-rotation tensor
  # ssdso - spin-spin coupling constants, diamagnetic spin orbit term
  # sspso - spin-spin coupling constants, paramagnetic spin orbit term
  # ssfc - spin-spin coupling constants, Fermi contact term
  # sssd - spin-spin coupling constants, spin dipole term
  # ssall - spin-spin coupling constants, calculate all above contributions
 # In addition you can change several parameters
 # e.g. for a different isotope.
 Nuclei = all N { PPP=39.1, QQQ=0.5, III=1.0 };
   # PPP - the HFC proportionality factor for this nucleus
   # = ge*gN*betaE*betaN
   # QQQ - the quadrupole moment for this nucleus
   # III - the spin for this nucleus
   # ist - isotope
   # ssgn - nuclear g-factor for spin-spin coupling
   # and spin-rotation constants (overrides ist)
 # For example:
 # calculates the hyperfine coupling for all nitrogen atoms
 Nuclei = all N { aiso, adip, fgrad, rho};
 # calculates the spin-spin coupling constants for all carbon atoms
 # assuming all carbon atoms are 13C
 Nuclei = all C { ssall, ist = 13};
 # You can also calculate properties for individual atoms
 # as in the following example:
 Nuclei = 1,5,8 { aiso, adip};
 # NOTE: Counting starts with atom 1!
 # WARNING: All the nuclei, mentioned in one line

```
(continues on next page)

**7.51. Calculation of Properties** **1037**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



**Hyperfine and Quadrupole Couplings**

The hyperfine coupling has four contributions:

(a) The isotropic Fermi contact term that arises from the finite spin density on the nucleus under investigation. It
is calculated for nucleus *𝑁* from:

4
*𝑎* iso ( *𝑁* ) = *𝑔* *𝑒* *𝑔* *𝑁* *𝛽* *𝑒* *𝛽* *𝑁* *𝜌* *⃗𝑅* *𝑁* (7.348)
(︂ 3 *[𝜋]* *[⟨][𝑆]* *[𝑧]* *[⟩]* *[−]* [1] )︂ (︁ )︁

Here, *⟨𝑆* *𝑧* *⟩* is the expectation value of the z-component of the total spin, *𝑔* *𝑒* and *𝑔* *𝑁* are the electron and nuclear

g-factors and *𝛽* *𝑒* and *𝛽* *𝑁* are the electron and nuclear magnetons respectively. *𝜌* *⃗𝑅* *𝑁* is the spin density at the
(︁ )︁

nucleus. The proportionality factor *𝑃* *𝑁* = *𝑔* *𝑒* *𝑔* *𝑁* *𝛽* *𝑒* *𝛽* *𝑁* is commonly used and has the dimensions MHz bohr [3] in
ORCA.

(b) The spin dipole part that arises from the magnetic dipole interaction of the magnetic nucleus with the magnetic
moment of the electron. It is also calculated as an expectation value over the spin density as:

*𝐴* [dip] *𝜇𝜈* [(] *[𝑁]* [) =] *[ 𝑃]* *[𝑁]* ∑︁ *𝑘𝑙𝜌* *𝑘𝑙* ⟨︀ *𝜑* *𝑘* ⃒⃒ *𝑟* *𝑁−* 5 (︀3 *⃗𝑟* *𝑁𝜇* *⃗𝑟* *𝑁𝜈* *−* *𝛿* *𝜇𝜈* *𝑟* *𝑁* [2] )︀⃒⃒ *𝜑* *𝑙* ⟩︀ (7.349)

where *𝜌* is the spin-density matrix and *⃗𝑟* *𝑁* is a vector of magnitude *𝑟* *𝑁* that points from the nucleus in question to
the electron ( *{𝜑}* is the set of basis functions).

(c) The second order contribution that arises from spin-orbit coupling. Presently ORCA can calculate all these
contributions. The first two are calculated as simple expectation values of the appropriate operators over the selfconsistent spin density, but the second order contribution requires the solution of the coupled-perturbed SCF equations and is consequently computationally more demanding. The contribution can be written:


*𝐴* [orb]
*𝜇𝜈* [(] *[𝑁]* [) =] *[ −]* 2 [1] *𝑆* *[𝑃]* *[𝑁]* ∑︁

*𝑘𝑙*


*𝜕* *𝜌* *𝑘𝑙*

*𝜕𝐼* *𝜈*


⟨︀ *𝜑* *𝑘* ⃒⃒ *ℎ* SOC *𝜇* ⃒⃒ *𝜑* *𝑙* ⟩︀ (7.350)


The derivative of the spin density is computed from solving the coupled-perturbed SCF equations with respect to
the nucleus-orbit coupling as perturbation. The nucleus-orbit coupling is represented by the operator

*ℎ* [NOC] *𝜈* ( *𝐴* ) = ∑︁ *𝑟* *𝑖𝐴* *[−]* [3] *[𝑙]* *𝑖,𝜈* [(] *[𝐴]* [)] (7.351)

*𝑖*

**1038** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

where the sum is over electrons and *𝐴* is the nucleus in question.

(d) The gauge-correction contribution.[492] This term is often small. However, it is needed in order to get exactly
gauge-invariant results. We recently showed that the gauge correction can become crucial in the long-distance limit
between the nuclear spin and the electron spin. This is relevant for pseudocontact NMR chemical shifts (PCS).[492]

The **field gradient tensor** is closely related to the dipole contribution to the hyperfine coupling. The main differences are that the electron instead of the spin density enters its calculation and that it contains a nuclear contribution
due to the surrounding nuclei. It is calculated from

*̸*



[∑︀] *𝑃* *𝑘𝑙* ⟨︀ *𝜑* *𝑘* ⃒⃒ *𝑟* *𝑁−* 5 (︀3 *⃗𝑟* *𝑁𝜇* *⃗𝑟* *𝑁𝜈* *−* *𝛿* *𝜇𝜈* *𝑟* *𝑁* [2] )︀⃒⃒ *𝜑* *𝑙* ⟩︀

*𝑘𝑙*

*̸*


*𝑉* *𝜇𝜈* ( *𝑁* ) = *−* [∑︀]

*̸*



[∑︀] *𝑍* *𝐴* *𝑅* *[⃗]* *𝐴𝑁* *[−]* [5] 3 *𝑅* *[⃗]* *𝐴𝑁𝜇* *𝑅* *[⃗]* *𝐴𝑁𝜈* *−* *𝛿* *𝜇𝜈* *𝑅* *𝐴𝑁* [2] (7.352)

*𝐴* = *̸* *𝑁* (︁ )︁


+ [∑︀]

*̸*


*̸*

with *𝑍* *𝐴* as the nuclear charge of nucleus *𝐴* and *𝑅* *[⃗]* *𝐴𝑁* as a vector of magnitude *𝑅* *𝐴𝑁* that points from nucleus *𝐴*
to nucleus *𝑁* . **P** is the first order density matrix.

NOTE:

  - Hyperfine and quadrupole couplings are properties where the standard basis sets that have been designed for
geometry optimization and the like may not be entirely satisfactory (especially for atoms heavier than Ne).
You should probably look into tailoring the basis set according to your needs. While it is likely that a later
release will provide one or two special basis sets for “core-property” calculations at this time you have to
make sure yourself that the basis set has enough flexibility in the core region, for example by uncontracting
core basis functions and adding s-primitives with large exponents (or using the “decontraction feature”,
section *Choice of Basis Set* ). If you add these tight functions and use DFT make sure that the numerical
integration is still satisfactory. Use the “SpecialGrid” feature to enlarge grids for individual atoms without
increasing the computational effort too drastically.

  - For heavy nuclei you may want to consider the possibility of relativistic effects. Scalar relativistic effects
can be handled with several quasi-relativistic Hamiltonians in ORCA, an overview of the possibilities and
some recommendations can be found in *Relativistic Calculations* . Note that relativistic calculations may have
special requirements on basis sets, and in the context of property calculations, you should be especially aware
of the importance of using picture change corrections (see *Relativistic Calculations* and *Picture-Change*
*Effects* ). In quasi-relativistic calculations with DFT, one should also be very cautious about accuracy of the
numerical integration, especially for heavier (transition metal) nuclei.

Second order HFCs require the calculation of the spin-orbit coupling contributions which in turn requires the
calculation of the coupled perturbed SCF equations. These effects can be quite significant for heavier nuclei and
should definitely be included for transition metal complexes. The spin-orbit coupling treatment used is the same
as described under *The Spin-Orbit Coupling Operator* .

**The g-Tensor**

The EPR g-tensor is a property that can be calculated as a second derivative of the energy and it is implemented as
such in ORCA for the SCF methods—e.g. HF and DFT—, CASSCF, as well as all-electron MP2 (or RI-MP2) and
double-hybrid DFT. The following four contributions arise for the g-tensor (SZ = spin Zeeman, RMC = relativistic
mass correction, DSO = diamagnetic spin-orbit correction, PSO = orbital Zeeman/SOC term):

*𝑔* *𝜇𝜈* [(][SZ][)] = *𝛿* *𝜇𝜈* *𝑔* *𝑒* (7.353)


*̸*

*𝑔* *𝜇𝜈* [(][RMC][)] = *−* *[𝛼]* 2 [2] *𝑆* *[𝑔]* *[𝑒]*


*̸*

∑︁ *𝑃* *𝑘𝑙* *[𝛼][−][𝛽]* ⟨ *𝜑* *𝑘* ⃒⃒⃒ *𝑇* ˆ⃒⃒⃒ *𝜑* *𝑙* ⟩ (7.354)

*𝑘,𝑙*


*̸*

*𝑔* *𝜇𝜈* [(][DSO][)] = *[𝛼]* 4 [2] *𝑆* *[𝑔]* *[𝑒]*


*̸*

*𝑃* *[𝛼][−][𝛽]*

∑︁ *𝑘𝑙*

*𝑘,𝑙*


*̸*

*𝜉* ( *𝑟* *𝐴* ) [ **r** *𝐴* **r** *𝑂* *−* **r** *𝐴,𝜇* **r** *𝑂,𝜈* ]

*𝐴*


*̸*

*𝜑* *𝑘*

⟨


*̸*

⃒⃒⃒⃒⃒


*̸*

∑︁


*̸*

*𝜑* *𝑙*
⃒⃒⃒⃒⃒


*̸*

⟩


*̸*

(7.355)


*̸*

*𝑔* *𝜇𝜈* [(][PSO][)] = *−* 2 *[𝑔]* *𝑆* *[𝑒]*


*̸*

∑︁ *𝑘,𝑙* *𝜕𝑃𝜕𝐵* *𝑘𝑙* *[𝛼][−]* *𝜇* *[𝛽]*


*̸*

⟨︀ *𝜑* *𝑘* ⃒⃒ *ℎ* SOC *𝜈* ⃒⃒ *𝜑* *𝑙* ⟩︀ (7.356)


*̸*

**7.51. Calculation of Properties** **1039**

**ORCA Manual** **,** **Release 6.0.1**

Here, *𝑔* *𝑒* is the free-electron g-value (=2.002319...), *𝑆* is the total spin, *𝛼* the fine structure constant, *𝑃* *[𝛼][−][𝛽]* is the
spin density matrix, *𝜑* is the basis set, *𝑇* [ˆ] is the kinetic energy operator, *𝜉* ( *𝑟* *𝐴* ) an approximate radial operator, *ℎ* [SOC]

the spatial part of an effective one-electron spin-orbit operator and *𝐵* *𝜇* is a component of the magnetic field. The
calculation of the derivative of the spin-density depends on the chosen level of theory. For the SCF-level it is done
based on the coupled-perturbed SCF theory with respect to a magnetic field perturbation.

**Accuracy.** g-tensor calculations at the SCF level are not highly demanding in terms of basis set size. Basis sets
that give reliable SCF results (at least valence double-zeta plus polarization) usually also give reliable g-tensor
results. For many molecules the Hartree-Fock approximation will give reasonable predictions. In a number of
cases, however, it breaks down completely. DFT is more robust in this respect and the number of molecules where
it fails is much smaller. Among the density functionals, the hybrid functionals seem to be the most accurate. In my
hands PBE0 is perhaps the best although PWP1 and B3LYP are not much worse. The GGA functionals such as BP,
PW91, BLYP or PBE are equally good for small radicals but are significantly inferior to their hybrid counterparts
for transition metal complexes.

**Gauge dependence.** Unfortunately, the g-tensor is a gauge dependent property, i.e. the results depend on where the
origin is chosen within the molecule. Unless fully invariant procedures (such as GIAOs) are used, this undesirable
aspect is always present in the calculations. GIAOs are now available for calculations on the SCF-level in ORCA.
However, if the choice of gauge origin is not outrageously poor, the gauge dependence is usually so small that it
can be ignored for all practical purposes, especially if large basis sets are used. ORCA gives you considerable
freedom in the choice of gauge origin. It can either be the center of mass, the center of nuclear charge, the center of
electronic charge, GIAOs (recommended if available), a special atom or a user-defined point in space. It is wise to
check the sensitivity of the results with respect to the choice of origin, especially when small g-shifts on the order
of only a few hundred ppm are calculated.

**Spin-orbit coupling operator.** In previous versions of the code, the g-tensor module used the parameterization
of Koseki *et al.* [462, 463, 464] for the spin-orbit operator. This is expected to be a reasonable approximation
for the 2p and 3d elements and less satisfactory for heavier main group or transition metal containing systems.
Thus, the main target molecules with the simple operators are radicals made of light atoms and first row transition
metal complexes. More accurate SOC operators (at only moderately increased computational cost) have now been
implemented and are described in section *The Spin-Orbit Coupling Operator* . With these operators there are
fewer restrictions. However, for very heavy elements they will suffer from the shortcomings of the Breit-Pauli
approximation and future releases will modify these operators to take into account the ZORA or DKH corrections
to the SOC.

**Zero-Field-Splitting**

It is well known that the ZFS consists of a first order term arising from the direct spin-spin interaction[364]:

*̸*


⃒⃒⃒⃒⃒⃒ *̸*


0 *𝑆𝑆*

*̸* ⃒⃒⃒⃒⃒⃒


*̸* ⟩


(7.357)

*̸*


*𝛼* [2]

2 *𝑆* *𝑆*

*̸*


*𝐷* *𝐾𝐿* [(][SS][)] [= 1]

*̸*


*𝑆* (2 *𝑆* *−* 1)

*̸*


∑︁

*𝑗* = *̸* *𝑖*


*𝑟* *𝑖* [2] *𝑗* *[𝛿]* *[𝐾𝐿]* *[−]* [3 (] **[r]** *[𝑖𝑗]* [)] *𝐾* [(] **[r]** *[𝑖𝑗]* [)] *𝐿* *{* 2ˆ *𝑠* *𝑧𝑖* *𝑠* ˆ *𝑧𝑗* *−* *𝑠* ˆ *𝑥𝑖* *𝑠* ˆ *𝑥𝑗* *−* *𝑠* ˆ *𝑦𝑖* *𝑠* ˆ *𝑦𝑗* *}*

*𝑟* [5]

*̸* *𝑖𝑗*


*𝑟* *𝑖* [2] *𝑗* *[𝛿]* *[𝐾𝐿]* *[−]* [3 (] **[r]** *[𝑖𝑗]* [)] *𝐾* [(] **[r]** *[𝑖𝑗]* [)] *𝐿*

*̸*


0 *𝑆𝑆*

⟨ *̸*


⟨ *̸*


∑︁

*𝑖* *̸*


*̸*

( *𝐾*, *𝐿* =x,y,z). Here *𝛼* is the fine structure constant ( *≈* 1/137 in atomic units), **r** *𝑖𝑗* is the electronic distance vector
with magnitude *𝑟* *𝑖𝑗* and ˆ *𝑠* *𝑖* is the spin-vector operator for the *𝑖* ’th electron. *|* 0 *𝑆𝑆⟩* is the exact ground state eigenfunction of the Born-Oppenheimer Hamiltonian with total spin *𝑆* and projection quantum number *𝑀* *𝑆* = *𝑆* . Since
the spin-spin interaction is of first order, it presents no particular difficulties. The more complicated contribution to
the **D** -tensor arises from the spin-orbit interaction, which gives a second order contribution. Under the assumption
that the spin-orbit coupling (SOC) operator can to a good approximation be represented by an effective one-electron
operator ( *𝐻* [ˆ] SOC = [∑︀] *𝑖* **[^h]** *𝑖* [SOC] **^s** *𝑖* ), ref [622] has derived the following sum-over-states (SOS) equations for the SOC
contribution to the ZFS tensor:


*̸*

*𝐷* *𝐾𝐿* [SOC] *[−]* [(0)] = *−* [1]


*̸*

∆ *[−]* [1]

∑︁ *𝑏*

*𝑏* ( *𝑆* *𝑏* = *𝑆* )


*̸*

(7.358)


*̸*

0 *𝑆𝑆*
⃒⃒⃒⃒⃒ ⟩


*̸*

*𝑏* *𝑆𝑆* *𝑏* *[𝑆𝑆]*
⃒⃒⃒⃒⃒ ⟩⟨ ⃒⃒⃒⃒⃒


*̸*

∑︁ *ℎ* ˆ *[𝐿]* *𝑖* [;][SOC] *𝑠* ˆ *𝑖,* 0

*𝑖*


*̸*

*𝑆* [2] ∑︁


*̸*

0 *[𝑆𝑆]*

⟨ ⃒⃒⃒⃒⃒


*̸*

∑︁ *ℎ* ˆ *[𝐾]* *𝑖* [;][SOC] *𝑠* ˆ *𝑖,* 0

*𝑖*


*̸*

∑︁


*̸*

1
*𝐷* *𝐾𝐿* [SOC] *[−]* [(] *[−]* [1)] = *−* *𝑆* (2 *𝑆* *−* 1)


*̸*

∆ *[−]* [1]

∑︁ *𝑏*

*𝑏* ( *𝑆* *𝑏* = *𝑆−* 1)


*̸*

0 *𝑆𝑆*
⃒⃒⃒⃒⃒ ⟩


*̸*

0 *[𝑆𝑆]*

⟨ ⃒⃒⃒⃒⃒


*̸*

∑︁ *ℎ* ˆ *[𝐾]* *𝑖* [;][SOC] *𝑠* ˆ *𝑖,* +1

*𝑖*


*̸*

*𝑏* *𝑆−* 1 *𝑆−* 1 *𝑏* *[𝑆][−]* [1] *[𝑆][−]* [1]
⃒⃒⃒⃒⃒ ⟩⟨ ⃒⃒⃒⃒⃒


*̸*

ˆ ˆ

∑︁ *ℎ* *[𝐿]* *𝑖* [;][SOC] *𝑠* *𝑖,−* 1

*𝑖*


*̸*

(7.359)

**1040** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


*𝐷* *𝐾𝐿* [SOC] *[−]* [(+1)] = *−* ( *𝑆* +1)(2 1 *𝑆* +1) *[·]*
∑︀ ∆ *[−]* *𝑏* [1]

*𝑏* ( *𝑆* *𝑏* = *𝑆* +1)


ˆ ˆ

0 *[𝑆𝑆]* ∑︀ *ℎ* *[𝐾]* *𝑖* [;][SOC] *𝑠* *𝑖,−* 1
⟨ ⃒⃒⃒⃒ *𝑖*


0 *[𝑆𝑆]* ∑︀
⟨ ⃒⃒⃒⃒ *𝑖*


*𝑏* *𝑆* +1 *𝑆* +1 *𝑏* *[𝑆]* [+1] *[𝑆]* [+1] ∑︀ *ℎ* ˆ *[𝐿]* *𝑖* [;][SOC] *𝑠* ˆ *𝑖,* +1
⃒⃒⃒⃒ ⟩⟨ ⃒⃒⃒⃒ *𝑖*


0 *𝑆𝑆* (7.360)
⃒⃒⃒⃒ ⟩


Here the one-electron spin-operator for electron *𝑖* has been written in terms of spherical vector operator components
*𝑠* *𝑖,𝑚* with *𝑚* = 0 *, ±* 1 and ∆ *𝑏* = *𝐸* *𝑏* *−* *𝐸* 0 is the excitation energy to the excited state multiplet ⃒⃒ *𝑏* *𝑆𝑆* ⟩︀ (all *𝑀* *𝑆*
components are degenerate at the level of the BO Hamiltonian).

One attractive possibility is to represent the SOC by the spin-orbit mean-field (SOMF) method developed by Hess
et al.,[390] widely used in the AMFI program by Schimmelpfennig [762] and discussed in detail by Berning et
al.[97] as well as in ref. [611]. In terms of an (orthonormal) one-electron basis, the matrix elements of the SOMF

operator are:


*ℎ* *[𝐾]* *𝑟𝑠* [;][SOC] = *𝑝* *ℎ* ˆ 1 *𝐾𝑒𝑙−* SOC *𝑞*
( ⃒⃒⃒ ⃒⃒⃒ )︁



[3] ˆ SOC (7.361)

2 (︀ *𝑠𝑞* ⃒⃒ *𝑔* *𝐾* ⃒⃒ *𝑝𝑟* )︀]︀



[∑︀] *𝑃* *𝑟𝑠* [︀(︀ *𝑝𝑞* ⃒⃒ *𝑔* ˆ *𝐾* SOC ⃒⃒ *𝑟𝑠* )︀ *−* [3] 2

*𝑟𝑠*


+ [∑︀]



[3] ˆ SOC *−* [3]

2 (︀ *𝑝𝑟* ⃒⃒ *𝑔* *𝐾* ⃒⃒ *𝑠𝑞* )︀ 2


and:


ˆ
*ℎ* *𝑘* [1] *[𝑒𝑙][−]* [SOC] ( **r** *𝑖* ) = *[𝛼]* 2 [2]


∑︁

*𝑖*


∑︁ *𝑍* *𝐴* *𝑟* *𝑖𝐴* *[−]* [3] **[^l]** *[𝑖𝐴]* [;] *[𝑘]* (7.362)

*𝐴*


*𝑔* ˆ *𝑘* [SOC] ( **r** *𝑖,* **r** *𝑗* ) = *−* *[𝛼]* 2 [2] **^l** *𝑖𝑗* ; *𝑘* *𝑟* *𝑖𝑗* *[−]* [3] (7.363)


**^l** *𝑖𝐴* = ( **^r** *𝑖* *−* **R** *𝐴* ) *×* **^p** *𝑖* is the angular momentum of the *𝑖* ’th electron relative to nucleus *𝐴* . The vector **^r** *𝑖𝐴* =
**^r** *𝑖* *−* **R** *𝐴* of magnitude *𝑟* *𝑖𝐴* is the position of the *𝑖* ’th electron relative to atom *𝐴* . Likewise, the vector **^r** *𝑖𝑗* =
**^r** *𝑖* *−* **^r** *𝑗* of magnitude *𝑟* *𝑖𝑗* is the position of the *𝑖* th electron relative to electron *𝑗* and **[^]** **l** *𝑖𝑗* = ( **^r** *𝑖* *−* **^r** *𝑗* ) *×* **^p** *𝑖* is its
angular momentum relative to this electron. **P** is the charge density matrix of the electron ground state ( *𝑃* *𝑝𝑞* =
⟨︀0 *𝑆𝑆* ⃒⃒ *𝐸* *𝑞𝑝* ⃒⃒ 0 *𝑆𝑆* ⟩︀with *𝐸* *𝑞* *[𝑝]* [=] *[ 𝑎]* [+] *𝑝𝛽* *[𝑎]* *[𝑞𝛽]* [+] *[ 𝑎]* *𝑝𝛼* [+] *[𝑎]* *[𝑞𝛼]* [where] *[ 𝑎]* [+] *𝑝𝜎* [and] *[ 𝑎]* *[𝑞𝜎]* [are the usual Fermion creation and annihilation]
operators).

**General Treatment of ZFS**

The zero-field splitting (ZFS) is typically the leading term in the Spin-Hamiltonian (SH) for transition metal complexes with a total ground state spin *𝑆* >1/2 (for reviews and references see chapter *Publications Related to ORCA* ).
Its net effect is to introduce a splitting of the 2 *𝑆* + 1 *𝑀* *𝑆* levels (which are exactly degenerate at the level of the
Born-Oppenheimer Hamiltonian), even in the absence of an external magnetic field. Thus, an analysis and interpretation of the ZFS is imperative if the information content of the various physical methods that are sensitive to
ZFS effects.

In 2007, we have developed a procedure that makes the ZFS calculation compatible with the language of analytic
derivatives.[614] Perhaps the most transparent route is to start from the exact solutions of the Born-Oppenheimer
Hamiltonian. To this end, we look at the second derivative of the ground state energy ( *𝐸* = 0 *[𝑆𝑆]* [⃒⃒] *𝐻* 0 *𝑆𝑆* ) with
⟨ ⃒ [ˆ] ⃒⃒⃒ ⟩
respect to a spin-dependent one-electron operator of the general form:

ˆ
*ℎ* *[𝐾]* [;(] *[𝑚]* [)] = *𝑥* [(] *𝐾* *[𝑚]* [)] ∑︁ *ℎ* *[𝐾]* *𝑝𝑞* *[𝑆]* [ˆ] *𝑝𝑞* [(] *[𝑚]* [)] (7.364)

*𝑝𝑞*

Where *ℎ* *[𝐾]*
*𝑝𝑞* [is the matrix of the] *[ 𝐾]* [’th component of the spatial part of the operator (assumed to be imaginary]

Hermitian as is the case for the spatial components of the SOC operator) and *𝑆* [ˆ] *𝑝𝑞* [(] *[𝑚]* [)] is the second quantized form
of the spin vector operator ( *𝑚* = 0 *, ±* 1). The quantity *𝑥* [(] *𝐾* *[𝑚]* [)] is a formal perturbation parameter. Using the exact
eigenfunctions of the BO operator, the first derivative is:


*𝜕𝐸*

*𝜕𝑥* [(] *𝐾* *[𝑚]* [)]


= *ℎ* *[𝐾]*
∑︁ *𝑝𝑞* *[𝑃]* *𝑝𝑞* [(] *[𝑚]* [)] (7.365)
⃒⃒⃒⃒⃒ *𝑥* [(] *𝐾* *[𝑚]* [)] =0 *𝑝𝑞*


With the components of the spin density:

*𝑃* *𝑝𝑞* [(] *[𝑚]* [)] = ⟨ 0 *[𝑆𝑆]* *|𝑆* [ˆ] *𝑝𝑞* [(] *[𝑚]* [)] *[|]* [0] *[𝑆𝑆]* [⟩] (7.366)

**7.51. Calculation of Properties** **1041**

**ORCA Manual** **,** **Release 6.0.1**

The second derivative with respect to a second component for *𝑚* *[′]* = *−𝑚* is:

*̸*

*̸*

︁


*𝜕* [2] *𝐸*

*𝜕𝑥* [(] *𝐾* *[𝑚]* [)] *[𝜕𝑥]* *𝐿* [(] *[−][𝑚]* [)]

*̸*

*̸*

︁


= *ℎ* *[𝐾]* *𝜕𝑃* *𝑝𝑞* [(] *[𝑚]* [)]
∑︁ *𝑝𝑞* (7.367)
⃒⃒⃒⃒⃒ *𝑥* [(] *𝐾* *[𝑚]* [)] = *𝑥* [(] *𝐿* *[−][𝑚]* [)] =0 *𝑝𝑞* *𝑥* [(] *𝐿* *[−][𝑚]* [)]

*̸*

*̸*

︁


The derivative of the spin density may be written as:

*𝜕𝑃𝑥* [(] *𝐿* *[−]* *𝑝𝑞* [(] *[𝑚][𝑚]* [)][)] = ⟨0 *[𝑆𝑆]* *𝐿* [(] *[−][𝑚]* [)] *|𝑆* [ˆ] *𝑝𝑞* [(] *[𝑚]* [)] *[|]* [0] *[𝑆𝑆]* [⟩] + ⟨0 *[𝑆𝑆]* *|𝑆* [ˆ] *𝑝𝑞* [(] *[𝑚]* [)] *[|]* [0] *[𝑆𝑆]* *𝐿* [(] *[−][𝑚]* [)] ⟩ (7.368)

Expanding the perturbed wavefunction in terms of the unperturbed states gives to first order:

⃒⃒⃒0 *𝑆𝑆𝐿* ( *−𝑚* ) ⟩ = *−* ∑︁ *𝑛* = 0∆ *̸* *[−]* *𝑛* [1] *[|][𝑛][⟩]* ⟨ *𝑛* ⃒⃒⃒ *ℎ* ˆ *𝐿* ;( *−𝑚* ) ⃒⃒⃒ 0 *𝑆𝑆* ⟩ (7.369)

Where *|𝑛⟩* is any of the *𝑏* *𝑆* *′* *𝑀* *′* . Thus, one gets:
⃒⃒⃒ ⟩

*̸*

︁


*̸*

*𝜕* [2] *𝐸*

*̸*

︁


*̸*

*ℎ* *[𝐾]* *𝑝𝑞* *𝜕𝑃* *𝑝𝑞* [(] *[𝑚]* [)] (7.370)
*𝑝𝑞* *𝑥* [(] *𝐿* *[−][𝑚]* [)]

*̸*

︁


*̸*

=
∑︁
*𝜕𝑥* [(] *𝐾* *[𝑚]* [)] *[𝜕𝑥]* [(] *𝐿* *[−][𝑚]* [)] *𝑝𝑞*

*̸*

︁


*̸*

= *−* ∑︁ ∆ *[−]* *𝑛* [1] [︁⟨0 *[𝑆𝑆]* *|ℎ* [ˆ] *[𝐿]* [;(] *[−][𝑚]* [)] *|𝑛* ⟩⟨ *𝑛|ℎ* [ˆ] *[𝐾]* [;(] *[𝑚]* [)] *|* 0 *[𝑆𝑆]* [⟩] + ⟨0 *[𝑆𝑆]* *|ℎ* [ˆ] *[𝐾]* [;(] *[𝑚]* [)] *|𝑛* ⟩⟨ *𝑛|ℎ* [ˆ] *[𝐿]* [;(] *[−][𝑚]* [)] *|* 0 *[𝑆𝑆]* [⟩]︁]

*𝑛* =0 *̸*

︁


*̸*

*̸*

(7.371)

The equality holds for exact states. For approximate electronic structure treatments, the analytic derivative approach
is more attractive since an infinite sum over states can never be performed in practice and the calculation of analytic
derivative is computationally less demanding than the calculation of excited many electron states.

Using eq. (7.370), the components of the SOC-contribution to the **D** -tensor are reformulated as

*𝐷* *𝐾𝐿* [SOC] *[−]* [(0)] = 2 *𝑆* 1 [2] ∑︁ *𝑝𝑞* *ℎ* *[𝐾]* *𝑝𝑞* [;][SOC] *𝜕𝑃𝜕𝑥* *𝑝𝑞* [(0)] *𝐿* [(0)] (7.372)

︁


*̸*

*̸*

1
*𝐷* *𝐾𝐿* [SOC] *[−]* [(] *[−]* [1)] = *𝑆* (2 *𝑆* *−* 1)

︁


*̸*

*̸*

∑︁ *ℎ* *[𝐾]* *𝑝𝑞* [;][SOC] *𝜕𝑃* *𝑝𝑞* [(+1)] (7.373)

*𝑝𝑞* *𝜕𝑥* [(] *𝐿* *[−]* [1)]

︁


*̸*

*̸*

1
*𝐷* *𝐾𝐿* [SOC] *[−]* [(+1)] = ( *𝑆* + 1) (2 *𝑆* + 1)

︁


*̸*

*̸*

∑︁ *ℎ* *[𝐾]* *𝑝𝑞* [;][SOC] *𝜕𝑃* *𝑝𝑞* [(] *[−]* [1)] (7.374)

*𝑝𝑞* *𝜕𝑥* [(+1)] *𝐿*

︁


*̸*

*̸*

These are general equations that can be applied together with any non-relativistic or scalar relativistic electronic
structure method that can be cast in second quantized form. Below, the formalism is applied to the case of a
self-consistent field (HF, DFT) reference state.

For DFT or HF ground states, the equations are further developed as follows:

The SCF energy is:

︁


*̸*

*̸*

*𝐸* SCF = *𝑉* NN + ⟨︀ **Ph** [+] [⟩︀] + [1]

2

︁


*̸*

*̸*

*𝜌* ( **r** 1 ) *𝜌* ( **r** 2 )
∫︁∫︁ *|* **r** 1 *−* **r** 2 *|*

︁


*̸*

*̸*

( **r** 1 ) *𝜌* ( **r** 2 )

*|* **r** 1 *−* **r** 2 *|* *[𝑑]* **[r]** [1] *[𝑑]* **[r]** [2] *[ −]* [1] 2

︁


*̸*

*̸*

2 *[𝑎]* [X] ∑︁

︁


*̸*

*̸*

∑︁ *𝑃* *𝜇𝜅* *[𝜎]* *[𝑃]* *𝜈𝜏* *[𝜎]* [(] *[𝜇𝜈][|][𝜅𝜏]* [) +] *[ 𝑐]* [DF] *[𝐸]* [XC] [[] *[𝜌]* *[𝛼]* *[, 𝜌]* *[𝛽]* []]

*𝜇𝜈𝜅𝜏𝜎*

︁


*̸*

*̸*

(7.375)

Here *𝑉* NN is the nuclear repulsion energy and *ℎ* *𝜇𝜈* is a matrix element of the one-electron operator which contains
the kinetic energy and electron-nuclear attraction terms ( *⟨* **ab** *⟩* denotes the trace of the matrix product **ab** ). As
usual, the molecular spin-orbitals *𝜓* *𝑝* *[𝜎]* [are expanded in atom centered basis functions (] *[𝜎]* [=] *[ 𝛼, 𝛽]* [)][:]

*𝜓* *𝑝* *[𝜎]* [(] **[r]** [) =] ∑︁ *𝑐* *[𝜎]* *𝜇𝑝* *[𝜑]* *[𝜇]* [(] **[r]** [)] (7.376)

*𝜇*

with MO coefficients *𝑐* *[𝜎]* *𝜇𝑝* [. The two-electron integrals are defined as:]

︁
( *𝜇𝜈|𝜅𝜏* ) = *𝜑* *𝜇* ( **r** 1 ) *𝜑* *𝜈* ( **r** 1 ) *𝑟* 12 *[−]* [1] *[𝜑]* *[𝜅]* [(] **[r]** [2] [)] *[ 𝜑]* *[𝜏]* [(] **[r]** [2] [)] *[ 𝑑]* **[r]** [1] *[𝑑]* **[r]** [2] (7.377)
∫ ∫

**1042** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

The mixing parameter *𝑎* X controls the fraction of Hartree-Fock exchange and is of a semi-empirical nature.
*𝐸* XC [ *𝜌* *𝛼* *, 𝜌* *𝛽* ] represent the exchange-correlation energy. The parameter *𝑐* DF is an overall scaling factor that allows one to proceed from Hartree-Fock theory ( *𝑎* X = 1 *, 𝑐* DF = 0) to pure DFT ( *𝑎* X = 0 *, 𝑐* DF = 1) to hybrid DFT
(0 *< 𝑎* X *<* 1 *, 𝑐* DF = 1). The orbitals satisfy the spin-unrestricted SCF equations:

*𝐹* *𝜇𝜈* *[𝜎]* [=] *[ ℎ]* *[𝜇𝜈]* [+] ∑︁ *𝑃* *𝜅𝜏* ( *𝜇𝜈|𝜅𝜏* ) *−* *𝑎* X *𝑃* *𝜅𝜏* *[𝜎]* [(] *[𝜇𝜅][|][𝜈𝜏]* [) +] *[ 𝑐]* [DF] [(] *[𝜇][|][𝑉]* *𝑋𝐶* *[𝛼]* *[|][𝜈]* [)] (7.378)

*𝜅𝜏*

With *𝑉* *𝑋𝐶* *[𝜎]* [=] *𝛿𝜌* *𝛿𝐸* *𝜎* *𝑋𝐶* ( **r** ) [and] *[ 𝑃]* *[𝜇𝜈]* [=] *[ 𝑃]* *𝜇𝜈* *[𝛼]* [+] *[ 𝑃]* *𝜇𝜈* *[𝛽]* [being the total electron density. For the SOC perturbation it is]
customary to regard the basis set as perturbation independent. In a spin-unrestricted treatment, the first derivative

is:


*𝜕𝐸* SCF

=
∑︁
*𝜕𝑥* [(] *𝐾* *[𝑚]* [)] *𝑖* *𝛼*


(︀ *𝑖* *𝛼* *|ℎ* *[𝐾]* *𝑠* *𝑚* *|𝑖* *𝛼* )︀ + ∑︁

*𝑖* *𝛽*


(︀ *𝑖* *𝛽* *|ℎ* *[𝐾]* *𝑠* *𝑚* *|𝑖* *𝛽* )︀ = 0 (7.379)


For the second derivative, the perturbed orbitals are required. However, in the presence of a spin-dependent perturbation they can no longer be taken as pure spin-up or spin-down orbitals. With respect to the *𝐿* ’th component
of the perturbation for spin-component *𝑚*, the orbitals are expanded as:


*𝜓* *𝑖* *[𝛼]* [;(] *[𝑚]* [)] *[𝐿]* ( **r** ) = ∑︁


∑︁ *𝑈* *𝑎* [(] *[𝑚]* *𝛼* *𝑖* [);] *𝛼* *[𝐿]* *[𝜓]* *𝑎* *[𝛼]* [(] **[r]** [) +] ∑︁

*𝑎* *𝛼* *𝑎*


∑︁ *𝑈* *𝑎* [(] *[𝑚]* *𝛽* *𝑖* [);] *𝛼* *[𝐿]* *[𝜓]* *𝑎* *[𝛽]* [(] **[r]** [)] (7.380)

*𝑎* *𝛽*


∑︁ *𝑈* *𝑎* [(] *[𝑚]* *𝛼* *𝑖* [);] *𝛽* *[𝐿]* *[𝜓]* *𝑎* *[𝛼]* [(] **[r]** [) +] ∑︁

*𝑎* *𝛼* *𝑎*


*𝜓* *𝑖* *[𝛽]* [;(] *[𝑚]* [)] *[𝐿]* ( **r** ) = ∑︁


∑︁ *𝑈* *𝑎* [(] *[𝑚]* *𝛽* *𝑖* [);] *𝛽* *[𝐿]* *[𝜓]* *𝑎* *[𝛽]* [(] **[r]** [)] (7.381)

*𝑎* *𝛽*


Since the matrix elements of the spin-vector operator components are purely real and the spatial part of the SOC
operator has purely imaginary matrix elements, it follows that the first order coefficients are purely imaginary. The
second derivative of the total SCF energy becomes:


*𝜕* [2] *𝐸* SCF

=
∑︁
*𝜕𝑥* [(] *𝐾* *[𝑚]* [)] *[𝜕𝑥]* [(] *𝐿* *[−][𝑚]* [)] *𝑖* *𝛼* *𝑎* *𝛼*

+
∑︁

*𝑖* *𝛼* *𝑎* *𝛽*

+
∑︁

*𝑖* *𝛽* *𝑎* *𝛼*

+
∑︁

*𝑖* *𝛽* *𝑎* *𝛽*


{︁ *𝑈* *𝑎* [(] *[−]* *𝛼* *𝑖* *[𝑚]* *𝛼* [);] *[𝐿][*]* (︀ *𝑎* *𝛼* *|ℎ* *[𝐾]* *𝑠* *𝑚* *|𝑖* *𝛼* )︀ + *𝑈* *𝑎* [(] *[−]* *𝛼* *𝑖* *[𝑚]* *𝛼* [);] *[𝐿]* (︀ *𝑖* *𝛼* *|ℎ* *[𝐾]* *𝑠* *𝑚* *|𝑎* *𝛼* )︀ [}︁]

{︁ *𝑈* *𝑎* [(] *[−]* *𝛽* *𝑖* *[𝑚]* *𝛼* [);] *[𝐿][*]* (︀ *𝑎* *𝛽* *|ℎ* *[𝐾]* *𝑠* *𝑚* *|𝑖* *𝛼* )︀ + *𝑈* *𝑎* [(] *[−]* *𝛽* *𝑖* *[𝑚]* *𝛼* [);] *[𝐿]* (︀ *𝑖* *𝛼* *|ℎ* *[𝐾]* *𝑠* *𝑚* *|𝑎* *𝛽* )︀ [}︁]

{︁ *𝑈* *𝑎* [(] *[−]* *𝛼* *𝑖* *[𝑚]* *𝛽* [);] *[𝐿][*]* (︀ *𝑎* *𝛼* *|ℎ* *[𝐾]* *𝑠* *𝑚* *|𝑖* *𝛽* )︀ + *𝑈* *𝑎* [(] *[−]* *𝛼* *𝑖* *[𝑚]* *𝛽* [);] *[𝐿]* (︀ *𝑖* *𝛽* *|ℎ* *[𝐾]* *𝑠* *𝑚* *|𝑎* *𝛼* )︀ [}︁]

{︁ *𝑈* *𝑎* [(] *[−]* *𝛽* *𝑖* *[𝑚]* *𝛽* [);] *[𝐿][*]* (︀ *𝑎* *𝛽* *|ℎ* *[𝐾]* *𝑠* *𝑚* *|𝑖* *𝛽* )︀ + *𝑈* *𝑎* [(] *[−]* *𝛽* *𝑖* *[𝑚]* *𝛽* [);] *[𝐿]* (︀ *𝑖* *𝛽* *|ℎ* *[𝐾]* *𝑠* *𝑚* *|𝑎* *𝛽* )︀ [}︁]


(7.382)


Examination of the three cases *𝑚* = 0 *, ±* 1 leads to the following equations for the **D** -tensor components:


*𝐷* *𝐾𝐿* [(0)] [=] *[ −]* 4 *𝑆* [1] [2] ∑︁

*𝜇𝜈*


*𝜕𝑃* *𝜇* [(0)] *𝜈*
*𝜕𝑥* [(0)] *𝐿*


1
*𝐷* *𝐾𝐿* [(+1)] [=]
2 ( *𝑆* + 1) (2 *𝑆* + 1)


∑︁

*𝜇𝜈*


(︀ *𝜇|ℎ* *[𝐾]* [;][SOC] *|𝜈* )︀ (7.383)

*𝜕𝑃* *𝜇* [(] *[−]* *𝜈* [1)]
(︀ *𝜇|ℎ* *[𝐾]* [;][SOC] *|𝜈* )︀ (7.384)
*𝜕𝑥* [(+1)] *𝐿*


1
*𝐷* *𝐾𝐿* [(] *[−]* [1)] [=] 2 *𝑆* (2 *𝑆* *−* 1)


∑︁

*𝜇𝜈*


*𝜕𝑃* *𝜇* [(+1)] *𝜈*
(︀ *𝜇|ℎ* *[𝐾]* [;][SOC] *|𝜈* )︀ (7.385)
*𝜕𝑥* [(] *𝐿* *[−]* [1)]


Where a special form of the perturbed densities has been chosen. They are given in the atomic orbital basis as:


*𝜕𝑃* *𝜇* [(0)] *𝜈* =
∑︁
*𝜕𝑥* [(0)] *𝐿* *𝑖* *𝑎*


∑︁ *𝑈* *𝑎* [(0);] *𝛽* *𝑖* *𝛽* *[𝐿]* *[𝑐]* *𝜇𝑖* *[𝛽]* *[𝑐]* *𝜈𝑎* *[𝛽]* (7.386)

*𝑖* *𝛽* *𝑎* *𝛽*


∑︁ *𝑈* *𝑎* [(0);] *𝛼* *𝑖* *𝛼* *[𝐿]* *[𝑐]* *[𝛼]* *𝜇𝑖* *[𝑐]* *𝜈𝑎* *[𝛼]* [+] ∑︁

*𝑖* *𝛼* *𝑎* *𝛼* *𝑖* *𝑎*


*𝜕𝑃* *𝜇* [(+1)] *𝜈* =
∑︁
*𝜕𝑥* [(] *𝐿* *[−]* [1)] *𝑖* *𝑎*


∑︁ *𝑈* *𝑎* [(] *[−]* *𝛼* *𝑖* [1);] *𝛽* *[𝐿]* *𝑐* *[𝛼]* *𝜇𝑎* *[𝑐]* *𝜈𝑖* *[𝛽]* (7.387)

*𝑖* *𝛽* *𝑎* *𝛼*


∑︁ *𝑈* *𝑎* [(] *[−]* *𝛽* *𝑖* [1);] *𝛼* *[𝐿]* *𝑐* *[𝛼]* *𝜇𝑖* *[𝑐]* *𝜈𝑎* *[𝛽]* *[−]* ∑︁

*𝑖* *𝛼* *𝑎* *𝛽* *𝑖* *𝛽* *𝑎* *𝛼*


**7.51. Calculation of Properties** **1043**

**ORCA Manual** **,** **Release 6.0.1**


*𝜕𝑃* *𝜇* [(] *[−]* *𝜈* [1)] = *−*
∑︁
*𝜕𝑥* [(+1)] *𝐿* *𝑖* *𝑎*


∑︁ *𝑈* *𝑎* [(+1);] *𝛼* *𝑖* *𝛽* *[𝐿]* *𝑐* *[𝛽]* *𝜇𝑖* *[𝑐]* *𝜈𝑎* *[𝛼]* (7.388)

*𝑖* *𝛽* *𝑎* *𝛼*


∑︁ *𝑈* *𝑎* [(+1);] *𝛽* *𝑖* *𝛼* *[𝐿]* *𝑐* *[𝛽]* *𝜇𝑎* *[𝑐]* *𝜈𝑖* *[𝛼]* [+] ∑︁

*𝑖* *𝛼* *𝑎* *𝛽* *𝑖* *𝛽* *𝑎* *𝛼*


The special form of the coupled perturbed equations are implemented in ORCArun as follows: The perturbation is
of the general form *ℎ* *[𝐾]* *𝑠* ˆ *𝑚* . The equations (7.383)-(7.388) and (7.389)-(7.394) below have been written in such a
way that the spin integration has been performed but that the spin-dependent factors have been dropped from the
right-hand sides and included in the prefactors of eqs. (7.383)-(7.385). The explicit forms of the linear equations
to be solved are:

*𝑚* = 0:

(︁ *𝜀* [(0)] *𝑎* *𝛼* *[−]* *[𝜀]* *𝑖* [(0)] *𝛼* )︁ *𝑈* *𝑎* *[𝐾]* *𝛼* [(0)] *𝑖* *𝛼* [+] *[ 𝑎]* [X] ∑︁ *𝑈* *𝑏* *[𝐾]* *𝛼* [(] *𝑗* *[𝑚]* *𝛼* [)] *[{]* [(] *[𝑏]* *[𝛼]* *[𝑖]* *[𝛼]* *[|][𝑎]* *[𝛼]* *[𝑗]* *[𝛼]* [)] *[ −]* [(] *[𝑗]* *[𝛼]* *[𝑖]* *[𝛼]* *[|][𝑎]* *[𝛼]* *[𝑏]* *[𝛼]* [)] *[}]* [ =] *[ −]* (︀ *𝑎* *𝛼* *|ℎ* *[𝐾]* *|𝑖* *𝛼* )︀ (7.389)

*𝑗* *𝛼* *𝑏* *𝛼*

(︁ *𝜀* [(0)] *𝑎* *𝛽* *[−]* *[𝜀]* *𝑖* [(0)] *𝛽* )︁ *𝑈* *𝑎* *[𝐾]* *𝛽* [(0)] *𝑖* *𝛽* [+] *[ 𝑎]* [X] ∑︁ *𝑈* *𝑏* *[𝐾]* *𝛽* *𝑗* [(] *[𝑚]* *𝛽* [)] *{* ( *𝑏* *𝛽* *𝑖* *𝛽* *|𝑎* *𝛽* *𝑗* *𝛽* ) *−* ( *𝑗* *𝛽* *𝑖* *𝛽* *|𝑎* *𝛽* *𝑏* *𝛽* ) *}* = *−* (︀ *𝑎* *𝛽* *|ℎ* *[𝐾]* *|𝑖* *𝛽* )︀ (7.390)

*𝑗* *𝛽* *𝑏* *𝛽*


*𝑚* = +1:

(︁ *𝜀* [(0)] *𝑎* *𝛼* *[−]* *[𝜀]* *𝑖* [(0)] *𝛽* )︁ *𝑈* *𝑎* *[𝐾]* *𝛼* [(+1)] *𝑖* *𝛽* + *𝑎* X ∑︁


∑︁ *𝑈* *𝑏* *[𝐾]* *𝛽* *𝑗* [(+1)] *𝛼* ( *𝑗* *𝛽* *𝑖* *𝛽* *|𝑎* *𝛼* *𝑏* *𝛼* ) = *−* (︀ *𝑎* *𝛼* *|ℎ* *[𝐾]* *|𝑖* *𝛽* )︀ (7.391)

*𝑏* *𝛼* *𝑗* *𝛽*


∑︁ *𝑈* *𝑏* *[𝐾]* *𝛽* *𝑗* [(+1)] *𝛼* ( *𝑏* *𝛽* *𝑖* *𝛽* *|𝑎* *𝛼* *𝑗* *𝛼* ) *−* *𝑎* X ∑︁

*𝑗* *𝛼* *𝑏* *𝛼* *𝑏* *𝛼* *𝑗*


(︁ *𝜀* [(0)] *𝑎* *𝛽* *[−]* *[𝜀]* *𝑖* [(0)] *𝛼* )︁ *𝑈* *𝑎* *[𝐾]* *𝛽* [(+1)] *𝑖* *𝛼* + *𝑎* X ∑︁


∑︁ *𝑈* *𝑏* *[𝐾]* *𝛽* *𝑗* [(+1)] *𝛼* ( *𝑗* *𝛼* *𝑖* *𝛼* *|𝑎* *𝛽* *𝑏* *𝛽* ) = 0 (7.392)

*𝑏* *𝛽* *𝑗* *𝛼*


∑︁ *𝑈* *𝑏* *[𝐾]* *𝛼* [(+1)] *𝑗* *𝛽* ( *𝑏* *𝛼* *𝑖* *𝛼* *|𝑎* *𝑏* *𝑗* *𝛽* ) *−* *𝑎* X ∑︁

*𝑗* *𝛽* *𝑏* *𝛼* *𝑏* *𝛽* *𝑗* *𝛼*


*𝑚* = *−* 1:

(︁ *𝜀* [(0)] *𝑎* *𝛽* *[−]* *[𝜀]* *𝑖* [(0)] *𝛼* )︁ *𝑈* *𝑎* *[𝐾]* *𝛽* [(] *𝑖* *[−]* *𝛼* [1)] + *𝑎* X ∑︁


∑︁ *𝑈* *𝑏* *[𝐾]* *𝛽* *𝑗* [(] *[−]* *𝛼* [1)] ( *𝑗* *𝛼* *𝑖* *𝛼* *|𝑎* *𝛽* *𝑏* *𝛽* ) = *−* (︀ *𝑎* *𝛽* *|ℎ* *[𝐾]* *|𝑖* *𝛼* )︀ (7.393)

*𝑏* *𝛽* *𝑗* *𝛼*


∑︁ *𝑈* *𝑏* *[𝐾]* *𝛼* [(] *𝑗* *[−]* *𝛽* [1)] ( *𝑏* *𝛼* *𝑖* *𝛼* *|𝑎* *𝑏* *𝑗* *𝛽* ) *−* *𝑎* X ∑︁

*𝑗* *𝛽* *𝑏* *𝛼* *𝑏* *𝛽* *𝑗* *𝛼*


(︁ *𝜀* [(0)] *𝑎* *𝛼* *[−]* *[𝜀]* *𝑖* [(0)] *𝛽* )︁ *𝑈* *𝑎* *[𝐾]* *𝛼* [(] *𝑖* *[−]* *𝛽* [1)] + *𝑎* X ∑︁


∑︁ *𝑈* *𝑏* *[𝐾]* *𝛽* *𝑗* [(] *[−]* *𝛼* [1)] ( *𝑗* *𝛽* *𝑖* *𝛽* *|𝑎* *𝛼* *𝑏* *𝛼* ) = 0 (7.394)

*𝑏* *𝛼* *𝑗* *𝛽*


∑︁ *𝑈* *𝑏* *[𝐾]* *𝛽* *𝑗* [(] *[−]* *𝛼* [1)] ( *𝑏* *𝛽* *𝑖* *𝛽* *|𝑎* *𝛼* *𝑗* *𝛼* ) *−* *𝑎* X ∑︁

*𝑗* *𝛼* *𝑏* *𝛼* *𝑏* *𝛼* *𝑗*


Note that these coupled-perturbed (CP) equations contain no contribution from the Coulomb potential or any other
local potential such as the exchange-correlation potential in DFT. Hence, in the absence of HF exchange, the
equations are trivially solved:


( *𝑎* *𝛼* *|* *ℎ* *[𝐾]* *|* *𝑖* *𝛼* )

(7.395)
*𝜀* [(0)] *𝑎* *𝛼* *[−]* *[𝜀]* [(0)] *𝑖* *𝛼*


*𝑈* *𝑎* *[𝐾]* *𝛼* [(0)] *𝑖* *𝛼* [=] *[ −]*

*𝑈* *𝑎* *[𝐾]* *𝛽* [(0)] *𝑖* *𝛽* [=] *[ −]*


( *𝑎* *𝛽* *|* *ℎ* *[𝐾]* *|* *𝑖* *𝛽* )

(7.396)
*𝜀* [(0)] *𝑎* *𝛽* *[−]* *[𝜀]* *𝑖* [(0)] *𝛽*


*𝑈* *𝑎* *[𝐾]* *𝛼* [(+1)] *𝑖* *𝛽* = *−*


( *𝑎* *𝛼* *|* *ℎ* *[𝐾]* *|* *𝑖* *𝛽* )

(7.397)
*𝜀* [(0)] *𝑎* *𝛼* *[−]* *[𝜀]* [(0)] *𝑖* *𝛽*


*𝑈* *𝑎* *[𝐾]* *𝛽* [(+1)] *𝑖* *𝛼* = 0 (7.398)


*𝑈* *𝑎* *[𝐾]* *𝛽* [(] *𝑖* *[−]* *𝛼* [1)] = *−*


( *𝑎* *𝛽* *|* *ℎ* *[𝐾]* *|* *𝑖* *𝛼* )

(7.399)
*𝜀* [(0)] *𝑎* *𝛽* *[−]* *[𝜀]* *𝑖* [(0)] *𝛼*


*𝑈* *𝑎* *[𝐾]* *𝛼* [(] *𝑖* *[−]* *𝛽* [1)] = 0 (7.400)

It is interesting that the “reverse spin flip coefficients” *𝑈* *𝑎* *[𝐾]* *𝛽* [(+1)] *𝑖* *𝛼* and *𝑈* *𝑎* *[𝐾]* *𝛼* [(] *𝑖* *[−]* *𝛽* [1)] are only nonzero in the presence of
HF exchange. In a perturbation expansion of the CP equations they arise at second order (V [2] /∆ *𝜀* [2] ) while the
other coefficients are of first order (V/∆ *𝜀* ; V represents the matrix elements of the perturbation). Hence, these
contributions are of the order of *𝛼* [4] and one could conceive dropping them from the treatment in order to stay
consistently at the level of *𝛼* [2] . These terms were nevertheless kept in the present treatment.

Equations (7.389)-(7.394) are referred to as CP-SOC (coupled-perturbed spin-orbit coupling) equations. They can
be solved by standard techniques and represent the desired analogue of the CP-SCF magnetic response equations
solved for the determination of the g-tensor and discussed in detail earlier [664]. It is readily confirmed that

**1044** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

in the absence of HF exchange, eqs. (7.395)-(7.400) inserted into eqs. (7.383)-(7.388) lead back to a modified
Pederson-Khanna type treatment of the SOC contributions to the **D** -tensor [662]. In the framework of the formalism
developed above, the Pederson-Khanna formula can be re-written in the form:


1
*𝐷* *𝐾𝐿* [(][SOC][;][PK][)] = 4 *𝑆* [2] ∑︁

*𝑖* *𝛽* *,𝑎* *𝛽*


(︁ *𝜓* *𝑖* *[𝛽]* ⃒⃒ *ℎ* *𝐾* ;SOC ⃒⃒ *𝜓* *𝑎𝛽* )︁ *𝑈* *𝑎* *[𝐿]* *𝛽* [;(0)] *𝑖* *𝛽* [+] 4 *𝑆* 1 [2] ∑︁

*𝑖* *𝛼* *,𝑎* *𝛼*


(7.401)


(︀ *𝜓* *𝑖* *[𝛼]* ⃒⃒ *ℎ* *𝐾* ;SOC ⃒⃒ *𝜓* *𝑎𝛼* )︀ *𝑈* *𝑎* *[𝐿]* *𝛼* [;(0)] *𝑖* *𝛼*


*−* [1]

4 *𝑆* [2] ∑︁

*𝑖* *𝛼* *,𝑎* *𝛽*


(︀ *𝜓* *𝑖* *[𝛼]* ⃒⃒ *ℎ* *𝐾* ;SOC ⃒⃒ *𝜓* *𝑎𝛽* )︀ *𝑈* *𝑎* *[𝐿]* *𝛽* [;(] *𝑖* *𝛼* *[−]* [1)] *−* 4 *𝑆* 1 [2] ∑︁

*𝑖* *𝛽* *,𝑎* *𝛼*


(︀ *𝜓* *𝑖* *[𝛼]* ⃒⃒ *ℎ* *𝐾* ;SOC ⃒⃒ *𝜓* *𝑎𝛼* )︀ *𝑈* *𝑎* *[𝐿]* *𝛼* [;(+1)] *𝑖* *𝛽*


This equation was derived from second-order non-self-consistent perturbation theory without recourse to spincoupling. For the special case of no Hartree-Fock exchange, the main difference to the treatment presented here
is that the correct prefactors from eqs. (7.372)-(7.374) occur in front of the spin-flip contributions rather than *±*
1/(4 *𝑆* [2] ) in eq. (7.401). In the presence of HF exchange it is suggested that the consistent generalization of the PK
method are eqs. (7.383)-(7.385) with the *±* 1/(4 *𝑆* [2] ) prefactors and this way the method has been implemented as
an option into the ORCA program.

For completeness, the evaluation of the spin-spin term in the SCF case proceeds conveniently through:


*𝐷* *𝐾𝐿* [(][SS][)] [=] *[𝑔]* 4 *𝑒* [2] *𝑆* (2 *𝛼𝑆* [2] *−* 1)


∑︁

*𝜇𝜈*


∑︁

*𝜅𝜏*


{︀ *𝑃* *𝜇𝜈* *[𝛼][−][𝛽]* *𝑃* *𝜅𝜏* *[𝛼][−][𝛽]* *−* *𝑃* *𝜇𝜅* *[𝛼][−][𝛽]* *𝑃* *𝜈𝜏* *[𝛼][−][𝛽]* }︀⟨︀ *𝜇𝜈* ⃒⃒ *𝑟* 12 *−* 5 {︀3 *𝑟* 12 *,𝐾* *𝑟* 12 *,𝐿* *−* *𝛿* *𝐾𝐿* *𝑟* 12 [2] }︀⃒⃒ *𝜅𝜏* ⟩︀

(7.402)


as derived by McWeeny and Mizuno and discussed in some detail by Sinnecker and Neese.[800] In this reference it
was found that DFT methods tend to overestimate the spin-spin contribution if the calculations are based on a spinunrestricted SCF treatment. A much better correlation with experiment was found for open-shell spin restricted
calculations. The origin of this effect proved to be difficult to understand but it was shown in ref [354] that in the
case of small spin-contamination, the results of ROKS calculations and of those that are obtained on the basis of
the spin-unrestricted natural orbital (UNO) determinant are virtually indistinguishable. It is therefore optionally
possible in the ORCA program to calculate the spin-spin term on the basis of the UNO determinant.

**Spin-rotation constants**

Spin-rotation constant calculations are implemented using perturbation-dependent atomic orbitals following [290].
As given in eq. 34 of that reference, the spin-rotation tensor of nucleus *𝐾*, **M** *𝐾*, is related to the nuclear shielding
tensor computed with GIAOs, ***𝜎*** [GIAO] *𝐾*, and the diamagnetic part of the shielding tensor with the gauge origin set at
that nucleus, ***𝜎*** [dia] *𝐾* [(] **[R]** *[𝐾]* [)][:]

**M** *𝐾* = 2 *𝛾* *𝐾* (︀ ***𝜎*** [GIAO] *𝐾* *−* ***𝜎*** [dia] *𝐾* [(] **[R]** *[𝐾]* [)] )︀ **I** *[−]* [1] *−* **M** [nuc] *𝐾*

where **M** [nuc] *𝐾* [is the nuclear component (given in eq. 14 of the reference),] **[ I]** [ is the inertia tensor, and] *[ 𝛾]* *[𝐾]* [is the nu-]
clear magnetogyric ratio. Accordingly, upon requesting spin-rotation constants, ORCA automatically computes the
NMR shieldings with GIAOs as well. The following input shows an example calculation of **M** ( [17] O) in H 2 [12] C [17] O:



**Note:**

  - The magnetogyric ratio used can be changed either by choosing the correct isotope via `ist`, or by providing
the nuclear g-factor directly via `ssgn` .

**7.51. Calculation of Properties** **1045**

**ORCA Manual** **,** **Release 6.0.1**

  - The masses used to compute the inertia tensor are independent of the chosen isotopes! The example above
requests atomic masses of the most abundant isotope (via the `Mass2016` keyword) and explicitly specifies
those of [12] C (which is the default) and [17] O.

**Cartesian Index Conventions for EPR and NMR Tensors**

The NMR shielding tensor ***𝜎*** and the EPR *𝑔* and *𝐴* tensors are in general nonsymmetric matrices. It is therefore
important to know the conventions used with regard to their cartesian indices. These conventions stipulate the
order of the vector–matrix–vector multiplications in the respective spin Hamiltonians. Unless stated otherwise,
ORCA adopts the following conventions:

For the NMR shielding tensor the nuclear Zeeman Hamiltonian assumes the form:

*𝐻* *𝐼* = *−𝑔* *𝑁* *𝛽* *𝑁* **B** ( **1** *−* ***𝜎*** ) **I** *,*

where **B** is the applied magnetic field vector.

For the EPR *𝑔* and *𝐴* tensors the EPR spin Hamiltonian assumes the form:

*𝐻* *𝑆* = *𝛽* *𝑒* **BgS** + **SAI** *.* (7.403)

**MP2 level magnetic properties**

Presently, hyperfine couplings (excluding the *𝐴* orb term), g-tensors, and shielding tensors without GIAOs can be
calculated for both canonical and RI-MP2 and double-hybrid DFT without the frozen core approximation. The
*𝐴* orb term of the hyperfine couplings is available only for RI-MP2 and double-hybrid DFT with and without frozen
core approximation. In case the RIJCOSX approximation is used, the keywords `Z_GridX`, `Z_GridX_RHS`, `KCOpt`,
`KC_GridX` and `KC_IntAccX` are relevant – see sections *RIJCOSX-RI-MP2 Gradients* and *MP2 and RI-MP2 Second*

*Derivatives* . NMR shielding and g-tensor calculations with GIAOs are available for RI-MP2 and double-hybrid
DFT with or without a frozen core. The implementation is described in detail in refs [829, 850] and the available
options are shown in section *RI-MP2 and Double-Hybrid DFT Response Properties* . Note that for double-hybrid
DFT the correct properties are printed after the density heading containing “Method : MP2” and “Level : Relaxed
density”. DLPNO-MP2 (and double-hybrid) shielding tensors are also available - see section *Local MP2 Response*
*Properties* .

**Nucleus-independent chemical shielding**

Aromaticity is a fundamental concept in chemistry and much attention has been payed to its analysis in quantum
chemistry. One possibility to gain insight into aromaticity is to sample the ring current effect in NMR close to the *𝜋* system. As this is not done by inspecting the chemical shielding of any of the atoms, this quantity is called nucleus
independent chemical shielding (NICS). Usually, a “dummy” atom is placed in the center of the ring and/or at some
distance away from it. In ORCA, one needs to use a ghost atom, e.g. “ `H:` ” to ensure that the program generates
DFT or COSX grid points in the region on interest. For technical reasons, this atom must also have at least one
basis function, which can be set with `NewGTO` . An s-function with a sufficiently large exponent will not overlap with
any other basis function in the molecule and will thus have no effect on the results, but only satisfy the technical
requirement (note that the extra grid points may change some of the calculation results by increasing the accuracy
of the numerical integration). If RI is used, a dummy fitting function must also be added to the AuxJ, AuxJK,
and/or AuxC basis set. A typical input for benzene looks like this:



(continues on next page)

**1046** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

*̸*

*̸*


**Shielding tensor orbital decomposition**

It is possible to decompose the NMR shielding tensor into orbital- or orbital pair contributions. One such option is
the Natural Chemical Shielding analysis (see Section *Natural Chemical Shielding Analysis (NCS)* ), while another
is presented here. The shielding tensor for nucleus *𝐴* can be exactly decomposed as follows:

*̸*

*̸*


***𝜎*** *[𝐴]* = ∑︁

*𝑝*

*̸*

*̸*


(︀ ***𝜎*** *[𝐴,]* *𝑝* [para] + ***𝜎*** *[𝐴,]* *𝑝* [dia] )︀

*̸*

*̸*


***𝜎*** *𝑖* *[𝐴,]* [para/dia] = ***𝜎*** *[𝐴,]* *𝑖𝑖* [para/dia] + [1] 2

*̸*

*̸*


***𝜎*** *[𝐴,]* *𝑖𝑎* [para/dia] + ***𝜎*** *[𝐴,]* *𝑎𝑖* [para/dia]
(︁ )︁

*̸*

*̸*


***𝜎*** *[𝐴,]* [para/dia] + ***𝜎*** *[𝐴,]* [para/dia] +
(︁ *𝑖𝑗* *𝑗𝑖* )︁ ∑︁

*̸* *𝑎*

***𝜎*** *[𝐴,]* *𝑎𝑏* [para/dia] + ***𝜎*** *[𝐴,]* *𝑏𝑎* [para/dia]
(︁ )︁

*̸*


*̸*

***𝜎*** *𝑎* *[𝐴,]* [para/dia] = ***𝜎*** *[𝐴,]* *𝑎𝑎* [para/dia] + 2 [1]

*̸*


∑︁

*𝑗* = *̸* *𝑖*

∑︁

*𝑏* = *̸* *𝑎*


*̸*

*̸*

***𝜎*** *[𝐴,]* [para] = *𝐷* **[B]**
*𝑝𝑞* *𝑝𝑞* *[ℎ]* **[M]** *𝑝𝑞* *[𝐴]*
***𝜎*** *[𝐴,]* *𝑝𝑞* [dia] = *𝐷* *𝑝𝑞* *ℎ* **[B]** *𝑝𝑞* *[,]* **[M]** *[𝐴]*

*𝐷* *𝑝𝑞* = ∑︁ *𝑐* *𝜇𝑝* *𝑆* *𝜇𝜈* *𝐷* *𝜈𝜅* *𝑆* *𝜅𝜆* *𝑐* *𝜆𝑞*

*𝜇𝜈𝜅𝜆*

*𝐷* *𝑝𝑞* **[B]** [=] ∑︁ *𝑐* *𝜇𝑝* *𝑆* *𝜇𝜈* *𝐷* *𝜈𝜅* **[B]** *[𝑆]* *[𝜅𝜆]* *[𝑐]* *[𝜆𝑞]*

*𝜇𝜈𝜅𝜆*

*ℎ* **[M]** *𝑝𝑞* *[𝐴]* = ∑︁ *𝑐* *𝜇𝑝* *ℎ* **[M]** *𝜇𝜈* *[𝐴]* *[𝑐]* *[𝜈𝑞]*

*𝜇𝜈*

*ℎ* *𝑝𝑞* **[B]** *[,]* **[M]** *[𝐴]* = ∑︁ *𝑐* *𝜇𝑝* *ℎ* *𝜇𝜈* **[B]** *[,]* **[M]** *[𝐴]* *𝑐* *𝜈𝑞*

*𝜇𝜈*

Note that for SCF methods (HF or DFT), ***𝜎*** *[𝐴,]* *𝑎* [para/dia] = 0. To request the analysis, a valid GBW file must be
given with the keyword `LocOrbGBW`, which can contain any orthonormal MOs in the same basis, e.g. canonical or
localized, although the decomposition above assumes that the Brillouin condition is fulfilled and may be misleading
if performed over NBOs for example. Orbital contributions over 0.01 ppm are printed – this is currently not userconfigurable. The separate orbital pair contributions can also be printed using `Printlevel=3` . The following
example input calculates HF and RI-MP2 shieldings for formaldehyde and decomposes them over Pipek–Mezey
localized orbitals (note that the virtual orbitals are likely not well localized - `AHFB` would be better suited there).
The second sub-calculation just prints the LMOs for convenient visualization with Avogadro.


*̸*

*̸*


*̸*

*̸*


*̸*

*̸*

(continues on next page)

**7.51. Calculation of Properties** **1047**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**Treatment of Tau in Meta-GGA Functionals**

For GIAO-based calculations with meta-GGAs, different options are available for the kinetic energy density *𝜏* . The
current-independent *𝜏* 0 is not gauge-invariant. Ignoring the terms, which produce the gauge-dependence, leads to
an ad-hoc gauge-invariant treatment (this was the default up to ORCA 5). A gauge-invariant definition *𝜏* MS, containing an explicit dependence on the magnetic field, was proposed by Maximoff and Scuseria.[567] However, this
ansatz produces unphysical paramagnetic contributions to the shielding tensor.[758] The last option, introduced
by Dobson,[216] is gauge-invariant but requires the solution of the CP-SCF equations, even for pure density functionals. For a discussion and comparison of these alternatives see refs [79] (in the context of TDDFT) and [714,
758] (in the context of NMR shielding). Note that the calculated shieldings can differ substantially between the
different approaches! Some other electronic structure programs use the MS ansatz by default, so be careful when
comparing results between different codes. In ORCA the treatment of *𝜏* in GIAO-based calculations is chosed as
follows



**7.51.4 Paramagnetic NMR shielding tensors**

For systems with spin *𝑆>* 0, the nuclear shielding contains a contribution which arises from the paramagnetism
of the unpaired electrons. [1] This contribution is temperature-dependent and is called the “paramagnetic shielding”
( ***𝜎*** [p] ). It adds to the temperature-indendent contribution to the shielding, also called the “orbital” contribution:

***𝜎*** = ***𝜎*** [orb] + ***𝜎*** [p] *.*

ORCA currently supports the calculation of ***𝜎*** [p] for systems whose paramagnetism can be described by the effective
EPR spin Hamiltonian

*𝐻* *𝑆* = **SDS** + *𝛽* *𝑒* **BgS** + **SAI** *.* (7.404)

The theoretical background can be found in Refs. [810, 863]. We reproduce here the main equations.

For a spin state described by Eq. (7.404), the paramagnetic shielding tensor is given by

***𝜎*** [p] = *−* *[𝛽]* *[𝑒]* *[𝑆]* [(] *[𝑆]* [+ 1] [)] (7.405)

*𝑔* *𝑁* *𝛽* *𝑁* 3 *𝑘𝑇* **[gZA]** *[,]*

1 For a comprehensive review on paramagnetic NMR, see e.g. [658].

**1048** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

where **Z** is a dimensionless 3 *×* 3 matrix which is determined by the ZFS and the temperature, as follows: Diagonalization of the ZFS Hamiltonian **SDS** yields energy levels *𝐸* *𝜆* and eigenstates *|𝑆𝜆𝑎⟩*, where *𝑎* labels degenerate
states if *𝐸* *𝜆* is degenerate. Then **Z** is defined as ( *𝑖, 𝑗* = *𝑥, 𝑦, 𝑧* )

*̸*


3 1
*𝑍* *𝑖𝑗* = *𝑆* ( *𝑆* + 1) *𝑄* 0

+2 *𝑘𝑇*
∑︁

*̸*


∑︁ *𝑒* *[−][𝐸]* *[𝜆]* *[/𝑘𝑇]* ︃∑︁

*𝜆* [ *𝑎,𝑎* *[′]*

*̸*


∑︁

*̸*


*⟨𝑆𝜆𝑎|𝑆* *𝑖* *|𝑆𝜆𝑎* *[′]* *⟩⟨𝑆𝜆𝑎* *[′]* *|𝑆* *𝑗* *|𝑆𝜆𝑎⟩*

*𝑎,𝑎* *[′]*

*̸*


*,*

*̸* ]︃


∑︁

*̸* *𝑎,𝑎* *[′]*


*⟨* *𝑆𝜆𝑎* *|* *𝑆* *𝑖* *|* *𝑆𝜆* *[′]* *𝑎* *[′]* *⟩⟨* *𝑆𝜆* *[′]* *𝑎* *[′]* *|* *𝑆* *𝑗* *|* *𝑆𝜆𝑎* *⟩*

*𝐸* *𝜆* *′* *−* *𝐸* *𝜆*

*̸*


*𝜆* *[′]* = *̸* *𝜆*


*̸*

where *𝑄* 0 = [∑︀] *𝜆* *[′]* *,𝑎* *[𝑒]* *[−][𝐸]* *[𝜆]* *[/𝑘𝑇]* [denotes the partition function. An important property of the] **[ Z]** [ matrix as defined]

above is that it goes to the identity matrix as **D** */𝑘𝑇* goes to zero.

The orbital part of the shielding, ***𝜎*** [orb], is calculated in the same manner as for closed-shell molecules. It is available
in ORCA for the unrestricted HF and DFT methods and for MP2 (see Section *MP2 level magnetic properties* for
more information on the latter).

The `orca_pnmr` tool uses Eq. *(7.407)* to calculate ***𝜎*** [p] . Usage of `orca_pnmr` is described in Section *orca_pnmr* .

**7.51.5 Calculating properties from existing densities**

Occasionally, one may calculate a density matrix using an expensive correlated method such as CCSD and realize
afterwards that a certain property such as the quadrupole moment or a hyperfine coupling constant (HFCC) is also
required. Rather than start the whole calculation from scratch, one may wish to use the existing density matrix
to calculate the properties. For this purpose, we have experimentally introduced a “properties only” calculation
mode, whereby the MOs are read from an existing *BaseName.gbw* file and the densities are read from an existing
*BaseName.densities* file and only the property calculations are performed. Note however, that this presents many
possibilities for error, so **only use it as a last resort and be very careful with the results** !

Take, for example, this CCSD calculation:


*̸*


*̸*


*̸*

This produces the files *BO-CCSD.gbw* and *BO-CCSD.densities* . To obtain the CCSD quadrupole moment and
HFCCs without repeating the whole calculation, we can copy these two files into a new directory (highly recommended!) and start a second job with the `!PropertiesOnly` keyword. Note that the basename of the second job
must be identical!

*̸*


(continues on next page)

**7.51. Calculation of Properties** **1049**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**7.51.6 Local Energy Decomposition**

The DLPNO-CCSD(T) method provides very accurate relative energies and allows to successfully predict many
chemical phenomena. In order to facilitate the interpretation of coupled cluster results, we have developed the
Local Energy Decomposition (LED) analysis [33, 105, 768], which permit to divide the total DLPNO-CCSD(T)
energy (including the reference energy) into physically meaningful contributions. A practical guide to the LED
scheme is reported in Section *Local Energy Decomposition* . Examples of applications of this scheme can be found
in Ref. [84, 106, 294, 536, 537, 904]

As a word of caution we emphasize that only the total energy is an observable and its decomposition is, to some
extent, arbitrary. Nevertheless, the LED analysis appears to be physically well grounded and logical to us, it is
straightforward to apply and comes typically at a negligible computational cost compared to DLPNO-CCSD(T)
calculations. Starting from ORCA 4.1, the LED scheme is available for both closed shell and open shell calculations. The code has also been made parallel and more efficient.

The LED scheme makes no assumption about the strength of the intermolecular interaction and hence it remains
valid and consistent over the entire potential energy surface. Alternative schemes, such as the popular symmetry
adapted perturbation theory, are perturbative in nature and hence are best applied to weakly interacting systems.

The idea of the LED analysis is rather simple. In local correlation methods occupied orbitals are localized and
can be readily assigned to pre-defined fragments in the molecule. The same can be done for the correlation energy
in terms of pair correlation energies that refer to pairs of occupied orbitals. In this way, both the correlation and
the reference energy can be decomposed into intra- and interfragment contributions. The fragmentation is user
defined. An arbitrary number of fragments can be defined. In the case that more than 2 fragments are defined, the
interfragment interaction is printed for each fragment pair.

A very important feature of the LED scheme is the possibility to distinguish between dispersive and non-dispersive
part of the DLPNO-CCSD(T) correlation energy. In brief, we exploit the fact that each CCSD pair correlation
energy contribution can be expressed as a sum of double excitations from pairs of occupied orbitals into the virtual space. As in the DLPNO-CCSD(T) scheme the virtual space is spanned by Pair Natural Orbitals(PNOs) that
are essentially local, the entire correlation energy can be decomposed into double excitations types, depending on
where occupied and virtual orbitals are localized. For each pair of fragments, the sum of all excitations corresponding to the interaction of instantaneous local dipoles located on different fragments defines the so called “London
dispersion” attraction between the two fragments in the LED framework.

For a system of two fragments, one can use as a reference point the geometrically and electronically relaxed fragments that constitute the interacting super-molecule. Relative to this reference state, the binding energy between
the fragments can be written as:

∆ *𝐸* =∆ *𝐸* *𝑔𝑒𝑜−𝑝𝑟𝑒𝑝*


+ ∆ *𝐸* *𝑒𝑙* *[𝑟𝑒𝑓.]* *−𝑝𝑟𝑒𝑝* [+] *[ 𝐸]* *𝑒𝑙𝑠𝑡𝑎𝑡* *[𝑟𝑒𝑓.]* [+] *[ 𝐸]* *𝑒𝑥𝑐ℎ* *[𝑟𝑒𝑓.]*
+ ∆ *𝐸* *𝑛𝑜𝑛* *[𝐶][−][𝐶𝐶𝑆𝐷]* *−𝑑𝑖𝑠𝑝𝑒𝑟𝑠𝑖𝑜𝑛* [+] *[ 𝐸]* *𝑑𝑖𝑠𝑝𝑒𝑟𝑠𝑖𝑜𝑛* *[𝐶][−][𝐶𝐶𝑆𝐷]*

+ ∆ *𝐸* *𝑖𝑛𝑡* *[𝐶][−]* [(] *[𝑇]* [)]


(7.406)


where ∆ *𝐸* *𝑔𝑒𝑜−𝑝𝑟𝑒𝑝* is the energy needed to distort the fragments from their equilibrium configuration to the interacting geometry (also called “strain” in other energy decomposition schemes). The ∆ *𝐸* *𝑒𝑙* *[𝑟𝑒𝑓.]* *−𝑝𝑟𝑒𝑝* [term represents the]
electronic preparation energy and describes how much energy is necessary to bring the fragments into the electronic structure that is optimal for interaction. *𝐸* *𝑒𝑥𝑐ℎ* *[𝑟𝑒𝑓.]* [is the inter-fragment exchange interaction (it always gives]
a binding contribution in our formalism) and *𝐸* *𝑒𝑙𝑠𝑡𝑎𝑡* *[𝑟𝑒𝑓.]* [is the electrostatic energy interaction between the distorted]
electronic clouds of the fragments. The sum of these terms gives the Hatree-Fock energy in the closed shell case
and the energy of the QRO determinant in the open shell case. Finally, the correlation energy is decomposed into
dispersive *𝐸* *𝑑𝑖𝑠𝑝𝑒𝑟𝑠𝑖𝑜𝑛* *[𝐶][−][𝐶𝐶𝑆𝐷]* [and non-dispersive][ ∆] *[𝐸]* *𝑛𝑜𝑛* *[𝐶][−][𝐶𝐶𝑆𝐷]* *−𝑑𝑖𝑠𝑝𝑒𝑟𝑠𝑖𝑜𝑛* [contributions plus a triples correction term to the]

interaction energy ∆ *𝐸* *𝑖𝑛𝑡* *[𝐶][−]* [(] *[𝑇]* [)] .

**1050** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

The *𝐸* *[𝐶][−][𝐶𝐶𝑆𝐷]*
*𝑑𝑖𝑠𝑝𝑒𝑟𝑠𝑖𝑜𝑛* [term contains the London dispersion contribution from the strong pairs described above plus]
the interfragment component of the weak pairs, which is essentially dispersive in nature. The ∆ *𝐸* *𝑛𝑜𝑛* *[𝐶][−][𝐶𝐶𝑆𝐷]* *−𝑑𝑖𝑠𝑝𝑒𝑟𝑠𝑖𝑜𝑛*
correlation term serves to correct the contributions to the binding energy approximately included in the reference
energy, e.g it counteracts the overpolarization typical of the HF method. It contains the so called charge transfer
excitations from the strong pairs *𝐸* *𝐶* *[𝐶𝑇]* *−𝑆𝑃* [(] *[𝑋][→][𝑌]* [)] + *𝐸* *𝐶* *[𝐶𝑇]* *−𝑆𝑃* [(] *[𝑋][←][𝑌]* [)], which represent the sum of all double excitation
contributions that do not conserve the charge within each fragment. Moreover, the non-dispersive term also includes
the electronic preparation from strong (∆ *𝐸* *𝑒𝑙* *[𝐶]* *−* *[−]* *𝑝𝑟𝑒𝑝* *[𝑆𝑃]* [) and weak (][∆] *[𝐸]* *𝑒𝑙* *[𝐶]* *−* *[−]* *𝑝𝑟𝑒𝑝* *[𝑊𝑃]* [) pairs. Finally,][ ∆] *[𝐸]* *𝑖𝑛𝑡* *[𝐶][−]* [(] *[𝑇]* [)] represents
the triples correction contribution to the interaction energy between the fragments. In the LED scheme, this term
can be further decomposed into intra- and interfragment components. This can be useful, for example, to estimate
the London dispersion contribution from the triples correction term, as suggested in ref.[536].
### **7.52 Natural Bond Orbital (NBO) Analysis**

A popular and useful method for population analysis is the natural bond orbital analysis due to Weinhold and
co-workers. It is implemented in the **NBO** program which is distributed in older versions via the CCL list and
in newer versions via the University of Wisconsin/Madison. Information about the NBO program can be found
[at http://www.chem.wisc.edu/~nbo7. In order to use it together with ORCA you need a version of the stand-](http://www.chem.wisc.edu/~nbo7)
alone executable. Starting with version 3.1.x ORCA can only be used with NBO6 or NBO7. To specify the NBO
executable the environment variable NBOEXE=/full/name/of/nbo7-executable has to be set. As the NBO part of
the interface is not independent of the integer data-type width (i4 or i8), the NBO executable which will be used
together with ORCA has to be compiled using i4!

ORCA features two methods to interface with the **NBO** program: `!` `NBO` keyword and the `%nbo` -block. The
following example illustrates the use for formaldehyde:

This produces the following output:




(continues on next page)

**7.52. Natural Bond Orbital (NBO) Analysis** **1051**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
    /AONBO / : Checkpoint the AO to NBO transformation
    /ARCHIVE/ : Write the archive file to lfn47
 Job title: ORCA Job: NBO_1
 NATURAL POPULATIONS: Natural atomic orbital occupancies
 NAO Atom No lang Type(AO) Occupancy Energy
 ------------------------------------------------------  1 C 1 s Cor( 1s) 1.99997 -11.34329
  2 C 1 s Val( 2s) 1.01533 -0.17540
  3 C 1 s Ryd( 3s) 0.00701 0.61376
  4 C 1 px Val( 2p) 0.81697 0.08822
  5 C 1 px Ryd( 3p) 0.01268 0.63900
  6 C 1 py Val( 2p) 1.09795 -0.01243
  7 C 1 py Ryd( 3p) 0.00055 0.80803
  8 C 1 pz Val( 2p) 0.66003 -0.03464
  9 C 1 pz Ryd( 3p) 0.00283 0.62824
 10 C 1 dxy Ryd( 3d) 0.00576 2.75039
 11 C 1 dxz Ryd( 3d) 0.00375 2.25746
 12 C 1 dyz Ryd( 3d) 0.00000 2.08566
 13 C 1 dx2y2 Ryd( 3d) 0.00337 2.74845
 14 C 1 dz2 Ryd( 3d) 0.00114 2.40647
 15 O 2 s Cor( 1s) 1.99998 -20.56485
 16 O 2 s Val( 2s) 1.70725 -0.92198
 17 O 2 s Ryd( 3s) 0.00171 1.55322
 18 O 2 px Val( 2p) 1.62177 -0.42255
 19 O 2 px Ryd( 3p) 0.00079 1.29654
 20 O 2 py Val( 2p) 1.91529 -0.46844
 21 O 2 py Ryd( 3p) 0.00383 1.41052
 22 O 2 pz Val( 2p) 1.32984 -0.28626
 23 O 2 pz Ryd( 3p) 0.00011 1.30080
 24 O 2 dxy Ryd( 3d) 0.00213 3.26414
 25 O 2 dxz Ryd( 3d) 0.00340 3.20490
 26 O 2 dyz Ryd( 3d) 0.00000 2.98918
 27 O 2 dx2y2 Ryd( 3d) 0.00406 3.55008
 28 O 2 dz2 Ryd( 3d) 0.00119 3.17511
 29 H 3 s Val( 1s) 0.88576 0.07107
 30 H 3 s Ryd( 2s) 0.00298 0.41181
 31 H 3 px Ryd( 2p) 0.00030 2.18260
 32 H 3 py Ryd( 2p) 0.00159 2.49146
 33 H 3 pz Ryd( 2p) 0.00002 1.85643
 34 H 4 s Val( 1s) 0.88576 0.07107
 35 H 4 s Ryd( 2s) 0.00298 0.41181
 36 H 4 px Ryd( 2p) 0.00030 2.18260
 37 H 4 py Ryd( 2p) 0.00159 2.49146
 38 H 4 pz Ryd( 2p) 0.00002 1.85643
 Summary of Natural Population Analysis:
                   Natural Population
       Natural -------------------------------------------- Atom No Charge Core Valence Rydberg Total
 -------------------------------------------------------------------  C 1 0.37265 1.99997 3.59028 0.03709 5.62735
  O 2 -0.59134 1.99998 6.57415 0.01720 8.59134

```
(continues on next page)

**1052** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
  H 3 0.10934 0.00000 0.88576 0.00489 0.89066
  H 4 0.10934 0.00000 0.88576 0.00489 0.89066
 ====================================================================
 * Total * -0.00000 3.99995 11.93596 0.06408 16.00000
                 Natural Population
 --------------------------------------------------------  Core 3.99995 ( 99.9988% of 4)
  Valence 11.93596 ( 99.4664% of 12)
  Natural Minimal Basis 15.93592 ( 99.5995% of 16)
  Natural Rydberg Basis 0.06408 ( 0.4005% of 16)
 --------------------------------------------------------  Atom No Natural Electron Configuration
 ---------------------------------------------------------------------------   C 1 [core]2s( 1.02)2p( 2.57)3s( 0.01)3p( 0.02)3d( 0.01)
   O 2 [core]2s( 1.71)2p( 4.87)3d( 0.01)
   H 3 1s( 0.89)
   H 4 1s( 0.89)
 NATURAL BOND ORBITAL ANALYSIS:
               Occupancies Lewis Structure Low High
     Max Occ ------------------- ----------------- occ occ
 Cycle Ctr Thresh Lewis non-Lewis CR BD nC LP (L) (NL)
 ============================================================================
  1 2 1.90 15.89671 0.10329 2 4 0 2 0 0
 --------------------------------------------------------------------------- Structure accepted: No low occupancy Lewis orbitals
 ------------------------------------------------------  Core 3.99995 ( 99.999% of 4)
  Valence Lewis 11.89676 ( 99.140% of 12)
 ================== =============================
  Total Lewis 15.89671 ( 99.354% of 16)
 ----------------------------------------------------  Valence non-Lewis 0.07835 ( 0.490% of 16)
  Rydberg non-Lewis 0.02493 ( 0.156% of 16)
 ================== =============================
  Total non-Lewis 0.10329 ( 0.646% of 16)
 ------------------------------------------------------   (Occupancy) Bond orbital / Coefficients / Hybrids
 ------------------ Lewis -----------------------------------------------------  1. (1.99997) CR ( 1) C 1 s(100.00%)
                      1.0000 0.0000 0.0000 0.0000 0.0000
                      0.0000 0.0000 0.0000 0.0000 0.0000
                      0.0000 0.0000 0.0000 0.0000
  2. (1.99998) CR ( 1) O 2 s(100.00%)
                      1.0000 0.0000 0.0000 0.0000 0.0000
                      0.0000 0.0000 0.0000 0.0000 0.0000
                      0.0000 0.0000 0.0000 0.0000
  3. (1.98853) LP ( 1) O 2 s( 56.22%)p 0.78( 43.73%)d 0.00( 0.05%)
                      0.0000 0.7496 -0.0170 0.6612 0.0069
                      0.0000 0.0000 0.0000 0.0000 0.0000
                      0.0000 0.0000 -0.0201 0.0100
  4. (1.91757) LP ( 2) O 2 s( 0.00%)p 1.00( 99.89%)d 0.00( 0.11%)
                      0.0000 0.0000 0.0000 -0.0000 -0.0000

```
(continues on next page)

**7.52. Natural Bond Orbital (NBO) Analysis** **1053**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
                      0.9994 -0.0098 0.0000 -0.0000 -0.0330
                     -0.0000 0.0000 0.0000 -0.0000
  5. (1.99996) BD ( 1) C 1- O 2
        ( 33.33%) 0.5773* C 1 s( 0.00%)p 1.00( 99.44%)d 0.01( 0.56%)
                      0.0000 -0.0000 -0.0000 0.0000 -0.0000
                     -0.0000 0.0000 0.9951 -0.0652 -0.0000
                      0.0750 0.0000 -0.0000 0.0000
        ( 66.67%) 0.8165* O 2 s( 0.00%)p 1.00( 99.75%)d 0.00( 0.25%)
                      0.0000 -0.0000 0.0000 0.0000 -0.0000
                     -0.0000 0.0000 0.9987 -0.0090 0.0000
                     -0.0505 0.0000 0.0000 -0.0000
  6. (1.99975) BD ( 2) C 1- O 2
        ( 32.59%) 0.5709* C 1 s( 32.18%)p 2.09( 67.35%)d 0.01( 0.46%)
                      0.0000 0.5628 0.0714 0.8149 0.0973
                     -0.0000 -0.0000 -0.0000 -0.0000 -0.0000
                     -0.0000 0.0000 0.0618 -0.0286
        ( 67.41%) 0.8211* O 2 s( 43.84%)p 1.27( 55.85%)d 0.01( 0.31%)
                      0.0000 0.6615 0.0284 -0.7470 -0.0215
                     -0.0000 0.0000 -0.0000 -0.0000 0.0000
                      0.0000 0.0000 0.0490 -0.0270
  7. (1.99548) BD ( 1) C 1- H 3
        ( 56.63%) 0.7526* C 1 s( 33.98%)p 1.94( 65.86%)d 0.00( 0.16%)
                      0.0000 0.5826 -0.0192 -0.3995 -0.0029
                      0.7063 -0.0087 0.0000 -0.0000 -0.0318
                     -0.0000 0.0000 -0.0180 -0.0153
        ( 43.37%) 0.6585* H 3 s( 99.79%)p 0.00( 0.21%)
                      0.9989 -0.0095 0.0184 -0.0416 0.0000
  8. (1.99548) BD ( 1) C 1- H 4
        ( 56.63%) 0.7526* C 1 s( 33.98%)p 1.94( 65.86%)d 0.00( 0.16%)
                      0.0000 0.5826 -0.0192 -0.3995 -0.0029
                     -0.7063 0.0087 -0.0000 0.0000 0.0318
                      0.0000 0.0000 -0.0180 -0.0153
        ( 43.37%) 0.6585* H 4 s( 99.79%)p 0.00( 0.21%)
                      0.9989 -0.0095 0.0184 0.0416 -0.0000
 ---------------- non-Lewis ---------------------------------------------------  9. (0.00000) BD*( 1) C 1- O 2
        ( 66.67%) 0.8165* C 1 s( 0.00%)p 1.00( 99.44%)d 0.01( 0.56%)
        ( 33.33%) -0.5773* O 2 s( 0.00%)p 1.00( 99.75%)d 0.00( 0.25%)
 10. (0.00000) BD*( 2) C 1- O 2
        ( 67.41%) 0.8211* C 1 s( 32.18%)p 2.09( 67.35%)d 0.01( 0.46%)
        ( 32.59%) -0.5709* O 2 s( 43.84%)p 1.27( 55.85%)d 0.01( 0.31%)
 11. (0.03918) BD*( 1) C 1- H 3
        ( 43.37%) 0.6585* C 1 s( 33.98%)p 1.94( 65.86%)d 0.00( 0.16%)
                      0.0000 -0.5826 0.0192 0.3995 0.0029
                     -0.7063 0.0087 -0.0000 0.0000 0.0318
                      0.0000 0.0000 0.0180 0.0153
        ( 56.63%) -0.7526* H 3 s( 99.79%)p 0.00( 0.21%)
                     -0.9989 0.0095 -0.0184 0.0416 -0.0000
 12. (0.03918) BD*( 1) C 1- H 4
        ( 43.37%) 0.6585* C 1 s( 33.98%)p 1.94( 65.86%)d 0.00( 0.16%)
                      0.0000 -0.5826 0.0192 0.3995 0.0029
                      0.7063 -0.0087 0.0000 -0.0000 -0.0318
                     -0.0000 0.0000 0.0180 0.0153
        ( 56.63%) -0.7526* H 4 s( 99.79%)p 0.00( 0.21%)
                     -0.9989 0.0095 -0.0184 -0.0416 0.0000
 13. (0.00969) RY ( 1) C 1 s( 29.83%)p 2.30( 68.57%)d 0.05( 1.60%)
                      0.0000 -0.0565 0.5432 -0.1169 0.8198
                      0.0000 -0.0000 0.0000 -0.0000 -0.0000
                      0.0000 0.0000 0.1087 -0.0648
 14. (0.00517) RY ( 2) C 1 s( 0.00%)p 1.00( 9.56%)d 9.46( 90.44%)
                      0.0000 0.0000 -0.0000 0.0000 -0.0000

```
(continues on next page)

**1054** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
                      0.0465 0.3057 0.0000 -0.0000 0.9510
                      0.0000 0.0000 -0.0000 -0.0000
 15. (0.00001) RY ( 3) C 1 s( 20.02%)p 0.82( 16.47%)d 3.17( 63.52%)
 16. (0.00000) RY ( 4) C 1 s( 0.00%)p 1.00( 90.64%)d 0.10( 9.36%)
 17. (0.00000) RY ( 5) C 1 s( 0.00%)p 1.00(100.00%)d 0.00( 0.00%)
 18. (0.00000) RY ( 6) C 1 s( 42.72%)p 0.35( 15.02%)d 0.99( 42.26%)
 19. (0.00000) RY ( 7) C 1 s( 0.00%)p 1.00( 0.56%)d99.99( 99.44%)
 20. (0.00000) RY ( 8) C 1 s( 0.00%)p 0.00( 0.00%)d 1.00(100.00%)
 21. (0.00000) RY ( 9) C 1 s( 7.29%)p 0.09( 0.66%)d12.63( 92.05%)
 22. (0.00368) RY ( 1) O 2 s( 0.00%)p 1.00( 98.96%)d 0.01( 1.04%)
                      0.0000 -0.0000 -0.0000 0.0000 0.0000
                      0.0064 0.9948 -0.0000 0.0000 -0.1018
                      0.0000 0.0000 -0.0000 0.0000
 23. (0.00014) RY ( 2) O 2 s( 35.10%)p 1.44( 50.60%)d 0.41( 14.30%)
                      0.0000 -0.0178 0.5922 0.0556 -0.7091
                      0.0000 -0.0000 -0.0000 0.0000 -0.0000
                      0.0000 0.0000 0.3336 -0.1780
 24. (0.00000) RY ( 3) O 2 s( 56.05%)p 0.25( 13.79%)d 0.54( 30.17%)
 25. (0.00000) RY ( 4) O 2 s( 0.00%)p 1.00(100.00%)d 0.00( 0.00%)
 26. (0.00000) RY ( 5) O 2 s( 0.00%)p 1.00( 1.14%)d86.35( 98.86%)
 27. (0.00000) RY ( 6) O 2 s( 0.00%)p 1.00( 0.25%)d99.99( 99.75%)
 28. (0.00000) RY ( 7) O 2 s( 0.00%)p 0.00( 0.00%)d 1.00(100.00%)
 29. (0.00000) RY ( 8) O 2 s( 6.72%)p 5.27( 35.42%)d 8.61( 57.85%)
 30. (0.00000) RY ( 9) O 2 s( 2.07%)p 0.30( 0.61%)d47.00( 97.32%)
 31. (0.00308) RY ( 1) H 3 s( 99.42%)p 0.01( 0.58%)
                      0.0096 0.9970 -0.0710 -0.0281 0.0000
 32. (0.00002) RY ( 2) H 3 s( 0.22%)p99.99( 99.78%)
 33. (0.00002) RY ( 3) H 3 s( 0.00%)p 1.00(100.00%)
 34. (0.00001) RY ( 4) H 3 s( 0.57%)p99.99( 99.43%)
 35. (0.00308) RY ( 1) H 4 s( 99.42%)p 0.01( 0.58%)
                      0.0096 0.9970 -0.0710 0.0281 0.0000
 36. (0.00002) RY ( 2) H 4 s( 0.22%)p99.99( 99.78%)
 37. (0.00002) RY ( 3) H 4 s( 0.00%)p 1.00(100.00%)
 38. (0.00001) RY ( 4) H 4 s( 0.57%)p99.99( 99.43%)
 NHO DIRECTIONALITY AND BOND BENDING (deviation from line of nuclear centers at
                    the position of maximum hybrid amplitude)
     [Thresholds for printing: angular deviation > 1.0 degree]
                   p- or d-character > 25.0%
                   orbital occupancy > 0.10e
             Line of Centers Hybrid 1 Hybrid 2
             --------------- ------------------- -----------------      NBO Theta Phi Theta Phi Dev Theta Phi Dev
 ===============================================================================
  3. LP ( 1) O 2 -- -- 90.0 0.0 -- -- -- -  4. LP ( 2) O 2 -- -- 90.0 90.7 -- -- -- -  5. BD ( 1) C 1- O 2 90.0 0.0 3.0 0.0 87.0 178.7 180.0 88.7
 SECOND ORDER PERTURBATION THEORY ANALYSIS OF FOCK MATRIX IN NBO BASIS
   Threshold for printing: 0.50 kcal/mol
                              E(2) E(NL)-E(L) F(L,NL)
   Donor (L) NBO Acceptor (NL) NBO kcal/mol a.u. a.u.
 ===============================================================================
 within unit 1
  3. LP ( 1) O 2 13. RY ( 1) C 1 8.58 1.40 0.098

```
(continues on next page)

**7.52. Natural Bond Orbital (NBO) Analysis** **1055**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
  4. LP ( 2) O 2 11. BD*( 1) C 1- H 3 26.11 1.16 0.156
  4. LP ( 2) O 2 12. BD*( 1) C 1- H 4 26.11 1.16 0.156
  4. LP ( 2) O 2 14. RY ( 2) C 1 5.72 3.06 0.118
  4. LP ( 2) O 2 26. RY ( 5) O 2 0.73 3.75 0.047
  7. BD ( 1) C 1- H 3 12. BD*( 1) C 1- H 4 0.74 1.42 0.029
  7. BD ( 1) C 1- H 3 22. RY ( 1) O 2 2.25 2.12 0.062
  8. BD ( 1) C 1- H 4 11. BD*( 1) C 1- H 3 0.74 1.42 0.029
  8. BD ( 1) C 1- H 4 22. RY ( 1) O 2 2.25 2.12 0.062
 NATURAL BOND ORBITALS (Summary):
                            Principal Delocalizations
      NBO Occupancy Energy (geminal,vicinal,remote)
 ===============================================================================
 Molecular unit 1 (CH2O)
 ------ Lewis -------------------------------------  1. CR ( 1) C 1 1.99997 -11.34329
  2. CR ( 1) O 2 1.99998 -20.56485
  3. LP ( 1) O 2 1.98853 -0.81352 13(v)
  4. LP ( 2) O 2 1.91757 -0.46975 11(v),12(v),14(v),26(g)
  5. BD ( 1) C 1- O 2 1.99996 -0.53505
  6. BD ( 2) C 1- O 2 1.99975 -1.23345
  7. BD ( 1) C 1- H 3 1.99548 -0.72703 22(v),12(g)
  8. BD ( 1) C 1- H 4 1.99548 -0.72703 22(v),11(g)
 ------ non-Lewis ---------------------------------  9. BD*( 1) C 1- O 2 0.00000 0.20704
  10. BD*( 2) C 1- O 2 0.00000 0.95146
  11. BD*( 1) C 1- H 3 0.03918 0.69317
  12. BD*( 1) C 1- H 4 0.03918 0.69317
  13. RY ( 1) C 1 0.00969 0.58169
  14. RY ( 2) C 1 0.00517 2.58837
  15. RY ( 3) C 1 0.00001 1.75652
  16. RY ( 4) C 1 0.00000 0.96046
  17. RY ( 5) C 1 0.00000 0.64510
  18. RY ( 6) C 1 0.00000 1.49223
  19. RY ( 7) C 1 0.00000 2.24615
  20. RY ( 8) C 1 0.00000 2.08566
  21. RY ( 9) C 1 0.00000 2.49414
  22. RY ( 1) O 2 0.00368 1.39676
  23. RY ( 2) O 2 0.00014 1.56107
  24. RY ( 3) O 2 0.00000 2.18160
  25. RY ( 4) O 2 0.00000 1.30222
  26. RY ( 5) O 2 0.00000 3.27920
  27. RY ( 6) O 2 0.00000 3.20505
  28. RY ( 7) O 2 0.00000 2.98918
  29. RY ( 8) O 2 0.00000 2.69359
  30. RY ( 9) O 2 0.00000 3.12898
  31. RY ( 1) H 3 0.00308 0.41874
  32. RY ( 2) H 3 0.00002 2.57996
  33. RY ( 3) H 3 0.00002 1.85643
  34. RY ( 4) H 3 0.00001 2.06898
  35. RY ( 1) H 4 0.00308 0.41874
  36. RY ( 2) H 4 0.00002 2.57996
  37. RY ( 3) H 4 0.00002 1.85643
  38. RY ( 4) H 4 0.00001 2.06898
     ------------------------------         Total Lewis 15.89671 ( 99.3545%)
      Valence non-Lewis 0.07835 ( 0.4897%)
      Rydberg non-Lewis 0.02493 ( 0.1558%)
     ------------------------------
```
(continues on next page)

**1056** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



Thus, in this example the NBO analysis of formaldehyde shows that a single Lewis structure is dominant with
single bonds between C and H, a double bond between C and O and two lone pairs at the oxygen – just as ordinary
chemical arguments would imply. In addition, the program produces the four corresponding valence antibonds.
The remaining components of the basis set span the “Rydberg” space and lead to semilocalized, orthogonal orbitals
that are assigned to single atoms (Note the nomenclature: BD = bond, BD* = antibond, LP = lone pair, CR = core
orbital, RY= Rydberg orbital). The NPA analysis shows a patially negative oxygen and partially positive carbon
and hydrogen atoms.

Additionally, the NBO orbitals are stored in the ORCA .gbw file format as `jobname.nbo` . This file can be used for
further analysis and usage with ORCA e.g. for plotting orbitals via `orca_plot` .

The **NBO** program has many additional features and analysis tools. The features that are implemented in ORCA
can be controlled via the `%nbo` -block



The syntax of the respective keylists is given by the NBO6.x/NBO7.x manual.

Specifying the single `! NBO` keyword corresponds to the `%nbo` -block



The full set of features beyond those which can be give via the `%nbo` block can be accessed using the file `FILE.47`,
which is generated by the NBO program. This is an ascii file that can be edited with a text editor. Add or remove
keywords in the corresponding blocks as needed and call the gennbo program like
```
gennbo < FILE.47 >jobname.nboout

```
**7.52. Natural Bond Orbital (NBO) Analysis** **1057**

If you have no need for this (rather large) file, then you have to delete it manually!

**7.52.1 NBO Deletions**

An advanced feature, which has been implemented via the ORCA-NBO interface, is the possibility of using dele
tions.

(continues on next page)

**1058** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



The `DELKEYLIST` provides NBO with the task to perform certain deletions of orbitals/interactions. Per deletion
ORCA calculates a new Fock matrix on basis of an NBO density corresponding to the deletions:



(continues on next page)

**7.52. Natural Bond Orbital (NBO) Analysis** **1059**

**ORCA Manual** **,** **Release 6.0.1**


(continued from previous page)



Multiple deletions can also be specified, as can be seen for this example. The output then also contains the additional
energy values:




(continues on next page)

**1060** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)




*NOTE: Deletions are only implemented for SCF methods!*

**7.52.2 NBO for Post-HF Densities**

NBO analysis can be performed on all methods producing a density. In some methods the density generation has
to be specified explictly, e. g. for MP2 calculations this would be:




The output will contain both the NBO analysis of the SCF density as well as of the MP2 relaxed density. An NBO
analysis of a density generated by the MDCI module can be specified as follows:




Again, the output will contain both the NBO analysis of the SCF density as well es of the CISD linearized density.

**7.52. Natural Bond Orbital (NBO) Analysis** **1061**

**ORCA Manual** **,** **Release 6.0.1**

**7.52.3 Natural Chemical Shielding Analysis (NCS)**

For closed-shell calculations of NMR chemical shielding at the SCF level (see sections *NMR Chemical Shifts* and
*EPR and NMR properties* ), the NCS analysis can be requested by adding `NCS` to the `NBOKEYLIST` . The `NCS` keyword
accepts the arguments `U`, `I`, `CSA`, `XYZ`, and `MO` to analyze the “unperturbed”, “induced”, anisotropic, Cartesian, and
canonical MO contributions to the shielding tensors, respectively, as well as a decimal number for the printing
threshold (in ppm). For more information, consult the NBO manual and the original publication.[113]


### **7.53 Population Analyses and Control of Output**

At present ORCA knows three different ways of analyzing the computed SCF wavefunction that will be described
below. All of these methods can produce a tremendous amount of output. However, this output can be precisely
controlled by the user to his or her individual needs.

In general there is one compound key called `PrintLevel` which is there to choose reasonable amounts of output.
All that `PrintLevel` does is to set certain flags in the array `Print` which holds the details about what to print and
what not.

**1062** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.53.1 Controlling Output**

The array `Print` allows the control of output. The general way of assigning elements of `Print` is:



The compound key `PrintLevel` can be used to select certain default settings for the print array. Specifying `Print`
after `PrintLevel` can be used to modify these defaults.



`Print` has presently the following elements that can be user controlled:

continues on next page

**7.53. Population Analyses and Control of Output** **1063**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.31 – continued from p revious p a g e

continues on next page

**1064** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.31 – continued from p revious p a g e

The various choices for PrintLevel have the following defaults:

**7.53. Population Analyses and Control of Output** **1065**

**ORCA Manual** **,** **Release 6.0.1**

**7.53.2 Mulliken Population Analysis**

The Mulliken population analysis [599] is, despite all its known considerable weaknesses, the standard in most
quantum chemical programs. It partitions the total density using the assignment of basis functions to given atoms
in the molecules and the basis function overlap. If the total charge density is written as *𝜌* ( *⃗𝑟* ) and the total number
of electrons is *𝑁* we have:

*𝜌* ( *⃗𝑟* ) *𝑑⃗𝑟* = *𝑁* (7.407)
∫︁

and from the density matrix **P** and the basis functions *𝜑* :

*𝜌* ( *⃗𝑟* ) = ∑︁ *𝑃* *𝜇𝜈* *𝜑* *𝜇* ( *⃗𝑟* ) *𝜑* *𝜈* ( *⃗𝑟* ) (7.408)

*𝜇𝜈*

*̸*


therefore:

*𝜌* ( *⃗𝑟* ) *𝑑⃗𝑟* = ∑︁ *𝑃* *𝜇𝜈*
∫︁

*𝜇𝜈*

*̸*


*𝜑* *𝜇* ( *⃗𝑟* ) *𝜑* *𝜈* ( *⃗𝑟* ) *𝑑⃗𝑟*
∫ ~~⏟~~ ~~⏞~~ (7.409)
*𝑆* *𝜇𝜈*

*̸*


= ∑︁ *𝑃* *𝜇𝜈* *𝑆* *𝜇𝜈* (7.410)

*𝜇𝜈*

After assigning each basis function to a given center this can be rewritten:

*̸*


=
∑︁

*𝐴*

*̸*


∑︁

*𝐵*

*̸*


∑︁

*𝜇*

*̸*


*𝐴* [∑︁]

*𝜈*

*̸*


*𝐵* *𝑃* *𝐴𝐵*
*𝜇𝜈* *[𝑆]* *𝜇𝜈* *[𝐴𝐵]* (7.411)

*̸*


∑︁

*𝐵<𝐴*

*̸*


∑︁

*𝜇*

*̸*


*𝐴* [∑︁]

*𝜈*

*̸*


*𝐴* *𝑃* *𝐴𝐴*
*𝜇𝜈* *[𝑆]* *𝜇𝜈* *[𝐴𝐴]* [+ 2] ∑︁

*𝐴*

*̸*


=
∑︁

*𝐴*

*̸*


∑︁ *𝐴* [∑︁]

*𝜇* *𝜈*

*̸*


*𝐵* *𝑃* *𝐴𝐵*
*𝜇𝜈* *[𝑆]* *𝜇𝜈* *[𝐴𝐵]* (7.412)

*̸*


Mulliken proposed to divide the second term equally between each pair of atoms involved and define the number
of electrons on center *𝐴*, *𝑁* *𝐴*, as:

*̸*


∑︁

*̸* *𝜇*


*𝐴* [∑︁]

*̸* *𝜈*


*𝐴* *𝑃* *𝐴𝐴*
*𝜇𝜈* *[𝑆]* *𝜇𝜈* *[𝐴𝐴]* [+] ∑︁

*𝐵* = *̸* *𝐴*


*𝑁* *𝐴* = ∑︁

*𝜇* *̸*


*𝐴* [∑︁]

*𝜈* *̸*


*𝐵* *𝑃* *𝐴𝐵*
*𝜇𝜈* *[𝑆]* *𝜇𝜈* *[𝐴𝐵]* (7.413)

*̸*


*̸*

such that [∑︀] *𝑁* *𝐴* = *𝑁* . The charge of an atom in the molecule is then:

*𝐴*

*𝑄* *𝐴* = *𝑍* *𝐴* *−* *𝑁* *𝐴* (7.414)

where *𝑍* *𝐴* is the core charge of atom *𝐴* . The cross terms between pairs of basis functions centered on different
atoms is the overlap charge and is used in ORCA to define the Mulliken bond order:


*̸*

*𝐵* *𝐴𝐵* = 2 ∑︁

*𝜇*


*̸*

*𝐴* [∑︁]

*𝜈*


*̸*

*𝐵* *𝑃* *𝐴𝐵*
*𝜇𝜈* *[𝑆]* *𝜇𝜈* *[𝐴𝐵]* (7.415)


*̸*

The Mulliken population analysis is turned on by using:


*̸*


*̸*


*̸*

A number of additional options can be specified to control the details of the Mulliken population analysis. By
default the Mulliken population analysis is turned on.


*̸*


*̸*


*̸*

(continues on next page)

**1066** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

These options allow to get very detailed information about the computed wavefunctions and is much more convenient than to look at the MOs directly. A “reduced orbital population” is a population per angular momentum type.
For example the sum of populations of each p *𝑧* orbital at a given atom is the reduced orbital population of the p *𝑧*
function.

Note that for finite temperature HF or KS-DFT calculations (SmearTemp *>* 0 K, fractional occupation numbers or
FOD analysis, see *Finite Temperature HF/KS-DFT* ), only the Mulliken reduced orbital charges based on *𝜌* *[𝐹𝑂𝐷]* will
be printed. They can be used to get a first impression about the localization of hot electrons in the molecule without
generating the corresponding FOD plot (see *FOD plots* ). The following example shows the corresponding printout
for the first carbon atom of *p* -benzyne based on a FOD analysis with default settings (see *Fractional Occupation*
*Number Weighted Electron Density (FOD)* ).

If other population analysis printouts are wanted the user is referred to the Löwdin analysis ( *Löwdin Population*
*Analysis* ) which is turned on by default using the total SCF density of the calculation, also in the case of finite
electronic temperature.

**7.53.3 Löwdin Population Analysis**

The Löwdin analysis [840] is somewhat more straightforward than the Mulliken analysis. In the Löwdin method
one changes to a basis where all overlap integrals vanish. This is accomplished via Löwdins symmetric orthogonalization matrix **S** *[−]* [1] *[/]* [2] . Using this transformation matrix the new basis functions are multicentered but are in a least
square sense as similar as possible to the original, strictly localized, atomic basis functions. The similarity of the
transformed functions and original functions is explored in the population analysis. The density matrix transforms

as:

**P** *[𝐿]* = **S** [1] *[/]* [2] **PS** [1] *[/]* [2] (7.416)

**7.53. Population Analyses and Control of Output** **1067**

**ORCA Manual** **,** **Release 6.0.1**

Then the atomic populations are:

*̸*


*𝑁* *𝐴* = ∑︁ *𝐴* *𝑃* *𝜇𝜇𝐿* (7.417)

*𝜇*

*̸*


The bond order is defined from the Wiberg index [889] that was first used in the context of semiempirical methods
(that are formulated in the Löwdin basis right from the start):

*̸*


*𝐵* *𝐴𝐵* = ∑︁

*𝜇*

*̸*


*𝐴* [∑︁]

*𝜈*

*̸*


*𝐵* [(︀] *𝑃* *𝜇𝜈* *[𝐿]* )︀ 2 (7.418)

*̸*


The output for the Löwdin population analysis (that I personally prefer over the Mulliken analysis) is closely similar.
By default the Löwdin population analysis is turned on and provides some more detail than the Mulliken analysis.

*̸*


*̸*


*̸*


The flags to regulate the details are almost identical:

*̸*


*̸*


*̸*


In addition one can set, in the method block, the threshold for the printing of the bond order.

*̸*


*̸*


*̸*


**7.53.4 Mayer Population Analysis**

Mayers bonding analysis [568, 569, 570, 571] is another creative attempt to define chemically useful indices. The
Mayer atomic charge is identical to the Mulliken charge. The Mayer bond order is defined as:

*̸*


*𝐵* *𝐴𝐵* = ∑︁

*𝜇*

*̸*


*𝐴* [∑︁]

*𝜈*

*̸*


*𝐵* ( **PS** ) *𝜇𝜈* ( **PS** ) *𝜈𝜇* + ( **RS** ) *𝜇𝜈* ( **RS** ) *𝜈𝜇* (7.419)

*̸*


Here **P** is the total electron density matrix and **R** is the spin-density matrix. These Mayer bond orders are very
useful. Mayer’s total valence for atom *𝐴* is defined as:

*̸*


*𝑉* *𝐴* = 2 *𝑁* *𝐴* *−* ∑︁

*𝜇*

*̸*


*𝐴* [∑︁] *𝐴* ( **PS** ) *𝜇𝜈* ( **PS** ) *𝜈𝜇* (7.420)

*𝜈*

*̸*


In normal bonding situations and with normal basis sets *𝑉* *𝐴* should be reasonably close to the valence of atom *𝐴*
in a chemical sense (i.e. close to four for a carbon atom). The bonded valence is given by:

*𝑋* *𝐴* = *𝑉* *𝐴* *−* ∑︁ *𝐵* *𝐴𝐵* (7.421)

*𝐵* = *̸* *𝐴*

**1068** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

and finally the free valence (a measure of the ability to form further bonds) is given by:

*𝐹* *𝐴* = *𝑉* *𝐴* *−* *𝑋* *𝐴* (7.422)

The Mayer population analysis is turned on by:



The output is rather simple and short and can not be further controlled. By default the Mayer population analysis
is turned on. In addition one can set, in the method block, the threshold for the printing of the bond order.



**7.53.5 Natural Population Analysis**

A popular and useful method for population analysis is the natural population analysis due to Weinhold and coworkers. It is implemented in the NBO interface.

**7.53.6 Local Spin Analysis**

It is common practice in various areas of chemistry to think about the interaction of open-shell systems in terms of
local spin states. For example, in dimeric or oligomeric transition metal clusters, the ‘exchange coupling’ between
open shell ions that exist locally in high-spin states is a much studied phenomenon. Diradicals would be typical
systems in organic chemistry that show this phenomenon. In quantum mechanics, however, the total spin is not a
local property, but instead a property of the system as a whole. The total spin squared, *𝑆* [2], and its projection onto
the z-axis, *𝑆* *𝑧*, commute with the non-relativistic Hamiltonian and hence, the eigenfunctions of the non-relativistic
Hamiltonian can be classified according to good quantum numbers *𝑆* and *𝑀* according to:

**S** [2] [ ⃒⃒] Ψ *[𝑆𝑀]* [⟩︀] = *𝑆* ( *𝑆* + 1) ⃒⃒Ψ *𝑆𝑀* ⟩︀

*𝑆* *𝑧* ⃒⃒Ψ *𝑆𝑀* ⟩︀ = *𝑀* ⃒⃒Ψ *𝑆𝑀* ⟩︀

where ⃒⃒Ψ *𝑆𝑀* ⟩︀ is an exact eigenfunction of the non-relativistic Hamiltonian or an approximation to it that conserves
the total spin as a good quantum number. The total spin itself is given by the sum over the individual electron spins

as:

**S** = ∑︁ **s** ( *𝑖* )

*𝑖*

And hence,

**S** [2] = ∑︁ *𝑖,𝑗* **[s]** [(] *[𝑖]* [)] **[s]** [(] *[𝑗]* [)]

is a two-electron property of the system. It is obviously not trivial to relate the chemically very meaningful concept
of local spin to a rigorous quantum mechanical treatment. While there are various proposals of how to deal with
this problem, we follow here a proposal of Clark and Davidson (Clark, A.E.; Davidson, E.R., J. Chem. Phys. 2001,
115, 7382-7392). The following equations are implemented in the SCF and CASSCF modules of Orca.

Clark and Davidson define fragment projection operators with the property:

*𝑃* *𝐴* *𝑃* *𝐵* = *𝛿* *𝐴𝐵* *𝑃* *𝐴*

and:

∑︁ *𝑃* *𝐴* = 1

*𝐴*

**7.53. Population Analyses and Control of Output** **1069**

**ORCA Manual** **,** **Release 6.0.1**

Then using this identity:


**S** = ∑︁

*𝑖*

**S** = ∑︁

*𝐴*


∑︁ **s** ( *𝑖* ) *𝑃* *𝐴* ( *𝑖* )

*𝐴*


∑︁


∑︁ **s** ( *𝑖* ) *𝑃* *𝐴* ( *𝑖* )

*𝑖*


∑︁


= ∑︁ **S** *𝐴* ( *𝑖* )

*𝐴*


they show that the local spin operators obey the standard relations for spin operators:

**S** *𝐴* = **S** *[†]* *𝐴*

**S** *𝐴* *×* **S** *𝐴* = *𝑖* ℏ **S** *𝐴*

Hence


**S** [2] = ∑︁

*𝐴*


∑︁ **S** *𝐴* **S** *𝐵*

*𝐵*


But then importantly:


**S** *𝐴* **S** *𝐵* = ∑︁

*𝑖*


∑︁ **s** ( *𝑖* ) **s** ( *𝑗* ) *𝑃* *𝐴* ( *𝑖* ) *𝑃* *𝐵* ( *𝑗* )

*𝑗*



[3]

4 *[𝛿]* *[𝐴𝐵]* ∑︁


∑︁ **s** ( *𝑖* ) **s** ( *𝑗* ) *{𝑃* *𝐴* ( *𝑖* ) *𝑃* *𝐵* ( *𝑗* ) + *𝑃* *𝐴* ( *𝑗* ) *𝑃* *𝐵* ( *𝑖* ) *}*

*𝑗>𝑖*


= [3]


*𝑃* *𝐴* ( *𝑖* ) + ∑︁
*𝐴* *𝑖*


*𝑖*


With the first- and second-order density matrix:

*𝛾* ( **x** *,* **x** *[′]* ) = *𝑁* Ψ( **x** *,* **x** 2 *, ...,* **x** *𝑁* )Ψ *[*]* ( **x** *[′]* *,* **x** 2 *, ...,* **x** *𝑁* ) *𝑑* **x** 2 *...𝑑* **x** *𝑁*
∫︁


*𝑁*
Γ( **x** 1 *,* **x** *[′]* 1 [;] **[ x]** 2 *[,]* **[ x]** *[′]* 2 [) =] Ψ( **x** 1 *,* **x** 2 *, ...,* **x** *𝑁* )Ψ *[*]* ( **x** *[′]* 1 *[,]* **[ x]** *[′]* 2 *[, ...,]* **[ x]** *𝑁* [)] *[𝑑]* **[x]** 3 *[...𝑑]* **[x]** *𝑁*
2
(︂ )︂∫︁


*𝑁*
(with (︀ 2 )︀ = [1] 2 *[𝑁]* [(] *[𝑁]* *[−]* [1)][). Then:]


*⟨* **S** *𝐴* **S** *𝐵* *⟩* = [3] 4 *[𝛿]* *[𝐴𝐵]* *[𝑡𝑟]* [(] *[𝛾𝑃]* *[𝐴]* [) + 2] *[𝑡𝑟]* [(] *[𝑃]* *[𝐴]* [(1)] *[𝑃]* *[𝐵]* [(2)] **[s]** [(1)] **[s]** [(2)Γ(1] *[,]* [ 1; 2] *[,]* [ 2))]


In terms of the number of electrons on site ‘A’and the expectation value of *𝑆* *𝑧* *[𝐴]*

⟨︀ *𝑆* *𝑧* *[𝐴]* ⟩︀ = 2 [1] *[𝑡𝑟]* [(] *[𝛾]* *[𝛼][−][𝛽]* *[𝑃]* *[𝐴]* [)]

⟨︀ *𝑁* *[𝐴]* [⟩︀] = *𝑡𝑟* ( *𝛾* *[𝛼]* [+] *[𝛽]* *𝑃* *𝐴* )


in terms of molecular orbitals:

⟨︀ *𝑆* *𝑧* *[𝐴]* ⟩︀ = [1] 2


∑︁ *𝛾* *𝑝𝑞* *[𝛼][−][𝛽]* *⟨𝑝|𝑃* *𝐴* *|𝑞⟩*

*𝑝,𝑞*



[1]

2 ∑︁


⟨︀ *𝑁* *[𝐴]* [⟩︀] = ∑︁ *𝛾* *𝑝𝑞* *[𝛼]* [+] *[𝛽]* *⟨𝑝|𝑃* *𝐴* *|𝑞⟩*

*𝑝,𝑞*


McWeeny and Kutzelnigg (McWeeny, R.; Kutzelnigg, W. Int. J. Quant. Chem. 1968, 11, 187-203) show that for
the expectation value of s(1)s(2), the relevant irreducible part of the two-body density can be expressed in terms
of the spinless density matrix of second order:


*𝑅* 0 [(0)] [(1] *[,]* [ 1] *[′]* [; 2] *[,]* [ 2] *[′]* [) =] *[ −]* [1] 3



[2]

3 [Γ(2] *[,]* [ 1] *[′]* [; 1] *[,]* [ 2] *[′]* [)]



[1]

3 [Γ(1] *[,]* [ 1] *[′]* [; 2] *[,]* [ 2] *[′]* [)] *[ −]* [2] 3



[1]

3 ∑︁


= *−* [1]


∑︁ Γ *[𝑝𝑞]* *𝑟𝑠* *[𝑝]* [(1)] *[𝑞]* [(1] *[′]* [)] *[𝑟]* [(2)] *[𝑠]* [(2] *[′]* [) + 2Γ] *[𝑝𝑞]* *𝑟𝑠* *[𝑝]* [(2)] *[𝑞]* [(1] *[′]* [)] *[𝑟]* [(1)] *[𝑠]* [(2] *[′]* [)]

*𝑝𝑞𝑟𝑠*


**1070** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**



[1]

3 ∑︁


= *−* [1]


∑︁ (Γ *[𝑝𝑞]* *𝑟𝑠* [+ 2Γ] *[𝑟𝑞]* *𝑝𝑠* [)] *[𝑝]* [(1)] *[𝑞]* [(1] *[′]* [)] *[𝑟]* [(2)] *[𝑠]* [(2] *[′]* [)]

*𝑝𝑞𝑟𝑠*


with a normalization factor of [3]

4 [after spin integration. Hence using this:]



[3] [6]

4 *[𝛿]* *[𝐴𝐵]* *[𝑡𝑟]* [(] *[𝛾𝑃]* *[𝐴]* [) +] 4


*⟨* **S** *𝐴* **S** *𝐵* *⟩* = [3]



[6] 4 *[𝑡𝑟]* [(] *[𝑃]* *[𝐴]* [(1)] *[𝑃]* *[𝐵]* [(2)] *[𝑅]* 0 [(0)] [(1] *[,]* [ 1; 2] *[,]* [ 2))]


And then performing the integral:

*⟨* **S** *𝐴* **S** *𝐵* *⟩* = [3] 4 *[𝛿]* *[𝐴𝐵]* *[𝑡𝑟]* [(] *[𝛾𝑃]* *[𝐴]* [)] *[ −]* 6 4 1 3

⏟ ⏞

1

2


∑︁ (Γ *[𝑝𝑞]* *𝑟𝑠* [+ 2Γ] *[𝑟𝑞]* *𝑝𝑠* [)] *[𝑃]* *𝑝𝑞* *[𝐴]* *[𝑃]* *𝑟𝑠* *[𝐵]*

*𝑝𝑞𝑟𝑠*


This is the final and perhaps most compact equation. The projection operator can be defined in very many different
ways. The easiest is to Löwdin orthogonalize the basis set:

⃒⃒ *𝜇* *𝐴𝐿* ⟩︀ = ∑︁ ⃒⃒ *𝜈* *𝐴* ⟩︀ *𝑆* *𝜇𝜈* *[−]* [1] *[/]* [2]

*𝜈* *[𝐴]*

where *𝐿* denotes the Löwdin basis. This means that molecular orbitals are expressed in the orthogonal basis as:

**c** *𝐿* = **S** [+1] *[/]* [2] **c**

and the density as:

**P** *𝐿* = **S** [+1] *[/]* [2] **PS** [+1] *[/]* [2]

The fragment projector is defined as:

*𝑃* *𝐴* = ∑︁ *|𝜇* *𝐿* *⟩⟨𝜇* *𝐿* *|*

*𝜇* *𝐿* *∈𝐴*

Clark and Davidson suggest a slightly more elaborate projector in which first, the intra-fragment overlap is eliminated. This happens with a matrix U that for two fragments takes form:


)︃


**U** =


**S** *[−]* *𝐴* [1] *[/]* [2] **0**
(︃ **0** **S** *[−]* *𝐵* [1] *[/]* [2]


where is the block of basis functions belonging to fragment A. Likewise:


⎞

⎟
⎠


Then the ‘pre-overlap’is:


**S** [+1] *𝐴* *[/]* [2] **0**

⎛

**U** *[−]* [1] = ⎜⎝ **0** **S** [+1] *𝐵* *[/]* [2]

**¯S** = **U** *[†]* **SU**


This contains the unit matrix in the intra-fragment blocks and non-zero elements elsewhere. This overlap matrix is
the finally orthogonalized to obtain the globally orthogonal Löwdin basis. We finally transform the MO coefficients
by the following transformation:

**c** *𝐿* = **S** [+1] *[/]* [2] **U** *[−]* [1] **c**

For the projectors, operating with the two MOs i and j gives:


*⟨𝑖|𝑃* *𝐴* *|𝑗⟩* = ∑︁

*𝜇* *𝐿* *∈𝐴*


∑︁

*𝜅* *[𝐵]* *𝐿* *[𝜏]* *𝐿* *[𝐶]*


⟨︀ *𝜅* *[𝐵]* *𝐿* *[|][𝜇]* *[𝐴]* *𝐿* ⟩︀⟨︀ *𝜇* *[𝐴]* *𝐿* *[|][𝜏]* *𝐿* *[𝐶]* ⟩︀ *𝑐* *[𝐿]* *𝜅𝑖* *[𝑐]* *[𝐿]* *𝜏𝑗*


=
∑︁ ∑︁

*𝜇* *𝐿* *∈𝐴* *𝜅* *[𝐵]* *𝐿* *[𝜏]* *𝐿* *[𝐶]*


*𝛿* *𝐴𝐵* *𝛿* *𝐴𝐶* *𝛿* *𝜅𝜇* *𝛿* *𝜏𝜇* *𝑐* *[𝐿]* *𝜅𝑖* *[𝑐]* *[𝐿]* *𝜏𝑗*


**7.53. Population Analyses and Control of Output** **1071**

**ORCA Manual** **,** **Release 6.0.1**


= *𝑐* *[𝐿]*
∑︁ *𝜇𝑖* *[𝑐]* *[𝐿]* *𝜇𝑗*

*𝜇* *𝐿* *∈𝐴*


Herrmann et al. (Herrmann, C.; Reiher, M.; Hess, B.A. J. Chem. Phys. 2005, 122, 34102) give the correct
expression of the expectation values for a single spin-unrestricted determinant


*𝑃* ¯ *[𝐴]* ¯
*𝑖𝑖*

¯ *𝑖*


}︃


*⟨* **S** *𝐴* **S** *𝐵* *⟩* = [3] 4 *[𝛿]* *[𝐴𝐵]*


{︃∑︁ *𝑖*


*𝑖* *𝑃* *𝑖𝑖* *[𝐴]* [+] ∑︁ ¯


*𝑃* ¯ *[𝐴]* ¯ ¯¯
¯ *𝑖* ¯ *𝑗* *𝑖𝑖* *[𝑃]* *𝑗* *[𝐵]* *𝑗* *[−]* ∑︁ *𝑖𝑗*


*𝑃* *[𝐴]*
*𝑖𝑗* *𝑖𝑗* *[𝑃]* *𝑖𝑗* *[𝐵]* *[−]* ∑︁ ¯ *𝑖* ¯ *𝑗*


*𝑃* ¯ *[𝐴]* ¯ ¯¯
¯ *𝑖* ¯ *𝑗* *𝑖𝑗* *[𝑃]* *𝑖* *[𝐵]* *𝑗* *[−]* ∑︁ ¯ *𝑖𝑗*


*𝑃* ¯ *[𝐴]* ¯
¯ *𝑖𝑗* *𝑖𝑖* *[𝑃]* *𝑗𝑗* *[𝐵]* *[−]* ∑︁ *𝑖* [¯] *𝑗*


*𝑃* *𝑖𝑖* *[𝐴]* *[𝑃]* ¯ *𝑗* *[𝐵]* ¯ *𝑗*
*𝑖* [¯] *𝑗*


⎫
⎬

⎭


+ [1] 4


⎧
⎨

⎩


∑︁


*𝑖𝑗* *𝑃* *𝑖𝑖* *[𝐴]* *[𝑃]* *𝑗𝑗* *[𝐵]* [+] ∑︁ ¯ *𝑖* ¯ *𝑗*


*−* *𝑃* *[𝐴]*
∑︁ *𝑖* [¯] *𝑗* *[𝑃]* *𝑖* *[𝐵]* [¯] *𝑗*

*𝑖* [¯] *𝑗*


Which is used in the Orca implementation.

The use of the Local spin-implementation is very easy. All that is required is to divide the molecule into fragments.
The rest happens automatically. For example, let us consider two nitrogen atoms at the dissociation limit. While
the total spin state is S=0, the tow nitrogen atoms local exist in high-spin states (S=3/2). Consider the following
test job:



and the output:




thus perfectly corresponding to the expectations. The same can be done at the CASSCF level:

**1072** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**



With the result:




Thus, cleanly confirming the expectations.

As a less trivial example, consider a typical Fe(III) antiferromatically coupled transition metal dimer. An appropriate input may be:




Where one of the bridging sulfurs was assigned to each site respectively.




(continues on next page)

**7.53. Population Analyses and Control of Output** **1073**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
  2 : -1.7579 2.3198

```
Nice shows the expected results with the local site spins being close to their ideal value 2.5 which would hold for
a high-spin Fe(III) ion.

**7.53.7 UNO Orbital Printing**

The analysis of UNO’s can be controlled similarly. The flags together with their default values are shown below:



**7.53.8 Hirshfeld Charges**

The partitioning method by Hirshfeld is one of the most used approaches in the so-called atoms in molecules (AIM)
methods.[394] In this case, the AIM density of atom A, *𝜌* *𝐴* ( *⃗𝑟* ) is written as:

*𝜌* *𝐴* ( *⃗𝑟* ) = *𝜌* ( *⃗𝑟* ) *𝑤* *𝐴* ( *⃗𝑟* ) (7.423)

Here, *𝜌* ( *⃗𝑟* ) is the total charge density at position *⃗𝑟*, and *𝑤* *𝐴* ( *⃗𝑟* ) a weighting function, that within the Hirshfeld
method is equal to:

*𝐴* [(] *[⃗𝑟]* [)]
*𝑤* *𝐴* ( *⃗𝑟* ) = *[𝜌]* [0] (7.424)
*𝜌* [0] ( *⃗𝑟* )

where *𝜌* [0] *𝐴* [(] *[⃗𝑟]* [)][ is the pro-atomic density of atom] *[ 𝐴]* [and] *[ 𝜌]* [0] [(] *[⃗𝑟]* [) =][ ∑︀] *𝐴* *[𝜌]* *𝐴* [0] [(] *[⃗𝑟]* [)][ the pro-molecular density. The ratio in]

eq. (7.423) is known as *stockholder* . From eqs. (7.423) and (7.424) one can calculate the Hirshfeld charges as:

*𝑄* *𝐴* [Hirsh] *[.]* = *𝑍* *𝐴* *−* *𝜌* *𝐴* ( *⃗𝑟* ) *𝑑⃗𝑟* (7.425)
∫︁

In ORCA, the pro-atomic density within the Hirshfeld method is calculated via density fitting with a set of Gaussian
s-functions per element.

The calculation of the Hirshfeld charges in ORCA is requested by writing
```
! Hirshfeld

```
in the ORCA input file, or alternatively via the `%output` block:



**1074** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


For instance, if we request the Hirshfeld charges for a water molecule:



ORCA prints the following information at the end of the output file:




**7.53.9 MBIS Charges**

The Minimal Basis Iterative Stockholder (MBIS) method is a variant of the Hirshfeld method.[870] The idea
behind this approach is that the pro-atomic density *𝜌* [0] *𝐴* [(] *[⃗𝑟]* [)][ is expanded in a minimal set of atom-centered s-type]
Slater functions *𝜌* [0] *𝐴𝑖* [(] *[⃗𝑟]* [)][:]


*𝜌* [0] *𝐴* [(] *[⃗𝑟]* [) =]


*𝑚* *𝐴*
∑︁ *𝜌* [0] *𝐴𝑖* [(] *[⃗𝑟]* [)] (7.426)

*𝑖* =1


with *𝜌* [0] *𝐴𝑖* [(] *[⃗𝑟]* [)][ equal to:]


⎞

(7.427)
⎠


*⃗*
⃒⃒ *⃗𝑟* *−* *𝑅* *𝐴* ⃒⃒
⃒ ⃒

*𝜎* *𝐴𝑖*


*𝑁* *𝐴𝑖*
*𝜌* [0] *𝐴𝑖* [(] *[⃗𝑟]* [) =]
*𝜎* *𝐴𝑖* [3] [8] *[𝜋]* [exp]


⎛⎝ *−*


Here, *𝑚* *𝐴* is the number of shells of atom *𝐴* . The populations *𝑁* *𝐴𝑖*, and the widths *𝜎* *𝐴𝑖* can be written as:

*𝑁* *𝐴𝑖* = *𝜌* ( *⃗𝑟* ) *[𝜌]* *𝐴𝑖* [0] [(] *[⃗𝑟]* [)] (7.428)
∫︁ *𝜌* [0] ( *⃗𝑟* ) *[𝑑⃗𝑟]*


1
*𝜎* *𝐴𝑖* =
3 *𝑁* *𝐴𝑖*


*𝐴𝑖* [(] *[⃗𝑟]* [)]
*𝜌* ( *⃗𝑟* ) *[𝜌]* [0]
∫︁ *𝜌* [0] ( *⃗𝑟* )


*⃗*
*⃗𝑟* *−* *𝑅* *𝐴* *𝑑⃗𝑟* (7.429)
⃒⃒⃒ ⃒⃒⃒


In order to compute the AIM densities *𝜌* *𝐴* ( *⃗𝑟* ), the MBIS method uses an iterative algorithm where: (1) an initial
guess is generated for the set of *𝑁* *𝐴𝑖* and *𝜎* *𝐴𝑖* and the pro-atomic densities are calculated through eqs. (7.426) and
(7.427), (2) the new set of *𝑁* *𝐴𝑖* and *𝜎* *𝐴𝑖* are obtained via eqs. (7.428) and (7.429), (3) if convergence is reached
for *𝜌* *𝐴* ( *⃗𝑟* ), the iterative process stops, otherwise we go back to (1) but now one uses the last estimates for *𝑁* *𝐴𝑖* and

*𝜎* *𝐴𝑖* .

Once, the MBIS iterative process stops, the MBIS charges are calculated as:

*𝑄* [MBIS] *𝐴* *[.]* = *𝑍* *𝐴* *−* *𝜌* *𝐴* ( *⃗𝑟* ) *𝑑⃗𝑟* (7.430)
∫︁

The calculation of the MBIS charges in ORCA is requested by writing

**7.53. Population Analyses and Control of Output** **1075**

**ORCA Manual** **,** **Release 6.0.1**
```
! MBIS

```
in the ORCA input file, or alternatively via the `%output` block:



If we request the MBIS charges for a HF calculation at the cc-pvdz level of a chloroform molecule:

ORCA prints the following information at the end of the output file:




The second block corresponds to the valence Slater function, which is caracterized by its population *𝑁* *𝐴,𝑣* and
width *𝜎* *𝐴,𝑣* .

The convergence threshold for the MBIS charges is set to 10 *[−]* [6] . However, it can be changed via the tag
`MBIS_CHARGETHRESH` in the `%method` block:



ORCA can also print the following MBIS-related quantities: (1) atomic dipole moments, (2) atomic
quadrupole moments, (3) atomic octupole moments, and (4) third radial moment of the MBIS density
*⃗* 3
*⟨𝑟* [3] *⟩* *𝐴* = ∫︀ [⃒] *⃗𝑟* *−* *𝑅* *𝐴* *𝜌* *𝐴* ( *⃗𝑟* ) *𝑑⃗𝑟* . The printing of these properties is controlled by the tag `MBIS_LARGEPRINT`,
( ⃒⃒ ⃒⃒⃒ )

**1076** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


to be specified in the `%method` block:



If this option is activated, an extra iteration is performed after reaching the convergence threshold for the charges.

The origin for the calculation of the atomic dipole, quadrupole and octupole moments is the center of each
atom (default). However, the user can also define a global origin (independent of the atom) through the tag
`MBIS_ORIGIN_MULT` in the `%method` block:


### **7.54 Orbital and Density Plots**

There are two types of graphics output possible in ORCA - two dimensional contour plots and three dimensional
surface plots. The quantities that can be plotted are the atomic orbitals, molecular orbitals, natural orbitals, the
total electron density or the total spin density. The graphics is controlled through the block `%plots` .

**7.54.1 Contour Plots**

The contour plots are controlled via the following variables



(continues on next page)

**7.54. Orbital and Density Plots** **1077**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**ORCA Manual** **,** **Release 6.0.1**

  - The command `MO("MyOrbital-15xy.plt",15,0);` is to be interpreted as follows: `MO` means that a MO
is to be plotted. “ `MyOrbital-15xy.plt` ” is the file to be created. `15` is the number of the MO to be drawn
(remember: counting starts at orbital 0!) and `0` is the operator the orbital belongs to. For a RHF (or RKS)
calculation there is only one operator which has number 0. For a UHF (or UKS) calculation there are two
operators - the spin-up orbitals belong to operator 0 and the spin-down orbitals belong to operator 1. For
ROHF calculations there may be many operators but at the end all orbitals will be collected in one set of
vectors. Thus the operator is always =0 in ROHF.

  - The `ELDENS` (plot of the total electron density) and `SPINDENS` (plot of the total spin density) commands
work analogous to the `MO` with the obvious difference that there is no MO or operator to be defined.

  - Analogous to `ELDENS` and `SPINDENS`, post-HF densities can be selected using the keyword extended
by the respective method. `ELDENSMDCI` / `SPINDENSMDCI` will plot the MDCI density, of course only
if is available. `ELDENSMP2RE` and `SPINDENSMP2RE` will work with the MP2 relaxed density, while
`ELDENSMP2UR` and `SPINDENSMP2UR` will yield the MP2 unrelaxed density. The OO-RI-MP2 densities
can be requested by `ELDENSOO` or `SPINDENSOO` . Similarly, AutoCI relaxed densities can be plotted by
using the `ELDENSAUTOCIRE` and `SPINDENSAUTOCIRE` keywords, and the unrelaxed densities by using
`ELDENSAUTOCIUR` and `SPINDENSAUTOCIUR` .

  - The `UNO` option plots natural orbitals of the UHF wavefunction (if they are available). No operator can be
given for this command because there is only one set of UHF-NOs. Similarly, using `UCO` option can be used
to plot the UHF corresponding orbitals.

  - If the program cannot find the plot module (“Bad command or filename”) try to use
`ProgPlot="orca_plot.exe"` in the `%method` block or point to the explicit path.

  - The defining vectors `v2` and `v3` are required to be orthonormal. The program will use a Schmidt orthonormalization of `v3` with respect to `v2` to ensure orthonormality. If you do not like this make sure that the input
vectors are already orthogonal.

   - `at1`, `at2` and `at3` can be used instead of `v1`, `v2` and `v3` . In this case say `v1` is taken as the coordinates of
atom `at1` . Mixed definitions where say `v2` is explicitly given and say `v3` is defined through `at3` are possible.
A value of -1 for `at1`, `at2` and `at3` signals that `at1`, `at2` and `at3` are not to be used. This type of definition
may sometimes be more convenient.

  - Variables can be assigned several times. The “actual” value a variable has is stored together with the command to generate a plot ( `MO`, `ELDENS` or `SPINDENS` ). Thus after each plot command the format or orientation
of the plot can be changed for the next one.

  - The `Origin` format produces a straightforward ASCII file with x, y and z values that can be read into your
favorite contour plot program or you could write a small program that reads such files and converts them to
whatever format is more appropriate for you.

  - I usually use Word for Windows to open the `HPGL` files which appears to work fine. Double clicking on the
graphics will allow modification of linewidth etc. For some reason that is not clear to me some graphics
programs do not like the HPGL code that is produced by ORCA. If you are an HPGL expert and you have a
suggestion - let me know.

**7.54.2 Surface Plots**

**General Points**

Surface plots can, for example, be created through an interface to Leif Laaksonen’s ***gOpenMol*** program. This
program can be obtained free of charge over the internet. It runs on a wide variety of platforms, is easy to use,
produces high quality graphics and is easy to interface [1] - thank you Leif for making this program available!

The relevant `[PLOTS]` section looks like this:

1 There were some reports of problems with the program on Windows platforms. Apparently it is better to choose the display settings as
“true color 32 bit” rather than “high 16 bit”. Thanks to Thomas Brunold!

**7.54. Orbital and Density Plots** **1079**

**ORCA Manual** **,** **Release 6.0.1**

NOTE:

  - it is admittedly inconvenient to manually input the dimension of the cube that is used for plotting. If you
do nothing such that `min1 = max1 = min2 = max2 = min3 = max3=0` then the program will try to be
smart and figure out a good cube size by itself. It will look at the minimum and maximum values of the
coordinates and then add 7 bohrs to each dimension in the hope to properly catch all wavefunction tails.

Sometimes you will want to produce orbital plots after you looked at the output file and decided which orbitals you
are interested in. In this case you can also run the `orca_plot` program in a crude interactive form by invoking it

as:
```
orca_plot MyGBWFile.gbw -i

```
This will provide you with a subset of the capabilities of this program but may already be enough to produce the
plots you want to look at. Note that for the name of the GBW-file you may as well input files that result from natural
orbitals (normally `*.uno` ), corresponding orbitals (normally `*.uco` ) or localized orbitals (normally `*.loc` ). Once
in the interactive program, by entering ‘1’ for ‘Enter type of plot,’ you will access a list of available plot capabilities
relevant to your current calculation file (MyGBWFile.gbw):



(continues on next page)

**1080** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

*˓→* `)` `- NOT AVAILABLE`
```
  10 - OO-RI-MP2 spin density ...... (pmp2ur ␣

```
*˓→* `)` `- NOT AVAILABLE`
```
  11 - MP2 relaxed density ...... (pmp2re ␣

```
*˓→* `)` `- NOT AVAILABLE`
```
  12 - MP2 unrelaxed density ...... (pmp2ur ␣

```
*˓→* `)` `- NOT AVAILABLE`
```
  13 - MP2 relaxed spin density ...... (rmp2re ␣

```
*˓→* `)` `- NOT AVAILABLE`
```
  14 - MP2 unrelaxed spin density ...... (rmp2ur ␣

```
*˓→* `)` `- NOT AVAILABLE`
```
  15 - LED dispersion interaction density ...... (ded21 ␣

```
*˓→* `)` `- NOT AVAILABLE`
```
  16 - Atom pair density
  17 - Shielding Tensors
  18 - Polarisability Tensor
  19 - AutoCI relaxed density ...... (autocipre ␣

```
*˓→* `)` `- NOT AVAILABLE`
```
  20 - AutoCI unrelaxed density ...... (autocipur ␣

```
*˓→* `)` `- NOT AVAILABLE`
```
  21 - AutoCI relaxed spin density ...... (autocirre ␣

```
*˓→* `)` `- NOT AVAILABLE`
```
  22 - AutoCI unrelaxed spin density ...... (autocirur ␣

```
*˓→* `)` `- NOT AVAILABLE`
```
----------------------------------------------------------------------Searching for State or Transition State AO Electron Densities: ...
----------------------------------------------------------------------  23 - CIS unrelaxed transition AO density ...... (Tdens-CIS ␣

```
*˓→* `)` `- NOT AVAILABLE`
```
  24 - ROCIS unrelaxed transition AO density ...... (Tdens-ROCIS ␣

```
*˓→* `)` `- NOT AVAILABLE`
```
  25 - CAS unrelaxed transition AO density ...... (Tdens-CAS ␣

```
*˓→* `)` `- NOT AVAILABLE`
```
  26 - ICE unrelaxed transition AO density ...... (Tdens-ICE ␣

```
*˓→* `)` `- NOT AVAILABLE`
```
  27 - MRCI unrelaxed transition AO density ...... (Tdens-MRCI ␣

```
*˓→* `)` `- NOT AVAILABLE`
```
  28 - LFT unrelaxed transition AO density ...... (Tdens-LFT ␣

```
*˓→* `)` `- NOT AVAILABLE`
```
----------------------------------------------------------------------Searching for State or Transition State MO Electron Densities: ...
----------------------------------------------------------------------  29 - CIS unrelaxed transition MO density ...... (Tdens-CISMO ␣

```
*˓→* `)` `- NOT AVAILABLE`
```
  30 - ROCIS unrelaxed transition MO density ...... (Tdens-ROCISMO ␣

```
*˓→* `)` `- NOT AVAILABLE`
```
  31 - CAS unrelaxed transition MO density ...... (Tdens-CASMO ␣

```
*˓→* `)` `- NOT AVAILABLE`
```
  32 - ICE unrelaxed transition MO density ...... (Tdens-ICEMO ␣

```
*˓→* `)` `- NOT AVAILABLE`
```
  33 - MRCI unrelaxed transition MO density ...... (Tdens-MRCIMO ␣

```
*˓→* `)` `- NOT AVAILABLE`
```
  34 - LFT unrelaxed transition MO density ...... (Tdens-LFTMO ␣

```
*˓→* `)` `- NOT AVAILABLE`
```
----------------------------------------------------------------------Searching for State or Transition State QDPT AO Electron Densities: ...
----------------------------------------------------------------------  35 - CAS QDPT unrelaxed transition AO density ...... (Tdens-CASQDSOC ␣

```
*˓→* `)` `- NOT AVAILABLE`
```
  36 - DCDCAS QDPT unrelaxed transition AO density ...... (Tdens-CASDCDQDSOC ␣

```
*˓→* `)` `- NOT AVAILABLE`

(continues on next page)

**7.54. Orbital and Density Plots** **1081**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



Fig. 7.64: The *𝜋* *[*]* orbital of H 2 CO as calculated by the RI-BP/VDZP method.

**1082** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**FOD plots**

The fractional occupation number weighted electron density ( *𝜌* *[𝐹𝑂𝐷]*, see *Fractional Occupation Numbers* ) can be
plotted in 3D for a pre-defined contour surface value which, after extensive testing, was set to the default value of
*𝜎* = 0 *.* 005 e/Bohr [3] . In order to allow comparison of various systems this value should be kept fix (in critical cases,
one may also check the FOD plot with a a smaller value of *𝜎* = 0 *.* 002 e/Bohr [3] for comparison). The FOD is strictly
positive in all space and resembles orbital densities (e.g., *𝜋* -shape in large polyenes) or the total charge density for
an ideal ‘metal’ with complete orbital degeneracy in trivial cases. FOD plots represent a cost-effective and robust
way to identify the ‘hot’ (strongly correlated) electrons in a molecule and to choose appropriate approximate QC
methods for a subsequent computational study of the systems in question. Based on our experience, the following
rules of thumb can be derived:

  - no significant *𝜌* *[𝐹𝑂𝐷]* : use (double)-hybrid functionals or (DLPNO-)CCSD(T) (single-reference electronic
structure)

  - significant but rather localized *𝜌* *[𝐹𝑂𝐷]* : use semi-local GGA functionals (or hybrid functional with low Fockexchange, avoid HF or MP2; slight multi-reference character)

  - significant *and* delocalized *𝜌* *[𝐹𝑂𝐷]* : use multi-reference methods (or finite temperature DFT; strong multireference character)

Basically, *𝜌* *[𝐹𝑂𝐷]* can be plotted analogously to an electron density calculated with ORCA using `Basename.`
`scfp_fod` instead of `Basename.scfp` . The required `Basename.scfp_fod` is stored in the `Basename.`
`densities` container. To print all available densities use the `9 - List all available densities` in
`orca_plot` :



Note that producing `*.cube` files with `orca_plot` (see *orca_plot* ) may take a considerable amount of time for
larger molecules, particularly if high quality plots for publication purposes (i.e., 120x120x120 resolution) are
wanted. An example FOD plot (singlet ground sate of *𝑝* -benzyne, see *Fractional Occupation Numbers* for the
corresponding ORCA input) is shown in Fig. 7.65. It has been produced with the ***UCSF CHIMERA*** program (this
[program can be obtained free of charge over the internet: https://www.cgl.ucsf.edu/chimera/) using the](https://www.cgl.ucsf.edu/chimera/) `*.cube`
file generated with `orca_plot` :



It is also possible to generate `*.cube` files from *𝜌* *[𝐹𝑂𝐷]* (analogously to electron density plots) with other programs
that can read ORCA `BaseName.gbw` and electron density files by simply using the `Basename.scfp_fod` file instead
of the `Basename.scfp` file.

**7.54. Orbital and Density Plots** **1083**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.65: FOD plot at *𝜎* = 0 *.* 005 e/Bohr [3] (TPSS/def2-TZVP (T = 5000 K) level) for the [1] *𝐴* *𝑔* ground state of
*𝑝* -benzyne (FOD depicted in yellow).

The significant and rather delocalized FOD for *𝑝* -benzyne ( [1] *𝐴* *𝑔* ) indicates that multi-reference methods would be
needed for reliable computational study of this molecule (category c)). More examples of FOD plots generated
with the same setup and programs can be found in the original publication and corresponding supplementary
information.[327]

**Interface to gOpenMol**

Here is a short summary of how to produce these plots with gOpenMol:

  - First of all the molecular geometry must be save by choosing `XYZFile=true` in the `[OUTPUT]` block. This
will produce a straightforward ascii file containing the molecular geometry (or simply `! XYZFile` ).

  - After having produced the plot files start ***gOpenMol*** and choose ***File-Import-Coords*** . In the dialog choose
the *XYZ* format and select the file. Then press ***apply*** and ***dismiss*** . The molecule should now be displayed in
the graphics window.

  - You can change the appearance by choosing ***View-Atom type*** .

  - The color of the background can be changed with ***Colour-Background*** .

  - After having done all this choose ***Plot-Contour*** and select the ***Browse*** button to select the appropriate
file. Then press ***Import File*** to read it in. NOTE: you can only directly read files that were produced in
`gOpenMol_bin` format. If you have chosen `gOpenMol_ascii` you must first use the ***gOpenMol*** file conversion utility under ***Run-Pltfile (conversion)*** to produce the binary plt file.

  - After having read the plt file choose the appropriate isocontour value (one for the positive and one for the
negative lobes of an orbital) and select suitable colors via ***Colour(n)*** to the right of the isocontour value. The
***Details*** button allows you to choose between solid and mesh representation and other things.

**1084** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

  - Once the plot looks the way you like, use ***File-Hardcopy*** to produce a publication quality postscript or bitmap
picture that can be imported into any word processing or graphics software.

**Interface to Molekel**

[The Molekel program (http://ugovaretto.github.io/molekel/) is another beautiful and easy-to-use graphics tool that](http://ugovaretto.github.io/molekel/)
is recommended in combination with ORCA. You may even find it a little easier to use than gOpenMol but this
may be a matter of personal taste. In order to produce plots with Molekel follow the following procedure:

  - Produce Gaussian-Cube files (and optionally also an XYZ file) with ORCA as described above.

  - Start Molekel and use the right mouse button to obtain the **Load** menu.

  - Choose the format **xyz** to load your coordinates

  - Use the right mouse button again to select the **Surface** menu

  - Choose the format “Gaussian Cube” and click **Load Surface**

  - Click on **Both Signs** if you visualize an orbital or spin density

  - Select a suitable contour value in the **Cutoff** box.

  - Click on **Create Surface** . That’s it!

  - In the **Color** menu (also available via the right mouse button) you can adjust the colors and in the main menu
the display options for your molecule. Default settings are in a startup file that you can modify to suit your
taste. More details are in the Molekel manual – check it out; it can do many other useful things for you too!
### **7.55 Utility Programs**

**7.55.1 orca_mapspc**

This utility program is used to turn calculated spectra into a format that can be plotted with standard graphics
programs. The usage is simple (for output examples see for example sections *Semiempirical Methods*, *IR Spectra*,
*Raman Spectra* and *Resonant Inelastic Scattering Spectroscopy* ):



The exact abilities of `orca_mapspc` can be seen by simply executing the command in a terminal
```
orca_mapspc

```
Then one gets:

**7.55. Utility Programs** **1085**

**ORCA Manual** **,** **Release 6.0.1**



NOTE:

  - The input to this program can either be a normal output file from an ORCA calculation or a ORCA .hess file
if IR or Raman spectra are desired

  - Unless it is specified otherwise the default lineshape is always assumed to be a Gaussian

  - There will be two output files:

**–** `Input-file.spc.dat` (spc=abs-like or cd or ir or raman): This file contains the data to be plotted

**–**
`Input-file.spc.stk` : This file contains the individual transitions (wavenumber and intensity)

  - The absorption plot has five columns: The first is the wavenumber in reciprocal centimeters, the second the
total intensity and the third to fifth are the individual polarizations (i.e. assuming that the electric vector of
the incoming beam is parallel to either the input x-, or y- or z-axis respectively). The last three columns are
useful for interpreting polarized single crystal spectra.

  - Generation of multiple spectra. When more than one spectra of the same kind are available the program will
try to plot them. For example in the case of a CASSCF calculation with the NEVPT2 flag on, there will be
two Absorption spectra (CASSCF and NEVPT2) that can be ploted

**1086** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

For example:
```
orca_mapspc My-CASSCF/NEVPT2-Output.out SOCABS -x07000 -x18000 -eV -n10000 -w2.0 -l

```


This will generate two kind of spectra one for the CASSCF and one for the NEVPT2 calculation



Other Absorption or CD spectra can also be generated in the same way.

**7.55.2 orca_chelpg**

This program calculates CHELPG atomic charges according to Breneman and Wiberg[124]. The atomic charges
are fitted to reproduce the electrostatic potential on a regular grid around the molecule, while constraining the sum
of all atomic charges to the molecule’s total charge. An additional constraint can be added, so the CHELPG charges
also reproduce the total dipole moment of the molecule.

The program works with default values in the following way:
```
orca_chelpg MyJob.gbw

```
The program uses three adjustable parameters, which can also be set in a separate chelpg input block



**7.55. Utility Programs** **1087**

**ORCA Manual** **,** **Release 6.0.1**

In this case, ORCA automatically calculates the CHELPG charges at the end of the calculation. Automatic calculation of CHELPG charges using the default values can also be achieved by specifying
```
! CHELPG

```
in the simple input section. By default the program uses the COSMO VDW radii for the exclusion of gridpoints
near the nuclei, as these are defined for all atoms. The BW radii are similar, but only defined for very few atom

types.

The charges may exhibit some dependence on the molecule’s orientation in space, or some artificial variations in
symmetric molecules. These effects can be minimized by increasing the CHELPG grid size, either by setting the
GRID parameter in the CHELPG block, or in the one-liner via
```
! CHELPG(LARGE)

```
If one wants that the calculated CHELPG charges reproduce the total dipole moment of the molecule, as well as
the electrostatic potential, then the following tag has to be added to the %chelpg block:



In particular, the constraint affects the *𝑥*, *𝑦*, *𝑧* components of the total dipole moment, so they reproduce the exact 3
components of the total dipole moment calculated via one-electron integrals.

**7.55.3 orca_pltvib**

This program is used in conjunction with gOpenMol (or xmol) to produce animations or plots of vibrational modes
following a frequency run. The usage is again simple and described in section *Animation of Vibrational Modes*
together with a short description of how to produce these plots in gOpenMol.

The program produces 20 frames of animation, where first and last frame correspond to the TS, all others calculated
as *𝑠𝑖𝑛* (2 *𝜋𝑓𝑟𝑎𝑚𝑒/* 20 *−* 1) ** 𝑑𝑖𝑠𝑝𝑙𝑎𝑐𝑒𝑚𝑒𝑛𝑡* .

**7.55.4 orca_vib**

This is a small “standalone” program to perform vibrational analysis. The idea is that the user has some control
over things like the atomic masses that enter the prediction of vibrational frequencies but are independent of the
electronic structure calculation as such.

The program takes a “ `.hess` ” file as input and produces essentially the same output as follows the frequency
calculation. The point is that the “ `.hess` ” is a user-editable textfile that can be manually changed to achieve
isotope shift predictions and the like. The usage together with an example is described in section *Isotope Shifts* . If
you pipe the output from the screen into a textfile you should also be able to use `orca_mapspc` to plot the modified
IR, Raman and NRVS spectra.

**7.55.5 orca_loc**

Localization is a widely used technique nowadays. By defining different functionals, various localization methods
are established. The most favorable localization methods are developed by Foster-Boys and Pipek-Mezey. In
ORCA there are four different localization methods available, the Pipek-Mezey method (PM), the Foster-Boys
method (FB), the intrinsic atomic orbitals (IAO) based PM method and the IAO based FB method.

For Foster-Boys localization there are three different algorithms: first there is the conventional algorithm (FB).
Second, there is an alternative algorithm (NEWBOYS), which is faster and could be used, for example, to localize
the virtual MOs of a large system.

The third Foster-Boys algorithm is based on an augmented Hessian procedure (AHFB). It is particularly suited
to obtain very tightly converged orbitals if an appropriate tolerance is requested (useful for local correlation).

**1088** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Furthermore, it systematically converges towards a local minimum, rather than a different type of stationary point.
The method proceeds in three stages. An initial set of localized orbitals is obtained through the NEWBOYS method.
This is followed by an augmented Hessian maximization (rational function optimization) either with direct or with
Davidson diagonalization, depending on the number of orbitals. Efficiency is therefore achieved for small and
large systems alike. If the optimization fails to proceed but the augmented Hessian has got the correct eigenvalue
structure, a Newton-Raphson maximization is triggered as the third stage. Currently, the only user-adjustable
parameter of the AHFB method is the tolerance Tol. Convergence is signalled when the eigenvalue structure is
correct, and the largest element of the orbital gradient, 4 *⟨𝑖|* **r** *|𝑗⟩* ( *⟨𝑗|* **r** *|𝑗⟩−⟨𝑖|* **r** *|𝑖⟩* ), is below Tol. This is different
from the other localization methods, which take the difference in the localization sum between two successive
iterations as the convergence criterion.

The intrinsic atomic orbitals and intrinsic bond orbitals **(IAOIBO)** localization method is developed by Gerald
Knizia, see Ref. [449]. In IAOIBO method, the occupied MOs are projected to a minimal basis set to get the IAOs,
firstly. In ORCA different from original IAOIBO method, the converged SCF MO of atoms are used instead of
Huzinaga MINI or STO-3G. However, the IAO charges computed by our method are quite similar to original IAO.
Then, Pipek-Mezey functional is employed to localize these IAOs to IBOs. Finally,IBOs will be backtransformed
to their original basis set. The IAO partial charges of canonical MOs for each atom is also printed out before the
IAOIBO localization. But make sure you have included all occupied MOs in the IAOIBO localization. Otherwise,
the IAO charges are meaningless. We further improved the original IAOIBO method by using the FB functional
instead of PM functional. The computational time of the new method named **IAOBOYS** should be faster than the
standard FB method for large systems. However, the IAO based method can only be used for the localization of
occupied MOs.

There are two ways to do the MO localization in ORCA . The simpler way is to request the localization at the end
of any ORCA calculation input file. Details are set in the %loc block.



The localized MOs are obtained iteratively. Convergence is achieved when the localization functional value is
self-consistent (contraled by Tol). Setting the flags OCC/VIRT to true will request a localization of the subspace.
If both flags are set, two consecutive localizations are performed. The localized orbitals are stored in the form of a
standard GBW file named *.loc* . Keep in mind that the localization of the occupied orbitals might change the total
energy depending on what type of calculation you want to perform thereafter. For RHF and UHF there shouldn’t
be any problems, but for CASSCF the keyword OCC is not sufficient. **CASSCF is not invariant to rotation of** ***all***
**the occupied orbitals.**
The other way to do the localization is calling the `orca_loc` program directly from shell, which is more general.
The `orca_loc` program requires an input of its own. The input is a textfile containing the necessary parameters.
If no input is specified, `orca_loc` returns a help-file with a description of the necessary input-parameters. You
need to specify in/output gbw-files, along with orbital ranges and the localization method to be used. A source of

**7.55. Utility Programs** **1089**

**ORCA Manual** **,** **Release 6.0.1**

confusion is the operator line op (alpha = 0 or beta = 1). For RHF(ROHF) and CASSCF, this should be set to
zero. The input file usually looks like,



If the input file is called myloc.inp, running “orca_loc myloc.inp” will produce the Myjob.loc.gbw file containing
the localized orbitals. Please make sure the Myjob.gbw is in the same directory as myloc.inp.

**7.55.6 orca_blockf**

This utility program allows the canonicalization of orbitals (.gbw file) for arbitrary subspaces. With canonicalization we refer to the block diagonalization of the Fock matrix. Note that the necessary Fock matrix must be
generated and be available on disk prior calling `orca_blockf` . The program is described in section *Local Zero-*
*Field Splitting*, where the Local ZFS decomposition is discussed.

**7.55.7 orca_plot**

Orca_plot is a utility program that can be used to generate 2D and 3D graphics of various types of orbitals and
densities during an ORCA run. It can in principle called in two ways:

1) Within a calculation input via the %block section. This is described in section *Orbital and Density Plots* . In
this way it can be used to create graphics (2D) or (3D) data for visualization.

2) It is also possible to run this program interactively. The input parameters are:



You will then get a simple, self-explaining menu that will allow you to generate a variety of files (such as `.plt`
and `.cube` ) directly from the `.gbw` files without restarting or running a new job. If needed, the -m-option allows
to control the memory usage of your plotting job.

The listed utilities are printed by writing in the terminal
```
orca_plot my.gbw -i

```


(continues on next page)

**1090** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



**Perform Orbital Plots**

Let’s assume the pyridine molecule in the following input:

We can select to plot the HOMO from the list of Occupied Orbitals



For this we modify options `2`, `3`, `4` and `8` as:




(continues on next page)

**7.55. Utility Programs** **1091**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

And we generate the plot as:



We can now use any visualization software e.g. chimera to plot the generated HOMO 20 orbital:(Figure: Fig. 7.66)

Fig. 7.66: Pyridine HOMO

**List of Density Plots**

If a density instead of an orbital plot is required options `1` and `9` can be used to list the available densities.

For example option `1` in the above example will provide the computed available densities.



(continues on next page)

**1092** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



In this case the (scf) electron density is available and can be chosen to be visualized in a similar process as described
above for the orbitals.



While Option `9` will give us the name of this density:



Following the above steps we can visualize the SCF electron density of pyridine



(continues on next page)

**7.55. Utility Programs** **1093**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



(Figure: Fig. 7.67)

**Perform Algebraic Operations**


Fig. 7.67: Pyridine SCF Electron Density


Starting from ORCA 6 one can perform simple Algebraic Operations with the computed densities. The presently
available operations are listed in menu option `10` :



The important step to these processes is to make sure that the desired State or Transition State Densities are available
in the Densities file. To achieve this, one should request the desired densities to be stored in the disk after the
calculation is executed by the commands `!KeepDens` or `!KeepTransDensity` . Please NOTE that storage of
several hundreds or thousands of these densities need to be done with care from the user’s perspective as they
might occupy several hundreds of GB disk space!

Let us in addition on top of the SCF calculation of pyridine perform a canonical CCSD calculation with the following input:

**1094** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Option `1` in the `orca_plot` menu will now provide us with both the scf and mdci electron densities.



Hence we can proceed and in option `2` of the `Available Algebraic Operations` menu take their difference to
produce the respective CCSD - HF electron correlation electron density as:




(continues on next page)

**7.55. Utility Programs** **1095**

**ORCA Manual** **,** **Release 6.0.1**


(continued from previous page)



We can directly visualize the produced `pyridine_ccsd.scfp_minus_pyridine_ccsd.mdcip.cube`

(Figure: Fig. 7.68)

Fig. 7.68: Pyridine CCSD-HF Electron Density

NOTE: The generated density is stored in the Density Container so that it can be further processed or properly
stored for future use



Another useful utility option of `orca_plot` is that is able to generate Natural Transition Orbitals (NTOs) of Natural
Difference Orbitals (NDOs) from any theory level available State or Transition Density. Let us show case an
example. We now perform a SA-CASSCF (7,8) calculation on the pyridine molecule according to the input where
we make sure that all relevant densities are kept on disk after the calculation by adding the `KeepTransDensity`
in the keyword list.



(continues on next page)

**1096** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



Indeed after the calculation we now have besides the CASSCF electron densities all the relevant CASSCF State

and Transition densities become now available.



We can now set ourselves to generate the NTOs and NDOs dominating the computed State 1



Hence by using options `6 =>NTOs` or `7 =>NDOs` of the `Available Algebraic Operations` menu, and processing the respective:

**7.55. Utility Programs** **1097**

**ORCA Manual** **,** **Release 6.0.1**

1) AO Transition densities *𝐷* 01 for NTOs



2) AO State densities *𝐷* 00 *−* *𝐷* 11 for NDOs



(continues on next page)

**1098** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



It is possible to produce the corresponding Donor and Acceptor NTOs and NDOs orbital pairs which can be readily
visualized in:

(Figure: Fig. 7.69)

**7.55. Utility Programs** **1099**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.69: Pyridine SA-CASSCF(8,7) NTO/NDO donor/acceptor orbital pairs for State 1

NOTE: It is beneficial and more correct to always process the AO basis Densities. In particular it is not possible
nor is correct to process reduced MO basis Densities.

**Additional TIPS regarding Density Plots**

1) As an alternative to menu option `9` one can check, which densities are available, directly in the calculation
directory by reading out the list of all densities contained in the densities-file:
```
orca_plot mymol.densities

```
2) When `orca_plot` is used for very expensive plots, it even can be called in parallel mode:
```
mpirun -np 4 /orca_path/orca_plot_mpi MyGBWFile.gbw -i MyGBWFile

```
3) It is possible to use `orca_plot` to create difference densities between the ground and excited states from CIS
or TD-DFT calculations directly from the .cis calculation information. This is implemented as an extra interactive menu point that is (hopefully) self-explanatory. Starting from ORCA 6 one can use the `Algebraic`
`Operations` utility menu to carry out these operations directly from the generated State and Transition
Densities.

**7.55.8 orca_2mkl: Old Molekel as well as Molden inputs**

This little utility program can be used to convert gbw files into mkl files which are of ASCII format. This is useful
since molekel can read these files and use them for plotting and the like. The contents of the mkl file is roughly
the same as the gbw file (except for the internal flags of ORCA) but this is an ASCII file which can also be read
for example by your own programs. It would therefore be a good point for developing an interface. It is likely that
this functionality will be further expanded in the future.



**1100** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

We have recently also added the capability to convert any gbw type file into MKL or Molden format. Thus, you
can use this device to vizualize QRO or UNO or UCO orbitals or any type of natural orbitals:



You also have the opportunity to run `orca_2mkl` backwards in order to produce gbw type files. You can use
this device in order to import orbitals from other sources into ORCA. This is not a frequently used option and
it has limited capabilities. Hence, it is documented here only in a cursory way in order for you to be able to
experiment. Note that the CASSCF tutorial, that supplements the manual, shows how to edit the molecular orbitals
using `orca_2mkl` .



**7.55.9 orca_2aim**

This utility program reads a `.gbw` file and creates a `.wfn` and `.wfx` file that can be used for topological analysis of
the electron density by other programs. This works for open-shell and closed-shell wave functions. The usage is
very simple – just type `AIM` in the simple input line of your input file, or use



**7.55.10 orca_vpot**

This program calculates the electrostatic potential at a given set of user defined points. It can be used with either
an input file or in interactive mode. It needs four arguments:
```
orca_vpot MyJob.gbw MyJob.scfp MyJob.vpot.xyz MyJob.vpot.out

```
*First* : The `gbw` file containing the correct geometry and basis set

*Second* : The desired density matrix in this basis (perhaps use the `KeepDens` keyword)

*Third* : an ASCII file with the target positions in AU, e.g.



*Fourth* : The target file which will then contain the electrostatic potential, e.g.



It should be straightforward for you to read this file and use the potential for whatever purpose.

There are some special ways to call orca_vpot: A call for use in parallel mode
```
mpirun -np 4 /full_path/orca_vpot_mpi MyJob.gbw MyJob.scfp MyJob.pot.xyz MyJob.pot.out

```
A call to check, which densities are available in MyJob.densities,

**7.55. Utility Programs** **1101**

**ORCA Manual** **,** **Release 6.0.1**
```
orca_vpot MyJob.densities

```
will give you a listing of all densities contained in the file.

In the case that basename of gbw- and densities-file do not match, you have to pass the densities’ name as fifth

argument to orca_vpot.
```
orca_vpot MyJob.gbw OtherJob.scfp MyJob.pot.xyz MyJob.pot.out OtherJob

```
A call to orca_vpot without any arguments will display a help message.

**7.55.11 orca_euler**

This utility program is used to calculate the relative orientation between calculated hyperfine coupling
(HFC)/nuclear quadrupole coupling (NQC) tensors and a reference tensor (the calculated molecular g-/D-tensor).
The `orca_euler` program is run by default in an ORCA job after the calculation of HFCs or NQCs, if g- or Dtensor are also calculated in the same job. The utility program can also be run as a stand-alone program. In this
case the `.property.txt` file of a previous NQC/HFC- and D- or g-tensor calculation must be available.

The orientation between the tensors is calculated in terms of a 3x3 rotational matrix R. This is parametrized by the
three so-called Euler angles *𝛼*, *𝛽* and *𝛾* . These angles define the relative orientation between two tensors A and
B by three successively applied rotations around different axes in order to align A with B. In the commonly used
z-y-z convention these three rotations are:

   - **Rotate A** *𝑥𝑦𝑧* **counterclockwise around its** *𝑧* **axis by** *𝛼* **to give A** *𝑥* *′* *𝑦* *′* *𝑧* *′* **.**

   - **Rotate A** *𝑥* *[′]* *𝑦* *[′]* *𝑧* *[′]* **counterclockwise around its** *𝑦* *[′]* **axis by** *𝛽* **to give A** *𝑥* *[′′]* *𝑦* *[′′]* *𝑧* *[′′]* **.**

   - **Rotate A** *𝑥* *′′* *𝑦* *′′* *𝑧* *′′* **counterclockwise around its** *𝑧* *[′′]* **axis by** *𝛾* **to align with B.**

NOTE:



  - By default the D-tensor is used as reference tensor only if *𝑆*   - [1] 2 [and if D>0.3 cm] *[−]* [1] [; in all other cases the]

g-tensor is used as reference tensor. The user can manually select the reference tensor – if the information
is available in the prop-file – by using – `refg` or - `refD` .

  - By default the Euler rotation in the z-y-z convention is used. The z-x-z convention can be selected manually
by using the option – `conv zxz` .

  - By default the axes of the g- or D-tensor are assigned depending on their magnitude. g min *→* *𝑔* *𝑥*, g mid *→* *𝑔* *𝑦*,
g max *→* *𝑔* *𝑧* (similarly for D). This ordering can be modified manually when running the standalone program
as shown in the following examples:

**1102** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**







  - The nuclear hyperfine and quadrupole coupling tensors can be plotted (in the xyz-file format) by the
`orca_euler` program using – `plotA` or – `plotQ` . The HFC tensor for atom 3 (counting starts at zero) is
e.g. stored in the file `prop-file.3.A.xyz`, the respective NQC tensor is stored in `prop-file.3.Q.xyz` .
In these xyz files the position of four atoms (He, Ne, Ar, Kr) is given. The x-, y- and z-direction of the tensor
are in the direction of the vectors between He-Ne, He-Ar and He-Kr.

  - The actual definition of the used rotation matrix and more information on the relative orientation can be
printed by using the option – `detail` .

**7.55.12 orca_exportbasis**

A small utility program to print out the basis sets used by ORCA. Its usage requires at least the name of the basis
set, as specified in the simple input line of ORCA. Additional parameters like an ECP basis set, a list of specific
atoms or the name of an ouput file are accepted. The output is stored in ASCII format, it can be inspected and
modified. The user can choose to print the basis sets in either `ORCA` format, which then can be copied into the input
file, or in `GAMESS-US` format, which can be read via the %basis block as externally specified basis. **NOTE:** Basis
set names containing special characters may need a pair of enclosing “ or ‘ to be recognized.




(continues on next page)

**7.55. Utility Programs** **1103**

**ORCA Manual** **,** **Release 6.0.1**


(continued from previous page)



The output stored in `GAMESS-US` format can be used in the %basis block of the next ORCA calculation.



**7.55.13 orca_eca**

This utility program makes use of the calculated exchange coupling constants to compute relative energies of all
possible spin states through diagonalization of spin Hamiltonian. The absolute and relative energies of the spin
states are printed in the `*.en` and `*.en0` files respectively. The on-site spin expectation values are also printed
in a `*.sp` file.The following example calculates the spin ladder for a system with exchange coupling constant of
-152.48 cm**-1 between Mn(III) and Mn(IV).



**7.55.14 orca_pnmr**

`orca_pnmr` calculates the paramagnetic contribution to the NMR shielding tensor from EPR *𝑔*, *𝐴*, and *𝐷* tensors
(see Section *Paramagnetic NMR shielding tensors* for theoretical background). It is a standalone program which
you can invoke on the command line after the main ORCA calculation has finished. Alternatively, it can read userprovided *𝑔* / *𝐴* / *𝐷* tensors from an input file (option `-i` ). Note that `orca_pnmr` expects *𝑔* and *𝐴* tensors that conform
to the convention described in Section *Cartesian Index Conventions for EPR and NMR Tensors* .



When called without options, `orca_pnmr` will attempt to extract *𝑔*, *𝐷*, and *𝐴* tensors from the property file
`BaseName.property.txt` and use these to calculate the paramagnetic shieldings at 298 K. Note that this functionality is not sophisticated: it only recognizes EPR tensors calculated by the EPRNMR module. A more flexible way
to use the capabilities of `orca_pnmr` is to manually edit the textfile `BaseName.pnmr.inp` and then run `orca_pnmr`
with the `-i` option. The file has the following format:

**1104** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**




   - *𝐷* and *𝑔* tensors are optional: if they are not supplied `orca_pnmr` will assume the isotropic free-electron
value for *𝑔*, and *𝐷* to be zero.

   - *𝐴* tensors, however, are not optional; without an *𝐴* tensor for a given nucleus, the pNMR shielding cannot
be calculated for that nucleus.

**7.55.15 orca_lft**

Starting from ORCA 5.0, ORCA features a standalone multiplet program called orca_lft.

  - Orca_lft is dedicated to experimental spectroscopists.

  - It is able to run an arbitrary number of spectra simulations with emphasis on X-ray spectroscopies.

In this section we briefly review the main functionalities of orca_lft. For a more detail description and examples
discussion please refer to the orca_lft tutorial.

1. The goal is to be able to compute various spectroscopic properties of a given LFT center (ion) if one can
manually pass the information of 1 and 2 electron integrals in the form of e.g the diagonal elements of the
LFT matrix (LFT orbital energies) and the Slater-Condon parameters of a given LFT problem.

2. This will allow the experimental spectroscopist to perform a massive amount of spectra simulations during
the actual running experiments

Any LFT problem can be parametrized in terms 1-electron *𝐻* *𝐿𝐹* matrix elements and the Slater-Condon 2-electron
integrals F0, F2, F4, (or the Racah parameters A, B, C, of the d-shell). (Figure: Fig. 7.70)

Fig. 7.70: Definition of an LFT problem in terms of 1-electron energies and Slater Condon parameters (SCPs)

In practice we need to know:

**7.55. Utility Programs** **1105**

**ORCA Manual** **,** **Release 6.0.1**

1. the Slater Condon parameters of a given LFT problem

2. the *𝐻* *𝐿𝐹* matrix elements or the relation of them (ligand field splitting, 10Dq, AOM model)

The design workflow of orca_lft is the following:

  - Solve the General CI problem on a User-specified LFT problem: Type of Ion, Number of Electrons, Involved
Shells, Involved Multiplicities

  - Compute All possible Non Relativistic States/Multiplicity

  - Compute the Transition Densities on the CSFs basis

  - Compute the Needed transition Moments in the given LFT basis (i.e. 2p3d)

  - Compute various properties with emphasis to X-ray spectroscopy (ABS, XAS, XES, RIXS) at the Non Relativistic Limit

  - Compute the respective Relativistically corrected States on the Quasi Degenerate Perturbation Theory basis

  - Provide access to various relativistically corrected properies (ABS, XAS, XES, RIXS, MCD, XMCD, GTensors, Dtensors, Hyperfine Couplings, Electric Field Gradients)

orca_lft requires its own input. By simply executing it from the terminal
```
orca_lft

```
one gets printings of the Usage:



various Run Options:




(continues on next page)

**1106** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



and various Spectra Simulation Options:

(continues on next page)

**7.55. Utility Programs** **1107**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
************************************************************************************************************
----------------------------------------------------------------------------------------------
```
*˓→* `-------------`
```
TIP: Switch ON a Property calculation as DoProperty true:
----------------------------------------------------------------------------------------------
```
*˓→* `-------------`
```
----------------------------------------------------------------------------------------------
```
*˓→* `-------------`
```
General Input Parameters:
----------------------------------------------------------------------------------------------
```
*˓→* `-------------`
```
NEl Sets the number of electrons
Shell_PQN Sets the principle quantum number per type of shells (s,p,d,f)
LFTCase !!!ALTERNATIVE TO Shell_PQN!!! Sets the given LFT problem (2p3d,␣

```
*˓→* `1s3p3d, ...)`
```
----------------------------------------------------------------------------------------------
```
*˓→* `------------`
```
LFTCase WILL replace Shell_PQN
----------------------------------------------------------------------------------------------
```
*˓→* `------------`
```
(e.g. Shell_PQN = 0,2,3,0 for a 2p3d calculation)
Mult Sets the Multiplicity/Multiplicities
NRoots Sets the number of Roots/Multiplicity
TMultiplets (0.01) Threshold for the Multiplets grouping in eV
DoeV All values in eV. This is default. If set false the cm-1 unit is␣

```
*˓→* `used throughout`
```
DoRAS Requests a RASCI calculation
RAS(nel: m1 h/ m2 / m3 p) Computes the X-Ray Emission Spectra
RAS-reference with nel electrons
m1= number orbitals in RAS-1
h = max. number of holes in RAS-1
m2= number of orbitals in RAS-2 (any number of electrons or holes)
m3= number of orbitals in RAS-3
p = max. number of particles in RAS-3
DoElastic Computes in addition the Elastic Scattering terms in RIXS/

```
*˓→* `RIXSSOC calculations`
```
----------------------------------------------------------------------------------------------
```
*˓→* `-------------`
```
Non Relativistic Spectroscopic Properties:
----------------------------------------------------------------------------------------------
```
*˓→* `-------------`
```
DoABS/DoXAS Computes the Absorption like Spectra
DoCD Computes the CD Spectra
DoXES Computes the X-Ray Emission Spectra
DoRIXS Computes the RIXS Spectra
DoQuadrupole Computes the ABS,XAS,RIXS Spectra beyond dipole approximation
----------------------------------------------------------------------------------------------
```
*˓→* `-------------`
```
Relativistically Corrected Spectroscopic Properties:
----------------------------------------------------------------------------------------------
```
*˓→* `-------------`
```
DoSOC Requests the Spin Orbit Coupling Calculations
Note that this turned on automatically if zeta SOC
constant are provided
----------------------------------------------------------------------------------------------
```
*˓→* `-------------`
```
DoABS/DoXAS Computes the SOC Corrected Absorption like Spectra

```
(continues on next page)

**1108** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



Orca_lft can run standalone by processing an input file (Basename.lft.inp) with orca_lft
```
orca_lft BaseName.lft.inp -sim

```
Alternatively, one can call the main orca program like
```
orca BaseName.lft.inp

```
**7.55. Utility Programs** **1109**

**ORCA Manual** **,** **Release 6.0.1**

The different benefits of the two runs are provided in the orca_lft tutorial

Orca_lft can also be used to automatically generate initial proper input files. For example, by running
```
orca_lft BaseName -pd_case

```
will generate an initial basename.lft_pd.inp input.



This will generate a bare input. One has to fill in the required LFT parameters and the desired spectroscopic
properies and start the simulations like in every common multiplet program.



(continues on next page)

**1110** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Special initial inputs based on an internal NEVPT2 data base can also be generated. For the 2p3d LFT case of NiII
this will look like this
```
orca_lft BaseName -atno28 -2p3d_case

```
This will generate the following imput where the LFT parameters are filled in from an internal NEVPT2 database
from precomputed CASCI/NEVPT2 AILFT LFT parameters

In the case of *𝑁𝑖* *[𝐼𝐼]* this will look like this. This is basically a ready to run input.




(continues on next page)

**7.55. Utility Programs** **1111**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Alternatively as discussed in the Abinitio Ligand Field Theory section ( *1- and 2-shell Abinitio Ligand Field Theory* )
one may actually run a 2-shell AILFT calculation and produce the respective *nevpt2.lft.inp file




The structure of an orca_lft input is the following:

It contains:

  - The General Parameters Block where the LFT problem is defined

—–Parameters—— NEl= 14 LFTCase 2p3d #Shells_PQN 0,2,3,0, Alternative definition using s,p,d,f main
quantum numbers Mult= 3, 1 NRoots= 25, 30 ——————–

**1112** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

  - The PARAMETERS Block where the SCPs and SOC constant parameters are defined

—Slater-Condon Parameters— —All Values in eV— PARAMETERS F0pp = 85.88 F2pp = 54.77 F0dd =
23.31 F2dd = 13.89 F4dd = 9.14 F0pd = 33.03 F2pd = 7.76 G1pd = 6.42 G3pd = 2.11 end ——————–

...

—SOC-CONSTANTS— —All Values in eV— PARAMETERS ZETA_P = 10.68 ZETA_D = 0.08 end

——————–

  - The FUNCTIONS Block where the LFT matrix is defined

  - The Properties Block where the desire simulation properties are specified

—SPECTRA/PROPERTIES— DoABS true ———

  - The xyz Block where the ion, charge, multiplicity and coordinates (0. 0. 0.) are defined

*xyz 2 3 Ni 0.0000000000 0.0000000000 0.0000000000 *

It should be emphasized the orca_lft via the FUNCTIONS and PARAMETERS blocks provides

  - an arbitary paramterization of the 1-electron LFT matrix and the Slater Condon Parameters

  - a powerfull parameters scanability

which helps to performs any kind of simulation without any symmetry restrictions. Details regarding the use of
the FUNCTIONS and PARAMETERS blocks with examples are provided in the orca_lft tutorial

Let us perform the *𝑁𝑖* [2+] L-edge XAS spectrum simulation using the following input



(continues on next page)

**7.55. Utility Programs** **1113**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



In a first step the definition of the LFT problem is performed:




(continues on next page)

**1114** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



In following the CI problem is defined:



And the CI problem is solved:



(continues on next page)

**7.55. Utility Programs** **1115**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

accompanied by a multiplet analysis:



In following SOC is computed on the QDPT framework

(continues on next page)

**1116** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



The corrected SOC states are then printed




(continues on next page)

**7.55. Utility Programs** **1117**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Followed by the SOC corrected Absorption (Here XAS) spectrum



By processing the *.out file as usual with orca_mapspc *orca_mapspc* the *.dat and *.stk files are generated resulting
in Fig. 7.71.

**1118** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.71: orca_lft simulated *𝑁𝑖* [2+] L-edge XAS spectrum

**7.55.16 orca_crystalprep**

ORCA 5.0 fetures a utility program that can process crystallographic files (.cif) or .xyz supercell files and produce
proper inputs for the embedded cluster calculations It is named orca_crystalprep tool.

Performing an embedded cluster calculation conventionally or within the Ionic-Crystal-QMMM one needs to define
basically 3 regions

1. The quantum cluster QC that will be treated quantum mechanically

2. The point charges region PC that represents the solids environment

3. A boundary region BR or ECP that is located between the QC and PC with the main role to prevent charge
communication between the QC and PC regions.

This implies that in a first step one needs to generate a SuperCell (.xyz) structure and separate the different regions
according to the calculation design. In a second step one needs to charge balance the system. All this is then need
to be combined into a proper calculation input.

This is clearly a multistep and many times multiplatform process that is

1. Complicated

2. Time consuming

3. Not user friendly

The orca_crystalprep utility is designed to automatically generate proper inputs for ORCA embedded cluster calculations with the aim to allow to a wide range of experienaced and not experienced users the ability to setup an
embedded cluster calculation with a minimal effort.

orca_crystalprep requires its own input. By simply executing it from the terminal

**7.55. Utility Programs** **1119**

**ORCA Manual** **,** **Release 6.0.1**
```
orca_crystalprep

```
one gets printings of the Usage:



and the different Options:




(continues on next page)

**1120** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
CellVolumeFraction value Cell(UniCell/SuperCell) fraction (default␣

```
*˓→* `1.0)`
```
DoSimpleInput true Flag to generate a conventional Embedding␣

```
*˓→* `Cluster input`
```
DoICQMMMInput true Flag to generate a Ionic-Crystal-QMMM␣

```
*˓→* `input`
```
WritePDB true Flag to run a Ionic-Crystal-QMMM input␣

```
*˓→* `from a PDF file`
```
QCCharge Charge Number Specify the total QC Charge
QCMult Multiplicity Number Specify the total Multiplicity
----------------------------------------------------------------------------------------------
```
*˓→* `--------------`
```
Special Tasks on Embedding Cluster Construction/Definition
----------------------------------------------------------------------------------------------
```
*˓→* `--------------`
```
DoLayers true Request Layers Definition
1) Layers Definition. There are 2 Options:
a) The Differnt regions are build in layers as multipoles of the UnitCell
b) The Differnt regions are build in layers around a predefined QC cluster via a QCAtom List
QCLayers QC Layers Number Specify the number of the QC Layers
ECPLayers ECP Layers Number Specify the number of the ECP Layers
PCLayers PC Layers Number Specify the number of the PC Layers
HFLayers HF Layers Number Specify the number of the HF Layers
Example Input
QCLayers 1
2) Atoms Definition. This is alternative to Layers Definition (e.g. DoLayers false)
NQCAtoms QC Atoms Number Specify the number of the QC Atoms
NHFAtoms HF Atoms Number Specify the number of the HF Atoms
NECPAtoms ECP Atoms Number Specify the number of the ECP Atoms
NPCAtoms PC Atoms Number Specify the number of the PC Atoms
QCAtoms QC Atoms List Specify the List of the QC Atoms (e.g.␣

```
*˓→* `0,1,4,10...`
```
HFAtoms HF Atoms List Specify the List of the HF Atoms (e.g.␣

```
*˓→* `0,1,4,10...`
```
ECPAtoms ECP Atoms List Specify the List of the ECP Atoms (e.g.␣

```
*˓→* `0,1,4,10...`
```
PCAtoms PC Atoms List Specify the List of the PC Atoms (e.g.␣

```
*˓→* `0,1,4,10...`
```
Example Input
NQAtoms= 4
QCAtoms 0,1,4,10
----------------------------------------------------------------------------------------------
```
*˓→* `--------------`
```
Request an Explicit Atom Definion in Ionic-Crystal-QMMM
HINT: This is automatically Set to true if an Atom List (QC Atoms, ECP Atoms, ...) is provided␣

```
*˓→* `by the user`
```
----------------------------------------------------------------------------------------------
```
*˓→* `--------------`
```
SetQCAtoms true Set explicitely the QC Atoms
SetHFAtoms true Set explicitely the HF Atoms
SetECPAtoms true Set explicitely the ECP Atoms
SetPCAtoms true Set explicitely the PC Atoms
SetPC2Atoms true Set explicitely the PC2 Atoms
----------------------------------------------------------------------------------------------
```
*˓→* `--------------`
```
Redefine SuperCell Origin. This is for shifting the center origin to a desired atom during the␣

```
*˓→* `SC Construction`
```
This Helps to automatically construct desired Cluster structures using the Layers Definition
----------------------------------------------------------------------------------------------
```
*˓→* `--------------`
```
ShiftOrigin true Request Origin Shift to a particular Atom

```
(continues on next page)

**7.55. Utility Programs** **1121**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



In a first step the orca_crystalprep tool can be used to generate its own input. So by running:
```
orca_crystalprep crystalprep.inp -geninput

```
it will generate the following initial input:



which looks like the following:



(continues on next page)

**1122** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



By providing names for the *.cif or *.xyz files that are desired to be processed and different options it is possible
to generate a ready to run embedding cluster input as is shown in Fig. 7.72.

**7.55. Utility Programs** **1123**

**ORCA Manual** **,** **Release 6.0.1**

Fig. 7.72: Embedded cluster IC-QM/MM Input generation

For the construction of the embedded cluster structure by default a layers approach is performed in which the
different structural layers are constructed as multiplets of the unitcell or a fraction of the unitcell

The unitcell fractions in terms of volume units are specified by the following keyword
```
CellVolumeFraction N #by default N=1

```
As an example let us discuss in detail the case of NaCl.

Let us assume that we want to generate an embedding cluster input

1. with a 20x20x20 supercell starting from the nacl.cif file

2. create an embedding cluster with 1 QC and 1ECPs layers

3. create an IC-QM/MM embedding cluster input

for this purpose the following input is used



(continues on next page)

**1124** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

In a first step the orca_crystalprep will process the nacl.cif file and will create the unitcell and the requested
20x20x20 supercell




In a following step the costruction of the embedding cluster structure will be initiated

**7.55. Utility Programs** **1125**

**ORCA Manual** **,** **Release 6.0.1**



In a next step the center of the .xyz supercell will be assigned to the closest atom:



In following an automatic layers generation is performed

The embedding cluster is then constructed:



Finally the IC-QM/MM embedding cluster will be generated



Ionic-Crystal QM/MM requires the generation of a simple force field *.prms For details see section: *ORCA Mul-*
*tiscale Implementation* The needed information including charge and spin is taken from a *metainfo file. The

**1126** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

orca_crystalprep provides the possibility to externally set chatge and spin in the *.metainfo file

This is acheived by the following process:

At first processing of the .cif files assignes atom types to all the detected atoms in the asymetric unit



In the orca_crystalprep input it is possible to assign specific initial charge and spin to atoms of a paricular atom
type in the following way:



This information is then passed in the *.metainfo file

while the generated IC-QM/MM embeding cluster input is provided below



**7.55. Utility Programs** **1127**

**ORCA Manual** **,** **Release 6.0.1**

Note: that the information regarding the QC, ECP and PC regions is read from the generated *.pdb file

  - Further information regarding the IC-QM/MM and the QM/MM module in general is provided in section

*ORCA Multiscale Implementation*

  - Further information and examples regarding the orca_crystalprep tool and the embedding approach is provided in the Treating Solids with the Embedding Cluster approach tutorial.
### **7.56 Compound Methods**

**7.56.1 Commands**

Below is a list of all available commands available in *Compound*

**——————————— Dataset Related ——————————–**

  - Dataset( *Dataset* )

  - MakeReferenceFromDir( *D.MakeReferenceFromDir* )

  - Print( *D.Print* )

**—————————— File Handling Related —————————–**

  - CloseFile ( *CloseFile* )

  - OpenFile ( *OpenFile* )

**——————————-** ***For*** **Loop Related ——————————-**

  - Break ( *Break* )

  - Continue ( *Continue* )

  - EndFor ( *EndFor* )

  - For ( *For* )

**——————————– Geometry Related ——————————-**

  - Geometry( *Geometry* )

  - BohrToAngs( *G.BohrToAngs* )

  - CreateBSSE( *G.CreateBSSE* )

  - FollowNormalMode( *G.FollowNormalMode* )

  - GetAtomicNumbers( *G.GetAtomicNumbers* )

  - GetBondDistance( *G.GetBondDistance* )

**1128** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

  - GetCartesians( *G.GetCartesians* )

  - GetGhostAtoms( *G.GetGhostAtoms* )

  - GetNumOfAtoms( *G.GetNumOfAtoms* )

  - MoveAtomToCenter( *G.MoveAtomToCenter* )

  - Read( *G.Read* )

  - RemoveAtoms( *G.RemoveAtoms* )

  - RemoveElements( *G.RemoveElements* )

  - WriteXYZFile( *G.WriteXYZFile* )

**——————————– G** ΟΑΤ **Related ——————————-**

  - GOAT( *GOAT* )

  - Get_Energy ( *Goat.Get_Energy* )

  - Get_Num_Of_Geometries ( *Goat.Get_Num_Of_Geometries* )

  - Parse_ensemble_file ( *Goat.Parse_Ensemble_File* )

  - Set_Basename ( *Goat.Set_Basename* )

  - Print ( *Goat.Print* )

  - WriteXYZFile ( *Goat.WriteXYZFile* )

**——————————** ***If*** **block Related ——————————**

   - If ( *If* )

**—————————- Linear Algebra Related —————————-**

  - Diagonalize( *Diagonalize* )

  - InvertMatrix( *InvertMatrix* )

  - Mat_p_Mat( *Mat_p_Mat* )

  - Mat_x_Mat( *Mat_x_Mat* )

  - Mat_x_Scal( *Mat_x_Scal* )

**————————— ORCA calculation Related —————————**

  - Basenames( *Basenames* )

  - ReadMOs( *ReadMOs* )

**—————————– Program flow Related —————————–**

  - Abort ( *Abort* )

  - End ( *End* )

  - EndRun ( *EndRun* )

  - GoTo ( *GoTo* )

**————————— Property File Related —————————-**

  - GetNumOfInstances( *GetNumOfInstances* )

  - Read( *Read* )

  - ReadProperty( *ReadProperty* )

**————————– String Handling Related ————————–**

  - GetBasename ( *S.GetBasename* )

  - GetChar ( *S.GetChar* )

**7.56. Compound Methods** **1129**

**ORCA Manual** **,** **Release 6.0.1**

  - GetSuffix ( *S.GetSuffix* )

  - Print ( *Print* )

  - Write2File ( *Write2File* )

  - Write2String ( *Write2String* )

**——————————— Step Related ———————————**

  - & ( *&* )

  - Alias ( *Alias* )

**—————————– Timer Related ————————————**

  - Timer ( *Timer* )

  - Last ( *T.Last* )

  - Reset ( *T.Reset* )

  - Start ( *T.Start* )

  - Stop ( *T.Stop* )

  - Total ( *T.Total* )

**————————— Variables Related ———————————-**

  - Variables ( *Variables - General* )

  - Variables - Assignment ( *Variables - Assignment* )

  - Variables - Declaration ( *Variables - Declaration* )

  - Variables - Functions ( *Variables - Functions* )

  - Variable - With ( *With* )

  - GetBool() *V.GetBool()*

  - GetDim1() *V.GetDim1()*

  - GetDim2() *V.GetDim2()*

  - GetDouble() *V.GetDouble()*

  - GetInteger() *V.GetInteger()*

  - GetSize() *V.GetSize()*

  - GetString() *V.GetString()*

  - PrintMatrix() *V.PrintMatrix()*

  - Write2File ( *Write2File* )

  - Write2String ( *Write2String* )

**&**

The *&* symbol has a special meaning in the compound block. Using this symbol inside the *New_Step* - *Step_End*
block the user can use variables that are defined outside the block. Both string and numerical variables are allowed.

**Syntax:**

**&{** ***variable*** **}**

**Example**

**1130** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**Abort**

*Abort* is used when the user wants to exit the program instantly. **Syntax:**
Abort;
**or alternatively:**
Abort

**Example:**



**Alias**

*Alias* is used to replace an integer number with a more representative string. It is useful when one performs more
than one calculations and the step numbers become too complicated to evaluate. In this case using Alias_Step after
the Step_End command will connect the preceeding calculation step number with the provided name.

**Syntax:**
Alias *𝑛𝑎𝑚𝑒* ;
**or alternatively:**
Alias *𝑛𝑎𝑚𝑒*

**Example:**

**7.56. Compound Methods** **1131**

**ORCA Manual** **,** **Release 6.0.1**

*NOTE* for the **Alias** command the final ‘;’ is optional.

**Basenames**

*Basenames* in a variable that is automatically created in *Compound* everytime a *New_Step* is used and it holds the
name of this step. It can be used to recover this name during running of a calculation. It practically is a vector were
value zero corresponds to the main calculation before any *new_step* command.

**Example:**



**1132** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**Break**

*Break* can be used inside a *For* loop (see (see *For* )) when one needs to break the loop under certain conditions.
The syntax is the following:

**Syntax:**
*For variable From Start value To End value Do*

*commands*

**break ;**
*commands*

*EndFor;*

**NOTE** both versions *break* and *break;* are legal.

What break actually does is to set the running index of the loop to the last allowed value and then jump to the
*EndFor* (see *EndFor* )).

**Example:**



**CloseFile**

When a file is opened in *Compound* using the *openFile* command (see *OpenFile* ), then it must be closed using the
*closeFile* command.

**Syntax:**
*closeFile* (file);

*file* is the file pointer created from the *openFile* command. For an example see paragraph *OpenFile* .

**Continue**

*Continue* can be used inside a *For* loop (see (see *For* )) when one needs to skip the current step of the loop and
proceed to the next one. The syntax is the following:

**Syntax:**
*For variable From Start value To End value Do*

*commands*

**continue ;**
*commands*

*EndFor;*

**NOTE** both versions *continue* and *continue;* are legal.

What continue actually does is to jump to the *EndFor* (see *EndFor* )).

**Example:**

**7.56. Compound Methods** **1133**

**ORCA Manual** **,** **Release 6.0.1**



**Dataset**

In *Compound* we have *Dataset* objects. These objects can be treated like normal variables of type ‘ *compDataset* ’.
An important difference between normal variables and *Dataset* variables is the declaration. Instead of the normal:
```
Variable x;

```
we excplicitly have to declare that this is a dataset. So the syntax for a dataset declaration is:

**Syntax:**
```
Dataset mySet;

```
**NOTE** in the case of datasets we do not allow multiple dataset declarations per line.

Below is a list of functions that work on *Dataset* .

  - MakeReferenceFromDir( *D.MakeReferenceFromDir* )

  - Print( *D.Print* )

**Example:**



**D.MakeReferenceFromDir**

*MakeReferenceFromDir* command acts on a dataset object (see *Dataset* ). It creates a json reference file based on
the *xyz files of the current folder. **NOTE** By default all charges and multplicities will be set to 0 and 1 respectively.

**Syntax:**
*mySet.MakeReferenceFromDir(dirName);*

Where:

   - *mySet* is a dataset object that is already declared

   - *dirName* The name of a directory that should contain some xyz files.

**Example:**

**1134** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**D.Print**

*Print* command acts on a dataset object (see *Dataset* ). It prints all details of the specific dataset object.

**Syntax:**
*mySet.Print();*

Where:

   - *mySet* is a dataset object that is already declared

**Example:**



**Diagonalize**

*Compound* can peform matrix algebraic operations, one of the available algebraic operation is matrix diagonalization. Be carefull that the matrix, that is to be diagonalized, **must be** a square symmetric matrix. It is also
important to remember that only the upper triangle part of the matrix will be used for the diagonalization. If
everything proceeds smoothly then the function will return the eigenvectors and eigenvalues of the matrix.

**Syntax:**
*A.Diagonalize(eigenValues, eigenVectors);*

Where:

   - *A:* The matrix to be diagonalized.

   - *eigenValues:* The vector with the eigenvalues

   - *eigenVectors:* The square matrix with the eigenvectros of the initial matrix.

**Example:**

**7.56. Compound Methods** **1135**

**ORCA Manual** **,** **Release 6.0.1**



**End**

*End* is the final command each compound script must have (unless there is an *EndRun* command (see *EndRun* )).
After *Compound* executes what is written in the script then it passes control again to normal ORCA input reading.
ORCA will continue analyze the input that rests after the *Compound* part but it will not run any calculation.

**EndRun**

#EndRun* is an alternative to the *End* command (see *EndRun* ) for ending the execution of a *Compound* script. The
difference between *end* and *EndRun* is that *EndRun* ignores everything after the *Compound* block. This makes it
even easier to use *Compound* as a full workflow run.

**EndFor**

All *For* loops (see *For* ) must finish with *EndFor* . The syntax and an example is shown in the *For* section (see *For* ).

**NOTE** For *EndFor* both *EndFor* and *EndFor;* are possible.

**For**

*For* loops are used to perform repetitive tasks. The syntax is the following:

**Syntax:**

**For** *variable* **From** *Start value* **To** *End value* **Do**

*commands*

**EndFor** or **EndFor;**

*Variable* should be a variable name not previously defined. *Start value* and *End value* should be integers defining
the start and end value of the *variable* . *Start value* and *End value* can be numbers, predefined variables or functions
of previously defined variables. The only requirement is that they should be **integers** . Keep in mind that the loop
will be performed from the first value to the *End value*, including the *End value* .

**Example:**

**1136** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**



**7.56. Compound Methods** **1137**

**ORCA Manual** **,** **Release 6.0.1**

**Geometry**

In *Compound* we have *Geometry* objects. These objects can be treated like normal variables of type ‘ *compGeom-*
*etry* ’. An important difference between normal variables and *Geometry* variables is the declaration. Instead of the
normal:
```
Variable myGeom;

```
we excplicitly have to declare that this is a geometry. So the syntax for a geometry declaration is:

**Syntax:**


Using the second definition one can define two geometry objects in the same line.

Below is a list of functions that work on *Geometry* objects.

  - BohrToAngs( *G.BohrToAngs* )

  - CreateBSSE ( *G.CreateBSSE* )

  - FollowNormalMode ( *G.FollowNormalMode* )

  - GetAtomicNumbers( *G.GetAtomicNumbers* )

  - GetBondDistance( *G.GetBondDistance* )

  - GetCartesians( *G.GetCartesians* )

  - GetGhostAtoms( *G.GetGhostAtoms* )

  - GetNumOfAtoms( *G.GetNumOfAtoms* )

  - MoveAtomToCenter( *G.MoveAtomToCenter* )

  - Read( *G.Read* )

  - RemoveAtoms( *G.RemoveAtoms* )

  - RemoveElements( *G.RemoveElements* )

  - WriteXYZFile( *G.WriteXYZFile* )

**G.BohrToAngs**

*BohrToAngs* command acts on a geometry object (see see *Geometry* ). It will transform the geometry of the
loaded geometry object from Bohr to Angstroms. Practically it will just multiply the coordinates with the factor *0.529177249* .

**Syntax:**
*myGeom.BohrToAngs();*

Where:

   - *myGeom* is a geometry object that already contains a geometry

**Example:**



(continues on next page)

**1138** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



**G.CreateBSSE**

*CreateBSSE* command acts on a geometry object (see see *Geometry* ). In the case that the geometry object contains
*ghost* atoms then *CreateBSSE* will create five new files:

  - myFilename_FragmentA.xyz

  - myFilename_MonomerA.xyz

  - myFilename_FragmentB.xyz

  - myFilename_MonomerB.xyz

  - myFilename_Total.xyz

**Syntax:**
*myGeom.CreateBSSE(filename=myFilename);*

Where:

   - *myGeom* is a geometry object that already contains a geometry

   *filename* is a base filename for the created files.

**Example:**



(continues on next page)

**7.56. Compound Methods** **1139**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



**NOTE** The files will contain XYZ geometries in **BOHRS** .

**G.FollowNormalMode**

*FollowNormalMode* command acts on a geometry object (see see *Geometry* ). It will displace the loaded geometry
following a chosen normal mode of vibtation

**Syntax:**
*myGeom.FollowNormalMode(vibrationSN=myVibration, [ScalingFactor=myScalingFactor]);*

Where:

   - *myGeom* is a geometry object that already contains a geometry

   - *vibrationSN* is the serial number of the vibration. **NOTE** Please remember that counting starts with 1.

   - *scalingFactor* is the scaling of the normal mode of vibration. This argument is optional.

**Example:**



**1140** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**G.GetAtomicNumbers**

Function *GetAtomicNumbers* acts on geometry objects and returns and array with the atomic numbers of the elements in the working geometry.

**Syntax:** *atomNumbers = geom.GetAtomicNumbers()*

*atomNumbers* A variable that will be filled with the values of the atomic numbers

*geom* A geometry object that should already be loaded.

**Example:**

**G.GetBondDistance**

Function *GetBondDistance* acts on geometry objects and returns the distance between two atoms **in Bohrs** .

**Syntax:**

*res = geom.GetBondDistance(atomA, atomB)*

Where:

*res* The distance between atoms atomA and atomB.

*geom* A geometry object previously loaded.

*atomA* The index of atomA in the geometry.

*atomB* The index of atomB in the geometry.

**NOTE** indices start counting from 0

**Example:**



(continues on next page)

**7.56. Compound Methods** **1141**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



**G.GetCartesians**

Function *GetCartesians* acts on geometry objects (see *Geometry* ) and returns the distance xyz cartesian coordinates. Please remember that it alsways returns the cooridnates in **BOHRS** .

**Syntax:**

*coords = geom.GetCartesians()*

Where:

*coords* : A ( *nAtoms*,3) array with the cartesian coordinates in **BOHRS** .

*geom* : A geometry object previously loaded.

**Example:**

**1142** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**G.GetGhostAtoms**

Function *GetGhostAtoms* acts on geometry objects (see *Geometry* ). It returns a vector of size nAtoms where for
each atom the value will be -1 if it is a ghost atom, otherwise the atomic number of the element

**Syntax:**

*ghostAtoms = geom.GetGhostAtoms()*

Where:

*ghostAtoms* : A ( *nAtoms*,1) integer vector with values -1 or the atomic number of the atom, in case it is not a ghost

atom.

*geom* : A geometry object previously loaded.

**Example:**

**G.GetNumOfAtoms**

*GetNumOfAtoms* returns an integer with the number of atoms of the working geometry.

**Syntax:**

*res = geom.GetNumOfAtoms();*

Where:

*res* is the resulting number of atoms

*geom* is the name of a geometry variable (see *Geometry* ) we are using.

**Example:**



(continues on next page)

**7.56. Compound Methods** **1143**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**G.MoveAtomToCenter**

Function *MoveAtomToCenter* acts on geometry objects (see *Geometry* ). It will adjust the cartesian coordinates so
that the chosen atom will rest at (0.0 0.0 0.0).

**Syntax:**

*geom.MoveAtomToCenter(atom serial nubmer);*

Where:

*geom* : A geometry object previously loaded.

*atom serial number* : The serial number of the atom in the geometry.

**Example:**



**NOTE** Please remember that counting **starts with 0**, meaning that the first atom is 0 and not 1!

**1144** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**G.Read**

Function *Read* acts on geometry objects (see *Geometry* ) and reads a geometry from a property file related to a
previous step.

**Syntax:**

*geom.Read([stepID=myStepID], propertySN=myPropertySN)*

Where:

*geom* : A geometry object that will be updated.

*stepID* : The step from which we are going to read the geometry. If not given the previous step will be used.

*propertySN* : The serial number the geometry in the property file. If not given the last available geometry will be
used.

**Example:**

**G.RemoveAtoms**

Function *RemoveAtoms* acts on geometry objects (see *Geometry* ). It accepts a list of atoms and removes them from
the loaded geometry. In the end the geometry object will be updated.

**Syntax:**

*geom.RemoveAtoms(atom1, atom2, ...);*

Where:

*geom* : A geometry object previously loaded.

*atom1, atom2, ...* : The serial number of the atoms in the geometry.

**Example:**



(continues on next page)

**7.56. Compound Methods** **1145**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**NOTE** Please remember that counting **starts with 0**, meaning that the first atom is 0 and not 1!

**G.RemoveElements**

Function *RemoveElements* acts on geometry objects (see *Geometry* ). It will remove from the loaded geometry all
atoms with an atomic number given in the list.

**Syntax:**

*geom.RemoveElements(atomNumber1, atomicNumber2, ...);*

Where:

*geom* : A geometry object previously loaded.

*atomicNumber1, atomicNumber2, ...* : The atomic number of elements to be removed from the current geometry.

**Example:**

**1146** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**G.WriteXYZFile**

Function *WriteXYZFile* acts on geometry objects (see *Geometry* ) and writes on disc an xyz file with the coordinates
of the current goemetry object. Please remember that it alsways writes the coordinates in **BOHRS** .

**Syntax:**

*res = geom.WriteXYZFile(filename=myFilename)*

Where:

*res* : An integer that returns ‘0’ if everything worked smoothly.

*myFilename* The name of the file that will contain the coordinates.

*geom* : A geometry object previously loaded.

**Example:**

**GOAT**

In *Compound* we have *GOAT* objects. These objects can be treated like normal variables of type ‘ *compGOAT* ’.
An important difference between normal variables and *GOAT* variables is the declaration. Instead of the normal:
```
Variable myGoat;

```
we excplicitly have to declare that this is a GOAT object. So the syntax for a goat declaration is:

**Syntax:**
```
GOAT myGoat;

```
Below is a list of functions that work on *Geometry* objects.

  - Get_Energy ( *Goat.Get_Energy* )

  - Get_Num_Of_Geometries ( *Goat.Get_Num_Of_Geometries* )

  - Parse_ensemble_file ( *Goat.Parse_Ensemble_File* )

  - Set_Basename ( *Goat.Set_Basename* )

  - Print ( *Goat.Print* )

  - WriteXYZFile ( *Goat.WriteXYZFile* )

**Example:**

**7.56. Compound Methods** **1147**

**ORCA Manual** **,** **Release 6.0.1**



**Goat.Get_Energy**

Function *Get_Energy* acts on goat objects (see *GOAT* ) and returns a double with the energy of the requested

structure.

**Syntax:**

*res = myGoat.Get_Energy(geomID=myGeomID)*

Where:

*res* : A double with the energy of the requested structure.

*myGoat* A GOAT object that is already loaded (meaning it has already parse an ensemble file, see (see
*Goat.Parse_Ensemble_File* ).

*myGeomID* : The geometry ID of the requested structure. Counting starts from 1.

**Example:**

see example in *GOAT*

**Goat.Get_Num_Of_Geometries**

Function *Get_Num_Of_Geometries* acts on goat objects (see *GOAT* ) and returns an integer with the number of
structures available in the current *GOAT* object.

**Syntax:**

*res = myGoat.Get_Num_Of_Geometries()*

Where:

*res* : An integer with the number of geometries in the current *GOAT* object.

*myGoat* A GOAT object that is already loaded (meaning it has already parse an ensemble file, see (see
*Goat.Parse_Ensemble_File* ).

**Example:**

see example in *GOAT*

**1148** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**Goat.Parse_Ensemble_File**

Function *Parse_Ensemble_File* acts on goat objects (see *GOAT* ). It will read an ensemble file created by a GOAT
run and then update the object with the geometries and energies of each geometry available in the current *GOAT*
object.

**Syntax:**

*res = geom.Parse_Enesemble_File(filename=myFilename)*

Where:

*res* : An integer that returns ‘0’ if everything worked smoothly.

*myFilename* The name of the file that will contain the coordinates.

*myGoat* : A GOAT object previously loaded.

**Example:**

see example in *GOAT*

**Goat.Set_Basename**

Function *Set_Basename* acts on goat objects (see *GOAT* ). It set the basename of the ensemble file created by a
GOAT run. It will automatically add the extension: `'.finalensemble.xyz'` in the end of the basename.

**Syntax:**

*myGoat.Set_Basename(myFilename)*

Where:

*myFilename* The basename of the GOAT ensemble file ( **without the extension ‘finalensemble.xyz’** ).

*myGOAT* : A GOAT object previously loaded.

**Example:**

see example in *GOAT*

**Goat.Print**

Function *Print* acts on goat objects (see *GOAT* ). It will print in the output the geometries of current GOAT object.

**Syntax:**

*myGoat.Print()*

Where:

*myGoat* : A GOAT object previously loaded.

**Example:**

see example in *GOAT*

**7.56. Compound Methods** **1149**

**ORCA Manual** **,** **Release 6.0.1**

**Goat.WriteXYZFile**

Function *WriteXYZFile* acts on goat objects (see *GOAT* ). It will write the requested geometry to an XYZ file on
disk. It expects two arguments:

1. The geometry ID of the geometry and

2. The filename that it will use to store the geometry

**Syntax:**

*myGoat.WriteXYZFile(geomID=myGeomID, filename=myFilename)*

Where:

*myFilename:* The name that it will be used to store the geometry on the disk.

*myGeomID* : The geometry ID of the requested structure. Counting starts from 1.

**Example:**

see example in *GOAT*

**GetNumOfInstances**

The *GetNumOfInstances* returns the number of instances of a specific object in a propertyfile.

**Syntax:**

*[res=] GetNumOfInstances(propertyName=myName,* *[step=myStep],* *[filename=myFilename],* *[baseProp-*
*erty=true/false])*

*Where:*

*res:* An integer that returns the number of instances of the required property in the property file.

*propertyName:* A string alias that defines the variable the user wants to read.

*step:* The step from which we want to read the property. If not given the property file from the last step will be
read.

*filename:* A filename of a property file. If a filename and at the same time a step are provided the program will
ignore the step and try to read the property file with the given filename.

**NOTE** please note that in the end of filename the extension *.property.txt* will be added.

*baseProperty:* A true/false boolean. The default value is set to false. If the value is set to true then a generic
property of the type asked will be read. This means if dipole moment is asked, it will return the last dipole moment,
irrelevant if and MP2 or SCF one wad defined.

**Example**



(continues on next page)

**1150** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**GoTo**

The *GoTo* command allows the ‘jump’ inside the normal flow of a *compound* script. The syntax of the command
can be best presented through an example.

**Example:**



Please note that the variable we use as a label for the *GoTo* command should be previously defined like a normal
variable.

**If**

The *if* block allows the user to make decisions. The syntax in *Compound* is the following:
**Syntax:**

**If** *(expression)* **Then**

*actions*

**Else if** *(expression)* **Then**

*actions*

**Else**

*actions*

**Endif**

Below is an example of the usage of *if block* in *compound* .



(continues on next page)

**7.56. Compound Methods** **1151**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
Variable b1 = False;
Variable b2 = True;
Variable s1 = "alpha";
Variable s2 = "beta";
Variable s3 = "alpha";
print( " --------------------------------------------------------- \n");
print( " ---------- SUMMARY OF IF CASES -------------- \n");
print( " --------------------------------------------------------- \n");
print(" x1: %.1lf\n", x1);
print(" y1: %.1lf\n", y1);
print(" b1: %s\n", b1.GetString());
print(" b2: %s\n", b2.GetString());
print(" s1: %s\n", s1);
print(" s2: %s\n", s2);
print(" s3: %s\n", s3);
# ****************************************************************
# DOUBLES
# ****************************************************************
print(" ------------------- Doubles ---------------------- \n");
print(" Variable/constant / One operator / if (x1>5) \n");
print(" No else if/No else \n");
if (x1>5) then
 print(" %.2lf > 5 \n", x1);
endif
# ---------------------------------------------------------------print(" function / Variable / One operator / if (3*x1>y1) \n");
print(" no else if / else \n");
if (3*x1>y1) then
 print(" 3*%.1lf > %.1lf\n", x1, y1);
else
 print(" 3*%.1lf < %.1lf\n", x1, y1);
endif
# ---------------------------------------------------------------print(" function / function / One operator / if (x1-y1>-10.0) \n");
print(" else if/else \n");
if (x1-y1>-10.0) then
 print(" %.2lf - %.2lf > -10.0\n", x1, y1);
else if (x1-y1 < -10.0) then
 print(" %.2lf - %.2lf < -10.0\n", x1, y1);
else
 print(" %.2lf - %.2lf = -10.0\n", x1, y1);
endif
# ****************************************************************
# BOOLEANS
# ****************************************************************
print(" --------------- Booleans ---------------------------\n");
print(" Variable / No operator / if (b1) \n");
if (b1) then
 print("b1 is True\n");
else
 print("b1 is False\n");
endIf
# -------------------------------------------------------------------# --------------------------------------------------------------------print(" Constant / No operator / if (true) \n");
if (True) then
 print( "True\n");
else
 print( "False");
endIf

```
(continues on next page)

**1152** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



Some comments about the syntax:

**7.56. Compound Methods** **1153**

**ORCA Manual** **,** **Release 6.0.1**

The *Else if* or *Else* blocks are not obligatory.

The numerical operators that can be used are: *‘>’, ‘<’, ‘>=’, ‘<=’, ‘=’* .

The available logical operators are: *‘and’ and ‘or’* .

Unfortunately in the current version multi-parentheses are not allowed.

There is now the possibility to compare strings.

**InvertMatrix**

*Compound* can peform matrix algebraic operations, one of the available algebraic operation is the inversion of a
matrix. Be carefull that the matrix, whose the invert we are looking for, **must be** a real, square matrix.

**Syntax:**
*AInvert = A.InvertMatrix();*

Where:

   - *A:* The matrix to be inverted.

   - *AInvert:* The invert of A. It can be A itself and then A will just be updated.

**Example:**



**Mat_p_Mat**

*Compound* can peform matrix algebraic operations, one of the available algebraic operation is matrix addittion. In
order to add two matrices they **must** have the same dimensions.

**Syntax:**
*C=Mat_p_Mat(alpha, A, beta, B);*

Where:

   - *C:* The resulting matrix.

   *alpha:* The coefficient for matrix A.

   - *A:* The left matrix of the addition.

**1154** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**



   - *beta:* The coefficient for matrix B.

   - *B:* The right matrix of the addition.

**Example:**



**Mat_x_Mat**

*Compound* can peform matrix algebraic operations, one of the available algebraic operation is matrix multiplication. In general we can multiply each matrix with constants *alpha* and *beta* so that the general multiplication

is:

*C=(alpha* A) *(beta* B)

In addition each of matrices A and B are allowed to be transposed.

**Syntax:**
*C=Mat_x_Mat(A, B, [transposeA], [transposeB], [alpha], [beta]);*

Where:

   - *C:* The resulting matrix.

   - *A:* The left matrix of the multiplication.

   - *B:* The right matrix of the multiplication.

   - *transposeA:* A boolean to state if matrix A should be transposed before the mutliplication (default: False).

   - *transposeB:* A boolean to state if matrix B should be transposed before the multiplication (default: False).

   - *alpha:* A scalar to multiply matrix A before the mutliplication (default 1.0).

   - *beta:* A scalar to mutliply matrix B before the multiplication (default 1.0).

**Example:**



(continues on next page)

**7.56. Compound Methods** **1155**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**Mat_x_Scal**

*Compound* can peform matrix algebraic operations, one of the available algebraic operation is multiplication of
the elements of a matrix with a scalar. The function returns the multiplied matrix that can be the one that we use
as an argument in the parenthesis, meaning it is updated, or a different one.

**Syntax:**
*C=Mat_x_Scal(alpha, A);*

Where:

   - *C:* The resulting matrix.

   - *alpha:* A scalar to multiply the elements of matrix A.

   - *A:* The matrix to be mutliplied.

**Example:**



**1156** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**New_Geom**

*New_Geom* is a platform for geometry manipulation. The basic idea is to have functions that can read a geometry
and then produce one or more new geometries with some characteristics that we need. For the moment under the
umbrella of *New_Geom* fall 4 different functions, and these are: Displace, Remove_Atom, Remove_Element.

**Displace**

The idea behind “ *Displace’* ” is to have a structure, perform an analytical frequncy calculation on it (currently we
do not store numerical frequencies in the property file) and then read the Hessian from this calculation to adjust
the geometry based on a normal mode of vibration that we choose. The syntax of this command is:

**syntax:** New_Geom = (Displace, step, hessian, frequency, scaling)

where:

*step* is the step from which we choose the original geometry
*hessian* is the hessian read from a property file
*frequency* defines which normal mode we will use and
*scaling* is a factor of how severe we want the displacement to be.

We should note that *Displace* is the only command of the *new_geom* family of commands that will not store a
geometry on disk but only internally pass the new geometry to the next calculation. An example of the usage of
this command can be found in the script ‘iterativeOptimization’ that is given with ORCA. The relevant part is as
follows: **example:**



**7.56. Compound Methods** **1157**

**ORCA Manual** **,** **Release 6.0.1**

**OpenFile**

*Compound* can write text files on disk. In order to write to a file a filepointer must be created. For this in *Compound*
exists the command *OpenFile* .

**Syntax:**
filePtr = *OpenFile* ( *Filename*, “ *open mode* ”);

*filePtr* is a variable previously declared.

*Filename* can be a string or a variable of string type and represents the name of the file on disk.

There are two available *opening modes* :

  - ‘w’. In this mode a new file will be created and the user can write on it. If an old file with the same name
exists, it’s contents will be deleted.

  - ‘a’. In this mode if a file already exists, the user will append to what already exists in the file.

**Example:**



**Remove_Atom**

Remove_atom removes an atom from a geometry given its index. We should point out that counting of atoms in
ORCA starts with 0. After this command is executed it will store on a disk a new geomety in a xyz format where
only the atom with the given index will be missing.

**Syntax:**

New_Geom = ( Remove_atom, atomIndex, “filename”, stepIndex, [geometry Index]);

where:

*atom Index* is the number of the atom we want to remove. It can be an integer number or a variable.
*filename* is the name of the file that we want to use for the new xyz file. It can be a string in quotation marks or
a variable already defined before. In the name the xyz extension will be automatically appended. *step Index* the
number of the step from which we will get the initial geometry. It has to be an integer number. *geometry Index*
In case there are more than one geometries in the corresponding property file we can choose one. If no number is
given but default the program will use the last one.

**1158** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


**example:**

if we use the normal ORCA input file:

together with the compound file “removeAtom.cmp” :




then the xyz file ‘newGeom.xyz’ will be created that should look like:




where the atom with *atomIndex = 0* meaning the first atom, meaning the oxygen is removed.

**Remove_Element**

Remove_element is similar to the Remove_atom but instead of using the index of the atom we use its atomic
number. Thus the syntax is:

**Syntax:** New_Geom = ( Remove_Element, atomic number, “filename”, stepIndex, [geometry Index]);

where:

*atomic number* is the atomic number of the atom we want to remove. It can be an integer number or a variable.
*filename* is the name of the file that we want to use for the new xyz file. It can be a string in quotation marks or
a variable already defined before. In the name the xyz extension will be automatically appended. *step Index* the
number of the step from which we will get the initial geometry. It has to be an integer number. *geometry Index*
In case there are more than one geometries in the corresponding property file we can choose one. If no number is
given but default the program will use the last one.

**example:**

if we use again the input from paragraph *1.1.7.2* but instead of asking the compound file “removeAtom.cmp” we
ask for the compound file “removeElement.cmp” that looks like:




**7.56. Compound Methods** **1159**

**ORCA Manual** **,** **Release 6.0.1**

then we will get again the same xyz file that was crated in paragraph *Remove_Atom* since the atom with atomic
number 8 (meaning the Oxygen) will be removed from the original geometry.

**New_Step**

New_Step signals the beginning of a new ORCA input.

**Syntax:**

New_Step
*...Normal ORCA input commands*
Step_End

There is no restriction in the input of ORCA, except of course that it should not include another Compound block.
It is important to remember that a *New_Step* command should always end with a *Step_End* command. Below we
show a simple example.

**Example:**



There is only a basic fundamental difference with a normal ORCA input. Inside the *New_Step* block it is not
necessary to include a geometry. ORCA will automatically try to read the geometry from the previous calculation.
Of course a geometry can be given and then ORCA will use it.

**Print**

Printing in the ORCA outpug can be customized using the *print* command. The syntax of the *print* command
closely follows the corresponding printf command from C/C++. So the usage of the *print* command is:

**Syntax:**
*print(format string, [variables]);*

For each variable there can be specifiers and flags for the specifiers. Currently *print* command supports three
datatypes namely integers, doubles and strings.

A format specifier follows this prototype: *%[flags][width][.precision]specifier*

where details for the specifiers and flags can be found in table Table 7.33

Table 7.33: compound print Specifiers

**1160** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**





**Example:**

(continues on next page)

**7.56. Compound Methods** **1161**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**Read**

The *Read* command reads a property from the property file.

**NOTE** This is the old syntax to read the property file and it **will be deprecated** in the next version of ORCA. For
the new syntax please use the **ReadProperty** command (see *ReadProperty* )

**Syntax**

*Read myVar = propertyName[stepID]*

*Where:*

*myVar:* The variable that will be updated

*propertyName:* The alias for the property we need to read

*stepID:* The step to which we refer.

**Example**



**ReadProperty**

One of the fundamental features of *Compound* is the ability to easily read ORCA calculated values from the property
file.

**Syntax:**

*[res=]* *readProperty(propertyName=myName,* *[step=myStep],* *[filename=myFilename],* *[baseProp-*
*erty=true/false])*

*Where: res:* An integer that returns the index of the found property if the property was found in the property file,
-1 if the property does not exist. This is not obligatory.

*propertyName:* A string alias that defines the variable the user wants to read.

**1162** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

*step:* The step from which we want to read the property. If not given the property file from the last step will be
read.

*filename:* A filename of a property file. If a filename and at the same time a step are provided the program will
ignore the step and try to read the property file with the given filename.

**NOTE** please note that in the end of filename the extension *.property.txt* will be added.

*baseProperty:* A true/false boolean. The default value is set to false. If the value is set to true then a generic
property of the type asked will be read. This means if dipole moment is asked, it will return the last dipole moment,
irrelevant if and MP2 or SCF one wad defined.

**Example**



**Read_Geom**

Read_Geom will read the geometry from a previous step.

**Syntax:**
Read_Geom *𝑛𝑢𝑚𝑏𝑒𝑟*

Here number is the number of the job that we want to read the geometry from. The directive should be positioned
before a *New_Step* - *Step_End* block.

**Example:**



(continues on next page)

**7.56. Compound Methods** **1163**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



In this case the third calculation, through the *Read_MGeom 1* command, will read the geometry from the first
calculation.

**ReadMOs**

ReadMOs reads the molecular orbitals from a previous step.

**Syntax:**
*ReadMOs(stepNumber);*

Where:

   - *stepNumber:* is the number of the step from which we want to read the orbitals.

**Example:**

**S.GetBasename**

In *Compound* strings have all the functionality of a normal variable. In addition they have some additional functions
that act only on strings. On of these functions is the function *GetBasename* . This function searches the string and
if it contains a dot it will return the part of the string before the dot.

**Syntax:**

*result = source.GetBasename();*

*Where:*

*result* is the returned string.

*source* is the original string.

**NOTE** If the original string contains no dot then the result string will be a copy of the source one.

**Example:**



(continues on next page)

**1164** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**S.GetChar**

In *Compound* strings have all the functionality of a normal variable. In addition they have some additional functions
that act only on strings. On of these functions is the function *GetChar* . This function searches the string and if it
contains a dot it will return the part of the string after the dot.

**Syntax:**

*result = source.GetChar(index);*

*Where:*

*result* is the returned string.

*index* is the index of the curracter in the string. Keep in mind that counting starts with **0** and not 1.

*source* is the original string.

**NOTE** If the index is larger than the size of the string or negative then the program will exit.

**Example:**



**7.56. Compound Methods** **1165**

**ORCA Manual** **,** **Release 6.0.1**

**S.GetSuffix**

In *Compound* strings have all the functionality of a normal variable. In addition they have some additional functions
that act only on strings. On of these functions is the function *GetSuffix* . This function searches the string and if it
contains a dot it will return the part of the string after the dot.

**Syntax:**

*result = source.GetSuffix();*

*Where:*

*result* is the returned string.

*source* is the original string.

**NOTE** If the original string contains no dot then the result string will be an empty string.

**Example:**



**Step_End**

Step_End signals the end of an ORCA Input. It should always be the last directive of an ORCA input inside the
compound block that starts with *New_Step* (see paragraph *New_Step* )

**Sys_cmd**

Sys_cmd will read a system command and execute it.

**Syntax:**
Sys_cmd *command*

**Example:**
```
SYS_CMD "orca_mapspc test.out SOCABS -x0700 -x1900 -w0.5 -eV -n10000 "

```
**1166** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**Timer**

A *timer* is an object that can keep time for tasks in compound. Before a timer object is used it has to be declared.
The declaration of a *timer* is slightly different that the rest of variables, because it has to explicitly declare it’s type.

**Syntax**

*timer myTimer;*

*where*

*timer* is used instead of the normal *variable* command to explicitly set the variable type to *compTimer* .

*myTimer* is a normal instance of the object.

**Example:**



Below is a lit of functions that work exclusively on *Timer* objects.

  - Last ( *T.Last* )

  - Reset ( *T.Reset* )

  - Start ( *T.Start* )

  - Stop ( *T.Stop* )

  - Total ( *T.Total* )

**7.56. Compound Methods** **1167**

**ORCA Manual** **,** **Release 6.0.1**

**T.Last**

Last is a function that works on a *timer* object. It returns, as a real number, the last value of the timer.

**Syntax**

*myTimer.Last();*

*Where:*

*myTimer:* is the *timer* object initialized before.

**Example:**



**NOTE** Before using last the *timer* object must, beside defined, be also initializee, using *Start* (see *T.Start* )

**T.Reset**

*Reset* is a function that works on a *timer* object. It resets the *timer* object to its initial state.

**Syntax**

*myTimer.Reset();*

*Where:*

*myTimer:* is the *timer* object initialized before.

**Example:**



(continues on next page)

**1168** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)


**T.Start**

*Start* is a function that works on a *timer* object. It retunrs the *timer* object to its initial state.

**Syntax**

*myTimer.Start();*

*Where:*

*myTimer:* is the *timer* object initialized before.

**Example:**




**7.56. Compound Methods** **1169**

**ORCA Manual** **,** **Release 6.0.1**

**T.Stop**

*Stop* is a function that works on a *timer* object. It stops the timer from counting.

**Syntax**

*myTimer.Stop();*

*Where:*

*myTimer:* is the *timer* object initialized before.

**Example:**

**T.Total**

*Total* is a function that works on a *timer* object. It returns a real number with the total time.

**Syntax**

*myTimer.Total();*

*Where:*

*myTimer:* is the *timer* object initialized before.

**Example:**



(continues on next page)

**1170** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**Variables - General**

Everything in the *Compound* language is based on variables. Their meaning and usage are similar to those in
any programming language: you need to declare a variable and then assign a value to it. Notably, in *Compound*,
a variable must be declared before it is assigned a value, following the syntax rules of languages like C. This
differs from languages like Python, where you can assign a value to a variable without prior declaration. The only
exception to this rule in Compound is the index in a for loop, which does not require prior declaration.

In *Compound* we support the following data types for variables:

  - Integer

  - Double

  - String

  - Boolean

  - File pointer

In addition to these data types *Compound* supports also variables of type *Geometry* and *Timer* but these are treated
separately (see *Geometry* and *Timer* ).

For each variable in *Compound* there are 3 major categories of usage:

  - The declaration (see *Variables - Declaration* )

  - The assignement (see *Variables - Assignment* ) and

  - Variable functions (see *Variables - Functions* )

**Variables - Declaration**

There are currently 6 different ways to declare a variable in *Compound* . Their syntax is the following:

**Syntax:**

**A.** *Variable name;*

**B.** *Variable name1, name2;*

**C.** *Variable name=value;*

**D.** *Variable name[𝑛];*

**7.56. Compound Methods** **1171**

**ORCA Manual** **,** **Release 6.0.1**

**E.** *Variable name[𝑛* 1 *][𝑛* 2 *];*

**F.** *Variable name={value1, value2, ...}* ;

**NOTE** In previous versions of *Compound* for variables that were matrices but the size was not known one had to
declare the variable using the following syntax:

*Variable name = [];*

This is now changed and the empty brackets are no longer needed, so that this variable can be defined like a normal
variable as in case *A* .

**Example**



(continues on next page)

**1172** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

Some comments for the different cases of variable declaration.
**Case A** is the simplest one were we just declare the name of a variable.

**Case B** is similar to *Case A* but here more than one variables are declared simultaneously.

In **Case C** we combine the variable declaration with the assignment of a value to the variable. It worth noting that
in this case *Compound* automatically deducts the type of the variable based on the given value.

**Case D** declares a 1-Dimensional array of a defined size.

**Case E** declares a 2-Dimensional array of defined size. For this case, and also accordingly for *Case E*, one can use
previously defined integer variables instead of numbers.

**Case F** defines an array based on a list of given values. The array will automatically define it’s size based on the
size of the list. The values in the list do not have to be all of the same type.

**NOTE** In the past for *Case F* empty brackets were needed after the name of the variable. This is no longer necessary.

**NOTE** It is important not to forget the final **;** symbol in the end of each declaration because the result of omitting
it is undefined.

**Variables - Assignment**

Assigning a value to a variable has a rather straightforward syntax.

**Syntax:**
*VariableName = CustomFunction;*

*Where:*

*VariableName* is a variable already declared.

*CustomFunction* a mathematical expression.

**Example:**



(continues on next page)

**7.56. Compound Methods** **1173**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**NOTE** It is important to remember to finish the variable assignment using the **‘;’** symbol.

**Variables - Functions**

Variables in *Compound* have a small number of functions that can help exctract information about them. In the
current version of *Compound* these functions are the following:

**Syntax:**
VariableName.Function();

where *VariableName* is a variable that is already declared. Then the function will return a value that depends on
the *Function* that we used.

Currenlty *Compound* supports the following functions:

  - GetBool() *V.GetBool()*

  - GetDim1() *V.GetDim1()*

**1174** **Chapter 7. Detailed Documentation**

  - GetDim2() *V.GetDim2()*

  - GetDouble() *V.GetDouble()*

  - GetInteger() *V.GetInteger()*

  - GetSize() *V.GetSize()*

  - GetString() *V.GetString()*

  - PrintMatrix() *V.PrintMatrix()*

**Example:**



**ORCA Manual** **,** **Release 6.0.1**

(continues on next page)


**7.56. Compound Methods** **1175**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**V.GetBool()**

This function will return a boolean value in case the variable is boolean or integer. For integers it will return *false*
for 0 and *true* for all other integer values. In all other cases the program will crash providing a relevant message.

**Syntax:**

*myVar.GetBool();*

*where:*

*myVar* is an already initialized variable.

**Example**



**1176** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**V.GetDim1()**

This function works on a variable. It will return the size of the first dimension of an array. If the variable is a scalar
it will return 1.

**Syntax:**

*myVar.GetDim1();*

*where:*

*myVar* is an already initialized variable.

**Example**

**V.GetDim2()**

This function works on a variable. It will return the size of the second dimension of an array. If the variable is a
scalar or a 1-Dimensional array it will return 1.

**Syntax:**

*myVar.GetDim2();*

*where:*

*myVar* is an already initialized variable.

**Example**



(continues on next page)

**7.56. Compound Methods** **1177**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



**V.GetDouble()**

This function works on a variable. It will return a double value in case the variable is integer or double. In all other
cases the program will crash providing a relevant message.

**Syntax:**

*myVar.GetDouble();*

*where:*

*myVar* is an already initialized variable.

**Example**



**1178** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**V.GetInteger()**

This function works on a variable. It will return an integer value in case the variable is integer or double. In all
other cases the program will crash providing a relevant message.

**Syntax:**

*myVar.GetInteger();*

*where:*

*myVar* is an already initialized variable.

**Example**



**V.GetSize()**

This function works on a variable. If the variable is a scalar it will return 1. If the variable is a 1-Dimensional

array it will return the size of the array which is the same with the *GetDim1()* . If the variable is a 2-Dimensional
array it will return the results Dim1*Dim2.

**Syntax:**

*myVar.GetSize();*

*where:*

*myVar* is an already initialized variable.

**Example**



(continues on next page)

**7.56. Compound Methods** **1179**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**V.GetString()**

This function works on a variable. It will return a string of the value of the variable. It works for doubles, integers
and booleans.

**Syntax:**

*myVar.GetString();*

*where:*

*myVar* is an already initialized variable.

**Example**



**1180** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**V.PrintMatrix()**

This function works on variables. It will print print an array on a format with 8 columns.

**Syntax:** *myVar.PrintMatrix([NCols=numOfColumns]);*

*where:*

*myVar* is an already initialized variable.

*numOfColumns* is the desired number of columns for the printing. This is not obligatory and if not used then by
default ORCA will print using **4** columns.

**Example**

**Example:**

**NOTE** In case of scalars it will only print the header without any values.

**NOTE** It only works for arrays of type *‘double’* or type *‘integer’* . With all variables of other types the program
will exit providing an error message.

**With**

The purpose of the “with” command is to add the ability to call compound while adjusting some of the variables
that are already defined in the compound file. This means that if there is a variable defined in the compound file
and a value is assigned to it, we can during the call change the assigned value of this variable.

One can pass numbers, string or boolean variables.

It should be noted that it is not possible to call array variables this way. Beside this restriction, the syntax of the
variable assignment in the case of with is the same with the variable assignment in a normal *Compound* script.

An important note here is that in case we use the *With* command the *%Compound* block should end with an *‘End’*
even if we call a *Compound* script file.
**Syntax:**
**% compound** *“filename”*
**With**

*var1* = *val1* ;
*var2* = *val2* ;

**End**

**Example:**



(continues on next page)

**7.56. Compound Methods** **1181**

**ORCA Manual** **,** **Release 6.0.1**


(continued from previous page)


**Write2File**

With the *Print* command (see *Print* ) one can write in the ORCA output. Nevertheless it might be that one would
prefer to write to a different file. In *Compound* one can achieve this using the *write2File* command. The syntax
follows closely the syntax of ‘fprintf’ command of the programming language C. The arguments definition and the
syntax is identical with the syntax of the *Compound ‘Print’* command with the addition that one should define a
file object to send the printing.

**Syntax:**
*Write2File(file variable, format string, [variables]);*

*Where:*

*file variable:* is a predefined variable corresponding to an already open, through the *OpenFile* command, file.

*format string* and *variables* follow exactly the syntax of the *Print* command, so for more details please refere to
section *Print* .

**NOTE** Please remember once everything is writen to the file to close the file, using the *CloseFile* command (see
*CloseFile* ).

**1182** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


**Example:**



**Write2String**

In case one needs to construct a string using some variables, *Compound* provides the *Write2String* command. The
syntax of the command is identical with the *Write2File* (see *Write2File* ) command with the only exception that
instead of a file we should provide the name of a variable that is already declared in the file. The syntax of the
format and the variables used is identical with the *Print* command (please refer to *Print* . )

**Syntax:**

*Write2String(variable, format string, [variables]);*

*where:*

*variable:* is the name of a variable that should already be declared.

*format string* and *variables* follow exactly the syntax of the *Print* command, so for more details please refer to
section *Print* .

**Example:**

**7.56. Compound Methods** **1183**

**ORCA Manual** **,** **Release 6.0.1**



**7.56.2 List of known Properties**

The name and a sort explanation of all the known variables that can be automatically recovered, from the property
file, are given in the next table

Table 7.34: Variables, known to the compound block, with short e

====================================== ================================================

====================================== ==========================================AUTOC

====================================== ================================================

++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++Energies++++

++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++ ENERGY Gradien

**1184** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.34 – continued from p revious p a g e

++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++ Electric Properties (Dipole mom

++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++ Electric Properties (Polarizability

++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++ Electric Properties (Quadrupole mom

AUTOCI_QUADRUPOLE_MOMENT_ELEC_CONTRIB AutoCI The elctronic contribution to the quadrupole moment tensor
AUTOCI_QUADRUPOLE_MOMENT_NUC_CONTRIB AutoCI The nuclear contribution to the quadrupole moment tensor

++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++ Magnetic Properties (D Tensor

AUTOCI_D_TENSOR_MULTIPLICITY AutoCI The spin-multiplicity used for the D Tensor calculation
++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++ Magnetic Properties (G Tensor





**7.56. Compound Methods** **1185**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.34 – continued from p revious p a g e







MDCI_DSINGLET_CORR_ENERGY Correlation energy from singlet electron pairs (only for closed-shell
MDCI_DTRIPLET_CORR_ENERGY Correlation energy from triplet electron pairs (only for closed-shell)
MDCI_SSINGLET_CORR_ENERGY Correlation energy from singlet electron pairs (only for closed-shell
MDCI_STRIPLET_CORR_ENERGY Correlation energy from triplet electron pairs (only for closed-shell)



**1186** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.34 – continued from p revious p a g e



CASSCF_CD_SPECTRUM_INFO Information about the excitations of the CASSCF CD spectrum

CASPT2_CD_SPECTRUM_INFO Information about the excitations of the CASPT2 CD spectrum

CAS_CUSTOM_ABS_SPECTRUM_INFO Information about the excitations of the custom CASSCF absorption

CAS_CUSTOM_CD_SPECTRUM_INFO Information about the excitations of the custom CASSCF CD spectr

DCDCAS_ABS_SPECTRUM_INFO Information about the excitations of the DCDCAS absorption spectr



**7.56. Compound Methods** **1187**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.34 – continued from p revious p a g e







**1188** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.34 – continued from p revious p a g e



EXTRAP_NUM_OF_ENERGIES The number of energies (basis sets) used for the extrapolation







**7.56. Compound Methods** **1189**

**ORCA Manual** **,** **Release 6.0.1**


Table 7.34 – continued from p revious p a g e







**7.56.3 List of known Simple input commands**

The name and a sort explanation of all compound protocols that are know through the simple input line, are given
in the next table. The syntax is always:

**Syntax:**
! compound[ *protocol name* ]

Table 7.35: Protocols, known to the simple input line, with short expla



**1190** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.35 – continued from p revious p a g e

















**7.56. Compound Methods** **1191**

**ORCA Manual** **,** **Release 6.0.1**

Table 7.35 – continued from p revious p a g e


### **7.57 Compound Examples**

**7.57.1 Introduction**

A library of compound scripts exist in page https://github.com/ORCAQuantumChemistry/CompoundScripts .

**7.57.2 Hello World**

**Introduction**

This is the simplest script that nevertheless points to an important feature of *Compound* . That is the fact that
*Compound* does not have to run an actual ‘normal’ ORCA calculation but it can also be used as a driver for various
tasks, in this case to just print a message.

**Filename**

helloWorld.inp

**SCRIPT**



**7.57.3 New Job**

**Introduction**

One of the features of ORCA that will be deprecated in the future and should not be used any more is the *‘New_Job’*
feature. The current script is a simple example how *Compound* can be used to just run a series of calculations.

**Filename**

replaceNewJob.inp

**SCRIPT**



(continues on next page)

**1192** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**Comments**

From the *Compound* point of view the syntax in this script is not the most efficient one. It can be rewritten in more
compact, cleaner, general way. Neverteless this is meant only as an exmample of how *Compound* can replace older
ORCA calculations that used the, to be deprecated, *‘New_Job’* feature.

**7.57.4 High Accuracy**

**Introduction**

This is a script that utilizes the scheme by N. J. DeYonker, T. R. Cundari, and A. K. Wilson published on: J. Chem.
Phys. 124, 114104 (2006). The script calculates accurate total energies of molecules.

**Filename**

ccCA_CBS_2.cmp

**SCRIPT**



(continues on next page)

**7.57. Compound Examples** **1193**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**Comments**

It is interesting that in this scheme the total energy is treated and there is not separation in extrapolation between
HF energy and correlation energy.

**7.57.5 Scan**

**Introduction**

This is an example script for a 1-Dimensional geometry scan. It is set up for the Ne-Ne bond distance but can be
modified to suit the user’s specific needs.

**Filename**

scan_1D_1M_1P.cmp

**SCRIPT**



(continues on next page)

**1194** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
#
# ------------------------------------------------------------#

```
`# ----------------` `Variables to change (e.g. through` *'* `with` *'* `)` `--------------------------`
```
Variable method = "HF"; # The methods of the calculation
Variable basis = "cc-pVDZ"; # The basis set of the calculation
Variable restOfInput = "TightSCF"; # Maybe something common for the simple input
Variable charge = 0; # Charge
Variable mult = 1; # Spin multiplicity
Variable myPropName = "SCF_Energy"; # The properties we want to read
#
Variable lowerLimit = 2.5; # Lower limit value
Variable UpperLimit = 5.0; # Upper limit value
Variable NSteps = 13; # Number of steps for the grid
Variable baseFilename = "myPotential"; # The basename for the created files
Variable plotPotential= true; # Plot the potential instead of absolute values
Variable DoKcal = true; # Multiply the potential values with the␣

```
*˓→* `HartreeToKcal factor`
```
Variable removeFiles = true; # Remove *_Compound_*, *bas* files
# ------------------ python plot relevant variables --------------------------------------Variable DoPython = true; # if we want python or not
Variable lw = 4; # The line width in case we plot with python
Variable marker = "o"; # The type of markers
Variable markerSize = 10; # The size of the markers in case we plot
Variable fontSize = 18;
#
# ----------------------- Rest of the variables --------------------------------#
Variable HartreeToKcal = 627.5096080305927; # Hartree to kcal/mol conversion␣

```
*˓→* `factor`
```
Variable stepSize = (UpperLimit-LowerLimit)/(NSteps-1); # The stepsize of the grid
Variable calcValues[NSteps]; # An array to store the␣

```
*˓→* `calculated values`
```
Variable res, dist, calcValue;
Variable myFilename, csvFilename;
Variable fPtr; # A file to write
# --------------------------------------------------# Open and Write file header for the absolute values
# --------------------------------------------------write2String(csvFilename, "%s_absValues.csv", baseFilename);
fPtr = OpenFile(csvFilename, "w");
write2File(fptr, "distance,method,property,calcValue\n");
# --------------------------------------------------# Perform the calculations and update the file
# --------------------------------------------------for iStep from 0 to NSteps-1 Do
 dist = lowerLimit + (iStep)*stepSize;
 New_Step
  !&{method} &{basis} &{restOfInput}
  *xyz &{charge} &{mult}
   Ne 0.0 0.0 0.0
   Ne 0.0 0.0 &{dist}
  *
  Step_end
  res = calcValue.readProperty(propertyName=myPropName);
  write2File(fPtr, "%.4lf,%20s,%20s,%20.10lf\n", dist, method,myPropName, calcValue);
  calcValues[iStep]=calcValue;
EndFor
CloseFile(fPtr); # Close the file

```
(continues on next page)

**7.57. Compound Examples** **1195**

**ORCA Manual** **,** **Release 6.0.1**


(continued from previous page)



**Comments**

This script has some interesing features. It contains two variables *removeFiles* and *DoPython* . If the first of them
is set to *true* then the script will use a system command to remove files that are not needed anymore after the end
of the calculation. The latter, *DoPython*, if set to *true* will read the *.csv* file that is created and write a *python* file

**1196** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

to make a plot of the results. Then it will run the python script to actually make the plot.

**7.57.6 Numerical polarizabilities**

**Introduction**

This script calculates numerically the polarizability of the molecule using single point calculations with an electric
field.

**Filename**

numericalPolarizability.cmp

**SCRIPT**

(continues on next page)

**7.57. Compound Examples** **1197**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
EFree.ReadProperty(propertyName=enPropName);
# -----------------------------------------------------------# Loop over the x, y, z directions
# -----------------------------------------------------------for i from 0 to 2 Do
 for j from 0 to 2 Do
  # ---------------------------------------------------------  # Create the appropriate direction oriented field string
  # ---------------------------------------------------------  # ---------------------- (++) -----------------------------  for k from 0 to 2 Do
   FField[k] = 0.0;
  EndFor
  FField[i] = FField[i] + E_Field;
  FField[j] = FField[j] + E_Field;
  write2String(FFieldStringPlusPlus, " %lf, %lf, %lf",
  FField[0], FField[1], FField[2]);
  #
  # --------------------- (+-) -----------------------------  for k from 0 to 2 Do
   FField[k] = 0.0;
  EndFor
  FField[i] = FField[i] + E_Field;
  FField[j] = FField[j] - E_Field;
  write2String(FFieldStringPlusMinus, " %lf, %lf, %lf",
  FField[0], FField[1], FField[2]);
  #
  # --------------------- (-+) -----------------------------  for k from 0 to 2 Do
   FField[k] = 0.0;
  EndFor
  FField[i] = FField[i] - E_Field;
  FField[j] = FField[j] + E_Field;
  write2String(FFieldStringMinusPlus, " %lf, %lf, %lf",
  FField[0], FField[1], FField[2]);
  #
  # --------------------- (--) -----------------------------  for k from 0 to 2 Do
   FField[k] = 0.0;
  EndFor
  FField[i] = FField[i] - E_Field;
  FField[j] = FField[j] - E_Field;
  write2String(FFieldStringMinusMinus, " %lf, %lf, %lf",
  FField[0], FField[1], FField[2]);
  # ---------------------------------------  # Perform the calculations.
  # The plus_plus (++) one
  # ---------------------------------------  ReadMOs(1);
  New_Step
   !&{method} &{basis} &{restOfInput}
   %SCF
    EField = &{FFieldStringPlusPlus}
   End
   &{blocksInput}
  Step_End
  EPlusPlus.readProperty(propertyName=enPropName);
  # ---------------------------------------  # The plus_minus (+-) one

```
(continues on next page)

**1198** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
  # ---------------------------------------  ReadMOs(1);
  New_Step
   !&{method} &{basis} &{restOfInput}
    %SCF
    EField = &{FFieldStringPlusMinus}
   End
   &{blocksInput}
  Step_End
  EPlusMinus.readProperty(propertyName=enPropName);
  # ---------------------------------------  # The minus_plus (-+) one
  # ---------------------------------------  ReadMOs(1);
  New_Step
   !&{method} &{basis} &{restOfInput}
   %SCF
    EField = &{FFieldStringMinusPlus}
   End
   &{blocksInput}
  Step_End
  EMinusPlus.readProperty(propertyName=enPropName);
  # ---------------------------------------  # And the minus_minus (--) one
  # ---------------------------------------  ReadMOs(1);
  New_Step
   !&{method} &{basis} &{restOfInput}
    %SCF
    EField = &{FFieldStringMinusMinus}
   End
   &{blocksInput}
  Step_End
  EMinusMinus.readProperty(propertyName=enPropName);
  a[i][j] = -(EPlusPlus-EPlusMinus-EMinusPlus+EMinusMinus)/(4*E_Field*E_Field);
 EndFor
EndFor
# ----------------------------------------# Diagonalize
# ----------------------------------------a.Diagonalize(aEigenValues, aEigenVectors);
# ----------------------------------------# Do some printing
# ----------------------------------------print( "\n\n");
print( " -------------------------------------------------------\n");
print( " COMPOUND \n");
print( " Numerical calculation of dipole polarizability\n");
print( " -------------------------------------------------------\n");
print( " Molecule : %s\n", molecule);
print( " charge : %d\n", charge);
print( " Mult : %d\n", mult);
print( " Method : %s\n", method);
print( " Basis : %s\n", basis);
print( " RestOfInput : %s\n", restOfInput);
print( " BlocksInput : %s\n", blocksInput);
print( " The electric field perturbation used was: %.5lf a.u.\n", E_Field);
print( " \n\n");

```
(continues on next page)

**7.57. Compound Examples** **1199**

**ORCA Manual** **,** **Release 6.0.1**


(continued from previous page)

**Comments**

In this script we also use the linear algebra *diagonalize* function that is available in *Compound* .

**7.57.7 Iterative optimization**

**Introduction**

This is a script that will perform a geometry optimization, then run a frequency calculation and in case there are
negative frequencies it will adjust the geometry, based on the Hessian, and optimize again.

**Filename**

iterativeOptimization.cmp

**SCRIPT**



(continues on next page)

**1200** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
# iterative Optimization protocol to find structure with no negative
# frequencies (e.g. real minima)
#
# Step 1. Run a single point calculation (we need it for the first property file)
#
# Step 1. Loop and perform calculations with (optimization and frequencies)
#
# Step 2. Check the frequencies. If there are negative ones use the hessian
# of the appropriate normal mode to adjust the geometry
#

```
`# ------ Variables to adjust (e.g. using` *'* `with` *'* `) -------------------`
```
Variable method = "HF"; #"HF-3c";
Variable MaxNTries = 25; # Number of maximum tries
Variable CutOff = -10.0; # CutOff for a negative frequency
Variable scaling = 0.6; # Scaling factor for normal mode
Variable NNegativeTarget = 0; # Number of negative frequencies we allow
Variable myFilename = "xyzInput.xyz";
Variable charge = 0;
Variable multiplicity = 2;
# -----------------------------------------------------------------# ------ Rest of variables ------------------Geometry myGeom;
Variable freqs, modes;
Variable res = -1;
Variable NNegative = 0;
Variable OptDone;
# ----------------------------------------------------------# Perform a single point calculation. We need it for
# the initial geometry from the property file
# ----------------------------------------------------------New_Step
 !&{method}
Step_End
myGeom.Read();
myGeom.WriteXYZFile(filename=myFilename);
# ----------------------------------------------------------# Start a for loop over number of tries
# ---------------------------------------------------------For itry From 1 To maxNTries Do
 # ------------------------------------------- # Perform a geometry optimization/Frequency calculation
 # ------------------------------------------- New_Step
  ! &{method} freq Opt
  *xyzfile &{charge} &{multiplicity} &{myFilename}
 Step_End
 res = freqs.readProperty(propertyName = "THERMO_FREQS");
 res = modes.readProperty(propertyName = "HESSIAN_MODES");
 myGeom.Read();
 # -------------------------------------------- # check for sufficiently negative frequencies
 # -------------------------------------------- NNegative = 0;
 For ifreq From 0 to freqs.GetSize()-1 Do
  if ( freqs[ifreq] < CutOff ) then
    myGeom.FollowNormalMode(vibrationSN=ifreq, scalingFactor=scaling);
    NNegative = NNegative + 1;
  endif

```
(continues on next page)

**7.57. Compound Examples** **1201**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**7.57.8 Gradient extrapolation**

**Introduction**

This script extrapolates the gradient of a molecule. It uses a two point extrapolation where the Hartree-Fock and
correlation parts of the gradient are extrapolated separately. This opens the way for geometry optimizations with
extrapolated gradients.

**Filename**

gradientExtrapolation.cmp

**SCRIPT**



(continues on next page)

**1202** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
#
#
# NOTE: It works with an xyz file the name of which we should provide.
# using the variable initialXYZFilename.
#
# We extrapolate the SCF part using the scheme
# proposed in: J. Phys. Chem. 129, 184116, 2008
# E_SCF(X) = E_SCF(CBS)+Aexp(-a*SQRT(X))
#
# We extrapolate the correlation part using the schem
# proposed in: J. Chem. Phys. 1997, 106, 9639
# E_CBS(CORR)=(X^b*E_X(CORR)-Y^b*E_Y(CORR))/(X^b-Y^b)
# We use alpha and beta exponents proposed in:
# J. Chem. Theory Comput., 7, 33-43 (2011)
# ---------------------- Variables ------------------------------
```
`# --- Variables to be adjusted (e.g. using` *'* `with` *'* `----------------------`
```
Variable Molecule = "initial.xyz"; # xyz file of the initial structure
Variable charge = 0; # Charge
Variable multiplicity = 1; # Spin multiplicity
Variable method = "MP2"; # The method we use for the calculation
Variable LowerBasis = "cc-pVDZ"; # Small basis set
Variable UpperBasis = "cc-pVTZ"; # Big basis set
Variable restOfInput = "EnGrad "; # The rest of the simple input
Variable addCorrelation = true; # If we have a correlation part
Variable scfEnPropName = "MP2_Ref_Energy"; # The name of the property for the SCFenergy
Variable corrEnPropName = "MP2_Corr_Energy"; # The name of the property for the␣

```
*˓→* `correlation energy`
```
Variable LowerCardinal = 2; # Cardinal number of small basis set
Variable UpperCardinal = 3; # Cardinal number of big basis set
Variable alpha = 4.420; # Exponent for SCF extrapolation
Variable beta = 2.460; # Exponent for corrleation extrapolation
Variable enGradFilename = "result.engrad"; # Filename of the ORCA engrad file
Variable produceEnGradFile = true; # Produce an ORCA engrad file
# --------------------------------------------------------------------# -------------- Rest of the variables -------------------------------Geometry myGeom;
Variable scfGradX, scfGradY; # SCF Gradients
Variable scfEnX, scfEnY, scfEnCBS; # SCF energies
Variable corrEnX, corrEnY, corrEnCBS; # Correlation enegies
Variable totalGradX, totalGradY; # Total Gradients
Variable eX = 0.0;
Variable eY = 0.0;
Variable res = -1;
Variable denominator = 0.0;
Variable gradX = 0.0, gradY = 0.0, gradCBS=0.0;
Variable nAtoms = 0;
Variable EnGradFile;
Variable Cartesians, AtomicNumbers;
# ------------------------------------------------------------------# Step 1. SCF Calculation with small basis set (X)
# ------------------------------------------------------------------New_Step
 ! HF &{LowerBasis} &{restOfInput}
 *xyzfile &{charge} &{multiplicity} &{Molecule}
Step_end
res = scfEnX.readProperty(propertyName="SCF_Energy");
res = scfGradX.readProperty(propertyName="Nuclear_Gradient", Property_Base=true);
myGeom.Read();

```
(continues on next page)

**7.57. Compound Examples** **1203**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
nAtoms = myGeom.GetNumOfAtoms();
# -----------------------------------------------------------------# Step 2. Initialize rest of the variables
# -----------------------------------------------------------------Variable corrGradX[3*nAtoms]; # Correlation part of gradient with basis X
Variable corrGradY[3*nAtoms]; # Correlation part of gradient with basis Y
Variable corrGradCBS[3*nAtoms]; # CBS estimation of correlation part of the gradient
Variable scfGradCBS[3*nAtoms]; # CBS estimation of SCF part of the gradient
Variable totalGradCBS[3*nAtoms];# CBS estimation of total gradient
# ------------------------------------------------# Step3. Correlation Calculation with small basis set (X)
# ------------------------------------------------if (addCorrelation) then
 New_Step
  ! &{method} &{LowerBasis} &{restOfInput}
 Step_end
 res = scfEnX.readProperty(propertyName=scfEnPropName);
 res = corrEnX.readProperty(propertyName=corrEnPropName);
 res = totalGradX.readProperty(propertyName="Nuclear_Gradient", Property_Base=true);
 # ------------------------------------------------ # Evaluate correlation gradient with small basis set (X)
 # ------------------------------------------------ corrGradX =mat_p_mat(1, totalGradX, -1, scfGradX);
EndIf
# ------------------------------------------------# Step4. SCF Calculation with large basis set (Y)
# ------------------------------------------------New_Step
 !HF &{UpperBasis} &{restOfInput}
Step_End
res = scfEnY.readProperty(propertyName="SCF_Energy");
res = scfGradY.readProperty(propertyName="Nuclear_Gradient", Property_Base=true);
# ------------------------------------------------# Step5. Correlation calculation with large basis set (Y)
# ------------------------------------------------if (addCorrelation) then
 New_Step
  ! &{method} &{UpperBasis} &{restOfInput}
 Step_end
 res = scfEnY.readProperty(propertyName=scfEnPropName);
 res = corrEnY.readProperty(propertyName=corrEnPropName);
 res = totalGradY.readProperty(propertyName="Nuclear_Gradient", Property_Base=true);
 # ------------------------------------------------ # Evaluate correlation gradient with big basis set Y
 # ------------------------------------------------ corrGradY = mat_p_mat(1, totalGradY, -1, scfGradY);
EndIf
# ------------------------------------------------# Step6. Extrapolate the SCF part of the gradient and energy
# ------------------------------------------------eX = exp(-alpha * sqrt(LowerCardinal));
eY = exp(-alpha * sqrt(UpperCardinal));
denominator = eY-eX;

```
(continues on next page)

**1204** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
scfEnCBS = (scfEnX*eY - scfEnY*eX)/(eY-eX);
for i from 0 to scfGradX.GetSize()-1 Do
 gradX = scfGradX[i];
 gradY = scfGradY[i];
 scfGradCBS[i] = (gradX * eY - gradY * eX)/denominator;
endFor
if (addCorrelation) then
 # ------------------------------------------------ # Step7. Extrapolate the correlation part of the gradient and energy
 # ------------------------------------------------ denominator = LowerCardinal^(beta)-(UpperCardinal)^(beta);
 corrEnCBS = (LowerCardinal^(beta)*corrEnX-(UpperCardinal)^(beta)*corrEnY)/denominator;
 for i from 0 to scfGradX.GetSize()-1 Do
  gradX = corrGradX[i];
  gradY = corrGradY[i];
  corrGradCBS[i] = (LowerCardinal^(beta)*gradX-(UpperCardinal)^(beta)*gradY)/denominator;
 endFor
 # ------------------------------------------------ # Add SCF and correlation part to get total CBS extrapolated values
 # ------------------------------------------------ totalGradCBS = mat_p_mat( 1, scfGradCBS, 1, corrGradCBS);
EndIf
# ------------------------------------------------# Step8. Present the results
# ------------------------------------------------print( "\n\n\n");
print( "--------------------------------------------------------\n");
print( " Compound Extrapolation of Gradient \n");
print( "--------------------------------------------------------\n");
print( "Number of atoms : %d\n", nAtoms);
print( "Lower basis set : %s\n", LowerBasis);
print( "Upper basis set : %s\n", UpperBasis);
print( "Alpha : %.2lf\n", alpha);
print( "Beta : %.2lf\n", beta);
print( "Lower Cardinal number : %d\n", LowerCardinal);
print( "Upper Cardinal number : %d\n", UpperCardinal);
print( "Method : %s\n", method);
print( "AddCorrelation : %s\n", AddCorrelation.GetString());
print( "Produce EnGrad File : %s\n", produceEnGradFile.GetString());
print( "\n\n");
print( "SCF Energy with small basis set : %.12e\n", scfEnX);
print( "SCF Energy with big basis set : %.12e\n", scfEnY);
print( "Extrapolated SCF energy : %.12e\n", scfEnCBS);
print("\n\n");
if (addCorrelation) then
 print( "Correlation Energy with small basis set : %.12e\n", corrEnX);
 print( "Correlation Energy with big basis set : %.12e\n", corrEnY);
 print( "Extrapolated correlation energy : %.12e\n", corrEnCBS);
 print("\n\n");
 print( "Total Energy with small basis set : %.12e\n", scfEnX + corrEnX);
 print( "Total Energy with big basis set : %.12e\n", scfEnY + corrEnY);
 print( "Extrapolated Total energy : %.12e\n", scfEnCBS + corrEnCBS);
 print("\n\n");
else

```
(continues on next page)

**7.57. Compound Examples** **1205**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
 print( "Total Energy with small basis set : %.12e\n", scfEnX);
 print( "Total Energy with big basis set : %.12e\n", scfEnY);
 print( "Extrapolated Total energy : %.12e\n", scfEnCBS);
 print("\n\n");
EndIf
print( "----------------------------------------------------------------\n");
print( "SCF Gradient with basis set: %s\n", LowerBasis );
print( "----------------------------------------------------------------\n");
print( "Atom %20s %20s %20s\n", "X", "Y", "Z");
for i from 0 to nAtoms-1 Do
 print("%4d %20lf %20lf %20lf\n", i, scfGradX[3*i], scfGradX[3*i+1],␣

```
*˓→* `scfGradX[3*i+2]);`
```
EndFor
if (addCorrelation) then
 print( "----------------------------------------------------------------\n");
 print( "Correlation Gradient with basis set: %s\n", LowerBasis );
 print( "----------------------------------------------------------------\n");
 print( "Atom %20s %20s %20s\n", "X", "Y", "Z");
 for i from 0 to nAtoms-1 Do
  print("%4d %20lf %20lf %20lf\n", i, corrGradX[3*i], corrGradX[3*i+1],␣

```
*˓→* `corrGradX[3*i+2]);`
```
 EndFor
 print( "----------------------------------------------------------------\n");
 print( "Total Gradient with basis set: %s\n", LowerBasis );
 print( "----------------------------------------------------------------\n");
 print( "Atom %20s %20s %20s\n", "X", "Y", "Z");
 for i from 0 to nAtoms-1 Do
  print("%4d %20lf %20lf %20lf\n", i, totalGradX[3*i], totalGradX[3*i+1],␣

```
*˓→* `totalGradX[3*i+2]);`
```
 EndFor
EndIf
print( "----------------------------------------------------------------\n");
print( "SCF Gradient with basis set: %s\n", UpperBasis );
print( "----------------------------------------------------------------\n");
print( "Atom %20s %20s %20s\n", "X", "Y", "Z");
for i from 0 to nAtoms-1 Do
 print("%4d %20lf %20lf %20lf\n", i, scfGradY[3*i], scfGradY[3*i+1],␣

```
*˓→* `scfGradY[3*i+2]);`
```
EndFor
if (addCorrelation) then
 print( "----------------------------------------------------------------\n");
 print( "Correlation gradient with basis set: %s\n", UpperBasis );
 print( "----------------------------------------------------------------\n");
 print( "Atom %20s %20s %20s\n", "X", "Y", "Z");
 for i from 0 to nAtoms-1 Do
  print("%4d %20lf %20lf %20lf\n", i, corrGradY[3*i], corrGradY[3*i+1],␣

```
*˓→* `corrGradY[3*i+2]);`
```
 EndFor
 print( "----------------------------------------------------------------\n");
 print( "Total Gradient with basis set: %s\n", UpperBasis );
 print( "----------------------------------------------------------------\n");
 print( "Atom %20s %20s %20s\n", "X", "Y", "Z");
 for i from 0 to nAtoms-1 Do
  print("%4d %20lf %20lf %20lf\n", i, totalGradY[3*i], totalGradY[3*i+1],␣

```
*˓→* `totalGradY[3*i+2]);`
```
 EndFor
EndIf

```
(continues on next page)

**1206** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
print( "----------------------------------------------------------------\n");
print( "Extrapolated SCF part of the Gradient:\n" );
print( "----------------------------------------------------------------\n");
print( "Atom %20s %20s %20s\n", "X", "Y", "Z");
for i from 0 to nAtoms-1 Do
 print("%4d %20lf %20lf %20lf\n", i, scfGradCBS[3*i], scfGradCBS[3*i+1],␣

```
*˓→* `scfGradCBS[3*i+2]);`
```
EndFor
if (addCorrelation) then
 print( "----------------------------------------------------------------\n");
 print( "Correlation Gradient with basis set:\n" );
 print( "----------------------------------------------------------------\n");
 print( "Atom %20s %20s %20s\n", "X", "Y", "Z");
 for i from 0 to nAtoms-1 Do
  print("%4d %20lf %20lf %20lf\n", i, corrGradCBS[3*i], corrGradCBS[3*i+1],␣

```
*˓→* `corrGradCBS[3*i+2]);`
```
 EndFor
 print( "----------------------------------------------------------------\n");
 print( "Total Gradient with basis set:\n" );
 print( "----------------------------------------------------------------\n");
 print( "Atom %20s %20s %20s\n", "X", "Y", "Z");
 for i from 0 to nAtoms-1 Do
  print("%4d %20lf %20lf %20lf\n", i, totalGradCBS[3*i], totalGradCBS[3*i+1],␣

```
*˓→* `totalGradCBS[3*i+2]);`
```
 EndFor
EndIf
print( "----------------------------------------------------------------\n");
if (produceEnGradFile) then
 # ----------------------------------------- # Read the geometry of the last calculation
 # ----------------------------------------- myGeom.Read();
 Cartesians = myGeom.GetCartesians();
 atomicNumbers = myGeom.GetAtomicNumbers();
 EnGradFile = openFile(enGradFilename, "w");
 Write2File(EnGradFile, "\n\n\n");
 Write2File(EnGradFile, " %d\n", nAtoms);
 Write2File(EnGradFile, "\n\n\n");
 if (addCorrelation) then
  Write2File(EnGradFile, " %.12lf\n", scfEnCBS + corrEnCBS);
 else
  Write2File(EnGradFile, " %.12lf\n", scfEnCBS);
 EndIf
 Write2File(EnGradFile, "\n\n\n");
 for i from 0 to 3*nAtoms-1 Do
  if (addCorrelation) then
   Write2File(EnGradFile, " %20.12lf\n", totalGradCBS[i]);
  else
   Write2File(EnGradFile, " %20.12lf\n", scfGradCBS[i]);
  EndIf
 EndFor
 Write2File(EnGradFile, "\n\n\n");
 for i from 0 to nAtoms-1 Do
  Write2File(EnGradFile, "%5d %12.8lf %12.8lf %12.8lf\n", atomicNumbers[i],␣

```
*˓→* `cartesians[i][0], cartesians[i][1], cartesians[i][2]);`
```
 EndFor
 closeFile(EnGradFile);

```
(continues on next page)

**7.57. Compound Examples** **1207**

**ORCA Manual** **,** **Release 6.0.1**


(continued from previous page)


**Comments**

**7.57.9 BSSE Optimization**

**Introduction**

This script optimizes the geometry of a molecule using gradients corrected for Basis Set Superposition Error
(BSSE) correction. The basic step is the usage of a second script that calculates BSSE corrected gradients.

**Filename**

BSSEOptimization.cmp

**SCRIPT**



(continues on next page)

**1208** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
variable myFilename = "compoundBSSE"; # Name for the created xyz files
Variable baseFilename = "run";
Variable gradCreateFile = "BSSEGradient.cmp";# The compound script that extrapolates the␣

```
*˓→* `gradient`
```
Variable DoOptimization = false; # Optimize the monomers or not
Variable produceEnGradFile = true; # Produce an ORCA engrad file
Variable enGradFilename = "result.engrad"; # Filename of the ORCA engrad file
# ------------------------------------------------------#
# Variables for the driver script
Variable createDriverScript = true; # The shell script driver
Variable driverScript; # A script to create the extrapolated energy␣

```
*˓→* `gradient`
```
Variable driverScriptName = "runningScript";
Variable submitCommand = "orca";
# -------------------------------------------------------# -------------------------------------------------------#
# Variables for the ORCA input
Variable createORCAInput = true;
Variable orcaInput; # The ORCA input for the gradient extrapolation
Variable orcaInputName = "runGradient.inp";
# -------------------------------------------------------# -----------------------------------------------# 1. Maybe Create the necessary driver script
# for the external optimizer and make it executable
# NOTE: This will depenend on the operating system
# ------------------------------------------------if (createDriverScript) then
 driverScript = openFile(driverScriptName, "w");
 write2File(driverScript, "source ~/.bashrc\n");
 write2File(driverScript, "%s %s\n", submitCommand, orcaInputName );
 write2File(driverScript, "cp %s %s_Compound_1_EXT.engrad\n", engradFilename, baseFilename);
 closeFile(driverScript);
 sys_cmd("chmod +x %s",driverScriptName);
EndIf
# -----------------------------------------------# 2. Maybe Create the ORCA input that will run the
# compound script for the gradient extrapolation
# ------------------------------------------------if (createORCAInput) then
 orcaInput = openFile(orcaInputName, "w");
 Write2File(orcaInput, "%%Compound \"%s\"\n", gradCreateFile);
 Write2File(orcaInput, " with\n");
 Write2File(orcaInput, " molecule =\"%s_Compound_1_EXT.xyz\"\;\n", baseFilename);
 Write2File(orcaInput, " charge = %d\;\n", charge);
 Write2File(orcaInput, " mutliplicity = %d\;\n", mult);
 Write2File(orcaInput, " method = \"%s\"\;\n", method);
 Write2File(orcaInput, " basis = \"%s\"\;\n", basis);
 Write2File(orcaInput, " restOfInput = \"%s\"\;\n", restOfInput);
 Write2File(orcaInput, " myPropName = \"%s\"\;\n", myPropName);
 Write2File(orcaInput, " myFilename = \"%s\"\;\n", myFilename);
 Write2File(orcaInput, " removeFiles = false\;\n");
 Write2File(orcaInput, " DoOptimization = %s\;\n", DoOptimization.GetString());
 Write2File(orcaInput, " produceEnGradFile = %s\;\n", produceEnGradFile.GetString());
 Write2File(orcaInput, " enGradFilename = \"%s\"\;\n", enGradFilename);
 Write2File(orcaInput, "End\n");
 closeFile(orcaInput);

```
(continues on next page)

**7.57. Compound Examples** **1209**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



**Comments**

The initial structure should contain some ghost atoms.

**7.57.10 Umbrella script**

**Introduction**

This script calculates the potential for the “umbrella effect” in NH_3. In addition it locates the minima and maxima
in the potential surface.

**Filename**

Umbrella.cmp

**SCRIPT**




(continues on next page)

**1210** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
```
for iang from 0 to nsteps-1 do
 angle = amin + iang*step;
 JobStep = iang+1;
 JobStep_m= JobStep-1;
 if (iang>0) then
  Read_Geom(JobStep_m);
  New_step
   ! &{method} &{basis} TightSCF Opt
   %base "&{JobName}.step&{JobStep}"
   %geom constraints
    {A 1 0 2 &{angle} C}
    {A 1 0 3 &{angle} C}
    {A 1 0 4 &{angle} C}
    end
   end
  Step_End
 else
  New_step
   ! &{method} &{basis} TightSCF Opt
   %base "&{JobName}.step&{JobStep}"
   %geom constraints
    {A 1 0 2 &{angle} C}
    {A 1 0 3 &{angle} C}
    {A 1 0 4 &{angle} C}
    end
   end
   * int 0 1
   N 0 0 0 0.0 0.0 0.0
   DA 1 0 0 2.0 0.0 0.0
   H 1 2 0 1.06 &{angle} 0.0
   H 1 2 3 1.06 &{angle} 120.0
   H 1 2 3 1.06 &{angle} 240.0
   *
  Step_End
 endif
  energies[iang].readProperty(propertyName="SCF_ENERGY");
  print(" index: %3d Angle %6.2lf Energy: %16.12lf Eh\n", iang, angle, energies[iang]);
EndFor
# Print a summary at the end of the calculation
# --------------------------------------------print("////////////////////////////////////////////////////////\n");
print("// POTENTIAL ENERGY RESULT\n");
print("////////////////////////////////////////////////////////\n");
variable minimum,maximum;
variable Em,E0,Ep;
variable i0,im,ip;
for iang from 0 to nsteps-1 do
 angle = amin + 1.0*iang*step;
 JobStep = iang+1;
 minimum = 0;
 maximum = 0;
 i0 = iang;
 im = iang-1;
 ip = iang+1;
 E0 = energies[i0];
 Em = E0;
 Ep = E0;
 if (iang>0 and iang<nsteps-1) then

```
(continues on next page)

**7.57. Compound Examples** **1211**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



**7.57.11 Multi reference**

**Introduction**

This is a script that calculates the atomic electron denstities in free atoms and makes a library of them.

**Filename**

atomDensities.inp

**SCRIPT**



(continues on next page)

**1212** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



**Comments**

Here, it’s interesting to note that depending on the selected atom, the script either performs a CASSCF calculation,
which provides details such as the number of electrons and number of roots, among other parameters, or it carries
out a simple Hartree-Fock calculation.

**7.57.12 GoTo**

**Introduction**

This is a brief example demonstrating how the *GoTo* command can be used in *Compound* .

**Filename**

goTo_Example.inp

**SCRIPT**



(continues on next page)

**7.57. Compound Examples** **1213**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)
### **7.58 orca_2json**

This utility program supports the exchange of external ORCA data like geometry, orbitals and basisets but also of
internal ORCA data like 1-electron and 2-electron integals with other programs.

**7.58.1 Export ORCA data**

The program reads information like geometries, basis sets, MOs etc. stored in the `.gbw` file or other equivalent ones
as `.uno`, `.mp2nat`, `.qro` etc. and calculates integrals to export them in JSON standard output formats. For density
information the `.densities` file must also be available. The program is called as a standalone via command line.

**Syntax:**



The following ASCII and binary JSON-formats are available as command line options. It is possible to specify
more than one format option.



In addition two more options are availble. The first of them is used to translate a basename.property.txt file to a
corresponding one in JSON format (see *Property File* ).
```
  -property Translate a *.txt property file to a *.json one

```
Finally, orca_2json has the ability to create a .gbw file from a json file. For this one needs to use the ‘-gbw’ option
(see *Import JSON data into ORCA* ).
```
  -gbw Create a GBW file from a json one

```
**1214** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**7.58.2 Configuration file**

The data stored in the json file can be configured more individually. Some information like atom information,
geometry and charge are always written in the outputfile (see *Basic Information* ). Other data can be requested via
keywords in a JSON-formatted configuration file that either exists for every ORCA output file or for all files in a
directory. Without these configuration files **ALL** available data are stored except for the densities and the integrals.
Because of the huge amount of data these are only available when explicitly requested in the configuration file.

You can specify a basename-dependend configuration file
```
BaseName.json.conf

```
or a global file used for all requests in a directory.
```
orca.json.conf

```
Most keywords in the configuration file can be activated or deactivated with true or false but some keywords like
densities or output formats have more options and require a list of values. If an option is not specifically selected
it is omitted.

**Structure of the configuration file** :



**Example**



Using the above configuration file in the working directory, *orca_2json* will not export the molecular coefficients
and the basis set information.

**Example**

Here is an example configuration file with most available keywords where everything is disabled except for the
basis set information and the specified Integrals, all densities stored in the density file are requested and the output
format should be ascii json and binary json.

(continues on next page)

**7.58. orca_2json** **1215**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)

**7.58.3 Available information**

**Property File**

Beside all information that we will see orca_2json can create, it can also translate the property file of ORCA
(basename.property.txt) to a JSON file. This option gives access to all properties stored in the property file. (For
more information on property file see *Property File* ).

The **syntax** is:
```
orca_2json basename -property

```
*Where*

*basename* is the name of the property file **without** the extension *property.txt* .

**Example**

If we use the following ORCA input (with the name test.inp):



ORCA will create and store on disk, a file named *“test.property.txt”* . The start of the file will look like this:



Then running *orca_2json* in the following way:

**1216** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**
```
orca_2json test -property

```
ORCA will create a new file on disk, named *“test.property.json”* . The start of this file will look like this:



**Basic Information**

Some basic information will always be written into the JSON-file as

**7.58. orca_2json** **1217**

**ORCA Manual** **,** **Release 6.0.1**

For example using the following configuration file where we set everything to false:

will still produce a json file which for the case of a H2 molecule should look like:





(continues on next page)

**1218** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



**Densities**

*orca_2json* can also export calculated densities in json format.

**Syntax** *“Densities” : [list of densities]*

Where *list of densities* should be a list of strings with the expected densities.

**NOTE** By default densities, due to their potential size, are not exported to a json file.

**NOTE** An empty bracket syntax ( *“Densities” : []* ) will cause the program to crash.

**NOTE** There is the string “All” available where the program will export all available densities.

**Electron Integrals**

The list of available electron integrals is shown in the next table.

**7.58. orca_2json** **1219**

**ORCA Manual** **,** **Release 6.0.1**

**1-electron integrals**

For 1-electron integrals we use the following notation:

**Example**

will produce a json file were only the H-Matrix and the Overlap matrix are printed (beside the basic information).
Please note that for the one electron relativistic integrals there is a separate variable (see *1-electron relativistic*
*integrals* )

**1-electron property integrals**

Also available are 1-electron property integrals.

Currently the following options are valid:

**Example**



**1220** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**1-electron relativistic integrals**

1-electron relativistic integrals follow the same notation as the corresponding non-relativistic ones (see *1-electron*
*integrals* ).

**Example**

This example will produce and store in the corresponding json file the X2C-transformed H-Matrix, as well as
the separate potential and kinetic contributions. Note that while the “relativistic” overlap matrix is available for
completeness, in X2C it is identical to the non-relativistic overlap by construction.

**1-electron relativistic property integrals**

Also available are 1-electron relativistic (X2C) property integrals similar to the non-relativistic ones but with
reduced options.

Currently the following options are valid:

**Example**



**Origin setting**

The origin of the electric property is per default the Cartesian origin but also the center of mass and the center of
nuclear charges can be selected. Additionally an arbitrary position can be given as x,y,z coordinates when ori_el =
3 is chosen. Currently the following options are valid:

**7.58. orca_2json** **1221**

**ORCA Manual** **,** **Release 6.0.1**

**Example**



**2-electron integrals**

ORCA_2json can produce and write on disk three main categories of 2-electron integrals.

1. Two-electron integrals in atomic basis ( *2-electron integrals in AO basis* )

2. Two-electron integrals in molecular basis ( *2-electron integrals in MO basis* )

3. Two-electron integrals using the resolution of identity approximation (RI). ( *RI 2-electron integrals* )

**2-electron integrals in AO basis**

In atomic basis the two-electron integrals can be saved in Coulomb order or in Exchange order. The keywords for
the two options are shown in the next table.

**2-electron integrals in MO basis**

In molecular basis, ORCA follows the accepted notation where by I,J,K and L we specify “internal” orbitals, meaning occupied in the reference wavefunction while by A,B,C and D we specify “external” orbitals, meaning orbitals
that are empty in the reference wavefunction. With P,Q,R and S we specify all possible orbitals, meaning both
“internal” and “external”. The available keywords in *“orca_2json”* for the two-electron integrals in the molecular
basis are the ones shown in the table below:

**1222** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**Example**

**RI 2-electron integrals**

Using the Resolution of Identity (RI) one can create the integrals in a more efficient way. There are two main
categories of RI integrals: the 3-index integrals, where only only half of the transformation has taken place, and
the 4-index integrlas where the integrals are totally transformed in the molecular basis. The notation of the integrals
follows the one we just described for the two-electron integrals in the molecular basis.

In addition to the integrals in case of RI integrals also the used RI Metric is available through the option Vaux:

**Example**

**7.58. orca_2json** **1223**

**ORCA Manual** **,** **Release 6.0.1**

**Full Integral Transformation**

The full transformation integrals can be selected via the FullTrafo keyword.

**More 2-electron integrals**

Also the non-redundant 2-electron integrals are available for the RI and the nonRI case. Therefore the options
2elNonRedIntegrals or 2elNonRedRIIntegrals must be specified.

**Orbital Windows, AuxBasisType and Threshold**

The orbital window can either be selected automatically by the transformation routine or given by the user via the
OrbWin keyword. The internal and external space (i0,i1,a0,a1) is defined via an integer list.

for example:

The default AUX basis type is AuxC but can be changed with the keyword AuxBasisType. Please keep in mind
that only those basis types used during the ORCA run can be selected.

To reduce the number of the integrals the keyword Thresh can be used to decrease the selected integrals to save disk
space. This effects ONLY the printing and not the accuracy of the generated integrals. The default print threshold
is 1.e-15.

**1224** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**Example**

**TDDFT amplitude data (CIS/RPA)**

The TDDFT amplitudes and root informations can be requested (no triplet information yet). The available options

are:

**Example**



**Example**



**JSON Format**

The JSON Format that is created can also be defined in the configuration file through the *JSONFormats* variable.

The available JSON formats are:

**7.58. orca_2json** **1225**

**ORCA Manual** **,** **Release 6.0.1**

**Example**




**MO Coefficients**

**Example**




**7.58.4 Import JSON data into ORCA**

Some information like geometry, basis set and Molecular orbitals stored in the json format written by orca_2json
can be used to create a new gbw-file to be specified as an orbital file in the orca input. The program is called as a
standalone via command line.
```
orca_2json BaseName.json -gbw

```
**1226** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

**Basic Information**

In order to create a functional gbw-file the following information must be provided:

**NOTE**

Please keep in mind that *MolecularOrbitals* is a composite of 2 different components, namely *“EnergyUnit”* and
*“MOs”* . Then *“MOs”* contains *“MOCoefficients”*, *“Occupancy”*, *“OrbitalEnergy”*, “OrbitalSymLabel”* and
“OrbitalSymmetry”*.

**Example**

The following file (let’s call it *filename.json* ) is a json file for H_2 molecule with STO-3G basis set.





(continues on next page)

**7.58. orca_2json** **1227**

**ORCA Manual** **,** **Release 6.0.1**

(continued from previous page)



running then the command
```
orca_2json filename.json -gbw

```
should create a gbw file that ORCA can read.

**Definition of the real solid harmonic Gaussian orbitals**

When integrals over real solid harmonic Gaussian orbitals are issued into a JSON file, the precise definition of
these orbitals becomes important. ORCA uses its own peculiar conventions for the arrangement and the phases of
the individual components of the orbital shells.

The definitions of the angular parts of all shell components up to angular momentum *𝑘* ( *ℓ* = 8) are documented
below. These correspond to the real solid harmonics *𝑆* *ℓ,𝑚* ( *𝑥, 𝑦, 𝑧* ) that are normalized the following way:

*𝜋* *𝜋*

sin *𝜗𝑑𝜗* *𝑑𝜙𝑟* *[−]* [2] *[ℓ]* *𝑆* *ℓ,𝑚* [2] [(] *[𝑥, 𝑦, 𝑧]* [) = 1]

∫︁ 0 ∫︁ *−𝜋*


*𝜋* *𝜋*

sin *𝜗𝑑𝜗*
0 ∫︁ *−*


*𝑑𝜙𝑟* *[−]* [2] *[ℓ]* *𝑆* *ℓ,𝑚* [2] [(] *[𝑥, 𝑦, 𝑧]* [) = 1]

*−𝜋*


*𝑅* *ℓ* ( *𝑟* ) is the common radial part of a shell with angular momentum *ℓ* that consists of a specific basis set dependent
linear combination of Gaussian primitives. It is normalized independently:

*∞*

*𝑟* [2] *[ℓ]* [+2] *𝑅* *ℓ* [2] [(] *[𝑟]* [)] *[ 𝑑𝑟]* [= 1]

∫︁ 0

The factors *𝑟* [2] and sin *𝜗* in these integrals arise from the volume element in spherical polar coordinates:

*𝑥* = *𝑟* sin *𝜗* cos *𝜙*

*𝑦* = *𝑟* sin *𝜗* sin *𝜙*

*𝑧* = *𝑟* cos *𝜗*

*𝑑𝑥𝑑𝑦𝑑𝑧* = *𝑟* [2] sin *𝜗𝑑𝑟𝑑𝜗𝑑𝜙*

**Angular momentum** ***𝑠*** **(** ***ℓ*** **= 0)**

1

*𝑠* =
2 *[√]* *𝜋* *[𝑅]* *[𝑠]* [(] *[𝑟]* [)]

**1228** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


**Angular momentum** ***𝑝*** **(** ***ℓ*** **= 1)**

**Angular momentum** ***𝑑*** **(** ***ℓ*** **= 2)**

**Angular momentum** ***𝑓*** **(** ***ℓ*** **= 3)**


*𝑁* *𝑝* = [1]


3

*𝑁* *𝑝* = 2 [1] √︂ *𝜋*

*𝑝* [(0)] = *𝑝* 0 = *𝑁* *𝑝* *𝑧𝑅* *𝑝* ( *𝑟* )

*𝑝* [(1)] = *𝑝* +1 = *𝑁* *𝑝* *𝑥𝑅* *𝑝* ( *𝑟* )

*𝑝* [(2)] = *𝑝* *−* 1 = *𝑁* *𝑝* *𝑦𝑅* *𝑝* ( *𝑟* )


2


√︂


√


*𝑁* *𝑑* = [1]

2


*𝑁* *𝑑* = [1]


15

*𝜋*


*√* 3

6 *[𝑁]* *[𝑑]* (︀3 *𝑧* [2] *−* *𝑟* [2] [)︀] *𝑅* *𝑑* ( *𝑟* )


*√*


*𝑑* [(0)] = *𝑑* 0 =


*𝑑* [(1)] = *𝑑* +1 = *𝑁* *𝑑* *𝑥𝑧𝑅* *𝑑* ( *𝑟* )

*𝑑* [(2)] = *𝑑* *−* 1 = *𝑁* *𝑑* *𝑦𝑧𝑅* *𝑑* ( *𝑟* )

*𝑥* [2] *−* *𝑦* [2]
*𝑑* [(3)] = *𝑑* +2 = *𝑁* *𝑑* *𝑅* *𝑑* ( *𝑟* )

2

*𝑑* [(4)] = *𝑑* *−* 2 = *𝑁* *𝑑* *𝑥𝑦𝑅* *𝑑* ( *𝑟* )


√


*𝑁* *𝑓* = [1]

2


*𝑁* *𝑓* = [1]


105

*𝜋*


*𝑓* [(0)] = *𝑓* 0 =

*𝑓* [(1)] = *𝑓* +1 =

*𝑓* [(2)] = *𝑓* *−* 1 =


*√* 15

30 *[𝑁]* *[𝑓]* *[𝑧]* (︀5 *𝑧* [2] *−* 3 *𝑟* [2] [)︀] *𝑅* *𝑓* ( *𝑟* )


*√* 10

20 *[𝑁]* *[𝑓]* *[𝑦]* (︀5 *𝑧* [2] *−* *𝑟* [2] [)︀] *𝑅* *𝑓* ( *𝑟* )


*√* 10

20 *[𝑁]* *[𝑓]* *[𝑥]* (︀5 *𝑧* [2] *−* *𝑟* [2] [)︀] *𝑅* *𝑓* ( *𝑟* )


*𝑓* [(3)] = *𝑓* +2 = [1] (︀ *𝑥* [2] *−* *𝑦* [2] [)︀] *𝑧𝑅* *𝑓* ( *𝑟* )

2 *[𝑁]* *[𝑓]*

*𝑓* [(4)] = *𝑓* *−* 2 = *𝑁* *𝑓* *𝑥𝑦𝑧𝑅* *𝑓* ( *𝑟* )


*√* 6

*𝑓* [(5)] = *𝑓* +3 = *−* (︀ *𝑥* [2] *−* 3 *𝑦* [2] [)︀] *𝑅* *𝑓* ( *𝑟* )

12 *[𝑁]* *[𝑓]* *[𝑥]*

*√* 6

*𝑓* [(6)] = *𝑓* *−* 3 = *−* (︀3 *𝑥* [2] *−* *𝑦* [2] [)︀] *𝑅* *𝑓* ( *𝑟* )

12 *[𝑁]* *[𝑓]* *[𝑦]*


**7.58. orca_2json** **1229**

**ORCA Manual** **,** **Release 6.0.1**

**Angular momentum** ***𝑔*** **(** ***ℓ*** **= 4)**


√


*𝑁* *𝑔* = [3] 2


*𝑁* *𝑔* = [3]


35

*𝜋*


*𝑔* [(0)] = *𝑔* 0 =

*𝑔* [(1)] = *𝑔* +1 =

*𝑔* [(2)] = *𝑔* *−* 1 =

*𝑔* [(3)] = *𝑔* +2 =

*𝑔* [(4)] = *𝑔* *−* 2 =


*√* 35

280 *[𝑁]* *[𝑔]* (︀35 *𝑧* [4] *−* 30 *𝑧* [2] *𝑟* [2] + 3 *𝑟* [4] [)︀] *𝑅* *𝑔* ( *𝑟* )


*√* 7

(︀7 *𝑧* [2] *−* *𝑟* [2] [)︀] *𝑅* *𝑔* ( *𝑟* )
14 *[𝑁]* *[𝑔]* *[𝑥𝑦]*


*√* 14

28 *[𝑁]* *[𝑔]* *[𝑥𝑧]* (︀7 *𝑧* [2] *−* 3 *𝑟* [2] [)︀] *𝑅* *𝑔* ( *𝑟* )


*√* 14

28 *[𝑁]* *[𝑔]* *[𝑦𝑧]* (︀7 *𝑧* [2] *−* 3 *𝑟* [2] [)︀] *𝑅* *𝑔* ( *𝑟* )


*√* 7

28 *[𝑁]* *[𝑔]* (︀ *𝑥* [2] *−* *𝑦* [2] [)︀(︀] 7 *𝑧* [2] *−* *𝑟* [2] [)︀] *𝑅* *𝑔* ( *𝑟* )


*√* 2

(︀ *𝑥* [2] *−* 3 *𝑦* [2] [)︀] *𝑧𝑅* *𝑔* ( *𝑟* )
4 *[𝑁]* *[𝑔]* *[𝑥]*


*√*


*𝑔* [(5)] = *𝑔* +3 = *−*

*𝑔* [(6)] = *𝑔* *−* 3 = *−*


*√* 2

(︀3 *𝑥* [2] *−* *𝑦* [2] [)︀] *𝑧𝑅* *𝑔* ( *𝑟* )
4 *[𝑁]* *[𝑔]* *[𝑦]*


*√*


*𝑔* [(7)] = *𝑔* +4 = *−* 8 [1] *[𝑁]* *[𝑔]* (︀ *𝑥* [4] *−* 6 *𝑥* [2] *𝑦* [2] + *𝑦* [4] [)︀] *𝑅* *𝑔* ( *𝑟* )


*𝑔* [(8)] = *𝑔* *−* 4 = *−* [1] (︀ *𝑥* [2] *−* *𝑦* [2] [)︀] *𝑅* *𝑔* ( *𝑟* )

2 *[𝑁]* *[𝑔]* *[𝑥𝑦]*


**Angular momentum** ***ℎ*** **(** ***ℓ*** **= 5)**


~~√~~


*𝑁* *ℎ* = [1]

2


*𝑁* *ℎ* = [1]


11

*𝜋*


*ℎ* [(0)] = *ℎ* 0 = 8 [1] *[𝑁]* *[ℎ]* *[𝑧]* (︀63 *𝑧* [4] *−* 70 *𝑧* [2] *𝑟* [2] + 15 *𝑟* [4] [)︀] *𝑅* *ℎ* ( *𝑟* )


*ℎ* [(1)] = *ℎ* +1 =

*ℎ* [(2)] = *ℎ* *−* 1 =

*ℎ* [(3)] = *ℎ* +2 =

*ℎ* [(4)] = *ℎ* *−* 2 =


*√* 15

*𝑁* *ℎ* *𝑥* (︀21 *𝑧* [4] *−* 14 *𝑧* [2] *𝑟* [2] + *𝑟* [4] [)︀] *𝑅* *ℎ* ( *𝑟* )
8


105

*𝑁* *ℎ* *𝑥𝑦𝑧* (︀3 *𝑧* [2] *−* *𝑟* [2] [)︀] *𝑅* *ℎ* ( *𝑟* )
2


*√* 15

*𝑁* *ℎ* *𝑦* (︀21 *𝑧* [4] *−* 14 *𝑧* [2] *𝑟* [2] + *𝑟* [4] [)︀] *𝑅* *ℎ* ( *𝑟* )
8


*√*

*√*


105

*𝑁* *ℎ* (︀ *𝑥* [2] *−* *𝑦* [2] [)︀] *𝑧* (︀3 *𝑧* [2] *−* *𝑟* [2] [)︀] *𝑅* *ℎ* ( *𝑟* )
4


105


105


*ℎ* [(5)] = *ℎ* +3 = *−*

*ℎ* [(6)] = *ℎ* *−* 3 = *−*


*√* 70

16 *[𝑁]* *[ℎ]* *[𝑥]* (︀ *𝑥* [2] *−* 3 *𝑦* [2] [)︀(︀] 9 *𝑧* [2] *−* *𝑟* [2] [)︀] *𝑅* *ℎ* ( *𝑟* )


*√* 70

16 *[𝑁]* *[ℎ]* *[𝑦]* (︀3 *𝑥* [2] *−* *𝑦* [2] [)︀(︀] 9 *𝑧* [2] *−* *𝑟* [2] [)︀] *𝑅* *ℎ* ( *𝑟* )


*√* 35
*ℎ* [(7)] = *ℎ* +4 = *−* [3] *𝑁* *ℎ* (︀ *𝑥* [4] *−* 6 *𝑥* [2] *𝑦* [2] + *𝑦* [4] [)︀] *𝑧𝑅* *ℎ* ( *𝑟* )

8


*√* 35
*ℎ* [(8)] = *ℎ* *−* 4 = *−* [3] *𝑁* *ℎ* *𝑥𝑦* (︀ *𝑥* [2] *−* *𝑦* [2] [)︀] *𝑧𝑅* *ℎ* ( *𝑟* )

2


*√* 14
*ℎ* [(9)] = *ℎ* +5 = [3] *𝑁* *ℎ* *𝑥* (︀ *𝑥* [4] *−* 10 *𝑥* [2] *𝑦* [2] + 5 *𝑦* [4] [)︀] *𝑅* *ℎ* ( *𝑟* )

16


*√* 14
*ℎ* [(10)] = *ℎ* *−* 5 = [3] *𝑁* *ℎ* *𝑦* (︀5 *𝑥* [4] *−* 10 *𝑥* [2] *𝑦* [2] + *𝑦* [4] [)︀] *𝑅* *ℎ* ( *𝑟* )

16


**1230** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


**Angular momentum** ***𝑖*** **(** ***ℓ*** **= 6)**


*𝑁* *𝑖* = [1]

2 ~~√~~


13

*𝜋*


*𝑖* [(0)] = *𝑖* 0 = 16 [1] *[𝑁]* *[𝑖]* (︀231 *𝑧* [6] *−* 315 *𝑧* [4] *𝑟* [2] + 105 *𝑧* [2] *𝑟* [4] *−* 5 *𝑟* [6] [)︀] *𝑅* *𝑖* ( *𝑟* )


*𝑖* [(1)] = *𝑖* +1 =

*𝑖* [(2)] = *𝑖* *−* 1 =

*𝑖* [(3)] = *𝑖* +2 =

*𝑖* [(4)] = *𝑖* *−* 2 =


*√* 21

*𝑁* *𝑖* *𝑥𝑧* (︀33 *𝑧* [4] *−* 30 *𝑧* [2] *𝑟* [2] + 5 *𝑟* [4] [)︀] *𝑅* *𝑖* ( *𝑟* )
8


*√* 210

*𝑁* *𝑖* *𝑥𝑦* (︀33 *𝑧* [4] *−* 18 *𝑧* [2] *𝑟* [2] + *𝑟* [4] [)︀] *𝑅* *𝑖* ( *𝑟* )
16


*√* 21

*𝑁* *𝑖* *𝑦𝑧* (︀33 *𝑧* [4] *−* 30 *𝑧* [2] *𝑟* [2] + 5 *𝑟* [4] [)︀] *𝑅* *𝑖* ( *𝑟* )
8


*√* 210

*𝑁* *𝑖* (︀ *𝑥* [2] *−* *𝑦* [2] [)︀(︀] 33 *𝑧* [4] *−* 18 *𝑧* [2] *𝑟* [2] + *𝑟* [4] [)︀] *𝑅* *𝑖* ( *𝑟* )
32


*√* 210

*𝑁* *𝑖* *𝑥* (︀ *𝑥* [2] *−* 3 *𝑦* [2] [)︀] *𝑧* (︀11 *𝑧* [2] *−* 3 *𝑟* [2] [)︀] *𝑅* *𝑖* ( *𝑟* )
16


*√*


*𝑖* [(5)] = *𝑖* +3 = *−*

*𝑖* [(6)] = *𝑖* *−* 3 = *−*


*√* 210

*𝑁* *𝑖* *𝑦* (︀3 *𝑥* [2] *−* *𝑦* [2] [)︀] *𝑧* (︀11 *𝑧* [2] *−* 3 *𝑟* [2] [)︀] *𝑅* *𝑖* ( *𝑟* )
16


*√*


*√* 7
*𝑖* [(7)] = *𝑖* +4 = *−* [3] 16 *[𝑁]* *[𝑖]* (︀ *𝑥* [4] *−* 6 *𝑥* [2] *𝑦* [2] + *𝑦* [4] [)︀(︀] 11 *𝑧* [2] *−* *𝑟* [2] [)︀] *𝑅* *𝑖* ( *𝑟* )


*√* 7
*𝑖* [(8)] = *𝑖* *−* 4 = *−* [3] *𝑁* *𝑖* *𝑥𝑦* (︀ *𝑥* [2] *−* *𝑦* [2] [)︀(︀] 11 *𝑧* [2] *−* *𝑟* [2] [)︀] *𝑅* *𝑖* ( *𝑟* )

4


*√* 154
*𝑖* [(9)] = *𝑖* +5 = [3] *𝑁* *𝑖* *𝑥* (︀ *𝑥* [4] *−* 10 *𝑥* [2] *𝑦* [2] + 5 *𝑦* [4] [)︀] *𝑧𝑅* *𝑖* ( *𝑟* )

16


*√* 154
*𝑖* [(10)] = *𝑖* *−* 5 = [3] *𝑁* *𝑖* *𝑦* (︀5 *𝑥* [4] *−* 10 *𝑥* [2] *𝑦* [2] + *𝑦* [4] [)︀] *𝑧𝑅* *𝑖* ( *𝑟* )

16


*𝑖* [(11)] = *𝑖* +6 =

*𝑖* [(12)] = *𝑖* *−* 6 =


*√* 462

*𝑁* *𝑖* (︀ *𝑥* [2] *−* *𝑦* [2] [)︀(︀] *𝑥* [4] *−* 14 *𝑥* [2] *𝑦* [2] + *𝑦* [4] [)︀] *𝑅* *𝑖* ( *𝑟* )
32


*√* 462

*𝑁* *𝑖* *𝑥𝑦* (︀3 *𝑥* [4] *−* 10 *𝑥* [2] *𝑦* [2] + 3 *𝑦* [4] [)︀] *𝑅* *𝑖* ( *𝑟* )
16


**7.58. orca_2json** **1231**

**ORCA Manual** **,** **Release 6.0.1**

**Angular momentum** ***𝑗*** **(** ***ℓ*** **= 7)**


~~√~~


*𝑁* *𝑗* = [1]

2


15

*𝜋*


*𝑗* [(0)] = *𝑗* 0 = 16 [1] *[𝑁]* *[𝑗]* *[𝑧]* (︀429 *𝑧* [6] *−* 693 *𝑧* [4] *𝑟* [2] + 315 *𝑧* [2] *𝑟* [4] *−* 35 *𝑟* [6] [)︀] *𝑅* *𝑗* ( *𝑟* )


*𝑗* [(1)] = *𝑗* +1 =

*𝑗* [(2)] = *𝑗* *−* 1 =

*𝑗* [(3)] = *𝑗* +2 =

*𝑗* [(4)] = *𝑗* *−* 2 =


*√* 7

32 *[𝑁]* *[𝑗]* *[𝑥]* (︀429 *𝑧* [6] *−* 495 *𝑧* [4] *𝑟* [2] + 135 *𝑧* [2] *𝑟* [4] *−* 5 *𝑟* [6] [)︀] *𝑅* *𝑗* ( *𝑟* )


*√* 42

16 *[𝑁]* *[𝑗]* *[𝑥𝑦𝑧]* (︀143 *𝑧* [4] *−* 110 *𝑧* [2] *𝑟* [2] + 15 *𝑟* [4] [)︀] *𝑅* *𝑗* ( *𝑟* )


*√* 7

32 *[𝑁]* *[𝑗]* *[𝑦]* (︀429 *𝑧* [6] *−* 495 *𝑧* [4] *𝑟* [2] + 135 *𝑧* [2] *𝑟* [4] *−* 5 *𝑟* [6] [)︀] *𝑅* *𝑗* ( *𝑟* )


*√* 42

32 *[𝑁]* *[𝑗]* (︀ *𝑥* [2] *−* *𝑦* [2] [)︀] *𝑧* (︀143 *𝑧* [4] *−* 110 *𝑧* [2] *𝑟* [2] + 15 *𝑟* [4] [)︀] *𝑅* *𝑗* ( *𝑟* )


*√* 21

32 *[𝑁]* *[𝑗]* *[𝑥]* (︀ *𝑥* [2] *−* 3 *𝑦* [2] [)︀(︀] 143 *𝑧* [4] *−* 66 *𝑧* [2] *𝑟* [2] + 3 *𝑟* [4] [)︀] *𝑅* *𝑗* ( *𝑟* )


*√*


*𝑗* [(5)] = *𝑗* +3 = *−*

*𝑗* [(6)] = *𝑗* *−* 3 = *−*

*𝑗* [(7)] = *𝑗* +4 = *−*

*𝑗* [(8)] = *𝑗* *−* 4 = *−*


231

*𝑁* *𝑗* *𝑥𝑦* (︀ *𝑥* [2] *−* *𝑦* [2] [)︀] *𝑧* (︀13 *𝑧* [2] *−* 3 *𝑟* [2] [)︀] *𝑅* *𝑗* ( *𝑟* )
4


*√* 21

32 *[𝑁]* *[𝑗]* *[𝑦]* (︀3 *𝑥* [2] *−* *𝑦* [2] [)︀(︀] 143 *𝑧* [4] *−* 66 *𝑧* [2] *𝑟* [2] + 3 *𝑟* [4] [)︀] *𝑅* *𝑗* ( *𝑟* )


*√*


*√* 231

*𝑁* *𝑗* (︀ *𝑥* [4] *−* 6 *𝑥* [2] *𝑦* [2] + *𝑦* [4] [)︀] *𝑧* (︀13 *𝑧* [2] *−* 3 *𝑟* [2] [)︀] *𝑅* *𝑗* ( *𝑟* )
16


*√*


*√*


231


*𝑗* [(9)] = *𝑗* +5 =

*𝑗* [(10)] = *𝑗* *−* 5 =

*𝑗* [(11)] = *𝑗* +6 =

*𝑗* [(12)] = *𝑗* *−* 6 =


*√* 231

*𝑁* *𝑗* *𝑥* (︀ *𝑥* [4] *−* 10 *𝑥* [2] *𝑦* [2] + 5 *𝑦* [4] [)︀(︀] 13 *𝑧* [2] *−* *𝑟* [2] [)︀] *𝑅* *𝑗* ( *𝑟* )
32


6006

*𝑁* *𝑗* *𝑥𝑦* (︀3 *𝑥* [2] *−* *𝑦* [2] [)︀(︀] *𝑥* [2] *−* 3 *𝑦* [2] [)︀] *𝑧𝑅* *𝑗* ( *𝑟* )
16


*√* 231

*𝑁* *𝑗* *𝑦* (︀5 *𝑥* [4] *−* 10 *𝑥* [2] *𝑦* [2] + *𝑦* [4] [)︀(︀] 13 *𝑧* [2] *−* *𝑟* [2] [)︀] *𝑅* *𝑗* ( *𝑟* )
32


*√*

*√*


6006

*𝑁* *𝑗* (︀ *𝑥* [2] *−* *𝑦* [2] [)︀(︀] *𝑥* [4] *−* 14 *𝑥* [2] *𝑦* [2] + *𝑦* [4] [)︀] *𝑧𝑅* *𝑗* ( *𝑟* )
32


6006


6006


*√* 429

*𝑁* *𝑗* *𝑥* (︀ *𝑥* [6] *−* 21 *𝑥* [4] *𝑦* [2] + 35 *𝑥* [2] *𝑦* [4] *−* 7 *𝑦* [6] [)︀] *𝑅* *𝑗* ( *𝑟* )
32


*√*


*𝑗* [(13)] = *𝑗* +7 = *−*

*𝑗* [(14)] = *𝑗* *−* 7 = *−*


*√* 429

*𝑁* *𝑗* *𝑦* (︀7 *𝑥* [6] *−* 35 *𝑥* [4] *𝑦* [2] + 21 *𝑥* [2] *𝑦* [4] *−* *𝑦* [6] [)︀] *𝑅* *𝑗* ( *𝑟* )
32


*√*


**1232** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**


**Angular momentum** ***𝑘*** **(** ***ℓ*** **= 8)**


√


*𝑁* *𝑘* = [1]

2


*𝑁* *𝑘* = [1]


17

*𝜋*


1
*𝑘* [(0)] = *𝑘* 0 = 128 *[𝑁]* *[𝑘]* (︀6435 *𝑧* [8] *−* 12012 *𝑧* [6] *𝑟* [2] + 6930 *𝑧* [4] *𝑟* [4] *−* 1260 *𝑧* [2] *𝑟* [6] + 35 *𝑟* [8] [)︀] *𝑅* *𝑘* ( *𝑟* )

*𝑘* [(1)] = *𝑘* +1 = 32 [3] *[𝑁]* *[𝑘]* *[𝑥𝑧]* (︀715 *𝑧* [6] *−* 1001 *𝑧* [4] *𝑟* [2] + 385 *𝑧* [2] *𝑟* [4] *−* 35 *𝑟* [6] [)︀] *𝑅* *𝑘* ( *𝑟* )

*𝑘* [(2)] = *𝑘* *−* 1 = 32 [3] *[𝑁]* *[𝑘]* *[𝑦𝑧]* (︀715 *𝑧* [6] *−* 1001 *𝑧* [4] *𝑟* [2] + 385 *𝑧* [2] *𝑟* [4] *−* 35 *𝑟* [6] [)︀] *𝑅* *𝑘* ( *𝑟* )

*√* 70
*𝑘* [(3)] = *𝑘* +2 = [3] *𝑁* *𝑘* (︀ *𝑥* [2] *−* *𝑦* [2] [)︀(︀] 143 *𝑧* [6] *−* 143 *𝑧* [4] *𝑟* [2] + 33 *𝑧* [2] *𝑟* [4] *−* *𝑟* [6] [)︀] *𝑅* *𝑘* ( *𝑟* )

64

*√* 70
*𝑘* [(4)] = *𝑘* *−* 2 = [3] *𝑁* *𝑘* *𝑥𝑦* (︀143 *𝑧* [6] *−* 143 *𝑧* [4] *𝑟* [2] + 33 *𝑧* [2] *𝑟* [4] *−* *𝑟* [6] [)︀] *𝑅* *𝑘* ( *𝑟* )

32


*√*

*√*


*𝑘* [(5)] = *𝑘* +3 = *−*

*𝑘* [(6)] = *𝑘* *−* 3 = *−*


1155

*𝑁* *𝑘* *𝑥* (︀ *𝑥* [2] *−* 3 *𝑦* [2] [)︀] *𝑧* (︀39 *𝑧* [4] *−* 26 *𝑧* [2] *𝑟* [2] + 3 *𝑟* [4] [)︀] *𝑅* *𝑘* ( *𝑟* )
32


1155


1155

*𝑁* *𝑘* *𝑦* (︀3 *𝑥* [2] *−* *𝑦* [2] [)︀] *𝑧* (︀39 *𝑧* [4] *−* 26 *𝑧* [2] *𝑟* [2] + 3 *𝑟* [4] [)︀] *𝑅* *𝑘* ( *𝑟* )
32


1155


*√* 77
*𝑘* [(7)] = *𝑘* +4 = *−* [3] *𝑁* *𝑘* (︀ *𝑥* [4] *−* 6 *𝑥* [2] *𝑦* [2] + *𝑦* [4] [)︀(︀] 65 *𝑧* [4] *−* 26 *𝑧* [2] *𝑟* [2] + *𝑟* [4] [)︀] *𝑅* *𝑘* ( *𝑟* )

64


*√* 77
*𝑘* [(8)] = *𝑘* *−* 4 = *−* [3] *𝑁* *𝑘* *𝑥𝑦* (︀ *𝑥* [2] *−* *𝑦* [2] [)︀(︀] 65 *𝑧* [4] *−* 26 *𝑧* [2] *𝑟* [2] + *𝑟* [4] [)︀] *𝑅* *𝑘* ( *𝑟* )

16


*√* 1001
*𝑘* [(9)] = *𝑘* +5 = [3] *𝑁* *𝑘* *𝑥* (︀ *𝑥* [4] *−* 10 *𝑥* [2] *𝑦* [2] + 5 *𝑦* [4] [)︀] *𝑧* (︀5 *𝑧* [2] *−* *𝑟* [2] [)︀] *𝑅* *𝑘* ( *𝑟* )

32


*√* 1001
*𝑘* [(10)] = *𝑘* *−* 5 = [3] *𝑁* *𝑘* *𝑦* (︀5 *𝑥* [4] *−* 10 *𝑥* [2] *𝑦* [2] + *𝑦* [4] [)︀] *𝑧* (︀5 *𝑧* [2] *−* *𝑟* [2] [)︀] *𝑅* *𝑘* ( *𝑟* )

32


*𝑘* [(11)] = *𝑘* +6 =

*𝑘* [(12)] = *𝑘* *−* 6 =


*√* 858

*𝑁* *𝑘* (︀ *𝑥* [2] *−* *𝑦* [2] [)︀(︀] *𝑥* [4] *−* 14 *𝑥* [2] *𝑦* [2] + *𝑦* [4] [)︀(︀] 15 *𝑧* [2] *−* *𝑟* [2] [)︀] *𝑅* *𝑘* ( *𝑟* )
64


*√* 858

*𝑁* *𝑘* *𝑥𝑦* (︀ *𝑥* [2] *−* 3 *𝑦* [2] [)︀(︀] 3 *𝑥* [2] *−* *𝑦* [2] [)︀(︀] 15 *𝑧* [2] *−* *𝑟* [2] [)︀] *𝑅* *𝑘* ( *𝑟* )
32


*√* 715
*𝑘* [(13)] = *𝑘* +7 = *−* [3] *𝑁* *𝑘* *𝑥* (︀ *𝑥* [6] *−* 21 *𝑥* [4] *𝑦* [2] + 35 *𝑥* [2] *𝑦* [4] *−* 7 *𝑦* [6] [)︀] *𝑧𝑅* *𝑘* ( *𝑟* )

32


*√* 715
*𝑘* [(14)] = *𝑘* *−* 7 = *−* [3] *𝑁* *𝑘* *𝑦* (︀7 *𝑥* [6] *−* 35 *𝑥* [4] *𝑦* [2] + 21 *𝑥* [2] *𝑦* [4] *−* *𝑦* [6] [)︀] *𝑧𝑅* *𝑘* ( *𝑟* )

32


*√* 715
*𝑘* [(15)] = *𝑘* +8 = *−* [3] *𝑁* *𝑘* (︀ *𝑥* [8] *−* 28 *𝑥* [6] *𝑦* [2] + 70 *𝑥* [4] *𝑦* [4] *−* 28 *𝑥* [2] *𝑦* [6] + *𝑦* [8] [)︀] *𝑅* *𝑘* ( *𝑟* )

128


*√* 715
*𝑘* [(16)] = *𝑘* *−* 8 = *−* [3] *𝑁* *𝑘* *𝑥𝑦* (︀ *𝑥* [2] *−* *𝑦* [2] [)︀(︀] *𝑥* [4] *−* 6 *𝑥* [2] *𝑦* [2] + *𝑦* [4] [)︀] *𝑅* *𝑘* ( *𝑟* )

16

### **7.59 Property File**

One of the files that ORCA produces, during a calculation, is the *property file* . The name of the file is *base-*
*name.property.txt*, where basename is the basename of the input file. As we will see later ORCA can also produce
the property file with the extension *.json* .

*Property file* has mainly two usages in ORCA. The first usage is to work as basis for the *Compound* scripting
language. *Compound* reads all its information concerning properties through the property file and not through
parsing of the ORCA output. The second usage of *property file* is to make it easier for other programs, or potential
GUIs, to create interfaces with ORCA.

The advantage of *Property file* compared to the normal ORCA output is that it’s syntax is well defined and so it is
easier to parse it.

**7.59. Property File** **1233**

**ORCA Manual** **,** **Release 6.0.1**

**7.59.1 txt format**

After any ORCA calculation a property file is created with the extension *.property.txt* . The file is a text file and one
can read it and edit it with any available text editor. Below we will analyze the syntax of the file.

The file always starts with the following three lines:



where, obviously the version of ORCA changes.

Then, the file consists of a list of properties. Each property starts with the symbol “ *$* ” followed by the name of the
property and ends with the symbol “ *$* ” followed by “ *End* ”.

For example:



Each property consists of components. Each component starts with the symbol “ *&* ” and has not ending symbol.

For example:
```
  &SCF_ENERGY [&Type "Double"] -1.1271129230772137e+00

```
Before proceeding to details about the property specific components, there are two components that exist in every
property and always in the same order.

The first one is the *GeometryIndex* component. The syntax for this is quite simple, the normal “ *&* ” component
start symbol, followed by “ *GeometryIndex* ” and then an integer.

For example:
```
&GeometryIndex 1

```
This is an easy way to know the geometry that the current property belongs to.

Then for all properties follows the *ListStatus* component. The syntax for this component is again the “ *&* ” component
start symbol, followed by “ *ListStatus* ” follow by one the following 5 options:

1. “ *IN* ” when the property is inside a list properties

2. “ *OUT* ” when the property is not inside a list of properties

3. “ *FIRST* ” when the property is the first in a list of properties

4. “ *LAST* ” when the property is the last in a list of properties

5. “ *UNIQUE* ” when the property is the only one in a list of properties

For example:
```
 &ListStatus OUT

```
Then for each property follows a series of *components* . Each component has the following syntax:

First the start of component symbol “ *&* ”.

Then follows the name of the component.

Then a bracket opens with various bracket information about the component. For details on the syntax of the
bracket information please check *Bracket information* .

**1234** **Chapter 7. Detailed Documentation**

**ORCA Manual** **,** **Release 6.0.1**

After the bracket there are different options.

If the type is a “Double” or an “Integer” then a number of the appropriate type is expected.

For example:
```
&NATOMS [&Type "Integer"] 2

```
If the type is a “String” then a string is expected starting with quotation marks.

For example:
```
&PROGNAME [&Type "String"] "ProgMDCI"

```
Finally if the type is a kind or Array then, unless there is a comment, that is enclosed inside quotation marks, an
array is written starting from the next line. We should note here that after the column header there is an empty line.
In addition there is always a first column with an integer giving just the row of the array.

For example:

**Bracket information**

Bracket information is a list of information separated with ‘,’. The first and most important bracket component is
the “ *Type* ”. Type can be one of the following:

1. “Double”

2. “Integer

3. “Boolean”

4. “String”

5. “ArrayOfDoubles”

6. “ArrayOfIntegers”

7. “ArrayOfBooleans”

8. “MixedMatrix”

9. “Coordinates”

For example:
```
&NATOMS [&Type "Integer"] 2

```
Then in case the “ *Type* ” is a kind of array the bracket must contain the dimension of the array, using the “ *Dim* ”

component.

For example:
```
&ATNO [&Type "ArrayOfIntegers", &Dim (2,1)]

```
**7.59. Property File** **1235**

**ORCA Manual** **,** **Release 6.0.1**

**7.59.2 JSON format**

The property file can be also produced in a JSON format. Internally this happens through transformation of the *txt*
*format* to JSON format. There are two ways to create a JSON property file.

The first way is through the normal ORCA input using the *WriteJSONPropertyFile* command.



this will create a *basename.property.txt* and in addition a *basename.property.json* file.

The second way is through the ORCA_2JSON command. For this one first has to run a normal ORCA input, that
will create a *basename.property.txt* file, and then use the command:
```
orca_2json basename property

```
where *basename* is the name of the ORCA input.

*Property File* in JSON format is readable by any JSON library.

**1236** **Chapter 7. Detailed Documentation**

**CHAPTER**